/**
 * $Id: mxAws3d.js,v 1.0 2015/10/11 07:05:39 mate Exp $
 * Copyright (c) 2006-2015, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Arrow NE
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dArrowNE(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dArrowNE, mxShape);

mxShapeAws3dArrowNE.prototype.cst = {
		ARROW_NE : 'mxgraph.aws3d.arrowNE'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dArrowNE.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(w - 17, 8);
	c.lineTo(w - 21, 5.5);
	c.lineTo(w, 0);
	c.lineTo(w - 9.7, 12.2);
	c.lineTo(w - 13.9, 9.8);
	c.lineTo(9.7, h - 3.5);
	c.arcTo(6, 3, 0, 0, 1, 9, h - 0.4);
	c.arcTo(5.2, 3, 0, 0, 1, 1, h - 1.4);
	c.arcTo(6, 2.8, 0, 0, 1, 3, h - 5.4);
	c.arcTo(5, 3, 0, 0, 1, 6.7, h - 5.2);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeAws3dArrowNE.prototype.cst.ARROW_NE, mxShapeAws3dArrowNE);

//**********************************************************************************************************************************************************
//Arrow SE
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dArrowSE(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dArrowSE, mxShape);

mxShapeAws3dArrowSE.prototype.cst = {
		ARROW_SE : 'mxgraph.aws3d.arrowSE'
};



/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dArrowSE.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(w - 17, h - 8);
	c.lineTo(w - 21, h - 5.5);
	c.lineTo(w, h);
	c.lineTo(w - 9.7, h - 12.2);
	c.lineTo(w - 13.9, h - 9.8);
	c.lineTo(9.7, 3.5);
	c.arcTo(6, 3, 0, 0, 0, 9, 0.4);
	c.arcTo(5.2, 3, 0, 0, 0, 1, 1.4);
	c.arcTo(6, 2.8, 0, 0, 0, 3, 5.4);
	c.arcTo(5, 3, 0, 0, 0, 6.7, 5.2);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeAws3dArrowSE.prototype.cst.ARROW_SE, mxShapeAws3dArrowSE);

//**********************************************************************************************************************************************************
//Arrow SW
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dArrowSW(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dArrowSW, mxShape);

mxShapeAws3dArrowSW.prototype.cst = {
		ARROW_SW : 'mxgraph.aws3d.arrowSW'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dArrowSW.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(17, h - 8);
	c.lineTo(21, h - 5.5);
	c.lineTo(0, h);
	c.lineTo(9.7, h - 12.2);
	c.lineTo(13.9, h - 9.8);
	c.lineTo(w - 9.7, 3.5);
	c.arcTo(6, 3, 0, 0, 1, w - 9, 0.4);
	c.arcTo(5.2, 3, 0, 0, 1, w - 1, 1.4);
	c.arcTo(6, 2.8, 0, 0, 1, w - 3, 5.4);
	c.arcTo(5, 3, 0, 0, 1, w - 6.7, 5.2);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeAws3dArrowSW.prototype.cst.ARROW_SW, mxShapeAws3dArrowSW);

//**********************************************************************************************************************************************************
//Arrow NW
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dArrowNW(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dArrowNW, mxShape);

mxShapeAws3dArrowNW.prototype.cst = {
		ARROW_NW : 'mxgraph.aws3d.arrowNW'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dArrowNW.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(17, 8);
	c.lineTo(21, 5.5);
	c.lineTo(0, 0);
	c.lineTo(9.7, 12.2);
	c.lineTo(13.9, 9.8);
	c.lineTo(w - 9.7, h - 3.5);
	c.arcTo(6, 3, 0, 0, 0, w - 9, h - 0.4);
	c.arcTo(5.2, 3, 0, 0, 0, w - 1, h - 1.4);
	c.arcTo(6, 2.8, 0, 0, 0, w - 3, h - 5.4);
	c.arcTo(5, 3, 0, 0, 0, w - 6.7, h - 5.2);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeAws3dArrowNW.prototype.cst.ARROW_NW, mxShapeAws3dArrowNW);

//**********************************************************************************************************************************************************
//Arrowless NE
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dArrowlessNE(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dArrowlessNE, mxShape);

mxShapeAws3dArrowlessNE.prototype.cst = {
		ARROWLESS_NE : 'mxgraph.aws3d.arrowlessNE'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dArrowlessNE.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(w - 3.1, 0);
	c.lineTo(w, 1.8);
	c.lineTo(9.7, h - 3.5);
	c.arcTo(6, 3, 0, 0, 1, 9, h - 0.4);
	c.arcTo(5.2, 3, 0, 0, 1, 1, h - 1.4);
	c.arcTo(6, 2.8, 0, 0, 1, 3, h - 5.4);
	c.arcTo(5, 3, 0, 0, 1, 6.7, h - 5.2);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeAws3dArrowlessNE.prototype.cst.ARROWLESS_NE, mxShapeAws3dArrowlessNE);

//**********************************************************************************************************************************************************
//Dashed edge with double arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dDashedEdgeDouble(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dDashedEdgeDouble, mxShape);

mxShapeAws3dDashedEdgeDouble.prototype.cst = {
		DASHED_EDGE_DOUBLE : 'mxgraph.aws3d.dashedEdgeDouble'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dDashedEdgeDouble.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.setFillColor('#2D6195');
	c.save();
	c.setStrokeColor('none');
	c.begin();
	c.moveTo(21, 5.5);
	c.lineTo(0, 0);
	c.lineTo(9.7, 12.2);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w - 21, h - 5.5);
	c.lineTo(w, h);
	c.lineTo(w - 9.7, h - 12.2);
	c.fillAndStroke();
	
	c.restore();
	c.setStrokeColor('#2D6195');
	c.setStrokeWidth('4');
	c.setDashed('true');
	c.setLineCap('round');
	
	c.begin();
	c.moveTo(7.675, 4.425);
	c.lineTo(w - 7.675, h - 4.425);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dDashedEdgeDouble.prototype.cst.DASHED_EDGE_DOUBLE, mxShapeAws3dDashedEdgeDouble);

//**********************************************************************************************************************************************************
//Dashed arrowless edge
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dDashedArrowlessEdge(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dDashedArrowlessEdge, mxShape);

mxShapeAws3dDashedArrowlessEdge.prototype.cst = {
		DASHED_ARROWLESS_EDGE : 'mxgraph.aws3d.dashedArrowlessEdge'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dDashedArrowlessEdge.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.setStrokeColor('#2D6195');
	c.setStrokeWidth('4');
	c.setDashed('true');
	c.setLineCap('round');
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dDashedArrowlessEdge.prototype.cst.DASHED_ARROWLESS_EDGE, mxShapeAws3dDashedArrowlessEdge);

//**********************************************************************************************************************************************************
//Dashed edge
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dDashedEdge(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dDashedEdge, mxShape);

mxShapeAws3dDashedEdge.prototype.cst = {
		DASHED_EDGE : 'mxgraph.aws3d.dashedEdge'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dDashedEdge.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.setFillColor('#2D6195');
	c.save();
	c.setStrokeColor('none');
	c.begin();
	c.moveTo(w - 21, 5.5);
	c.lineTo(w, 0);
	c.lineTo(w - 9.7, 12.2);
	c.fillAndStroke();
	
	c.restore();
	c.setStrokeColor('#2D6195');
	c.setStrokeWidth('4');
	c.setDashed('true');
	c.setLineCap('round');
	
	c.begin();
	c.moveTo(w - 7.675, 4.425);
	c.lineTo(0, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dDashedEdge.prototype.cst.DASHED_EDGE, mxShapeAws3dDashedEdge);

//**********************************************************************************************************************************************************
//Flat edge
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dFlatEdge(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dFlatEdge, mxShape);

mxShapeAws3dFlatEdge.prototype.cst = {
		FLAT_EDGE : 'mxgraph.aws3d.flatEdge'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dFlatEdge.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.setFillColor('#F4B934');
	c.setStrokeColor('none');
	c.begin();
	c.moveTo(w - 46, 8.8);
	c.lineTo(w - 61.2, 0);
	c.lineTo(w, 0);
	c.lineTo(w, 35.5);
	c.lineTo(w - 15.4, 26.5);
	c.lineTo(30.7, h);
	c.lineTo(0, h - 17.7);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeAws3dFlatEdge.prototype.cst.FLAT_EDGE, mxShapeAws3dFlatEdge);

//**********************************************************************************************************************************************************
//Flat double edge
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dFlatDoubleEdge(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dFlatDoubleEdge, mxShape);

mxShapeAws3dFlatDoubleEdge.prototype.cst = {
		FLAT_DOUBLE_EDGE : 'mxgraph.aws3d.flatDoubleEdge'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dFlatDoubleEdge.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.setFillColor('#F4B934');
	c.setStrokeColor('none');

	c.begin();
	c.moveTo(15.3, 61.9);
	c.lineTo(30.8, 53.2);
	c.lineTo(15.4, 44.2);
	c.lineTo(0, 53.2);
	c.lineTo(15.4, 8.8);
	c.lineTo(92.1, 0);
	c.lineTo(76.5, 8.8);
	c.lineTo(92.1, 17.7);
	c.lineTo(107.4, 8.8);
	
	c.lineTo(w - 15.3, h - 61.9);
	c.lineTo(w - 30.8, h - 53.2);
	c.lineTo(w - 15.4, h - 44.2);
	c.lineTo(w, h - 53.2);
	c.lineTo(w - 15.4, h - 8.8);
	c.lineTo(w - 92.1, h);
	c.lineTo(w - 76.5, h - 8.8);
	c.lineTo(w - 92.1, h - 17.7);
	c.lineTo(w - 107.4, h - 8.8);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeAws3dFlatDoubleEdge.prototype.cst.FLAT_DOUBLE_EDGE, mxShapeAws3dFlatDoubleEdge);

//**********************************************************************************************************************************************************
//AMI
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dAMI(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dAMI, mxShape);

mxShapeAws3dAMI.prototype.cst = {
		AMI : 'mxgraph.aws3d.ami',
		SHADING_COLORS : 'shadingCols' 
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dAMI.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	var strokeWidth1 = strokeWidth * w / 92;
	var strokeWidth2 = strokeWidth * h / 60;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	
	c.setStrokeWidth(strokeWidth);
	c.setShadow(false);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if (isShadow == 1)
	{
		c.setShadow(true);
	}

	c.begin();
	c.moveTo(0, h * 0.6483);
	c.lineTo(w * 0.0684, h * 0.4133);
	c.lineTo(w * 0.5326, 0);
	c.lineTo(w * 0.6685, 0);
	c.lineTo(w * 0.9359, h * 0.2367);
	c.lineTo(w, h * 0.465);
	c.lineTo(w * 0.4, h);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dAMI.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.65);
	c.lineTo(w * 0.0652, h * 0.5);
	c.lineTo(w * 0.3326, h * 0.7667);
	c.lineTo(w * 0.4663, h * 0.7667);
	c.lineTo(w * 0.4, h);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.4, h);
	c.lineTo(w * 0.4641, h * 0.77);
	c.lineTo(w * 0.9326, h * 0.355);
	c.lineTo(w * 0.9347, h * 0.24);
	c.lineTo(w, h * 0.4667);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.65);
	c.lineTo(w * 0.0652, h * 0.5);
	c.lineTo(w * 0.3326, h * 0.7667);
	c.lineTo(w * 0.4663, h * 0.7667);
	c.lineTo(w * 0.4, h);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w * 0.4, h);
	c.lineTo(w * 0.4641, h * 0.77);
	c.lineTo(w * 0.9326, h * 0.355);
	c.lineTo(w * 0.9347, h * 0.24);
	c.lineTo(w, h * 0.4667);
	c.close();
	c.stroke();
	
	c.begin();
	c.moveTo(w * 0.0652, h * 0.42);
	c.lineTo(w * 0.0652, h * 0.5);
	c.moveTo(w * 0.3337, h * 0.7667);
	c.lineTo(w * 0.4, h);
	c.moveTo(w * 0.9348, h * 0.355);
	c.lineTo(w, h * 0.4733);
	c.stroke();
	
	c.setLineJoin('miter');
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.1935, h * 0.42);
	c.lineTo(w * 0.5543, h * 0.0967);
	c.lineTo(w * 0.6652, h * 0.1967);
	c.lineTo(w * 0.3, h * 0.5133);
	c.close();
	c.moveTo(w * 0.2967, h * 0.4633);
	c.lineTo(w * 0.3837, h * 0.3883);
	c.lineTo(w * 0.3326, h * 0.3417);
	c.lineTo(w * 0.2467, h * 0.42);
	c.close();
	c.moveTo(w * 0.362, h * 0.32);
	c.lineTo(w * 0.412, h * 0.3633);
	c.lineTo(w * 0.5054, h * 0.2867);
	c.lineTo(w * 0.4522, h * 0.24);
	c.close();
	c.moveTo(w * 0.5293, h * 0.26);
	c.lineTo(w * 0.6109, h * 0.1933);
	c.lineTo(w * 0.5511, h * 0.145);
	c.lineTo(w * 0.4739, h * 0.2133);
	c.close();
	c.moveTo(w * 0.3528, h * 0.557);
	c.lineTo(w * 0.7137, h * 0.2337);
	c.lineTo(w * 0.8246, h * 0.3337);
	c.lineTo(w * 0.4593, h * 0.6503);
	c.close();
	c.moveTo(w * 0.4561, h * 0.6003);
	c.lineTo(w * 0.543, h * 0.5253);
	c.lineTo(w * 0.492, h * 0.4787);
	c.lineTo(w * 0.4061, h * 0.557);
	c.close();
	c.moveTo(w * 0.5213, h * 0.457);
	c.lineTo(w * 0.5713, h * 0.5003);
	c.lineTo(w * 0.6648, h * 0.4237);
	c.lineTo(w * 0.6115, h * 0.377);
	c.close();
	c.moveTo(w * 0.6887, h * 0.397);
	c.lineTo(w * 0.7702, h * 0.3303);
	c.lineTo(w * 0.7104, h * 0.282);
	c.lineTo(w * 0.6333, h * 0.3503);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.6483);
	c.lineTo(w * 0.0684, h * 0.4133);
	c.lineTo(w * 0.5326, 0);
	c.lineTo(w * 0.6685, 0);
	c.lineTo(w * 0.9359, h * 0.2367);
	c.lineTo(w, h * 0.465);
	c.lineTo(w * 0.4, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dAMI.prototype.cst.AMI, mxShapeAws3dAMI);

//**********************************************************************************************************************************************************
//Snapshot
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dSnapshot(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dSnapshot, mxShape);

mxShapeAws3dSnapshot.prototype.cst = {
		SNAPSHOT : 'mxgraph.aws3d.snapshot',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dSnapshot.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 92;
	var strokeWidth2 = strokeWidth * h / 60;
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	
	c.setStrokeWidth(strokeWidth);
	c.setShadow(false);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if(isShadow == 1)
	{
		c.setShadow(true);
	}
	
	c.begin();
	c.moveTo(w, h * 0.6483);
	c.lineTo(w * 0.9316, h * 0.4133);
	c.lineTo(w * 0.4674, 0);
	c.lineTo(w * 0.3315, 0);
	c.lineTo(w * 0.0641, h * 0.2367);
	c.lineTo(0, h * 0.465);
	c.lineTo(w * 0.6, h);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');

	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dSnapshot.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	
	c.begin();
	c.moveTo(w, h * 0.65);
	c.lineTo(w * 0.9348, h * 0.52);
	c.lineTo(w * 0.6674, h * 0.7667);
	c.lineTo(w * 0.5337, h * 0.7667);
	c.lineTo(w * 0.6, h);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	c.begin();
	c.moveTo(w * 0.6, h);
	c.lineTo(w * 0.5359, h * 0.77);
	c.lineTo(w * 0.0674, h * 0.355);
	c.lineTo(w * 0.0653, h * 0.24);
	c.lineTo(0, h * 0.4667);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(w, h * 0.65);
	c.lineTo(w * 0.9348, h * 0.52);
	c.lineTo(w * 0.6674, h * 0.7667);
	c.lineTo(w * 0.5337, h * 0.7667);
	c.lineTo(w * 0.6, h);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w * 0.6, h);
	c.lineTo(w * 0.5359, h * 0.77);
	c.lineTo(w * 0.0674, h * 0.355);
	c.lineTo(w * 0.0653, h * 0.24);
	c.lineTo(0, h * 0.4667);
	c.close();
	c.stroke();
	
	c.begin();
	c.moveTo(w * 0.9348, h * 0.42);
	c.lineTo(w * 0.9348, h * 0.52);
	c.moveTo(w * 0.6663, h * 0.7667);
	c.lineTo(w * 0.6, h);
	c.moveTo(w * 0.0652, h * 0.355);
	c.lineTo(0, h * 0.4733);
	c.stroke();
	
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(w, h * 0.6483);
	c.lineTo(w * 0.9316, h * 0.4133);
	c.lineTo(w * 0.4674, 0);
	c.lineTo(w * 0.3315, 0);
	c.lineTo(w * 0.0641, h * 0.2367);
	c.lineTo(0, h * 0.465);
	c.lineTo(w * 0.6, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dSnapshot.prototype.cst.SNAPSHOT, mxShapeAws3dSnapshot);

//**********************************************************************************************************************************************************
//Application
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dApplication(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dApplication, mxShape);

mxShapeAws3dApplication.prototype.cst = {
		APPLICATION : 'mxgraph.aws3d.application',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dApplication.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 62;
	var strokeWidth2 = strokeWidth * h / 68.8;
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	c.setShadow(false);
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if (isShadow == 1)
	{
		c.setShadow(true);
	}
	
	c.begin();
	c.moveTo(0, h * 0.2544);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.2544);
	c.lineTo(w, h * 0.7485);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.7485);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dApplication.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.2544);
	c.lineTo(w * 0.5, h * 0.5015);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.7485);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5, h * 0.5015);
	c.lineTo(w, h * 0.2544);
	c.lineTo(w, h * 0.7485);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.2544);
	c.lineTo(w * 0.5, h * 0.5015);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.7485);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w * 0.5, h * 0.5015);
	c.lineTo(w, h * 0.2544);
	c.lineTo(w, h * 0.7485);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
	
	c.setLineJoin('miter');
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.6694, h * 0.0872);
	c.lineTo(w * 0.7629, h * 0.1337);
	c.lineTo(w * 0.2661, h * 0.3882);
	c.lineTo(w * 0.2661, h * 0.5407);
	c.lineTo(w * 0.1742, h * 0.4953);
	c.lineTo(w * 0.1742, h * 0.3459);
	c.close();
	c.moveTo(w * 0.8629, h * 0.1846);
	c.lineTo(w * 0.379, h * 0.4331);
	c.lineTo(w * 0.379, h * 0.5945);
	c.lineTo(w * 0.2855, h * 0.5494);
	c.lineTo(w * 0.2855, h * 0.3953);
	c.lineTo(w * 0.7839, h * 0.1439);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.2544);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.2544);
	c.lineTo(w, h * 0.7485);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.7485);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dApplication.prototype.cst.APPLICATION, mxShapeAws3dApplication);

//**********************************************************************************************************************************************************
//Application Server
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dApplicationServer(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dApplicationServer, mxShape);

mxShapeAws3dApplicationServer.prototype.cst = {
		APPLICATION_SERVER : 'mxgraph.aws3d.application_server',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dApplicationServer.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 123;
	var strokeWidth2 = strokeWidth * h / 124;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dApplicationServer.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7236);
	c.lineTo(0, h * 0.2863);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.2863);
	c.lineTo(w, h * 0.7236);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dApplicationServer.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dApplicationServer.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.2863);
	c.lineTo(w * 0.5, h * 0.5726);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.7177);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w, h * 0.2863);
	c.lineTo(w * 0.5, h * 0.5726);
	c.lineTo(w * 0.5, h);
	c.lineTo(w, h * 0.7177);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.2863);
	c.lineTo(w * 0.5, h * 0.5726);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.7177);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w, h * 0.2863);
	c.lineTo(w * 0.5, h * 0.5726);
	c.lineTo(w * 0.5, h);
	c.lineTo(w, h * 0.7177);
	c.close();
	c.stroke();
	
	c.setLineJoin('miter');
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.374, h * 0.4435);
	c.arcTo(w * 0.0325, h * 0.0202, 0, 0, 1, w * 0.374, h * 0.4153);
	c.lineTo(w * 0.4797, h * 0.3548);
	c.arcTo(w * 0.0325, h * 0.0161, 0, 0, 1, w * 0.5203, h * 0.3548);
	c.lineTo(w * 0.626, h * 0.4153);
	c.arcTo(w * 0.0325, h * 0.0202, 0, 0, 1, w * 0.626, h * 0.4411);
	c.lineTo(w * 0.5203, h * 0.5016);
	c.arcTo(w * 0.0325, h * 0.0161, 0, 0, 1, w * 0.4797, h * 0.5016);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7236);
	c.lineTo(0, h * 0.2863);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.2863);
	c.lineTo(w, h * 0.7236);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dApplicationServer.prototype.cst.APPLICATION_SERVER, mxShapeAws3dApplicationServer);

//**********************************************************************************************************************************************************
//CloudFront
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dCloudFront(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dCloudFront, mxShape);

mxShapeAws3dCloudFront.prototype.cst = {
		CLOUDFRONT : 'mxgraph.aws3d.cloudfront',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dCloudFront.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 103.8;
	var strokeWidth2 = strokeWidth * h / 169.8;
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	c.setShadow(false);
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if (isShadow == 1)
	{
		c.setShadow(true);
	}
	
	c.begin();
	c.moveTo(0, h * 0.7915);
	c.lineTo(0, h * 0.7491);
	c.lineTo(w * 0.0588, h * 0.7279);
	c.lineTo(w * 0.0588, h * 0.1036);
	c.lineTo(w * 0.3526, 0);
	c.lineTo(w * 0.9422, h * 0.2073);
	c.lineTo(w * 0.9422, h * 0.8316);
	c.lineTo(w, h * 0.8539);
	c.lineTo(w, h * 0.894);
	c.lineTo(w * 0.7013, h);
	c.lineTo(w * 0.5877, h);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dCloudFront.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(w * 0.0588, h * 0.106);
	c.lineTo(w * 0.6474, h * 0.3121);
	c.lineTo(w * 0.6474, h * 0.9352);
	c.lineTo(w * 0.7052, h);
	c.lineTo(w * 0.5915, h);
	c.lineTo(0, h * 0.7915);
	c.lineTo(0, h * 0.7491);
	c.lineTo(w * 0.0588, h * 0.7279);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.6474, h * 0.3121);
	c.lineTo(w * 0.9422, h * 0.2073);
	c.lineTo(w * 0.9422, h * 0.8363);
	c.lineTo(w, h * 0.8539);
	c.lineTo(w, h * 0.894);
	c.lineTo(w * 0.7013, h);
	c.lineTo(w * 0.6474, h * 0.9305);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	c.begin();
	c.moveTo(0, h * 0.7915);
	c.lineTo(w * 0.0559, h * 0.7291);
	c.lineTo(w * 0.6474, h * 0.9364);
	c.lineTo(w * 0.5896, h);
	c.moveTo(w * 0.6493, h * 0.9364);
	c.lineTo(w * 0.9412, h * 0.8333);
	c.lineTo(w, h * 0.894);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.0588, h * 0.106);
	c.lineTo(w * 0.6474, h * 0.3121);
	c.lineTo(w * 0.6474, h * 0.9352);
	c.lineTo(w * 0.7052, h);
	c.lineTo(w * 0.5915, h);
	c.lineTo(0, h * 0.7915);
	c.lineTo(0, h * 0.7491);
	c.lineTo(w * 0.0588, h * 0.7279);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w * 0.6474, h * 0.3121);
	c.lineTo(w * 0.9422, h * 0.2073);
	c.lineTo(w * 0.9422, h * 0.8363);
	c.lineTo(w, h * 0.8539);
	c.lineTo(w, h * 0.894);
	c.lineTo(w * 0.7013, h);
	c.lineTo(w * 0.6474, h * 0.9305);
	c.close();
	c.stroke();

	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	
	c.begin();
	c.moveTo(w * 0.3333, h * 0.6643);
	c.arcTo(w * 0.3372, h * 0.2061, 0, 0, 1, w * 0.2351, h * 0.6042);
	c.arcTo(w * 0.4528, h * 0.2768, 0, 0, 1, w * 0.1724, h * 0.523);
	c.lineTo(w * 0.2428, h * 0.5677);
	c.lineTo(w * 0.2427, h * 0.5895);
	c.lineTo(w * 0.2765, h * 0.5995);
	c.close();
	c.moveTo(w * 0.1599, h * 0.4935);
	c.arcTo(w * 0.3372, h * 0.2061, 0, 0, 1, w * 0.1522, h * 0.4146);
	c.arcTo(w * 0.1156, h * 0.0883, 0, 0, 1, w * 0.2071, h * 0.3486);
	c.lineTo(w * 0.2013, h * 0.4187);
	c.lineTo(w * 0.1859, h * 0.4146);
	c.lineTo(w * 0.1859, h * 0.4464);
	c.lineTo(w * 0.1907, h * 0.4493);
	c.close();
	c.moveTo(w * 0.2235, h * 0.3445);
	c.arcTo(w * 0.1927, h * 0.1767, 0, 0, 1, w * 0.368, h * 0.361);
	c.arcTo(w * 0.3854, h * 0.2356, 0, 0, 1, w * 0.468, h * 0.4299);
	c.lineTo(w * 0.368, h * 0.4034);
	c.lineTo(w * 0.368, h * 0.394);
	c.lineTo(w * 0.3256, h * 0.3799);
	c.lineTo(w * 0.3256, h * 0.3887);
	c.close();
	c.moveTo(w * 0.4855, h * 0.4499);
	c.arcTo(w * 0.3854, h * 0.2356, 0, 0, 1, w * 0.5337, h * 0.5395);
	c.arcTo(w * 0.3854, h * 0.2356, 0, 0, 1, w * 0.5328, h * 0.6302);
	c.lineTo(w * 0.4952, h * 0.5589);
	c.lineTo(w * 0.5019, h * 0.5595);
	c.lineTo(w * 0.5019, h * 0.5265);
	c.lineTo(w * 0.4855, h * 0.5194);
	c.close();
	c.moveTo(w * 0.5241, h * 0.6455);
	c.arcTo(w * 0.0963, h * 0.0589, 0, 0, 1, w * 0.4663, h * 0.682);
	c.arcTo(w * 0.1445, h * 0.0883, 0, 0, 1, w * 0.3642, h * 0.6761);
	c.lineTo(w * 0.4239, h * 0.6525);
	c.lineTo(w * 0.4566, h * 0.6643);
	c.lineTo(w * 0.4566, h * 0.6413);
	c.close();
	c.moveTo(w * 0.3507, h * 0.6667);
	c.lineTo(w * 0.2871, h * 0.5919);
	c.lineTo(w * 0.4123, h * 0.6366);
	c.close();
	c.moveTo(w * 0.2563, h * 0.5595);
	c.lineTo(w * 0.1753, h * 0.5088);
	c.lineTo(w * 0.2052, h * 0.4594);
	c.close();
	c.moveTo(w * 0.2139, h * 0.4229);
	c.lineTo(w * 0.2197, h * 0.3528);
	c.lineTo(w * 0.3256, h * 0.4028);
	c.lineTo(w * 0.2283, h * 0.4252);
	c.close();
	c.moveTo(w * 0.2264, h * 0.4417);
	c.lineTo(w * 0.3218, h * 0.4146);
	c.lineTo(w * 0.3353, h * 0.4181);
	c.lineTo(w * 0.3353, h * 0.4971);
	c.lineTo(w * 0.3208, h * 0.4912);
	c.lineTo(w * 0.3208, h * 0.4965);
	c.lineTo(w * 0.2264, h * 0.4482);
	c.close();
	c.moveTo(w * 0.2697, h * 0.5618);
	c.lineTo(w * 0.2245, h * 0.4635);
	c.lineTo(w * 0.2331, h * 0.4588);
	c.lineTo(w * 0.3256, h * 0.5112);
	c.lineTo(w * 0.3237, h * 0.5241);
	c.close();
	c.moveTo(w * 0.2852, h * 0.576);
	c.lineTo(w * 0.2852, h * 0.5654);
	c.lineTo(w * 0.3391, h * 0.53);
	c.lineTo(w * 0.3516, h * 0.5347);
	c.lineTo(w * 0.4133, h * 0.6213);
	c.close();
	c.moveTo(w * 0.368, h * 0.5141);
	c.lineTo(w * 0.368, h * 0.5088);
	c.lineTo(w * 0.3526, h * 0.5029);
	c.lineTo(w * 0.3526, h * 0.4234);
	c.lineTo(w * 0.3622, h * 0.4276);
	c.lineTo(w * 0.4547, h * 0.5177);
	c.lineTo(w * 0.4557, h * 0.5277);
	c.close();
	c.moveTo(w * 0.3671, h * 0.417);
	c.lineTo(w * 0.4692, h * 0.4411);
	c.lineTo(w * 0.4721, h * 0.52);
	c.close();
	c.moveTo(w * 0.368, h * 0.5253);
	c.lineTo(w * 0.4566, h * 0.5359);
	c.lineTo(w * 0.4566, h * 0.5453);
	c.lineTo(w * 0.4663, h * 0.5465);
	c.lineTo(w * 0.4335, h * 0.6201);
	c.lineTo(w * 0.422, h * 0.616);
	c.lineTo(w * 0.368, h * 0.5389);
	c.close();
	c.moveTo(w * 0.4798, h * 0.5583);
	c.lineTo(w * 0.5183, h * 0.629);
	c.lineTo(w * 0.4557, h * 0.6313);
	c.lineTo(w * 0.4557, h * 0.6237);
	c.lineTo(w * 0.447, h * 0.6225);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7915);
	c.lineTo(0, h * 0.7491);
	c.lineTo(w * 0.0588, h * 0.7279);
	c.lineTo(w * 0.0588, h * 0.1036);
	c.lineTo(w * 0.3526, 0);
	c.lineTo(w * 0.9422, h * 0.2073);
	c.lineTo(w * 0.9422, h * 0.8316);
	c.lineTo(w, h * 0.8539);
	c.lineTo(w, h * 0.894);
	c.lineTo(w * 0.7013, h);
	c.lineTo(w * 0.5877, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dCloudFront.prototype.cst.CLOUDFRONT, mxShapeAws3dCloudFront);

//**********************************************************************************************************************************************************
//Data Center
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dDataCenter(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dDataCenter, mxShape);

mxShapeAws3dDataCenter.prototype.cst = {
		DATA_CENTER : 'mxgraph.aws3d.dataCenter',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dDataCenter.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 123;
	var strokeWidth2 = strokeWidth * h / 142;
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	c.setShadow(false);
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if (isShadow == 1)
	{
		c.setShadow(true);
	}
	
	c.begin();
	c.moveTo(0, h * 0.7465);
	c.lineTo(0, h * 0.25);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.25);
	c.lineTo(w, h * 0.7465);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dDataCenter.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.7465);
	c.lineTo(0, h * 0.25);
	c.lineTo(w * 0.5, h * 0.5);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w, h * 0.7465);
	c.lineTo(w, h * 0.25);
	c.lineTo(w * 0.5, h * 0.5);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	c.begin();
	c.moveTo(0, h * 0.7465);
	c.lineTo(0, h * 0.25);
	c.lineTo(w * 0.5, h * 0.5);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w, h * 0.7465);
	c.lineTo(w, h * 0.25);
	c.lineTo(w * 0.5, h * 0.5);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();

	c.setLineCap('round');
	c.setStrokeWidth(3 * strokeWidth);

	c.begin();
	c.moveTo(w * 0.0894, h * 0.3838);
	c.lineTo(w * 0.4187, h * 0.5493);
	c.moveTo(w * 0.0894, h * 0.4331);
	c.lineTo(w * 0.4187, h * 0.5986);
	c.moveTo(w * 0.0894, h * 0.4824);
	c.lineTo(w * 0.4187, h * 0.6479);
	c.moveTo(w * 0.5854, h * 0.5493);
	c.lineTo(w * 0.9146, h * 0.3838);
	c.moveTo(w * 0.5854, h * 0.5986);
	c.lineTo(w * 0.9146, h * 0.4331);
	c.moveTo(w * 0.5854, h * 0.6479);
	c.lineTo(w * 0.9146, h * 0.4824);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7465);
	c.lineTo(0, h * 0.25);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.25);
	c.lineTo(w, h * 0.7465);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dDataCenter.prototype.cst.DATA_CENTER, mxShapeAws3dDataCenter);

//**********************************************************************************************************************************************************
//Data Server
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dDataServer(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dDataServer, mxShape);

mxShapeAws3dDataServer.prototype.cst = {
		DATA_SERVER : 'mxgraph.aws3d.dataServer',
		SHADINC_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dDataServer.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 123;
	var strokeWidth2 = strokeWidth * h / 106;
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	c.setShadow(false);
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if (isShadow == 1)
	{
		c.setShadow(true);
	}
	
	c.begin();
	c.moveTo(0, h * 0.6651);
	c.lineTo(0, h * 0.3349);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.3349);
	c.lineTo(w, h * 0.6651);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dDataServer.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.6651);
	c.lineTo(0, h * 0.3349);
	c.lineTo(w * 0.5, h * 0.6698);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w, h * 0.6651);
	c.lineTo(w, h * 0.3349);
	c.lineTo(w * 0.5, h * 0.6698);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	c.begin();
	c.moveTo(0, h * 0.6651);
	c.lineTo(0, h * 0.3349);
	c.lineTo(w * 0.5, h * 0.6698);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w, h * 0.6651);
	c.lineTo(w, h * 0.3349);
	c.lineTo(w * 0.5, h * 0.6698);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();

	c.setLineCap('round');
	c.setStrokeWidth(3 * strokeWidth);

	c.begin();
	c.moveTo(w * 0.0878, h * 0.4858);
	c.lineTo(w * 0.4187, h * 0.7094);
	c.moveTo(w * 0.587, h * 0.7094);
	c.lineTo(w * 0.9187, h * 0.4858);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.6651);
	c.lineTo(0, h * 0.3349);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.3349);
	c.lineTo(w, h * 0.6651);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dDataServer.prototype.cst.DATA_SERVER, mxShapeAws3dDataServer);

//**********************************************************************************************************************************************************
//Elastic Load Balancing
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dElasticLoadBalancing(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dElasticLoadBalancing, mxShape);

mxShapeAws3dElasticLoadBalancing.prototype.cst = {
		ELASTIC_LOAD_BALANCING : 'mxgraph.aws3d.elasticLoadBalancing',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dElasticLoadBalancing.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 92;
	var strokeWidth2 = strokeWidth * h / 88.17;
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	c.setShadow(false);
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if (isShadow == 1)
	{
		c.setShadow(true);
	}
	
	c.begin();
	c.moveTo(0, h * 0.7996);
	c.lineTo(0, h * 0.1985);
	c.lineTo(w * 0.3315, 0);
	c.lineTo(w * 0.6685, 0);
	c.lineTo(w, h * 0.1985);
	c.lineTo(w, h * 0.7996);
	c.lineTo(w * 0.6685, h);
	c.lineTo(w * 0.3315, h);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dElasticLoadBalancing.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.4026);
	c.lineTo(w * 0.3315, h * 0.6011);
	c.lineTo(w * 0.6685, h * 0.6011);
	c.lineTo(w * 0.6685, h);
	c.lineTo(w * 0.3315, h);
	c.lineTo(0, h * 0.7996);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.6685, h * 0.6011);
	c.lineTo(w, h * 0.4026);
	c.lineTo(w, h * 0.7996);
	c.lineTo(w * 0.6685, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	c.begin();
	c.moveTo(0, h * 0.4026);
	c.lineTo(w * 0.3315, h * 0.6011);
	c.lineTo(w * 0.6685, h * 0.6011);
	c.lineTo(w * 0.6685, h);
	c.lineTo(w * 0.3315, h);
	c.lineTo(0, h * 0.7996);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w * 0.6685, h * 0.6011);
	c.lineTo(w, h * 0.4026);
	c.lineTo(w, h * 0.7996);
	c.lineTo(w * 0.6685, h);
	c.close();
	c.moveTo(w * 0.3315, h * 0.6011);
	c.lineTo(w * 0.3315, h);
	c.stroke();

	c.restore();
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.337, h * 0.1395);
	c.arcTo(w * 0.3043, h * 0.1928, 0, 0, 1, w * 0.5, h * 0.1191);
	c.arcTo(w * 0.3043, h * 0.1928, 0, 0, 1, w * 0.6739, h * 0.1645);
	c.arcTo(w * 0.3261, h * 0.2155, 0, 0, 1, w * 0.8152, h * 0.3176);
	c.arcTo(w * 0.3261, h * 0.1701, 0, 0, 1, w * 0.75, h * 0.4367);
	c.arcTo(w * 0.3261, h * 0.3403, 0, 0, 1, w * 0.6033, h * 0.4854);
	c.arcTo(w * 0.3261, h * 0.2268, 0, 0, 1, w * 0.4348, h * 0.4741);
	c.arcTo(w * 0.3261, h * 0.2268, 0, 0, 1, w * 0.2848, h * 0.4094);
	c.arcTo(w * 0.3261, h * 0.2268, 0, 0, 1, w * 0.2065, h * 0.3062);
	c.arcTo(w * 0.3261, h * 0.1701, 0, 0, 1, w * 0.2446, h * 0.1928);
	c.arcTo(w * 0.2717, h * 0.1701, 0, 0, 1, w * 0.337, h * 0.1395);
	c.fill();

	c.restore();
	c.begin();
	c.moveTo(w * 0.2826, h * 0.372);
	c.lineTo(w * 0.362, h * 0.3232);
	c.lineTo(w * 0.4054, h * 0.3482);
	c.lineTo(w * 0.4457, h * 0.2654);
	c.lineTo(w * 0.4185, h * 0.2643);
	c.lineTo(w * 0.4728, h * 0.2132);
	c.lineTo(w * 0.4348, h * 0.1928);
	c.lineTo(w * 0.5141, h * 0.144);
	c.lineTo(w * 0.5837, h * 0.1883);
	c.lineTo(w * 0.5043, h * 0.2348);
	c.lineTo(w * 0.4848, h * 0.2223);
	c.lineTo(w * 0.4967, h * 0.2688);
	c.lineTo(w * 0.463, h * 0.2665);
	c.lineTo(w * 0.4304, h * 0.3346);
	c.lineTo(w * 0.4946, h * 0.2949);
	c.lineTo(w * 0.4761, h * 0.2858);
	c.lineTo(w * 0.5511, h * 0.2631);
	c.lineTo(w * 0.5261, h * 0.2472);
	c.lineTo(w * 0.6043, h * 0.1996);
	c.lineTo(w * 0.6761, h * 0.2404);
	c.lineTo(w * 0.5978, h * 0.2892);
	c.lineTo(w * 0.5652, h * 0.2699);
	c.lineTo(w * 0.5293, h * 0.3198);
	c.lineTo(w * 0.5087, h * 0.3051);
	c.lineTo(w * 0.4543, h * 0.3391);
	c.lineTo(w * 0.563, h * 0.3221);
	c.lineTo(w * 0.5598, h * 0.3017);
	c.lineTo(w * 0.6326, h * 0.3096);
	c.lineTo(w * 0.6163, h * 0.2994);
	c.lineTo(w * 0.6957, h * 0.2529);
	c.lineTo(w * 0.7674, h * 0.2938);
	c.lineTo(w * 0.687, h * 0.3425);
	c.lineTo(w * 0.6489, h * 0.321);
	c.lineTo(w * 0.5707, h * 0.3539);
	c.lineTo(w * 0.5674, h * 0.3369);
	c.lineTo(w * 0.4293, h * 0.3618);
	c.lineTo(w * 0.4641, h * 0.3834);
	c.lineTo(w * 0.3859, h * 0.4299);
	c.close();
	c.fill();
	
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7996);
	c.lineTo(0, h * 0.1985);
	c.lineTo(w * 0.3315, 0);
	c.lineTo(w * 0.6685, 0);
	c.lineTo(w, h * 0.1985);
	c.lineTo(w, h * 0.7996);
	c.lineTo(w * 0.6685, h);
	c.lineTo(w * 0.3315, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dElasticLoadBalancing.prototype.cst.ELASTIC_LOAD_BALANCING, mxShapeAws3dElasticLoadBalancing);

//**********************************************************************************************************************************************************
//Instance
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dInstance(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dInstance, mxShape);

mxShapeAws3dInstance.prototype.cst = {
		INSTANCE : 'mxgraph.aws3d.instance',
		SHADIG_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dInstance.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 123;
	var strokeWidth2 = strokeWidth * h / 97;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dInstance.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.634);
	c.lineTo(0, h * 0.2732);
	c.lineTo(w * 0.374, 0);
	c.lineTo(w * 0.622, 0);
	c.lineTo(w, h * 0.2732);
	c.lineTo(w, h * 0.634);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dInstance.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dInstance.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.2732);
	c.lineTo(w * 0.5, h * 0.6392);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.634);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5, h * 0.6392);
	c.lineTo(w, h * 0.2732);
	c.lineTo(w, h * 0.6392);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.2732);
	c.lineTo(w * 0.5, h * 0.6392);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.634);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w * 0.5, h * 0.6392);
	c.lineTo(w, h * 0.2732);
	c.lineTo(w, h * 0.6392);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
	
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.374, h * 0.4742);
	c.arcTo(w * 0.0325, h * 0.0258, 0, 0, 1, w * 0.374, h * 0.4381);
	c.lineTo(w * 0.4797, h * 0.3608);
	c.arcTo(w * 0.0325, h * 0.0206, 0, 0, 1, w * 0.5203, h * 0.3608);
	c.lineTo(w * 0.626, h * 0.4381);
	c.arcTo(w * 0.0325, h * 0.0258, 0, 0, 1, w * 0.626, h * 0.4711);
	c.lineTo(w * 0.5203, h * 0.5485);
	c.arcTo(w * 0.0325, h * 0.0206, 0, 0, 1, w * 0.4797, h * 0.5485);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.634);
	c.lineTo(0, h * 0.2732);
	c.lineTo(w * 0.374, 0);
	c.lineTo(w * 0.622, 0);
	c.lineTo(w, h * 0.2732);
	c.lineTo(w, h * 0.634);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dInstance.prototype.cst.INSTANCE, mxShapeAws3dInstance);

//**********************************************************************************************************************************************************
//Internet Gateway
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dInternetGateway(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dInternetGateway, mxShape);

mxShapeAws3dInternetGateway.prototype.cst = {
		INTERNET_GATEWAY : 'mxgraph.aws3d.internetGateway',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dInternetGateway.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 116.7;
	var strokeWidth2 = strokeWidth * h / 102.8;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dInternetGateway.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.save();
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(w * 0.4199, h * 0.5447);
	c.lineTo(w * 0.4199, h * 0.035);
	c.lineTo(w * 0.8946, 0);
	c.lineTo(w, h * 0.0691);
	c.lineTo(w, h * 0.4134);
	c.lineTo(w * 0.6812, h * 0.7247);
	c.close();
	c.fillAndStroke();

	c.restore();
	c.save();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dInternetGateway.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	c.begin();
	c.moveTo(w * 0.4199, h * 0.5447);
	c.lineTo(w * 0.4199, h * 0.035);
	c.lineTo(w * 0.6838, h * 0.2072);
	c.lineTo(w * 0.6838, h * 0.7247);
	c.close();
	c.fill();
	
	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.6838, h * 0.2072);
	c.lineTo(w, h * 0.0691);
	c.lineTo(w, h * 0.4134);
	c.lineTo(w * 0.6838, h * 0.7247);
	c.close();
	c.fill();

	c.restore();
	c.setShadow(false);
	c.begin();
	c.moveTo(w * 0.4199, h * 0.5447);
	c.lineTo(w * 0.4199, h * 0.035);
	c.lineTo(w * 0.6838, h * 0.2072);
	c.lineTo(w * 0.6838, h * 0.7247);
	c.close();
	c.stroke();

	c.restore();
	c.setLineJoin('round');
	c.setShadow(false);

	c.begin();
	c.moveTo(w * 0.6838, h * 0.2072);
	c.lineTo(w, h * 0.0691);
	c.lineTo(w, h * 0.4134);
	c.lineTo(w * 0.6838, h * 0.7247);
	c.close();
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	
	c.begin();
	c.moveTo(w * 0.4199, h * 0.5447);
	c.lineTo(w * 0.4199, h * 0.035);
	c.lineTo(w * 0.8946, 0);
	c.lineTo(w, h * 0.0691);
	c.lineTo(w, h * 0.4134);
	c.lineTo(w * 0.6812, h * 0.7247);
	c.close();
	c.stroke();

	c.restore();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.929);
	c.lineTo(0, h * 0.5866);
	c.lineTo(w * 0.3171, h * 0.1031);
	c.lineTo(w * 0.5784, h * 0.2753);
	c.lineTo(w * 0.5784, h * 0.7928);
	c.lineTo(w * 0.1054, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dInternetGateway.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setShadow(false);
	c.setLineJoin('round');
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dInternetGateway.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.929);
	c.lineTo(0, h * 0.5866);
	c.lineTo(w * 0.1054, h * 0.6537);
	c.lineTo(w * 0.1054, h);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.1054, h);
	c.lineTo(w * 0.1054, h * 0.6537);
	c.lineTo(w * 0.5784, h * 0.2753);
	c.lineTo(w * 0.5784, h * 0.7928);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.929);
	c.lineTo(0, h * 0.5866);
	c.lineTo(w * 0.1054, h * 0.6537);
	c.lineTo(w * 0.1054, h);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w * 0.1054, h);
	c.lineTo(w * 0.1054, h * 0.6537);
	c.lineTo(w * 0.5784, h * 0.2753);
	c.lineTo(w * 0.5784, h * 0.7928);
	c.close();
	c.stroke();
	
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.929);
	c.lineTo(0, h * 0.5866);
	c.lineTo(w * 0.3171, h * 0.1031);
	c.lineTo(w * 0.5784, h * 0.2753);
	c.lineTo(w * 0.5784, h * 0.7928);
	c.lineTo(w * 0.1054, h);
	c.close();
	c.stroke();
	
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.7849, h * 0.5039);
	c.arcTo(w * 0.0343, h * 0.0632, 0, 0, 1, w * 0.7481, h * 0.4796);
	c.arcTo(w * 0.0857, h * 0.0973, 0, 0, 1, w * 0.7661, h * 0.3911);
	c.arcTo(w * 0.06, h * 0.0681, 0, 0, 1, w * 0.7712, h * 0.3356);
	c.arcTo(w * 0.0257, h * 0.0292, 0, 0, 1, w * 0.7952, h * 0.32);
	c.arcTo(w * 0.1285, h * 0.1459, 0, 0, 1, w * 0.8166, h * 0.2461);
	c.arcTo(w * 0.06, h * 0.0973, 0, 0, 1, w * 0.8595, h * 0.2238);
	c.arcTo(w * 0.0514, h * 0.0973, 0, 0, 1, w * 0.8937, h * 0.2743);
	c.arcTo(w * 0.0428, h * 0.0778, 0, 0, 1, w * 0.9323, h * 0.3093);
	c.arcTo(w * 0.0686, h * 0.0778, 0, 0, 1, w * 0.928, h * 0.3716);
	c.arcTo(w * 0.0857, h * 0.0973, 0, 0, 1, w * 0.8972, h * 0.4125);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeAws3dInternetGateway.prototype.cst.INTERNET_GATEWAY, mxShapeAws3dInternetGateway);

//**********************************************************************************************************************************************************
//Oracle Data Center
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dOracleDataCenter(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dOracleDataCenter, mxShape);

mxShapeAws3dOracleDataCenter.prototype.cst = {
		ORACLE_DATA_CENTER : 'mxgraph.aws3d.oracleDataCenter'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dOracleDataCenter.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 123;
	var strokeWidth2 = strokeWidth * h /142;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	c.setStrokeWidth(strokeWidth);
	
	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dOracleDataCenter.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.save();
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7464);
	c.lineTo(0, h * 0.25);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.25);
	c.lineTo(w, h * 0.7464);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dOracleDataCenter.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	c.setAlpha('0.1');
	
	c.begin();
	c.moveTo(0, h * 0.7464);
	c.lineTo(0, h * 0.25);
	c.lineTo(w * 0.5, h * 0.5);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();

	c.setAlpha('0.3');
	c.begin();
	c.moveTo(w * 0.5, h * 0.5);
	c.lineTo(w, h * 0.25);
	c.lineTo(w, h * 0.7464);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.setFillColor('#ff0000');

	c.begin();
	c.moveTo(0, h * 0.5866);
	c.lineTo(w * 0.5, h * 0.8359);
	c.lineTo(w, h * 0.5866);
	c.lineTo(w, h * 0.6986);
	c.lineTo(w * 0.5, h * 0.9486);
	c.lineTo(0, h * 0.6986);
	c.fill();

	c.setStrokeWidth(0.5 * strokeWidth);
	c.setStrokeColor('#ffffff');
	c.setFillColor('#ffffff');
	
	c.begin();
	c.moveTo(0, h * 0.5866);
	c.lineTo(w * 0.5, h * 0.8359);
	c.lineTo(w, h * 0.5866);
	c.moveTo(w, h * 0.6986);
	c.lineTo(w * 0.5, h * 0.9486);
	c.lineTo(0, h * 0.6986);
	c.stroke();
	
	c.begin();
	c.moveTo(w * 0.0813, h * 0.7113);
	c.arcTo(w * 0.0569, h * 0.0493, 0, 0, 1, w * 0.065, h * 0.6831);
	c.arcTo(w * 0.065, h * 0.0563, 0, 0, 1, w * 0.065, h * 0.6613);
	c.arcTo(w * 0.0163, h * 0.0141, 0, 0, 1, w * 0.0797, h * 0.6549);
	c.lineTo(w * 0.122, h * 0.6754);
	c.arcTo(w * 0.065, h * 0.0563, 0, 0, 1, w * 0.1358, h * 0.6937);
	c.arcTo(w * 0.065, h * 0.0563, 0, 0, 1, w * 0.139, h * 0.7232);
	c.arcTo(w * 0.0179, h * 0.0155, 0, 0, 1, w * 0.1187, h * 0.7296);
	c.close();
	c.moveTo(w * 0.1163, h * 0.7183);
	c.arcTo(w * 0.0089, h * 0.0077, 0, 0, 0, w * 0.1285, h * 0.7148);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 0, w * 0.1293, h * 0.7021);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 0, w * 0.1179, h * 0.6831);
	c.lineTo(w * 0.087, h * 0.6676);
	c.arcTo(w * 0.0081, h * 0.007, 0, 0, 0, w * 0.0764, h * 0.6697);
	c.arcTo(w * 0.0325, h * 0.0352, 0, 0, 0, w * 0.078, h * 0.6937);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 0, w * 0.087, h * 0.7035);
	c.close();
	c.moveTo(w * 0.1439, h * 0.743);
	c.lineTo(w * 0.1439, h * 0.6866);
	c.lineTo(w * 0.1846, h * 0.707);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.1967, h * 0.7183);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.2, h * 0.738);
	c.arcTo(w * 0.0138, h * 0.0155, 0, 0, 1, w * 0.1813, h * 0.743);
	c.lineTo(w * 0.1992, h * 0.769);
	c.lineTo(w * 0.187, h * 0.7641);
	c.lineTo(w * 0.1577, h * 0.7218);
	c.lineTo(w * 0.1854, h * 0.7345);
	c.arcTo(w * 0.0041, h * 0.0035, 0, 0, 0, w * 0.1911, h * 0.7317);
	c.arcTo(w * 0.0163, h * 0.0141, 0, 0, 0, w * 0.1894, h * 0.7225);
	c.arcTo(w * 0.0325, h * 0.0282, 0, 0, 0, w * 0.1821, h * 0.7155);
	c.lineTo(w * 0.1528, h * 0.7007);
	c.lineTo(w * 0.1528, h * 0.7472);
	c.close();
	c.moveTo(w * 0.2008, h * 0.7711);
	c.lineTo(w * 0.2293, h * 0.7338);
	c.arcTo(w * 0.0065, h * 0.0056, 0, 0, 1, w * 0.2382, h * 0.7324);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.2431, h * 0.7415);
	c.lineTo(w * 0.2699, h * 0.8035);
	c.lineTo(w * 0.2602, h * 0.8007);
	c.lineTo(w * 0.252, h * 0.7859);
	c.lineTo(w * 0.2293, h * 0.7754);
	c.lineTo(w * 0.2244, h * 0.7634);
	c.lineTo(w * 0.248, h * 0.7739);
	c.lineTo(w * 0.235, h * 0.7444);
	c.lineTo(w * 0.2122, h * 0.7768);
	c.close();
	c.moveTo(w * 0.3244, h * 0.8225);
	c.lineTo(w * 0.3171, h * 0.8289);
	c.lineTo(w * 0.2854, h * 0.8127);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.2724, h * 0.7986);
	c.arcTo(w * 0.0569, h * 0.0493, 0, 0, 1, w * 0.265, h * 0.7746);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.2683, h * 0.762);
	c.arcTo(w * 0.0163, h * 0.0141, 0, 0, 1, w * 0.2829, h * 0.757);
	c.lineTo(w * 0.3228, h * 0.7761);
	c.lineTo(w * 0.3179, h * 0.7831);
	c.lineTo(w * 0.2878, h * 0.7683);
	c.arcTo(w * 0.0081, h * 0.007, 0, 0, 0, w * 0.2789, h * 0.7697);
	c.arcTo(w * 0.0244, h * 0.0211, 0, 0, 0, w * 0.2748, h * 0.7831);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 0, w * 0.2878, h * 0.8042);
	c.close();
	c.moveTo(w * 0.3276, h * 0.7789);
	c.lineTo(w * 0.3366, h * 0.7831);
	c.lineTo(w * 0.3366, h * 0.8289);
	c.lineTo(w * 0.3805, h * 0.8507);
	c.lineTo(w * 0.3748, h * 0.857);
	c.lineTo(w * 0.3317, h * 0.8359);
	c.arcTo(w * 0.0163, h * 0.0141, 0, 0, 1, w * 0.3276, h * 0.8275);
	c.close();
	c.moveTo(w * 0.435, h * 0.8775);
	c.lineTo(w * 0.4325, h * 0.8866);
	c.lineTo(w * 0.3959, h * 0.8683);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.3862, h * 0.8563);
	c.arcTo(w * 0.0528, h * 0.0458, 0, 0, 1, w * 0.3805, h * 0.8183);
	c.arcTo(w * 0.0163, h * 0.0141, 0, 0, 1, w * 0.3951, h * 0.8134);
	c.lineTo(w * 0.435, h * 0.8324);
	c.lineTo(w * 0.4285, h * 0.838);
	c.lineTo(w * 0.4008, h * 0.8246);
	c.arcTo(w * 0.0098, h * 0.0085, 0, 0, 0, w * 0.3878, h * 0.831);
	c.lineTo(w * 0.4333, h * 0.8542);
	c.lineTo(w * 0.426, h * 0.8606);
	c.lineTo(w * 0.3878, h * 0.8415);
	c.arcTo(w * 0.0325, h * 0.0282, 0, 0, 0, w * 0.3976, h * 0.8585);
	c.close();

	c.moveTo(w * 0.6171, h * 0.8063);
	c.arcTo(w * 0.0163, h * 0.0141, 0, 0, 1, w * 0.6366, h * 0.8092);
	c.arcTo(w * 0.0325, h * 0.0282, 0, 0, 1, w * 0.639, h * 0.8303);
	c.arcTo(w * 0.065, h * 0.0563, 0, 0, 1, w * 0.6211, h * 0.8592);
	c.lineTo(w * 0.5894, h * 0.8761);
	c.arcTo(w * 0.0203, h * 0.0176, 0, 0, 1, w * 0.565, h * 0.8732);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.5659, h * 0.8458);
	c.arcTo(w * 0.0488, h * 0.0422, 0, 0, 1, w * 0.5805, h * 0.8246);
	c.close();
	c.moveTo(w * 0.5886, h * 0.8296);
	c.arcTo(w * 0.0325, h * 0.0282, 0, 0, 0, w * 0.5748, h * 0.8472);
	c.arcTo(w * 0.0325, h * 0.0282, 0, 0, 0, w * 0.574, h * 0.862);
	c.arcTo(w * 0.0098, h * 0.0085, 0, 0, 0, w * 0.587, h * 0.8676);
	c.lineTo(w * 0.6163, h * 0.8528);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 0, w * 0.6285, h * 0.8359);
	c.arcTo(w * 0.0244, h * 0.0211, 0, 0, 0, w * 0.6293, h * 0.8225);
	c.arcTo(w * 0.0098, h * 0.0085, 0, 0, 0, w * 0.6163, h * 0.8155);
	c.close();

	c.moveTo(w * 0.64, h * 0.85);
	c.lineTo(w * 0.64, h * 0.7930);
	c.lineTo(w * 0.6854, h * 0.7718);
	c.arcTo(w * 0.0106, h * 0.0092, 0, 0, 1, w * 0.7008, h * 0.7782);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.6959, h * 0.8);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.6805, h * 0.8127);
	c.lineTo(w * 0.6992, h * 0.8218);
	c.lineTo(w * 0.6854, h * 0.8282);
	c.lineTo(w * 0.6569, h * 0.8141);
	c.lineTo(w * 0.6805, h * 0.8021);
	c.arcTo(w * 0.0203, h * 0.0176, 0, 0, 0, w * 0.6894, h * 0.7923);
	c.arcTo(w * 0.0244, h * 0.0211, 0, 0, 0, w * 0.6894, h * 0.7845);
	c.arcTo(w * 0.0041, h * 0.0035, 0, 0, 0, w * 0.6837, h * 0.7831);
	c.lineTo(w * 0.6528, h * 0.7979);
	c.lineTo(w * 0.6528, h * 0.8437);
	c.close();
	c.moveTo(w * 0.7, h * 0.8204);
	c.lineTo(w * 0.7301, h * 0.7507);
	c.arcTo(w * 0.0098, h * 0.0085, 0, 0, 1, w * 0.7358, h * 0.7444);
	c.arcTo(w * 0.0098, h * 0.0085, 0, 0, 1, w * 0.7415, h * 0.7486);
	c.lineTo(w * 0.7699, h * 0.7852);
	c.lineTo(w * 0.7602, h * 0.7908);
	c.lineTo(w * 0.7537, h * 0.7838);
	c.lineTo(w * 0.7276, h * 0.7958);
	c.lineTo(w * 0.7228, h * 0.788);
	c.lineTo(w * 0.748, h * 0.7768);
	c.lineTo(w * 0.7358, h * 0.7585);
	c.lineTo(w * 0.7114, h * 0.8155);
	c.close();
	c.moveTo(w * 0.8244, h * 0.7486);
	c.lineTo(w * 0.8171, h * 0.762);
	c.lineTo(w * 0.7894, h * 0.7761);
	c.arcTo(w * 0.0244, h * 0.0211, 0, 0, 1, w * 0.7683, h * 0.7746);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.7667, h * 0.7507);
	c.arcTo(w * 0.0488, h * 0.0423, 0, 0, 1, w * 0.7937, h * 0.7162);
	c.lineTo(w * 0.822, h * 0.7035);
	c.lineTo(w * 0.8171, h * 0.7155);
	c.lineTo(w * 0.7902, h * 0.7296);
	c.arcTo(w * 0.0325, h * 0.0282, 0, 0, 0, w * 0.778, h * 0.743);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 0, w * 0.7756, h * 0.7606);
	c.arcTo(w * 0.0077, h * 0.0067, 0, 0, 0, w * 0.787, h * 0.767);
	c.close();
	c.moveTo(w * 0.8366, h * 0.6949);
	c.lineTo(w * 0.8366, h * 0.7423);
	c.lineTo(w * 0.878, h * 0.7231);
	c.lineTo(w * 0.874, h * 0.7338);
	c.lineTo(w * 0.8333, h * 0.7535);
	c.arcTo(w * 0.0041, h * 0.0035, 0, 0, 1, w * 0.8268, h * 0.75);
	c.lineTo(w * 0.8268, h * 0.7007);
	c.close();
	c.moveTo(w * 0.9342, h * 0.6472);
	c.lineTo(w * 0.9293, h * 0.6599);
	c.lineTo(w * 0.9033, h * 0.6725);
	c.arcTo(w * 0.0325, h * 0.0282, 0, 0, 0, w * 0.8927, h * 0.6817);
	c.arcTo(w * 0.0406, h * 0.0352, 0, 0, 0, w * 0.887, h * 0.6937);
	c.lineTo(w * 0.9309, h * 0.6725);
	c.lineTo(w * 0.9268, h * 0.6845);
	c.lineTo(w * 0.887, h * 0.7035);
	c.arcTo(w * 0.0089, h * 0.0077, 0, 0, 0, w * 0.8992, h * 0.7106);
	c.lineTo(w * 0.935, h * 0.693);
	c.lineTo(w * 0.9285, h * 0.7063);
	c.lineTo(w * 0.9008, h * 0.7197);
	c.arcTo(w * 0.0163, h * 0.0141, 0, 0, 1, w * 0.8829, h * 0.7204);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.8764, h * 0.7028);
	c.arcTo(w * 0.065, h * 0.0563, 0, 0, 1, w * 0.8959, h * 0.6669);
	c.fill();

	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7464);
	c.lineTo(0, h * 0.25);
	c.lineTo(w * 0.5, h * 0.5);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w * 0.5, h * 0.5);
	c.lineTo(w, h * 0.25);
	c.lineTo(w, h * 0.7464);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
	
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7464);
	c.lineTo(0, h * 0.25);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.25);
	c.lineTo(w, h * 0.7464);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
	
	c.restore();
	c.setShadow(false);
	c.setStrokeWidth(3 * strokeWidth);
	c.setLineCap('round');
	c.begin();
	c.moveTo(w * 0.0894, h * 0.3838);
	c.lineTo(w * 0.4187, h * 0.5493);
	c.moveTo(w * 0.0894, h * 0.4331);
	c.lineTo(w * 0.4187, h * 0.5986);
	c.moveTo(w * 0.0894, h * 0.4824);
	c.lineTo(w * 0.4187, h * 0.6479);
	c.moveTo(w * 0.5854, h * 0.5492);
	c.lineTo(w * 0.9146, h * 0.3838);
	c.moveTo(w * 0.5854, h * 0.5986);
	c.lineTo(w * 0.9146, h * 0.4331);
	c.moveTo(w * 0.5854, h * 0.6479);
	c.lineTo(w * 0.9146, h * 0.4824);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dOracleDataCenter.prototype.cst.ORACLE_DATA_CENTER, mxShapeAws3dOracleDataCenter);

//**********************************************************************************************************************************************************
//Oracle Database Server
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dOracleDatabaseServer(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dOracleDatabaseServer, mxShape);

mxShapeAws3dOracleDatabaseServer.prototype.cst = {
		ORACLE_DB_SERVER : 'mxgraph.aws3d.oracleDbServer'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dOracleDatabaseServer.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 123;
	var strokeWidth2 = strokeWidth * h /142;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	c.setStrokeWidth(strokeWidth);
	
	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dOracleDatabaseServer.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.save();
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.374, 0);
	c.lineTo(w * 0.626, 0);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3346);
	c.lineTo(w, h * 0.7331);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dOracleDatabaseServer.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	c.setAlpha('0.1');
	
	c.begin();
	c.moveTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.126, h * 0.267);
	c.lineTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.close();
	c.moveTo(w * 0.874, h * 0.267);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3308);
	c.fill();

	c.setAlpha('0.3');
	c.begin();
	c.moveTo(w * 0.5, h);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.622, h * 0.4023);
	c.lineTo(w * 0.874, h * 0.267);
	c.lineTo(w, h * 0.3308);
	c.lineTo(w, h * 0.7331);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.setFillColor('#ff0000');

	c.begin();
	c.moveTo(0, h * 0.5586);
	c.lineTo(w * 0.5, h * 0.8248);
	c.lineTo(w, h * 0.5586);
	c.lineTo(w, h * 0.6782);
	c.lineTo(w * 0.5, h * 0.9453);
	c.lineTo(0, h * 0.6782);
	c.fill();

	c.setStrokeWidth(0.5 * strokeWidth);
	c.setStrokeColor('#ffffff');
	c.setFillColor('#ffffff');
	
	c.begin();
	c.moveTo(0, h * 0.5586);
	c.lineTo(w * 0.5, h * 0.8248);
	c.lineTo(w, h * 0.5586);
	c.moveTo(w, h * 0.6782);
	c.lineTo(w * 0.5, h * 0.9453);
	c.lineTo(0, h * 0.6782);
	c.stroke();
	
	c.begin();
	c.moveTo(w * 0.0813, h * 0.6918);
	c.arcTo(w * 0.0569, h * 0.0526, 0, 0, 1, w * 0.065, h * 0.6616);
	c.arcTo(w * 0.065, h * 0.0601, 0, 0, 1, w * 0.065, h * 0.6384);
	c.arcTo(w * 0.0163, h * 0.0151, 0, 0, 1, w * 0.0797, h * 0.6315);
	c.lineTo(w * 0.122, h * 0.6534);
	c.arcTo(w * 0.065, h * 0.0601, 0, 0, 1, w * 0.1358, h * 0.673);
	c.arcTo(w * 0.065, h * 0.0601, 0, 0, 1, w * 0.139, h * 0.7045);
	c.arcTo(w * 0.0179, h * 0.0165, 0, 0, 1, w * 0.1187, h * 0.7113);
	c.close();
	c.moveTo(w * 0.1163, h * 0.6992);
	c.arcTo(w * 0.0089, h * 0.0082, 0, 0, 0, w * 0.1285, h * 0.6955);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 0, w * 0.1293, h * 0.6819);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 0, w * 0.1179, h * 0.6616);
	c.lineTo(w * 0.087, h * 0.6451);
	c.arcTo(w * 0.0081, h * 0.0075, 0, 0, 0, w * 0.0764, h * 0.6473);
	c.arcTo(w * 0.0325, h * 0.0376, 0, 0, 0, w * 0.078, h * 0.673);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 0, w * 0.087, h * 0.6834);
	c.close();
	c.moveTo(w * 0.1439, h * 0.7256);
	c.lineTo(w * 0.1439, h * 0.6654);
	c.lineTo(w * 0.1846, h * 0.6872);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 1, w * 0.1967, h * 0.6992);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 1, w * 0.2, h * 0.7203);
	c.arcTo(w * 0.0138, h * 0.0165, 0, 0, 1, w * 0.1813, h * 0.7256);
	c.lineTo(w * 0.1992, h * 0.7534);
	c.lineTo(w * 0.187, h * 0.7481);
	c.lineTo(w * 0.1577, h * 0.7029);
	c.lineTo(w * 0.1854, h * 0.7165);
	c.arcTo(w * 0.0041, h * 0.0037, 0, 0, 0, w * 0.1911, h * 0.7135);
	c.arcTo(w * 0.0163, h * 0.0151, 0, 0, 0, w * 0.1894, h * 0.7037);
	c.arcTo(w * 0.0325, h * 0.0301, 0, 0, 0, w * 0.1821, h * 0.6962);
	c.lineTo(w * 0.1528, h * 0.6804);
	c.lineTo(w * 0.1528, h * 0.7301);
	c.close();
	c.moveTo(w * 0.2008, h * 0.7556);
	c.lineTo(w * 0.2293, h * 0.7158);
	c.arcTo(w * 0.0065, h * 0.006, 0, 0, 1, w * 0.2382, h * 0.7143);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 1, w * 0.2431, h * 0.724);
	c.lineTo(w * 0.2699, h * 0.7902);
	c.lineTo(w * 0.2602, h * 0.7872);
	c.lineTo(w * 0.252, h * 0.7714);
	c.lineTo(w * 0.2293, h * 0.7602);
	c.lineTo(w * 0.2244, h * 0.7474);
	c.lineTo(w * 0.248, h * 0.7586);
	c.lineTo(w * 0.235, h * 0.7271);
	c.lineTo(w * 0.2122, h * 0.7617);
	c.close();
	c.moveTo(w * 0.3244, h * 0.8105);
	c.lineTo(w * 0.3171, h * 0.8173);
	c.lineTo(w * 0.2854, h * 0.8);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 1, w * 0.2724, h * 0.785);
	c.arcTo(w * 0.0569, h * 0.0526, 0, 0, 1, w * 0.265, h * 0.7593);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 1, w * 0.2683, h * 0.7459);
	c.arcTo(w * 0.0163, h * 0.0151, 0, 0, 1, w * 0.2829, h * 0.7405);
	c.lineTo(w * 0.3228, h * 0.7609);
	c.lineTo(w * 0.3179, h * 0.7684);
	c.lineTo(w * 0.2878, h * 0.7526);
	c.arcTo(w * 0.0081, h * 0.0075, 0, 0, 0, w * 0.2789, h * 0.7541);
	c.arcTo(w * 0.0244, h * 0.0225, 0, 0, 0, w * 0.2748, h * 0.7684);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 0, w * 0.2878, h * 0.7909);
	c.close();
	c.moveTo(w * 0.3276, h * 0.7639);
	c.lineTo(w * 0.3366, h * 0.7684);
	c.lineTo(w * 0.3366, h * 0.8173);
	c.lineTo(w * 0.3805, h * 0.8406);
	c.lineTo(w * 0.3748, h * 0.8473);
	c.lineTo(w * 0.3317, h * 0.8248);
	c.arcTo(w * 0.0163, h * 0.0151, 0, 0, 1, w * 0.3276, h * 0.8158);
	c.close();
	c.moveTo(w * 0.435, h * 0.8692);
	c.lineTo(w * 0.4325, h * 0.8789);
	c.lineTo(w * 0.3959, h * 0.8594);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 1, w * 0.3862, h * 0.8466);
	c.arcTo(w * 0.0528, h * 0.0489, 0, 0, 1, w * 0.3805, h * 0.806);
	c.arcTo(w * 0.0163, h * 0.0151, 0, 0, 1, w * 0.3951, h * 0.8008);
	c.lineTo(w * 0.435, h * 0.821);
	c.lineTo(w * 0.4285, h * 0.827);
	c.lineTo(w * 0.4008, h * 0.8127);
	c.arcTo(w * 0.0098, h * 0.0091, 0, 0, 0, w * 0.3878, h * 0.8196);
	c.lineTo(w * 0.4333, h * 0.8443);
	c.lineTo(w * 0.426, h * 0.8512);
	c.lineTo(w * 0.3878, h * 0.8308);
	c.arcTo(w * 0.0325, h * 0.0301, 0, 0, 0, w * 0.3976, h * 0.8489);
	c.close();

	c.moveTo(w * 0.6171, h * 0.7932);
	c.arcTo(w * 0.0163, h * 0.0151, 0, 0, 1, w * 0.6366, h * 0.7963);
	c.arcTo(w * 0.0325, h * 0.0301, 0, 0, 1, w * 0.639, h * 0.8188);
	c.arcTo(w * 0.065, h * 0.0601, 0, 0, 1, w * 0.6211, h * 0.8497);
	c.lineTo(w * 0.5894, h * 0.8677);
	c.arcTo(w * 0.0203, h * 0.0188, 0, 0, 1, w * 0.565, h * 0.8646);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 1, w * 0.5659, h * 0.8354);
	c.arcTo(w * 0.0488, h * 0.0451, 0, 0, 1, w * 0.5805, h * 0.8127);
	c.close();
	c.moveTo(w * 0.5886, h * 0.8181);
	c.arcTo(w * 0.0325, h * 0.0301, 0, 0, 0, w * 0.5748, h * 0.8368);
	c.arcTo(w * 0.0325, h * 0.0301, 0, 0, 0, w * 0.574, h * 0.8527);
	c.arcTo(w * 0.0098, h * 0.0091, 0, 0, 0, w * 0.587, h * 0.8586);
	c.lineTo(w * 0.6163, h * 0.8428);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 0, w * 0.6285, h * 0.8248);
	c.arcTo(w * 0.0244, h * 0.0225, 0, 0, 0, w * 0.6293, h * 0.8105);
	c.arcTo(w * 0.0098, h * 0.0091, 0, 0, 0, w * 0.6163, h * 0.803);
	c.close();
	c.moveTo(w * 0.64, h * 0.8398);
	c.lineTo(w * 0.64, h * 0.779);
	c.lineTo(w * 0.6854, h * 0.7563);
	c.arcTo(w * 0.0106, h * 0.0098, 0, 0, 1, w * 0.7008, h * 0.7632);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 1, w * 0.6959, h * 0.7865);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 1, w * 0.6805, h * 0.8);
	c.lineTo(w * 0.6992, h * 0.8097);
	c.lineTo(w * 0.6854, h * 0.8166);
	c.lineTo(w * 0.6569, h * 0.8015);
	c.lineTo(w * 0.6805, h * 0.7887);
	c.arcTo(w * 0.0203, h * 0.0188, 0, 0, 0, w * 0.6894, h * 0.7782);
	c.arcTo(w * 0.0244, h * 0.0225, 0, 0, 0, w * 0.6894, h * 0.7699);
	c.arcTo(w * 0.0041, h * 0.0037, 0, 0, 0, w * 0.6837, h * 0.7684);
	c.lineTo(w * 0.6528, h * 0.7842);
	c.lineTo(w * 0.6528, h * 0.8331);
	c.close();
	c.moveTo(w * 0.7, h * 0.8082);
	c.lineTo(w * 0.7301, h * 0.7338);
	c.arcTo(w * 0.0098, h * 0.0091, 0, 0, 1, w * 0.7358, h * 0.7271);
	c.arcTo(w * 0.0098, h * 0.0091, 0, 0, 1, w * 0.7415, h * 0.7316);
	c.lineTo(w * 0.7699, h * 0.7707);
	c.lineTo(w * 0.7602, h * 0.7766);
	c.lineTo(w * 0.7537, h * 0.7692);
	c.lineTo(w * 0.7276, h * 0.782);
	c.lineTo(w * 0.7228, h * 0.7736);
	c.lineTo(w * 0.748, h * 0.7617);
	c.lineTo(w * 0.7358, h * 0.7421);
	c.lineTo(w * 0.7114, h * 0.803);
	c.close();
	c.moveTo(w * 0.8244, h * 0.7316);
	c.lineTo(w * 0.8171, h * 0.7459);
	c.lineTo(w * 0.7894, h * 0.7609);
	c.arcTo(w * 0.0244, h * 0.0225, 0, 0, 1, w * 0.7683, h * 0.7593);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 1, w * 0.7667, h * 0.7338);
	c.arcTo(w * 0.0488, h * 0.0452, 0, 0, 1, w * 0.7937, h * 0.697);
	c.lineTo(w * 0.822, h * 0.6834);
	c.lineTo(w * 0.8171, h * 0.6962);
	c.lineTo(w * 0.7902, h * 0.7113);
	c.arcTo(w * 0.0325, h * 0.0301, 0, 0, 0, w * 0.778, h * 0.7256);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 0, w * 0.7756, h * 0.7444);
	c.arcTo(w * 0.0077, h * 0.0072, 0, 0, 0, w * 0.787, h * 0.7512);
	c.close();
	c.moveTo(w * 0.8366, h * 0.6742);
	c.lineTo(w * 0.8366, h * 0.7248);
	c.lineTo(w * 0.878, h * 0.7043);
	c.lineTo(w * 0.874, h * 0.7158);
	c.lineTo(w * 0.8333, h * 0.7368);
	c.arcTo(w * 0.0041, h * 0.0037, 0, 0, 1, w * 0.8268, h * 0.7324);
	c.lineTo(w * 0.8268, h * 0.6804);
	c.close();
	c.moveTo(w * 0.9342, h * 0.6233);
	c.lineTo(w * 0.9293, h * 0.6369);
	c.lineTo(w * 0.9033, h * 0.6503);
	c.arcTo(w * 0.0325, h * 0.0301, 0, 0, 0, w * 0.8927, h * 0.6601);
	c.arcTo(w * 0.0406, h * 0.0376, 0, 0, 0, w * 0.887, h * 0.6729);
	c.lineTo(w * 0.9309, h * 0.6503);
	c.lineTo(w * 0.9268, h * 0.6631);
	c.lineTo(w * 0.887, h * 0.6834);
	c.arcTo(w * 0.0089, h * 0.0082, 0, 0, 0, w * 0.8992, h * 0.691);
	c.lineTo(w * 0.935, h * 0.6722);
	c.lineTo(w * 0.9285, h * 0.6864);
	c.lineTo(w * 0.9008, h * 0.7007);
	c.arcTo(w * 0.0163, h * 0.0151, 0, 0, 1, w * 0.8829, h * 0.7015);
	c.arcTo(w * 0.0407, h * 0.0376, 0, 0, 1, w * 0.8764, h * 0.6827);
	c.arcTo(w * 0.065, h * 0.0601, 0, 0, 1, w * 0.8959, h * 0.6443);
	c.fill();

	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');

	c.begin();
	c.moveTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.126, h * 0.267);
	c.lineTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.622, h * 0.4023);
	c.lineTo(w * 0.874, h * 0.267);
	c.lineTo(w * 0.874, h * 0.1316);
	c.moveTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.267);
	c.moveTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.5, h);
	c.moveTo(w, h * 0.3346);
	c.lineTo(w * 0.87, h * 0.267);
	c.moveTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.622, h * 0.4023);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');

	c.begin();
	c.moveTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.374, 0);
	c.lineTo(w * 0.626, 0);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3346);
	c.lineTo(w, h * 0.7331);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dOracleDatabaseServer.prototype.cst.ORACLE_DB_SERVER, mxShapeAws3dOracleDatabaseServer);//zzz

//**********************************************************************************************************************************************************
//RDS Master
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dRdsMaster(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dRdsMaster, mxShape);

mxShapeAws3dRdsMaster.prototype.cst = {
		RDS_MASTER : 'mxgraph.aws3d.rdsMaster',
		SHADIG_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dRdsMaster.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 123;
	var strokeWidth2 = strokeWidth * h /133;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	c.setStrokeWidth(strokeWidth);
	
	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dRdsMaster.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.374, 0);
	c.lineTo(w * 0.626, 0);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3346);
	c.lineTo(w, h * 0.7331);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dRdsMaster.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dRdsMaster.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.126, h * 0.267);
	c.lineTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.close();
	c.moveTo(w * 0.874, h * 0.267);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3308);
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5, h);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.622, h * 0.4023);
	c.lineTo(w * 0.874, h * 0.267);
	c.lineTo(w, h * 0.3308);
	c.lineTo(w, h * 0.7331);
	c.close();
	c.fill();
	
	c.restore();

	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.setShadow(false);

	c.begin();
	c.moveTo(w * 0.1878, h * 0.1932);
	c.lineTo(w * 0.4854, h * 0.0414);
	c.lineTo(w * 0.5886, h * 0.094);
	c.lineTo(w * 0.4455, h * 0.2308);
	c.lineTo(w * 0.7122, h * 0.1579);
	c.lineTo(w * 0.8171, h * 0.2098);
	c.lineTo(w * 0.5187, h * 0.3617);
	c.lineTo(w * 0.4537, h * 0.3293);
	c.lineTo(w * 0.7016, h * 0.2053);
	c.lineTo(w * 0.3854, h * 0.2947);
	c.lineTo(w * 0.3187, h * 0.2602);
	c.lineTo(w * 0.4959, h * 0.0992);
	c.lineTo(w * 0.2504, h * 0.2256);
	c.close();
	c.fill();
	
	c.setLineJoin('round');

	c.begin();
	c.moveTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.126, h * 0.267);
	c.lineTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.622, h * 0.4023);
	c.lineTo(w * 0.874, h * 0.267);
	c.lineTo(w * 0.874, h * 0.1316);
	c.moveTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.267);
	c.moveTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.5, h);
	c.moveTo(w, h * 0.3346);
	c.lineTo(w * 0.87, h * 0.267);
	c.moveTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.622, h * 0.4023);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');

	c.begin();
	c.moveTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.374, 0);
	c.lineTo(w * 0.626, 0);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3346);
	c.lineTo(w, h * 0.7331);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dRdsMaster.prototype.cst.RDS_MASTER, mxShapeAws3dRdsMaster);

//**********************************************************************************************************************************************************
//RDS
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dRds(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dRds, mxShape);

mxShapeAws3dRds.prototype.cst = {
		RDS : 'mxgraph.aws3d.rds',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dRds.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 123;
	var strokeWidth2 = strokeWidth * h /133;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	c.setStrokeWidth(strokeWidth);
	
	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dRds.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.374, 0);
	c.lineTo(w * 0.626, 0);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3346);
	c.lineTo(w, h * 0.7331);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dRds.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dRds.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.126, h * 0.267);
	c.lineTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.close();
	c.moveTo(w * 0.874, h * 0.267);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3308);
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5, h);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.622, h * 0.4023);
	c.lineTo(w * 0.874, h * 0.267);
	c.lineTo(w, h * 0.3308);
	c.lineTo(w, h * 0.7331);
	c.close();
	c.fill();
	
	c.restore();

	c.setFillColor('#ffffff');
	c.setShadow(false);
	c.begin();
	c.moveTo(0, h * 0.6053);
	c.lineTo(w * 0.5, h * 0.8722);
	c.lineTo(w, h * 0.6053);
	c.lineTo(w, h * 0.6278);
	c.lineTo(w * 0.5, h * 0.8947);
	c.lineTo(0, h * 0.6278);
	c.close();
	c.fill();

	c.setLineJoin('round');

	c.begin();
	c.moveTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.126, h * 0.267);
	c.lineTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.622, h * 0.4023);
	c.lineTo(w * 0.874, h * 0.267);
	c.lineTo(w * 0.874, h * 0.1316);
	c.moveTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.267);
	c.moveTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.5, h);
	c.moveTo(w, h * 0.3346);
	c.lineTo(w * 0.87, h * 0.267);
	c.moveTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.622, h * 0.4023);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');

	c.begin();
	c.moveTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.374, 0);
	c.lineTo(w * 0.626, 0);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3346);
	c.lineTo(w, h * 0.7331);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dRds.prototype.cst.RDS, mxShapeAws3dRds);

//**********************************************************************************************************************************************************
//Route 53
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dRoute53(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dRoute53, mxShape);

mxShapeAws3dRoute53.prototype.cst = {
		ROUTE_53 : 'mxgraph.aws3d.route53',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dRoute53.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 117;
	var strokeWidth2 = strokeWidth * h /134.4;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	c.setStrokeWidth(strokeWidth);
	
	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dRoute53.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.6994);
	c.lineTo(0, h * 0.2009);
	c.lineTo(w * 0.0427, h * 0.0781);
	c.lineTo(w * 0.7974, 0);
	c.lineTo(w, h * 0.1004);
	c.lineTo(w, h * 0.5915);
	c.lineTo(w * 0.8376, h * 0.9784);
	c.lineTo(w * 0.5983, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dRoute53.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dRoute53.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.2009);
	c.lineTo(w * 0.6009, h * 0.5007);
	c.lineTo(w * 0.8376, h * 0.4799);
	c.lineTo(w * 0.8376, h * 0.9784);
	c.lineTo(w * 0.5966, h);
	c.lineTo(0, h * 0.6979);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.8348, h * 0.4861);
	c.lineTo(w * 0.9985, h * 0.0992);
	c.lineTo(w, h * 0.5952);
	c.lineTo(w * 0.8404, h * 0.9747);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');

	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);

	c.begin();
	c.moveTo(w * 0.5855, h * 0.1079);
	c.arcTo(w * 0.094, h * 0.0744, 0, 0, 0, w * 0.6863, h * 0.1548);
	c.arcTo(w * 0.0855, h * 0.0446, 0, 0, 0, w * 0.7761, h * 0.2031);
	c.lineTo(w * 0.7726, h * 0.2455);
	c.arcTo(w * 0.0769, h * 0.0298, 0, 0, 0, w * 0.694, h * 0.2693);
	c.arcTo(w * 0.0684, h * 0.0446, 0, 0, 1, w * 0.5897, h * 0.3051);
	c.arcTo(w * 0.4274, h * 0.372, 0, 0, 0, w * 0.4573, h * 0.2753);
	c.arcTo(w * 0.0855, h * 0.0744, 0, 0, 0, w * 0.4188, h * 0.2344);
	c.lineTo(w * 0.3846, h * 0.2083);
	c.arcTo(w * 0.0769, h * 0.0372, 0, 0, 1, w * 0.4103, h * 0.1525);
	c.arcTo(w * 0.0855, h * 0.0409, 0, 0, 0, w * 0.4906, h * 0.1079);
	c.close();
	c.fill();

	c.begin();
	c.moveTo(0, h * 0.2009);
	c.lineTo(w * 0.6009, h * 0.5007);
	c.lineTo(w * 0.8376, h * 0.4799);
	c.lineTo(w * 0.8376, h * 0.9784);
	c.lineTo(w * 0.5966, h);
	c.lineTo(0, h * 0.6979);
	c.close();
	c.moveTo(w * 0.8348, h * 0.4861);
	c.lineTo(w * 0.9985, h * 0.0992);
	c.lineTo(w, h * 0.5952);
	c.lineTo(w * 0.8404, h * 0.9747);
	c.close();
	c.moveTo(w * 0.6009, h * 0.5007);
	c.lineTo(w * 0.6009, h);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');

	c.begin();
	c.moveTo(0, h * 0.6994);
	c.lineTo(0, h * 0.2009);
	c.lineTo(w * 0.0427, h * 0.0781);
	c.lineTo(w * 0.7974, 0);
	c.lineTo(w, h * 0.1004);
	c.lineTo(w, h * 0.5915);
	c.lineTo(w * 0.8376, h * 0.9784);
	c.lineTo(w * 0.5983, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dRoute53.prototype.cst.ROUTE_53, mxShapeAws3dRoute53);

//**********************************************************************************************************************************************************
//S3 Bucket
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dS3Bucket(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dS3Bucket, mxShape);

mxShapeAws3dS3Bucket.prototype.cst = {
		S3_BUCKET : 'mxgraph.aws3d.s3Bucket',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dS3Bucket.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 61.5;
	var strokeWidth2 = strokeWidth * h / 63.8;
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	c.setShadow(false);
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if (isShadow == 1)
	{
		c.setShadow(true);
	}
	
	c.begin();
	c.moveTo(0, h * 0.2774);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.2774);
	c.lineTo(w * 0.7967, h * 0.8307);
	c.lineTo(w * 0.5, h);
	c.lineTo(w * 0.1951, h * 0.8307);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dS3Bucket.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.2774);
	c.lineTo(w * 0.5, h * 0.5564);
	c.lineTo(w * 0.5, h);
	c.lineTo(w * 0.1984, h * 0.8307);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5, h * 0.5533);
	c.lineTo(w, h * 0.2774);
	c.lineTo(w * 0.7967, h * 0.8307);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.2774);
	c.lineTo(w * 0.5, h * 0.5564);
	c.lineTo(w, h * 0.2774);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.5, h * 0.5564);
	c.lineTo(w * 0.5, h);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.2774);
	c.lineTo(w * 0.5008, 0);
	c.lineTo(w, h * 0.2774);
	c.lineTo(w * 0.7967, h * 0.8307);
	c.lineTo(w * 0.5008, h);
	c.lineTo(w * 0.1951, h * 0.8307);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dS3Bucket.prototype.cst.S3_BUCKET, mxShapeAws3dS3Bucket);

//**********************************************************************************************************************************************************
//S3
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dS3(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dS3, mxShape);

mxShapeAws3dS3.prototype.cst = {
		S3 : 'mxgraph.aws3d.s3',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dS3.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 231.5;
	var strokeWidth2 = strokeWidth * h / 239;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dS3.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7782);
	c.lineTo(0, h * 0.3406);
	c.lineTo(w * 0.5974, 0);
	c.lineTo(w, h * 0.2218);
	c.lineTo(w, h * 0.6674);
	c.lineTo(w * 0.3991, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dS3.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dS3.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.3406);
	c.lineTo(w * 0.3991, h * 0.5548);
	c.lineTo(w * 0.3991, h);
	c.lineTo(0, h * 0.7782);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.3991, h * 0.5548);
	c.lineTo(w, h * 0.2218);
	c.lineTo(w, h * 0.6661);
	c.lineTo(w * 0.3991, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.3406);
	c.lineTo(w * 0.3991, h * 0.5548);
	c.lineTo(w, h * 0.2218);
	c.moveTo(w * 0.3991, h * 0.5548);
	c.lineTo(w * 0.3991, h);
	c.moveTo(w * 0.3991, h * 0.3335);
	c.lineTo(w * 0.2009, h * 0.448);
	c.lineTo(w * 0.2009, h * 0.8891);
	c.moveTo(w * 0.5983, h * 0.2209);
	c.lineTo(w * 0.7948, h * 0.1109);
	c.moveTo(w * 0.2022, h * 0.2218);
	c.lineTo(w * 0.5991, h * 0.4448);
	c.lineTo(w * 0.5991, h * 0.8891);
	c.moveTo(w * 0.4004, h * 0.1117);
	c.lineTo(w * 0.7978, h * 0.3335);
	c.lineTo(w * 0.7978, h * 0.7791);
	c.stroke();

	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.4773, h * 0.2155);
	c.arcTo(w * 0.0086, h * 0.0046, 0, 0, 1, w * 0.4903, h * 0.2096);
	c.arcTo(w * 0.2808, h * 0.272, 0, 0, 1, w * 0.6004, h * 0.2619);
	c.arcTo(w * 0.108, h * 0.105, 0, 0, 1, w * 0.6177, h * 0.277);
	c.arcTo(w * 0.0065, h * 0.0063, 0, 0, 1, w * 0.6099, h * 0.2879);
	c.arcTo(w * 0.1944, h * 0.1883, 0, 0, 1, w * 0.5378, h * 0.2607);
	c.arcTo(w * 0.216, h * 0.2092, 0, 0, 1, w * 0.4773, h * 0.2155);
	c.close();
	c.fill();

	c.begin();
	c.moveTo(w * 0.4687, h * 0.2138);
	c.arcTo(w * 0.1512, h * 0.1464, 0, 0, 0, w * 0.4838, h * 0.2343);
	c.arcTo(w * 0.2376, h * 0.2301, 0, 0, 0, w * 0.5529, h * 0.2774);
	c.arcTo(w * 0.1728, h * 0.1674, 0, 0, 0, w * 0.6091, h * 0.2954);
	c.lineTo(w * 0.4946, h * 0.3339);
	c.arcTo(w * 0.1944, h * 0.1883, 0, 0, 1, w * 0.4549, h * 0.3205);
	c.arcTo(w * 0.1944, h * 0.1883, 0, 0, 1, w * 0.419, h * 0.3004);
	c.arcTo(w * 0.1944, h * 0.1883, 0, 0, 1, w * 0.3965, h * 0.2795);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7782);
	c.lineTo(0, h * 0.3406);
	c.lineTo(w * 0.5974, 0);
	c.lineTo(w, h * 0.2218);
	c.lineTo(w, h * 0.6674);
	c.lineTo(w * 0.3991, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dS3.prototype.cst.S3, mxShapeAws3dS3);

//**********************************************************************************************************************************************************
//SimpleDB
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dSimpleDB(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dSimpleDB, mxShape);

mxShapeAws3dSimpleDB.prototype.cst = {
		SIMPLE_DB : 'mxgraph.aws3d.simpleDb',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dSimpleDB.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 123;
	var strokeWidth2 = strokeWidth * h /133;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	c.setStrokeWidth(strokeWidth);
	
	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dSimpleDB.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.save();
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.374, 0);
	c.lineTo(w * 0.626, 0);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3346);
	c.lineTo(w, h * 0.7331);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dSimpleDB.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dSimpleDB.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.126, h * 0.267);
	c.lineTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.close();
	c.moveTo(w * 0.874, h * 0.267);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3308);
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5, h);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.622, h * 0.4023);
	c.lineTo(w * 0.874, h * 0.267);
	c.lineTo(w, h * 0.3308);
	c.lineTo(w, h * 0.7331);
	c.close();
	c.fill();
	
	c.restore();

	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.setShadow(false);

	c.begin();
	c.moveTo(w * 0.1821, h * 0.182);
	c.lineTo(w * 0.4659, h * 0.0308);
	c.lineTo(w * 0.822, h * 0.2218);
	c.lineTo(w * 0.539, h * 0.3714);
	c.close();
	c.fill();
	
	c.setLineJoin('round');

	c.begin();
	c.moveTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.126, h * 0.267);
	c.lineTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.622, h * 0.4023);
	c.lineTo(w * 0.874, h * 0.267);
	c.lineTo(w * 0.874, h * 0.1316);
	c.moveTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.267);
	c.moveTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.5, h);
	c.moveTo(w, h * 0.3346);
	c.lineTo(w * 0.87, h * 0.267);
	c.moveTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.622, h * 0.4023);
	c.stroke();

	c.restore();
	c.setShadow(false);
	var fillColor = mxUtils.getValue(this.state.style, 'fillColor', '#ffffff');
	c.setStrokeColor(fillColor);
	c.setStrokeWidth(2.2 * strokeWidth);
	c.begin();
	c.moveTo(w * 0.2382, h * 0.2218);
	c.lineTo(w * 0.5415, h * 0.0602);

	c.moveTo(w * 0.3821, h * 0.0564);
	c.lineTo(w * 0.7737, h * 0.2656);
	
	c.moveTo(w * 0.2967, h * 0.0915);
	c.lineTo(w * 0.7114, h * 0.312);
	
	c.moveTo(w * 0.2209, h * 0.1316);
	c.lineTo(w * 0.6179, h * 0.3434);
	c.stroke();
	
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');

	c.begin();
	c.moveTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.374, 0);
	c.lineTo(w * 0.626, 0);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3346);
	c.lineTo(w, h * 0.7331);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dSimpleDB.prototype.cst.SIMPLE_DB, mxShapeAws3dSimpleDB);

//**********************************************************************************************************************************************************
//SQS
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dSqs(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dSqs, mxShape);

mxShapeAws3dSqs.prototype.cst = {
		SQS : 'mxgraph.aws3d.sqs',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dSqs.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 184;
	var strokeWidth2 = strokeWidth * h / 212.75;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dSqs.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7485);
	c.lineTo(0, h * 0.584);
	c.lineTo(w * 0.1658, h * 0.1666);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w * 0.8337, h * 0.1666);
	c.lineTo(w, h * 0.584);
	c.lineTo(w, h * 0.7485);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dSqs.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dSqs.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(w * 0.1658, h * 0.1671);
	c.lineTo(w * 0.5, h * 0.334);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.7485);
	c.lineTo(0, h * 0.584);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5, h * 0.3344);
	c.lineTo(w * 0.8332, h * 0.1671);
	c.lineTo(w, h * 0.584);
	c.lineTo(w, h * 0.7509);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(w * 0.6674, h * 0.0844);
	c.lineTo(w * 0.3337, h * 0.2512);
	c.lineTo(w * 0.25, h * 0.7109);
	c.lineTo(w * 0.25, h * 0.8736);

	c.moveTo(w * 0.3326, h * 0.0839);
	c.lineTo(w * 0.6674, h * 0.2512);
	c.lineTo(w * 0.75, h * 0.7053);
	c.lineTo(w * 0.75, h * 0.874);

	c.moveTo(0, h * 0.584);
	c.lineTo(w * 0.5, h * 0.8331);
	c.lineTo(w, h * 0.584);

	c.moveTo(w * 0.1658, h * 0.1671);
	c.lineTo(w * 0.5, h * 0.334);
	c.lineTo(w * 0.8332, h * 0.1671);

	c.moveTo(w * 0.5, h * 0.334);
	c.lineTo(w * 0.5, h);
	c.stroke();

	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.3337, h * 0.1511);
	c.lineTo(w * 0.4668, h * 0.0848);
	c.lineTo(w * 0.6663, h * 0.184);
	c.lineTo(w * 0.5337, h * 0.2503);
	c.close();
	c.fill();

	var fillColor = mxUtils.getValue(this.state.style, 'fillColor', '#000000');
	c.setFillColor(fillColor);

	c.begin();
	c.moveTo(w * 0.3902, h * 0.153);
	c.lineTo(w * 0.4701, h * 0.113);
	c.lineTo(w * 0.4701, h * 0.153);
	c.close();
	c.moveTo(w * 0.4402, h * 0.1784);
	c.lineTo(w * 0.5196, h * 0.1384);
	c.lineTo(w * 0.5196, h * 0.1784);
	c.close();
	c.moveTo(w * 0.4908, h * 0.2033);
	c.lineTo(w * 0.5701, h * 0.1633);
	c.lineTo(w * 0.5701, h * 0.2033);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7485);
	c.lineTo(0, h * 0.584);
	c.lineTo(w * 0.1658, h * 0.1666);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w * 0.8337, h * 0.1666);
	c.lineTo(w, h * 0.584);
	c.lineTo(w, h * 0.7485);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dSqs.prototype.cst.SQS, mxShapeAws3dSqs);

//**********************************************************************************************************************************************************
//VPC Gateway
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dVpcGateway(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dVpcGateway, mxShape);

mxShapeAws3dVpcGateway.prototype.cst = {
		VPC_GATEWAY : 'mxgraph.aws3d.vpcGateway',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dVpcGateway.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 116.7;
	var strokeWidth2 = strokeWidth * h / 102.8;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dVpcGateway.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.save();
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(w * 0.5801, h * 0.5447);
	c.lineTo(w * 0.5801, h * 0.035);
	c.lineTo(w * 0.1054, 0);
	c.lineTo(0, h * 0.0691);
	c.lineTo(0, h * 0.4134);
	c.lineTo(w * 0.3188, h * 0.7247);
	c.close();
	c.fillAndStroke();

	c.restore();
	c.save();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dVpcGateway.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5801, h * 0.5447);
	c.lineTo(w * 0.5801, h * 0.035);
	c.lineTo(w * 0.3162, h * 0.2072);
	c.lineTo(w * 0.3162, h * 0.7247);
	c.close();
	c.fill();
	
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	c.begin();
	c.moveTo(w * 0.3162, h * 0.2072);
	c.lineTo(0, h * 0.0691);
	c.lineTo(0, h * 0.4134);
	c.lineTo(w * 0.3162, h * 0.7247);
	c.close();
	c.fill();

	c.restore();
	c.setShadow(false);
	c.begin();
	c.moveTo(w * 0.5801, h * 0.5447);
	c.lineTo(w * 0.5801, h * 0.035);
	c.lineTo(w * 0.3162, h * 0.2072);
	c.lineTo(w * 0.3162, h * 0.7247);
	c.close();
	c.stroke();

	c.restore();
	c.setLineJoin('round');
	c.setShadow(false);

	c.begin();
	c.moveTo(w * 0.3162, h * 0.2072);
	c.lineTo(0, h * 0.0691);
	c.lineTo(0, h * 0.4134);
	c.lineTo(w * 0.3162, h * 0.7247);
	c.close();
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	
	c.begin();
	c.moveTo(w * 0.5801, h * 0.5447);
	c.lineTo(w * 0.5801, h * 0.035);
	c.lineTo(w * 0.1054, 0);
	c.lineTo(0, h * 0.0691);
	c.lineTo(0, h * 0.4134);
	c.lineTo(w * 0.3188, h * 0.7247);
	c.close();
	c.stroke();

	c.restore();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(w, h * 0.929);
	c.lineTo(w, h * 0.5866);
	c.lineTo(w * 0.6829, h * 0.1031);
	c.lineTo(w * 0.4216, h * 0.2753);
	c.lineTo(w * 0.4216, h * 0.7928);
	c.lineTo(w * 0.8946, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dVpcGateway.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setShadow(false);
	c.setLineJoin('round');
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dVpcGateway.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	
	c.begin();
	c.moveTo(w, h * 0.929);
	c.lineTo(w, h * 0.5866);
	c.lineTo(w * 0.8946, h * 0.6537);
	c.lineTo(w * 0.8946, h);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	c.begin();
	c.moveTo(w * 0.8946, h);
	c.lineTo(w * 0.8946, h * 0.6537);
	c.lineTo(w * 0.4216, h * 0.2753);
	c.lineTo(w * 0.4216, h * 0.7928);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(w, h * 0.929);
	c.lineTo(w, h * 0.5866);
	c.lineTo(w * 0.8946, h * 0.6537);
	c.lineTo(w * 0.8946, h);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w * 0.8946, h);
	c.lineTo(w * 0.8946, h * 0.6537);
	c.lineTo(w * 0.4216, h * 0.2753);
	c.lineTo(w * 0.4216, h * 0.7928);
	c.close();
	c.stroke();
	
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(w, h * 0.929);
	c.lineTo(w, h * 0.5866);
	c.lineTo(w * 0.6829, h * 0.1031);
	c.lineTo(w * 0.4216, h * 0.2753);
	c.lineTo(w * 0.4216, h * 0.7928);
	c.lineTo(w * 0.8946, h);
	c.close();
	c.stroke();

	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.5587, h * 0.7743);
	c.lineTo(w * 0.5587, h * 0.6274);
	c.lineTo(w * 0.5775, h * 0.6342);
	c.lineTo(w * 0.5775, h * 0.57);
	c.arcTo(w * 0.0428, h * 0.0486, 0, 0, 1, w * 0.6058, h * 0.5253);
	c.arcTo(w * 0.0686, h * 0.0778, 0, 0, 1, w * 0.6564, h * 0.5447);
	c.arcTo(w * 0.0857, h * 0.0973, 0, 0, 1, w * 0.6847, h * 0.607);
	c.lineTo(w * 0.6847, h * 0.6877);
	c.lineTo(w * 0.7001, h * 0.6946);
	c.lineTo(w * 0.7001, h * 0.8405);
	c.close();
	c.moveTo(w * 0.6564, h * 0.6741);
	c.lineTo(w * 0.6564, h * 0.6177);
	c.arcTo(w * 0.06, h * 0.0681, 0, 0, 0, w * 0.6392, h * 0.57);
	c.arcTo(w * 0.0343, h * 0.0389, 0, 0, 0, w * 0.6195, h * 0.5574);
	c.arcTo(w * 0.0111, h * 0.0126, 0, 0, 0, w * 0.6058, h * 0.5691);
	c.lineTo(w * 0.6058, h * 0.6498);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeAws3dVpcGateway.prototype.cst.VPC_GATEWAY, mxShapeAws3dVpcGateway);

//**********************************************************************************************************************************************************
//Web Server
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dWebServer(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dWebServer, mxShape);

mxShapeAws3dWebServer.prototype.cst = {
		WEB_SERVER : 'mxgraph.aws3d.webServer',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dWebServer.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 123;
	var strokeWidth2 = strokeWidth * h / 106;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dWebServer.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.6651);
	c.lineTo(0, h * 0.3349);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.3349);
	c.lineTo(w, h * 0.6651);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dWebServer.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dWebServer.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.3349);
	c.lineTo(w * 0.5, h * 0.6651);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.6651);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5, h * 0.6651);
	c.lineTo(w, h * 0.3349);
	c.lineTo(w, h * 0.6651);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.3349);
	c.lineTo(w * 0.5, h * 0.6651);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.6651);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w * 0.5, h * 0.6651);
	c.lineTo(w, h * 0.3349);
	c.lineTo(w, h * 0.6651);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
	
	c.setLineJoin('miter');
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.374, h * 0.5189);
	c.arcTo(w * 0.0325, h * 0.0236, 0, 0, 1, w * 0.374, h * 0.4858);
	c.lineTo(w * 0.4797, h * 0.4151);
	c.arcTo(w * 0.0325, h * 0.0236, 0, 0, 1, w * 0.5203, h * 0.4151);
	c.lineTo(w * 0.626, h * 0.4858);
	c.arcTo(w * 0.0325, h * 0.0236, 0, 0, 1, w * 0.626, h * 0.516);
	c.lineTo(w * 0.5203, h * 0.5868);
	c.arcTo(w * 0.0325, h * 0.0236, 0, 0, 1, w * 0.4797, h * 0.5868);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.6651);
	c.lineTo(0, h * 0.3349);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.3349);
	c.lineTo(w, h * 0.6651);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dWebServer.prototype.cst.WEB_SERVER, mxShapeAws3dWebServer);

//**********************************************************************************************************************************************************
//DynamoDB
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dDynamoDB(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dDynamoDB, mxShape);

mxShapeAws3dDynamoDB.prototype.cst = {
		DYNAMO_DB : 'mxgraph.aws3d.dynamoDb',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dDynamoDB.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 181.5;
	var strokeWidth2 = strokeWidth * h / 210;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dDynamoDB.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.8333);
	c.lineTo(0, h * 0.1667);
	c.lineTo(w * 0.3333, h * 0.0014);
	c.lineTo(w * 0.4986, h * 0.1667);
	c.lineTo(w * 0.6639, 0);
	c.lineTo(w, h * 0.169);
	c.lineTo(w, h * 0.8333);
	c.lineTo(w * 0.6667, h);
	c.lineTo(w * 0.5014, h * 0.9162);
	c.lineTo(w * 0.3333, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dDynamoDB.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dDynamoDB.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(w * 0.168, h * 0.3333);
	c.lineTo(0, h * 0.3333);
	c.lineTo(w * 0.3333, h * 0.5);
	c.lineTo(w * 0.3333, h);
	c.lineTo(0, h * 0.8333);
	c.lineTo(0, h * 0.1714);
	c.close();
	c.moveTo(w * 0.4986, h * 0.1667);
	c.lineTo(w * 0.6667, 0);
	c.lineTo(w, h * 0.169);
	c.lineTo(w * 0.832, h * 0.3348);//
	c.lineTo(w, h * 0.3333);
	c.lineTo(w * 0.6667, h * 0.5);
	c.lineTo(w * 0.5014, h * 0.5);
	c.lineTo(w * 0.832, h * 0.3348);
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.3333, h * 0.5);
	c.lineTo(w * 0.4986, h * 0.5);
	c.lineTo(w * 0.4986, h * 0.9162);
	c.lineTo(w * 0.3333, h);
	c.close();
	c.moveTo(w * 0.6667, h);
	c.lineTo(w * 0.6667, h * 0.5);
	c.lineTo(w, h * 0.3333);
	c.lineTo(w * 0.832, h * 0.3348);
	c.lineTo(w, h * 0.169);
	c.lineTo(w, h * 0.831);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(w * 0.168, h * 0.3333);
	c.lineTo(0, h * 0.3333);
	c.lineTo(w * 0.3333, h * 0.5);
	c.lineTo(w * 0.3333, h);
	c.lineTo(0, h * 0.8333);
	c.lineTo(0, h * 0.1714);
	c.close();
	c.moveTo(w * 0.4986, h * 0.1667);
	c.lineTo(w * 0.6667, 0);
	c.lineTo(w, h * 0.169);
	c.lineTo(w * 0.832, h * 0.3348);
	c.lineTo(w, h * 0.3333);
	c.lineTo(w * 0.6667, h * 0.5);
	c.lineTo(w * 0.5014, h * 0.5);
	c.lineTo(w * 0.832, h * 0.3348);
	c.close();
	c.moveTo(w * 0.3333, h * 0.5);
	c.lineTo(w * 0.4986, h * 0.5);
	c.lineTo(w * 0.4986, h * 0.9162);
	c.lineTo(w * 0.3333, h);
	c.close();
	c.moveTo(w * 0.6667, h);
	c.lineTo(w * 0.6667, h * 0.5);
	c.lineTo(w, h * 0.3333);
	c.lineTo(w, h * 0.831);
	c.close();
	c.moveTo(w * 0.168, h * 0.3333);
	c.lineTo(w * 0.5, h * 0.1667);
	c.moveTo(w * 0.168, h * 0.3333);
	c.lineTo(w * 0.5014, h * 0.5);
	c.stroke();

	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.4876, h * 0.2262);
	c.arcTo(w * 0.303, h * 0.2619, 0, 0, 1, w * 0.5647, h * 0.25);
	c.arcTo(w * 0.4407, h * 0.381, 0, 0, 1, w * 0.6419, h * 0.2905);
	c.arcTo(w * 0.303, h * 0.2619, 0, 0, 1, w * 0.6799, h * 0.32);
	c.arcTo(w * 0.0132, h * 0.0076, 0, 0, 1, w * 0.6634, h * 0.3314);
	c.arcTo(w * 0.303, h * 0.2619, 0, 0, 1, w * 0.5978, h * 0.3119);
	c.arcTo(w * 0.4408, h * 0.381, 0, 0, 1, w * 0.508, h * 0.2667);
	c.arcTo(w * 0.303, h * 0.2619, 0, 0, 1, w * 0.4711, h * 0.2343);
	c.arcTo(w * 0.0132, h * 0.0076, 0, 0, 1, w * 0.4876, h * 0.2262);
	c.close();
	c.fill();

	c.begin();
	c.moveTo(w * 0.5124, h * 0.4143);
	c.arcTo(w * 0.1102, h * 0.0952, 0, 0, 1, w * 0.4683, h * 0.4095);
	c.arcTo(w * 0.4408, h * 0.381, 0, 0, 1, w * 0.3829, h * 0.3757);
	c.arcTo(w * 0.4408, h * 0.381, 0, 0, 1, w * 0.3196, h * 0.3371);
	c.arcTo(w * 0.0661, h * 0.0357, 0, 0, 1, w * 0.3058, h * 0.3081);
	c.lineTo(w * 0.4612, h * 0.2333);
	c.arcTo(w * 0.0661, h * 0.0476, 0, 0, 0, w * 0.4744, h * 0.2548);
	c.arcTo(w * 0.3306, h * 0.2857, 0, 0, 0, w * 0.53, h * 0.2905);
	c.arcTo(w * 0.4408, h * 0.381, 0, 0, 0, w * 0.6198, h * 0.3295);
	c.arcTo(w * 0.1102, h * 0.0952, 0, 0, 0, w * 0.665, h * 0.3367);
	c.close();
	c.moveTo(w * 0.5052, h * 0.3714);
	c.arcTo(w * 0.0275, h * 0.019, 0, 0, 1, w * 0.5135, h * 0.3581);
	c.arcTo(w * 0.0275, h * 0.0238, 0, 0, 1, w * 0.5344, h * 0.3571);
	c.lineTo(w * 0.5405, h * 0.3471);
	c.arcTo(w * 0.0275, h * 0.0143, 0, 0, 1, w * 0.5278, h * 0.3381);
	c.arcTo(w * 0.022, h * 0.0119, 0, 0, 1, w * 0.5372, h * 0.3271);
	c.lineTo(w * 0.5306, h * 0.3186);
	c.arcTo(w * 0.0331, h * 0.0286, 0, 0, 1, w * 0.5041, h * 0.3143);
	c.arcTo(w * 0.0275, h * 0.0143, 0, 0, 1, w * 0.4975, h * 0.3029);
	c.lineTo(w * 0.4777, h * 0.2995);
	c.arcTo(w * 0.0331, h * 0.0286, 0, 0, 1, w * 0.4628, h * 0.3033);
	c.arcTo(w * 0.0331, h * 0.0286, 0, 0, 1, w * 0.4408, h * 0.2967);
	c.lineTo(w * 0.4187, h * 0.3);
	c.arcTo(w * 0.011, h * 0.0081, 0, 0, 1, w * 0.4132, h * 0.3124);
	c.arcTo(w * 0.0386, h * 0.0333, 0, 0, 1, w * 0.395, h * 0.3129);
	c.lineTo(w * 0.3873, h * 0.3224);
	c.arcTo(w * 0.0165, h * 0.0143, 0, 0, 1, w * 0.3994, h * 0.3333);
	c.arcTo(w * 0.0138, h * 0.0119, 0, 0, 1, w * 0.3901, h * 0.3433);
	c.lineTo(w * 0.3994, h * 0.3514);
	c.arcTo(w * 0.0331, h * 0.0286, 0, 0, 1, w * 0.4215, h * 0.3548);
	c.arcTo(w * 0.0165, h * 0.0119, 0, 0, 1, w * 0.4298, h * 0.3667);
	c.lineTo(w * 0.449, h * 0.3714);
	c.arcTo(w * 0.0331, h * 0.0286, 0, 0, 1, w * 0.4711, h * 0.3657);
	c.arcTo(w * 0.0331, h * 0.0286, 0, 0, 1, w * 0.4887, h * 0.3724);
	c.close();
	c.moveTo(w * 0.4986, h * 0.351);
	c.arcTo(w * 0.0441, h * 0.0381, 0, 0, 1, w * 0.4804, h * 0.3552);
	c.arcTo(w * 0.1102, h * 0.0952, 0, 0, 1, w * 0.443, h * 0.349);
	c.lineTo(w * 0.4413, h * 0.3529);
	c.lineTo(w * 0.4242, h * 0.3371);
	c.arcTo(w * 0.1102, h * 0.0952, 0, 0, 0, w * 0.4545, h * 0.3462);
	c.arcTo(w * 0.1102, h * 0.0952, 0, 0, 0, w * 0.4793, h * 0.3476);
	c.arcTo(w * 0.0441, h * 0.0381, 0, 0, 0, w * 0.4986, h * 0.3448);
	c.close();
	c.moveTo(w * 0.503, h * 0.3349);
	c.arcTo(w * 0.1102, h * 0.0952, 0, 0, 0, w * 0.4766, h * 0.3233);
	c.arcTo(w * 0.0826, h * 0.0714, 0, 0, 0, w * 0.4529, h * 0.32);
	c.arcTo(w * 0.0551, h * 0.0476, 0, 0, 0, w * 0.4325, h * 0.3238);
	c.lineTo(w * 0.427, h * 0.3195);
	c.arcTo(w * 0.0826, h * 0.0714, 0, 0, 1, w * 0.4556, h * 0.3157);
	c.arcTo(w * 0.0826, h * 0.0714, 0, 0, 1, w * 0.4851, h * 0.3232);
	c.lineTo(w * 0.4876, h * 0.3181);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.8333);
	c.lineTo(0, h * 0.1667);
	c.lineTo(w * 0.3333, h * 0.0014);
	c.lineTo(w * 0.4986, h * 0.1667);
	c.lineTo(w * 0.6639, 0);
	c.lineTo(w, h * 0.169);
	c.lineTo(w, h * 0.8333);
	c.lineTo(w * 0.6667, h);
	c.lineTo(w * 0.5014, h * 0.9162);
	c.lineTo(w * 0.3333, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dDynamoDB.prototype.cst.DYNAMO_DB, mxShapeAws3dDynamoDB);

//**********************************************************************************************************************************************************
//Elastic MapReduce
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dElasticMapReduce(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dElasticMapReduce, mxShape);

mxShapeAws3dElasticMapReduce.prototype.cst = {
		ELASTIC_MAP_REDUCE : 'mxgraph.aws3d.elasticMapReduce',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dElasticMapReduce.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 123;
	var strokeWidth2 = strokeWidth * h /133;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	c.setStrokeWidth(strokeWidth);
	
	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dElasticMapReduce.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.374, 0);
	c.lineTo(w * 0.626, 0);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3346);
	c.lineTo(w, h * 0.7331);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dElasticMapReduce.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dDynamoDB.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.126, h * 0.267);
	c.lineTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.close();
	c.moveTo(w * 0.874, h * 0.267);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3308);
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5, h);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.622, h * 0.4023);
	c.lineTo(w * 0.874, h * 0.267);
	c.lineTo(w, h * 0.3308);
	c.lineTo(w, h * 0.7331);
	c.close();
	c.fill();
	
	c.restore();

	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.setShadow(false);

	c.begin();
	c.moveTo(w * 0.3336, h * 0.1789);
	c.arcTo(w * 0.0328, h * 0.0301, 0, 0, 1, w * 0.359, h * 0.1789);
	c.lineTo(w * 0.4001, h * 0.2015);
	c.arcTo(w * 0.0074, h * 0.0068, 0, 0, 1, w * 0.4008, h * 0.2135);
	c.lineTo(w * 0.3574, h * 0.2368);
	c.arcTo(w * 0.0328, h * 0.0301, 0, 0, 1, w * 0.3352, h * 0.2368);
	c.lineTo(w * 0.2934, h * 0.2143);
	c.arcTo(w * 0.0074, h * 0.0068, 0, 0, 1, w * 0.2934, h * 0.2015);
	c.close();
	c.moveTo(w * 0.3705, h * 0.1729);
	c.arcTo(w * 0.0074, h * 0.0068, 0, 0, 1, w * 0.3705, h * 0.1602);
	c.lineTo(w * 0.4139, h * 0.1368);
	c.arcTo(w * 0.0328, h * 0.0301, 0, 0, 1, w * 0.4336, h * 0.1368);
	c.lineTo(w * 0.4811, h * 0.1617);
	c.arcTo(w * 0.0074, h * 0.0068, 0, 0, 1, w * 0.4811, h * 0.1708);
	c.lineTo(w * 0.4328, h * 0.1955);
	c.arcTo(w * 0.0328, h * 0.0301, 0, 0, 1, w * 0.4156, h * 0.1955);
	c.close();
	c.moveTo(w * 0.4467, h * 0.1308);
	c.arcTo(w * 0.0074, h * 0.0068, 0, 0, 1, w * 0.4467, h * 0.1203);
	c.lineTo(w * 0.491, h * 0.0962);
	c.arcTo(w * 0.0328, h * 0.0301, 0, 0, 1, w * 0.5123, h * 0.0962);
	c.lineTo(w * 0.559, h * 0.1203);
	c.arcTo(w * 0.0074, h * 0.0068, 0, 0, 1, w * 0.559, h * 0.1293);
	c.lineTo(w * 0.5123, h * 0.1549);
	c.arcTo(w * 0.0328, h * 0.0301, 0, 0, 1, w * 0.4918, h * 0.1549);
	c.close();
	c.moveTo(w * 0.568, h * 0.1383);
	c.arcTo(w * 0.0328, h * 0.0301, 0, 0, 1, w * 0.5918, h * 0.1383);
	c.lineTo(w * 0.6361, h * 0.1624);
	c.arcTo(w * 0.0074, h * 0.0068, 0, 0, 1, w * 0.6366, h * 0.1714);
	c.lineTo(w * 0.5885, h * 0.1955);
	c.arcTo(w * 0.0328, h * 0.0301, 0, 0, 1, w * 0.568, h * 0.1955);
	c.lineTo(w * 0.523, h * 0.1714);
	c.arcTo(w * 0.0074, h * 0.0068, 0, 0, 1, w * 0.523, h * 0.1616);
	c.close();
	c.moveTo(w * 0.6451, h * 0.1789);
	c.arcTo(w * 0.0328, h * 0.0301, 0, 0, 1, w * 0.6697, h * 0.1789);
	c.lineTo(w * 0.7123, h * 0.2023);
	c.arcTo(w * 0.0074, h * 0.0068, 0, 0, 1, w * 0.7123, h * 0.2128);
	c.lineTo(w * 0.6664, h * 0.2376);
	c.arcTo(w * 0.0328, h * 0.0301, 0, 0, 1, w * 0.6492, h * 0.2376);
	c.lineTo(w * 0.6016, h * 0.2135);
	c.arcTo(w * 0.0074, h * 0.0068, 0, 0, 1, w * 0.6016, h * 0.2023);
	c.close();
	c.moveTo(w * 0.6369, h * 0.2451);
	c.arcTo(w * 0.0074, h * 0.0068, 0, 0, 1, w * 0.6369, h * 0.2526);
	c.lineTo(w * 0.5172, h * 0.3173);
	c.arcTo(w * 0.0328, h * 0.0301, 0, 0, 1, w * 0.4893, h * 0.3173);
	c.lineTo(w * 0.3697, h * 0.2541);
	c.arcTo(w * 0.0074, h * 0.0068, 0, 0, 1, w * 0.3697, h * 0.2436);
	c.lineTo(w * 0.4918, h * 0.1782);
	c.arcTo(w * 0.0328, h * 0.0301, 0, 0, 1, w * 0.5131, h * 0.1782);
	c.close();
	c.fill();

	c.moveTo(w * 0., h * 0.);
	c.lineTo(w * 0., h * 0.);
	c.arcTo(w * 0., h * 0., 0, 0, 1, w * 0., h * 0.);
	
	c.setLineJoin('round');

	c.begin();
	c.moveTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.126, h * 0.267);
	c.lineTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.622, h * 0.4023);
	c.lineTo(w * 0.874, h * 0.267);
	c.lineTo(w * 0.874, h * 0.1316);
	c.moveTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.267);
	c.moveTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.5, h);
	c.moveTo(w, h * 0.3346);
	c.lineTo(w * 0.87, h * 0.267);
	c.moveTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.622, h * 0.4023);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');

	c.begin();
	c.moveTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.374, 0);
	c.lineTo(w * 0.626, 0);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3346);
	c.lineTo(w, h * 0.7331);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dElasticMapReduce.prototype.cst.ELASTIC_MAP_REDUCE, mxShapeAws3dElasticMapReduce);

//**********************************************************************************************************************************************************
//RDS Slave
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dRdsSlave(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dRdsSlave, mxShape);

mxShapeAws3dRdsSlave.prototype.cst = {
		RDS_SLAVE : 'mxgraph.aws3d.rdsSlave'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dRdsSlave.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 123;
	var strokeWidth2 = strokeWidth * h /133;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	c.setStrokeWidth(strokeWidth);
	
	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dRdsSlave.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.374, 0);
	c.lineTo(w * 0.626, 0);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3346);
	c.lineTo(w, h * 0.7331);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dRdsSlave.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	c.setAlpha('0.1');
	
	c.begin();
	c.moveTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.126, h * 0.267);
	c.lineTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.close();
	c.moveTo(w * 0.874, h * 0.267);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3308);
	c.fill();

	c.setAlpha('0.3');
	c.begin();
	c.moveTo(w * 0.5, h);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.622, h * 0.4023);
	c.lineTo(w * 0.874, h * 0.267);
	c.lineTo(w, h * 0.3308);
	c.lineTo(w, h * 0.7331);
	c.close();
	c.fill();
	
	c.restore();

	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.setShadow(false);

	c.begin();
	c.moveTo(w * 0.2457, h * 0.2137);
	c.lineTo(w * 0.5393, h * 0.0593);
	c.lineTo(w * 0.6875, h * 0.1377);
	c.arcTo(w * 0.0871, h * 0.0799, 0, 0, 1, w * 0.7137, h * 0.1625);
	c.arcTo(w * 0.0348, h * 0.032, 0, 0, 1, w * 0.7076, h * 0.1968);
	c.arcTo(w * 0.1743, h * 0.1599, 0, 0, 1, w * 0.6597, h * 0.2249);
	c.arcTo(w * 0.1307, h * 0.1199, 0, 0, 1, w * 0.5943, h * 0.232);
	c.arcTo(w * 0.1307, h * 0.1199, 0, 0, 1, w * 0.5542, h * 0.2225);
	c.arcTo(w * 0.0871, h * 0.0799, 0, 0, 1, w * 0.5673, h * 0.2353);
	c.arcTo(w * 0.0261, h * 0.024, 0, 0, 1, w * 0.5611, h * 0.2729);
	c.lineTo(w * 0.4889, h * 0.316);
	c.arcTo(w * 0.0261, h * 0.024, 0, 0, 0, w * 0.4766, h * 0.3352);
	c.lineTo(w * 0.4052, h * 0.2992);
	c.arcTo(w * 0.0173, h * 0.0159, 0, 0, 1, w * 0.4121, h * 0.2841);
	c.lineTo(w * 0.4914, h * 0.2368);
	c.arcTo(w * 0.0218, h * 0.02, 0, 0, 0, w * 0.4897, h * 0.2129);
	c.lineTo(w * 0.4409, h * 0.1857);
	c.lineTo(w * 0.3145, h * 0.2529);
	c.close();
	c.moveTo(w * 0.4801, h * 0.1633);
	c.lineTo(w * 0.5263, h * 0.1865);
	c.arcTo(w * 0.0871, h * 0.0799, 0, 0, 0, w * 0.583, h * 0.1905);
	c.arcTo(w * 0.1307, h * 0.1199, 0, 0, 0, w * 0.6196, h * 0.1721);
	c.arcTo(w * 0.0261, h * 0.024, 0, 0, 0, w * 0.6117, h * 0.1441);
	c.lineTo(w * 0.5655, h * 0.1193);
	c.fill();

	c.setLineJoin('round');

	c.begin();
	c.moveTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.126, h * 0.267);
	c.lineTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.622, h * 0.4023);
	c.lineTo(w * 0.874, h * 0.267);
	c.lineTo(w * 0.874, h * 0.1316);
	c.moveTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.267);
	c.moveTo(w * 0.5, h * 0.6015);
	c.lineTo(w * 0.5, h);
	c.moveTo(w, h * 0.3346);
	c.lineTo(w * 0.87, h * 0.267);
	c.moveTo(w * 0.378, h * 0.4023);
	c.lineTo(w * 0.622, h * 0.4023);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');

	c.begin();
	c.moveTo(0, h * 0.7331);
	c.lineTo(0, h * 0.3346);
	c.lineTo(w * 0.126, h * 0.1316);
	c.lineTo(w * 0.374, 0);
	c.lineTo(w * 0.626, 0);
	c.lineTo(w * 0.874, h * 0.1316);
	c.lineTo(w, h * 0.3346);
	c.lineTo(w, h * 0.7331);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dRdsSlave.prototype.cst.RDS_SLAVE, mxShapeAws3dRdsSlave);

//**********************************************************************************************************************************************************
//AMI
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dAMI2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dAMI2, mxShape);

mxShapeAws3dAMI2.prototype.cst = {
		AMI_2 : 'mxgraph.aws3d.ami2',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dAMI2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	var strokeWidth1 = strokeWidth * w / 92;
	var strokeWidth2 = strokeWidth * h / 60;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	
	c.setStrokeWidth(strokeWidth);
	c.setShadow(false);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if (isShadow == 1)
	{
		c.setShadow(true);
	}

	c.begin();
	c.moveTo(0, h * 0.572);
	c.lineTo(w * 0.0865, h * 0.284);
	c.lineTo(w * 0.4203, 0);
	c.lineTo(w * 0.5865, 0);
	c.lineTo(w * 0.919, h * 0.286);
	c.lineTo(w, h * 0.566);
	c.lineTo(w * 0.5027, h);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dAMI2.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.566);
	c.lineTo(w * 0.0892, h * 0.282);
	c.lineTo(w * 0.0878, h * 0.426);
	c.lineTo(w * 0.4216, h * 0.712);
	c.lineTo(w * 0.5865, h * 0.712);
	c.lineTo(w * 0.5027, h);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5027, h);
	c.lineTo(w * 0.5865, h * 0.712);
	c.lineTo(w * 0.9176, h * 0.43);
	c.lineTo(w, h * 0.566);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.566);
	c.lineTo(w * 0.0892, h * 0.282);
	c.lineTo(w * 0.0878, h * 0.426);
	c.lineTo(w * 0.4216, h * 0.712);
	c.lineTo(w * 0.5865, h * 0.712);
	c.lineTo(w * 0.5027, h);
	c.close();
	c.moveTo(w * 0.5027, h);
	c.lineTo(w * 0.5865, h * 0.712);
	c.lineTo(w * 0.9176, h * 0.43);
	c.lineTo(w, h * 0.566);
	c.close();
	c.moveTo(0, h * 0.572);
	c.lineTo(w * 0.0892, h * 0.422);
	c.moveTo(w * 0.5027, h);
	c.lineTo(w * 0.4189, h * 0.708);
	c.moveTo(w * 0.9176, h * 0.43);
	c.lineTo(w * 0.9176, h * 0.29);
	c.stroke();
	
	c.setStrokeWidth(2 * strokeWidth);
	c.setLineJoin('round');
	c.begin();
	c.moveTo(w * 0.2095, h * 0.376);
	c.lineTo(w * 0.527, h * 0.104);
	c.lineTo(w * 0.6338, h * 0.194);
	c.lineTo(w * 0.3149, h * 0.468);
	c.close();
	c.moveTo(w * 0.3716, h * 0.518);
	c.lineTo(w * 0.6892, h * 0.246);
	c.lineTo(w * 0.796, h * 0.336);
	c.lineTo(w * 0.477, h * 0.61);
	c.close();
	c.moveTo(w * 0.3108, h * 0.282);
	c.lineTo(w * 0.4257, h * 0.38);
	c.moveTo(w * 0.4189, h * 0.194);
	c.lineTo(w * 0.5297, h * 0.288);
	c.moveTo(w * 0.5838, h * 0.338);
	c.lineTo(w * 0.6892, h * 0.426);
	c.moveTo(w * 0.4757, h * 0.426);
	c.lineTo(w * 0.5838, h * 0.518);
	c.stroke();

	c.setStrokeColor('#292929');

	c.begin();
	c.moveTo(0, h * 0.572);
	c.lineTo(w * 0.0865, h * 0.284);
	c.lineTo(w * 0.4203, 0);
	c.lineTo(w * 0.5865, 0);
	c.lineTo(w * 0.919, h * 0.286);
	c.lineTo(w, h * 0.566);
	c.lineTo(w * 0.5027, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dAMI2.prototype.cst.AMI_2, mxShapeAws3dAMI2);

//**********************************************************************************************************************************************************
//EBS
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dEbs(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dEbs, mxShape);

mxShapeAws3dEbs.prototype.cst = {
		EBS : 'mxgraph.aws3d.ebs',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dEbs.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 92;
	var strokeWidth2 = strokeWidth * h / 60;
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	
	c.setStrokeWidth(strokeWidth);
	c.setShadow(false);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if(isShadow == 1)
	{
		c.setShadow(true);
	}
	
	c.begin();
	c.moveTo(0, h * 0.5276);
	c.lineTo(0, h * 0.4188);
	c.lineTo(w * 0.071, h * 0.2898);
	c.lineTo(w * 0.4033, 0);
	c.lineTo(w * 0.9301, h * 0.464);
	c.lineTo(w, h * 0.5863);
	c.lineTo(w, h * 0.7035);
	c.lineTo(w * 0.6667, h);
	c.lineTo(w * 0.5355, h);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');
	
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dEbs.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(w * 0.071, h * 0.2948);
	c.lineTo(w * 0.6011, h * 0.7621);
	c.lineTo(w * 0.6667, h);
	c.lineTo(w * 0.5355, h);
	c.lineTo(0, h * 0.5276);
	c.lineTo(0, h * 0.4137);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.6011, h * 0.7655);
	c.lineTo(w * 0.9344, h * 0.4724);
	c.lineTo(w, h * 0.7035);
	c.lineTo(w * 0.6667, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(w * 0.071, h * 0.2948);
	c.lineTo(w * 0.6011, h * 0.7621);
	c.lineTo(w * 0.6667, h);
	c.lineTo(w * 0.5355, h);
	c.lineTo(0, h * 0.5276);
	c.lineTo(0, h * 0.4137);
	c.close();
	c.moveTo(w * 0.6011, h * 0.7655);
	c.lineTo(w * 0.9344, h * 0.4724);
	c.lineTo(w, h * 0.7035);
	c.lineTo(w * 0.6667, h);
	c.close();
	c.moveTo(w * 0.0033, h * 0.5276);
	c.lineTo(w * 0.071, h * 0.2898);
	c.moveTo(w * 0.5325, h * 0.9976);
	c.lineTo(w * 0.603, h * 0.7593);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.5276);
	c.lineTo(0, h * 0.4188);
	c.lineTo(w * 0.071, h * 0.2898);
	c.lineTo(w * 0.4033, 0);
	c.lineTo(w * 0.9301, h * 0.464);
	c.lineTo(w, h * 0.5863);
	c.lineTo(w, h * 0.7035);
	c.lineTo(w * 0.6667, h);
	c.lineTo(w * 0.5355, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dEbs.prototype.cst.EBS, mxShapeAws3dEbs);

//**********************************************************************************************************************************************************
//Oracle  Server
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dOracleServer(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dOracleServer, mxShape);

mxShapeAws3dOracleServer.prototype.cst = {
		ORACLE_SERVER : 'mxgraph.aws3d.oracleServer'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dOracleServer.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 123;
	var strokeWidth2 = strokeWidth * h /133;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	c.setStrokeWidth(strokeWidth);
	
	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dOracleServer.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.save();
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7464);
	c.lineTo(0, h * 0.25);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.25);
	c.lineTo(w, h * 0.7464);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dOracleServer.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	c.setAlpha('0.1');
	
	c.begin();
	c.moveTo(0, h * 0.7464);
	c.lineTo(0, h * 0.25);
	c.lineTo(w * 0.5, h * 0.5);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();

	c.setAlpha('0.3');
	c.begin();
	c.moveTo(w * 0.5, h * 0.5);
	c.lineTo(w, h * 0.25);
	c.lineTo(w, h * 0.7464);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.setFillColor('#ff0000');

	c.begin();
	c.moveTo(0, h * 0.5866);
	c.lineTo(w * 0.5, h * 0.8359);
	c.lineTo(w, h * 0.5866);
	c.lineTo(w, h * 0.6986);
	c.lineTo(w * 0.5, h * 0.9486);
	c.lineTo(0, h * 0.6986);
	c.fill();

	c.setStrokeWidth(0.5 * strokeWidth);
	c.setStrokeColor('#ffffff');
	c.setFillColor('#ffffff');
	
	c.begin();
	c.moveTo(0, h * 0.5866);
	c.lineTo(w * 0.5, h * 0.8359);
	c.lineTo(w, h * 0.5866);
	c.moveTo(w, h * 0.6986);
	c.lineTo(w * 0.5, h * 0.9486);
	c.lineTo(0, h * 0.6986);
	c.stroke();
	
	c.begin();
	c.moveTo(w * 0.0813, h * 0.7113);
	c.arcTo(w * 0.0569, h * 0.0493, 0, 0, 1, w * 0.065, h * 0.6831);
	c.arcTo(w * 0.065, h * 0.0563, 0, 0, 1, w * 0.065, h * 0.6613);
	c.arcTo(w * 0.0163, h * 0.0141, 0, 0, 1, w * 0.0797, h * 0.6549);
	c.lineTo(w * 0.122, h * 0.6754);
	c.arcTo(w * 0.065, h * 0.0563, 0, 0, 1, w * 0.1358, h * 0.6937);
	c.arcTo(w * 0.065, h * 0.0563, 0, 0, 1, w * 0.139, h * 0.7232);
	c.arcTo(w * 0.0179, h * 0.0155, 0, 0, 1, w * 0.1187, h * 0.7296);
	c.close();
	c.moveTo(w * 0.1163, h * 0.7183);
	c.arcTo(w * 0.0089, h * 0.0077, 0, 0, 0, w * 0.1285, h * 0.7148);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 0, w * 0.1293, h * 0.7021);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 0, w * 0.1179, h * 0.6831);
	c.lineTo(w * 0.087, h * 0.6676);
	c.arcTo(w * 0.0081, h * 0.007, 0, 0, 0, w * 0.0764, h * 0.6697);
	c.arcTo(w * 0.0325, h * 0.0352, 0, 0, 0, w * 0.078, h * 0.6937);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 0, w * 0.087, h * 0.7035);
	c.close();
	c.moveTo(w * 0.1439, h * 0.743);
	c.lineTo(w * 0.1439, h * 0.6866);
	c.lineTo(w * 0.1846, h * 0.707);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.1967, h * 0.7183);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.2, h * 0.738);
	c.arcTo(w * 0.0138, h * 0.0155, 0, 0, 1, w * 0.1813, h * 0.743);
	c.lineTo(w * 0.1992, h * 0.769);
	c.lineTo(w * 0.187, h * 0.7641);
	c.lineTo(w * 0.1577, h * 0.7218);
	c.lineTo(w * 0.1854, h * 0.7345);
	c.arcTo(w * 0.0041, h * 0.0035, 0, 0, 0, w * 0.1911, h * 0.7317);
	c.arcTo(w * 0.0163, h * 0.0141, 0, 0, 0, w * 0.1894, h * 0.7225);
	c.arcTo(w * 0.0325, h * 0.0282, 0, 0, 0, w * 0.1821, h * 0.7155);
	c.lineTo(w * 0.1528, h * 0.7007);
	c.lineTo(w * 0.1528, h * 0.7472);
	c.close();
	c.moveTo(w * 0.2008, h * 0.7711);
	c.lineTo(w * 0.2293, h * 0.7338);
	c.arcTo(w * 0.0065, h * 0.0056, 0, 0, 1, w * 0.2382, h * 0.7324);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.2431, h * 0.7415);
	c.lineTo(w * 0.2699, h * 0.8035);
	c.lineTo(w * 0.2602, h * 0.8007);
	c.lineTo(w * 0.252, h * 0.7859);
	c.lineTo(w * 0.2293, h * 0.7754);
	c.lineTo(w * 0.2244, h * 0.7634);
	c.lineTo(w * 0.248, h * 0.7739);
	c.lineTo(w * 0.235, h * 0.7444);
	c.lineTo(w * 0.2122, h * 0.7768);
	c.close();
	c.moveTo(w * 0.3244, h * 0.8225);
	c.lineTo(w * 0.3171, h * 0.8289);
	c.lineTo(w * 0.2854, h * 0.8127);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.2724, h * 0.7986);
	c.arcTo(w * 0.0569, h * 0.0493, 0, 0, 1, w * 0.265, h * 0.7746);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.2683, h * 0.762);
	c.arcTo(w * 0.0163, h * 0.0141, 0, 0, 1, w * 0.2829, h * 0.757);
	c.lineTo(w * 0.3228, h * 0.7761);
	c.lineTo(w * 0.3179, h * 0.7831);
	c.lineTo(w * 0.2878, h * 0.7683);
	c.arcTo(w * 0.0081, h * 0.007, 0, 0, 0, w * 0.2789, h * 0.7697);
	c.arcTo(w * 0.0244, h * 0.0211, 0, 0, 0, w * 0.2748, h * 0.7831);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 0, w * 0.2878, h * 0.8042);
	c.close();
	c.moveTo(w * 0.3276, h * 0.7789);
	c.lineTo(w * 0.3366, h * 0.7831);
	c.lineTo(w * 0.3366, h * 0.8289);
	c.lineTo(w * 0.3805, h * 0.8507);
	c.lineTo(w * 0.3748, h * 0.857);
	c.lineTo(w * 0.3317, h * 0.8359);
	c.arcTo(w * 0.0163, h * 0.0141, 0, 0, 1, w * 0.3276, h * 0.8275);
	c.close();
	c.moveTo(w * 0.435, h * 0.8775);
	c.lineTo(w * 0.4325, h * 0.8866);
	c.lineTo(w * 0.3959, h * 0.8683);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.3862, h * 0.8563);
	c.arcTo(w * 0.0528, h * 0.0458, 0, 0, 1, w * 0.3805, h * 0.8183);
	c.arcTo(w * 0.0163, h * 0.0141, 0, 0, 1, w * 0.3951, h * 0.8134);
	c.lineTo(w * 0.435, h * 0.8324);
	c.lineTo(w * 0.4285, h * 0.838);
	c.lineTo(w * 0.4008, h * 0.8246);
	c.arcTo(w * 0.0098, h * 0.0085, 0, 0, 0, w * 0.3878, h * 0.831);
	c.lineTo(w * 0.4333, h * 0.8542);
	c.lineTo(w * 0.426, h * 0.8606);
	c.lineTo(w * 0.3878, h * 0.8415);
	c.arcTo(w * 0.0325, h * 0.0282, 0, 0, 0, w * 0.3976, h * 0.8585);
	c.close();

	c.moveTo(w * 0.6171, h * 0.8063);
	c.arcTo(w * 0.0163, h * 0.0141, 0, 0, 1, w * 0.6366, h * 0.8092);
	c.arcTo(w * 0.0325, h * 0.0282, 0, 0, 1, w * 0.639, h * 0.8303);
	c.arcTo(w * 0.065, h * 0.0563, 0, 0, 1, w * 0.6211, h * 0.8592);
	c.lineTo(w * 0.5894, h * 0.8761);
	c.arcTo(w * 0.0203, h * 0.0176, 0, 0, 1, w * 0.565, h * 0.8732);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.5659, h * 0.8458);
	c.arcTo(w * 0.0488, h * 0.0422, 0, 0, 1, w * 0.5805, h * 0.8246);
	c.close();
	c.moveTo(w * 0.5886, h * 0.8296);
	c.arcTo(w * 0.0325, h * 0.0282, 0, 0, 0, w * 0.5748, h * 0.8472);
	c.arcTo(w * 0.0325, h * 0.0282, 0, 0, 0, w * 0.574, h * 0.862);
	c.arcTo(w * 0.0098, h * 0.0085, 0, 0, 0, w * 0.587, h * 0.8676);
	c.lineTo(w * 0.6163, h * 0.8528);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 0, w * 0.6285, h * 0.8359);
	c.arcTo(w * 0.0244, h * 0.0211, 0, 0, 0, w * 0.6293, h * 0.8225);
	c.arcTo(w * 0.0098, h * 0.0085, 0, 0, 0, w * 0.6163, h * 0.8155);
	c.close();

	c.moveTo(w * 0.64, h * 0.85);
	c.lineTo(w * 0.64, h * 0.7930);
	c.lineTo(w * 0.6854, h * 0.7718);
	c.arcTo(w * 0.0106, h * 0.0092, 0, 0, 1, w * 0.7008, h * 0.7782);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.6959, h * 0.8);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.6805, h * 0.8127);
	c.lineTo(w * 0.6992, h * 0.8218);
	c.lineTo(w * 0.6854, h * 0.8282);
	c.lineTo(w * 0.6569, h * 0.8141);
	c.lineTo(w * 0.6805, h * 0.8021);
	c.arcTo(w * 0.0203, h * 0.0176, 0, 0, 0, w * 0.6894, h * 0.7923);
	c.arcTo(w * 0.0244, h * 0.0211, 0, 0, 0, w * 0.6894, h * 0.7845);
	c.arcTo(w * 0.0041, h * 0.0035, 0, 0, 0, w * 0.6837, h * 0.7831);
	c.lineTo(w * 0.6528, h * 0.7979);
	c.lineTo(w * 0.6528, h * 0.8437);
	c.close();
	c.moveTo(w * 0.7, h * 0.8204);
	c.lineTo(w * 0.7301, h * 0.7507);
	c.arcTo(w * 0.0098, h * 0.0085, 0, 0, 1, w * 0.7358, h * 0.7444);
	c.arcTo(w * 0.0098, h * 0.0085, 0, 0, 1, w * 0.7415, h * 0.7486);
	c.lineTo(w * 0.7699, h * 0.7852);
	c.lineTo(w * 0.7602, h * 0.7908);
	c.lineTo(w * 0.7537, h * 0.7838);
	c.lineTo(w * 0.7276, h * 0.7958);
	c.lineTo(w * 0.7228, h * 0.788);
	c.lineTo(w * 0.748, h * 0.7768);
	c.lineTo(w * 0.7358, h * 0.7585);
	c.lineTo(w * 0.7114, h * 0.8155);
	c.close();
	c.moveTo(w * 0.8244, h * 0.7486);
	c.lineTo(w * 0.8171, h * 0.762);
	c.lineTo(w * 0.7894, h * 0.7761);
	c.arcTo(w * 0.0244, h * 0.0211, 0, 0, 1, w * 0.7683, h * 0.7746);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.7667, h * 0.7507);
	c.arcTo(w * 0.0488, h * 0.0423, 0, 0, 1, w * 0.7937, h * 0.7162);
	c.lineTo(w * 0.822, h * 0.7035);
	c.lineTo(w * 0.8171, h * 0.7155);
	c.lineTo(w * 0.7902, h * 0.7296);
	c.arcTo(w * 0.0325, h * 0.0282, 0, 0, 0, w * 0.778, h * 0.743);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 0, w * 0.7756, h * 0.7606);
	c.arcTo(w * 0.0077, h * 0.0067, 0, 0, 0, w * 0.787, h * 0.767);
	c.close();
	c.moveTo(w * 0.8366, h * 0.6949);
	c.lineTo(w * 0.8366, h * 0.7423);
	c.lineTo(w * 0.878, h * 0.7231);
	c.lineTo(w * 0.874, h * 0.7338);
	c.lineTo(w * 0.8333, h * 0.7535);
	c.arcTo(w * 0.0041, h * 0.0035, 0, 0, 1, w * 0.8268, h * 0.75);
	c.lineTo(w * 0.8268, h * 0.7007);
	c.close();
	c.moveTo(w * 0.9342, h * 0.6472);
	c.lineTo(w * 0.9293, h * 0.6599);
	c.lineTo(w * 0.9033, h * 0.6725);
	c.arcTo(w * 0.0325, h * 0.0282, 0, 0, 0, w * 0.8927, h * 0.6817);
	c.arcTo(w * 0.0406, h * 0.0352, 0, 0, 0, w * 0.887, h * 0.6937);
	c.lineTo(w * 0.9309, h * 0.6725);
	c.lineTo(w * 0.9268, h * 0.6845);
	c.lineTo(w * 0.887, h * 0.7035);
	c.arcTo(w * 0.0089, h * 0.0077, 0, 0, 0, w * 0.8992, h * 0.7106);
	c.lineTo(w * 0.935, h * 0.693);
	c.lineTo(w * 0.9285, h * 0.7063);
	c.lineTo(w * 0.9008, h * 0.7197);
	c.arcTo(w * 0.0163, h * 0.0141, 0, 0, 1, w * 0.8829, h * 0.7204);
	c.arcTo(w * 0.0407, h * 0.0352, 0, 0, 1, w * 0.8764, h * 0.7028);
	c.arcTo(w * 0.065, h * 0.0563, 0, 0, 1, w * 0.8959, h * 0.6669);
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.7464);
	c.lineTo(0, h * 0.25);
	c.lineTo(w * 0.5, h * 0.5);
	c.lineTo(w * 0.5, h);
	c.close();
	c.moveTo(w * 0.5, h * 0.5);
	c.lineTo(w, h * 0.25);
	c.lineTo(w, h * 0.7464);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();

	c.setLineJoin('miter');
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.374, h * 0.3873);
	c.arcTo(w * 0.0325, h * 0.01764, 0, 0, 1, w * 0.374, h * 0.3626);
	c.lineTo(w * 0.4797, h * 0.3098);
	c.arcTo(w * 0.0325, h * 0.0141, 0, 0, 1, w * 0.5203, h * 0.3098);
	c.lineTo(w * 0.626, h * 0.3626);
	c.arcTo(w * 0.0325, h * 0.01764, 0, 0, 1, w * 0.626, h * 0.3852);
	c.lineTo(w * 0.5203, h * 0.438);
	c.arcTo(w * 0.0325, h * 0.0141, 0, 0, 1, w * 0.4797, h * 0.438);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7464);
	c.lineTo(0, h * 0.25);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.25);
	c.lineTo(w, h * 0.7464);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dOracleServer.prototype.cst.ORACLE_SERVER, mxShapeAws3dOracleServer);

//**********************************************************************************************************************************************************
//Secure Connection
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dSecureConnection(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dSecureConnection, mxShape);

mxShapeAws3dSecureConnection.prototype.cst = {
		SECURE_CONNECTION : 'mxgraph.aws3d.secureConnection'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dSecureConnection.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 57;
	var strokeWidth2 = strokeWidth * h /34;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	c.setStrokeWidth(strokeWidth);
	
	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dSecureConnection.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.begin();
	c.moveTo(w * 0.0058, h * 0.3889);
	c.arcTo(w * 0.2096, h * 0.3536, 0, 0, 1, w * 0.0774, h * 0.1856);
	c.arcTo(w * 0.5241, h * 0.8839, 0, 0, 1, w * 0.308, h * 0.0262);
	c.arcTo(w * 0.8735, h * 1.4732, 0, 0, 1, w * 0.6417, h * 0.056);
	c.arcTo(w * 0.6988, h * 1.1786, 0, 0, 1, w * 0.9106, h * 0.277);
	c.arcTo(w * 0.2621, h * 0.442, 0, 0, 1, w, h * 0.5451);
	c.arcTo(w * 0.2096, h * 0.3536, 0, 0, 1, w * 0.9474, h * 0.7808);
	c.arcTo(w * 0.4368, h * 0.7366, 0, 0, 1, w * 0.7186, h * 0.9605);
	c.arcTo(w * 0.8735, h * 1.4732, 0, 0, 1, w * 0.3045, h * 0.9104);
	c.arcTo(w * 0.6115, h * 1.0312, 0, 0, 1, w * 0.0687, h * 0.6747);
	c.arcTo(w * 0.2096, h * 0.3536, 0, 0, 1, w * 0.0058, h * 0.3889);
	c.close();
	c.fill();
};

mxShapeAws3dSecureConnection.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);

	c.begin();
	c.moveTo(w * 0.2661, h * 0.5068);
	c.lineTo(w * 0.5002, h * 0.7336);
	c.lineTo(w * 0.6626, h * 0.5775);
	c.lineTo(w * 0.6469, h * 0.5539);
	c.lineTo(w * 0.6958, h * 0.5097);
	c.arcTo(w * 0.0874, h * 0.1473, 0, 0, 0, w * 0.7325, h * 0.4066);
	c.arcTo(w * 0.0874, h * 0.1473, 0, 0, 0, w * 0.6889, h * 0.3153);
	c.arcTo(w * 0.1747, h * 0.2946, 0, 0, 0, w * 0.5928, h * 0.2622);
	c.arcTo(w * 0.1398, h * 0.2357, 0, 0, 0, w * 0.5107, h * 0.3005);
	c.lineTo(w * 0.446, h * 0.3654);
	c.lineTo(w * 0.4268, h * 0.3477);
	c.close();
	c.moveTo(w * 0.4949, h * 0.4184);
	c.lineTo(w * 0.5491, h * 0.3624);
	c.arcTo(w * 0.1222, h * 0.2062, 0, 0, 1, w * 0.6277, h * 0.3536);
	c.arcTo(w * 0.0874, h * 0.1179, 0, 0, 1, w * 0.6679, h * 0.3978);
	c.arcTo(w * 0.0175, h * 0.0295, 0, 0, 1, w * 0.6626, h * 0.439);
	c.lineTo(w * 0.5928, h * 0.5068);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeAws3dSecureConnection.prototype.cst.SECURE_CONNECTION, mxShapeAws3dSecureConnection);

//**********************************************************************************************************************************************************
//Email Service
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dEmailService(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dEmailService, mxShape);

mxShapeAws3dEmailService.prototype.cst = {
		EMAIL_SERVICE : 'mxgraph.aws3d.email_service',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dEmailService.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 151;
	var strokeWidth2 = strokeWidth * h / 192;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dEmailService.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.8182);
	c.lineTo(0, h * 0.1818);
	c.lineTo(w * 0.4007, 0);
	c.lineTo(w * 0.606, 0);
	c.lineTo(w, h * 0.1792);
	c.lineTo(w, h * 0.8182);
	c.lineTo(w * 0.5993, h);
	c.lineTo(w * 0.4007, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dEmailService.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dEmailService.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.2727);
	c.lineTo(w * 0.4007, h * 0.4546);
	c.lineTo(w * 0.5993, h * 0.4546);
	c.lineTo(w * 0.5993, h);
	c.lineTo(w * 0.4007, h);
	c.lineTo(0, h * 0.8182);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5993, h * 0.4546);
	c.lineTo(w, h * 0.2727);
	c.lineTo(w * 0.8013, h * 0.1792);
	c.lineTo(w * 0.8013, h * 0.0883);
	c.lineTo(w, h * 0.1792);
	c.lineTo(w, h * 0.8182);
	c.lineTo(w * 0.5993, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.2727);
	c.lineTo(w * 0.4007, h * 0.4546);
	c.lineTo(w * 0.5993, h * 0.4546);
	c.lineTo(w * 0.5993, h);
	c.lineTo(w * 0.4007, h);
	c.lineTo(0, h * 0.8182);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w * 0.5993, h * 0.4546);
	c.lineTo(w, h * 0.2727);
	c.lineTo(w * 0.8013, h * 0.1792);
	c.lineTo(w * 0.8013, h * 0.0883);
	c.lineTo(w, h * 0.1792);
	c.lineTo(w, h * 0.8182);
	c.lineTo(w * 0.5993, h);
	c.close();
	c.stroke();
	
	c.begin();
	c.moveTo(w * 0.202, h * 0.0883);
	c.lineTo(w * 0.202, h * 0.1818);
	c.lineTo(w * 0.4007, h * 0.2727);
	c.lineTo(w * 0.5993, h * 0.2727);
	c.lineTo(w * 0.798, h * 0.1818);
	c.moveTo(w * 0.2053, h * 0.1818);
	c.lineTo(w * 0.0033, h * 0.2714);
	c.moveTo(w * 0.4007, h * 0.2727);
	c.lineTo(w * 0.4007, h * 0.9961);
	c.moveTo(w * 0.5993, h * 0.2727);
	c.lineTo(w * 0.5993, h * 0.4546);
	c.stroke();
	
	c.setLineJoin('miter');
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.4437, h * 0.0779);
	c.arcTo(w * 0.0662, h * 0.0519, 0, 0, 1, w * 0.404, h * 0.0706);
	c.arcTo(w * 0.0464, h * 0.0364, 0, 0, 1, w * 0.3815, h * 0.0421);
	c.arcTo(w * 0.053, h * 0.026, 0, 0, 1, w * 0.4205, h * 0.0187);
	c.arcTo(w * 0.1987, h * 0.1558, 0, 0, 1, w * 0.4768, h * 0.0203);
	c.arcTo(w * 0.0795, h * 0.0364, 0, 0, 1, w * 0.5199, h * 0.0494);
	c.arcTo(w * 0.0265, h * 0.0208, 0, 0, 1, w * 0.5099, h * 0.0649);
	c.arcTo(w * 0.0795, h * 0.0623, 0, 0, 1, w * 0.4536, h * 0.0727);
	c.arcTo(w * 0.0199, h * 0.0156, 0, 0, 1, w * 0.4404, h * 0.0597);
	c.arcTo(w * 0.0265, h * 0.0208, 0, 0, 1, w * 0.4219, h * 0.0566);
	c.arcTo(w * 0.0199, h * 0.0114, 0, 0, 1, w * 0.4172, h * 0.0431);
	c.arcTo(w * 0.0265, h * 0.0208, 0, 0, 1, w * 0.4483, h * 0.0416);
	c.arcTo(w * 0.0132, h * 0.0104, 0, 0, 1, w * 0.457, h * 0.053);
	c.arcTo(w * 0.0132, h * 0.0104, 0, 0, 0, w * 0.4669, h * 0.0431);
	c.arcTo(w * 0.0166, h * 0.0166, 0, 0, 0, w * 0.4464, h * 0.0358);
	c.lineTo(w * 0.4437, h * 0.0338);
	c.arcTo(w * 0.0199, h * 0.0156, 0, 0, 1, w * 0.4603, h * 0.0322);
	c.arcTo(w * 0.0397, h * 0.0156, 0, 0, 1, w * 0.4755, h * 0.0462);
	c.arcTo(w * 0.0199, h * 0.0156, 0, 0, 1, w * 0.4669, h * 0.0545);
	c.arcTo(w * 0.053, h * 0.0416, 0, 0, 1, w * 0.453, h * 0.0608);
	c.arcTo(w * 0.0099, h * 0.0078, 0, 0, 0, w * 0.4636, h * 0.0675);
	c.arcTo(w * 0.0662, h * 0.0519, 0, 0, 0, w * 0.498, h * 0.0623);
	c.arcTo(w * 0.0185, h * 0.0145, 0, 0, 0, w * 0.5079, h * 0.0457);
	c.arcTo(w * 0.053, h * 0.0416, 0, 0, 0, w * 0.4848, h * 0.0296);
	c.arcTo(w * 0.0993, h * 0.0779, 0, 0, 0, w * 0.455, h * 0.0234);
	c.arcTo(w * 0.1325, h * 0.1039, 0, 0, 0, w * 0.4172, h * 0.026);
	c.arcTo(w * 0.0397, h * 0.0312, 0, 0, 0, w * 0.3927, h * 0.039);
	c.arcTo(w * 0.0265, h * 0.0208, 0, 0, 0, w * 0.3974, h * 0.0571);
	c.arcTo(w * 0.053, h * 0.0416, 0, 0, 0, w * 0.4205, h * 0.0701);
	c.arcTo(w * 0.0331, h * 0.026, 0, 0, 0, w * 0.4404, h * 0.0722);
	c.moveTo(w * 0.42, h * 0.049);
	c.arcTo(w * 0.02, h * 0.02, 0, 0, 0, w * 0.435, h * 0.055);
	c.arcTo(w * 0.02, h * 0.02, 0, 0, 0, w * 0.45, h * 0.049);
	c.arcTo(w * 0.02, h * 0.02, 0, 0, 0, w * 0.435, h * 0.043);
	c.arcTo(w * 0.02, h * 0.02, 0, 0, 0, w * 0.42, h * 0.049);
	c.close();
	c.moveTo(w * 0.4669, h * 0.0894);
	c.arcTo(w * 0.1325, h * 0.1039, 0, 0, 0, w * 0.5099, h * 0.0831);
	c.lineTo(w * 0.6689, h * 0.1543);
	c.lineTo(w * 0.4887, h * 0.1371);
	c.close();
	c.moveTo(w * 0.3887, h * 0.0769);
	c.arcTo(w * 0.0662, h * 0.0519, 0, 0, 0, w * 0.4205, h * 0.0888);
	c.arcTo(w * 0.0662, h * 0.026, 0, 0, 0, w * 0.447, h * 0.0894);
	c.lineTo(w * 0.4735, h * 0.1512);
	c.lineTo(w * 0.6689, h * 0.1688);
	c.lineTo(w * 0.5199, h * 0.2364);
	c.lineTo(w * 0.2815, h * 0.1273);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.8182);
	c.lineTo(0, h * 0.1818);
	c.lineTo(w * 0.4007, 0);
	c.lineTo(w * 0.606, 0);
	c.lineTo(w, h * 0.1792);
	c.lineTo(w, h * 0.8182);
	c.lineTo(w * 0.5993, h);
	c.lineTo(w * 0.4007, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dEmailService.prototype.cst.EMAIL_SERVICE, mxShapeAws3dEmailService);

//**********************************************************************************************************************************************************
//Worker
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dWorker(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dWorker, mxShape);

mxShapeAws3dWorker.prototype.cst = {
		WORKER : 'mxgraph.aws3d.worker',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dWorker.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	var strokeWidth1 = strokeWidth * w / 74;
	var strokeWidth2 = strokeWidth * h / 50;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	
	c.setStrokeWidth(strokeWidth);
	c.setShadow(false);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if (isShadow == 1)
	{
		c.setShadow(true);
	}

	c.begin();
	c.moveTo(0, h * 0.572);
	c.lineTo(w * 0.0865, h * 0.284);
	c.lineTo(w * 0.4203, 0);
	c.lineTo(w * 0.5865, 0);
	c.lineTo(w * 0.919, h * 0.286);
	c.lineTo(w, h * 0.566);
	c.lineTo(w * 0.5027, h);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dWorker.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.566);
	c.lineTo(w * 0.0892, h * 0.282);
	c.lineTo(w * 0.0878, h * 0.426);
	c.lineTo(w * 0.4216, h * 0.712);
	c.lineTo(w * 0.5865, h * 0.712);
	c.lineTo(w * 0.5027, h);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5027, h);
	c.lineTo(w * 0.5865, h * 0.712);
	c.lineTo(w * 0.9176, h * 0.43);
	c.lineTo(w, h * 0.566);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.566);
	c.lineTo(w * 0.0892, h * 0.282);
	c.lineTo(w * 0.0878, h * 0.426);
	c.lineTo(w * 0.4216, h * 0.712);
	c.lineTo(w * 0.5865, h * 0.712);
	c.lineTo(w * 0.5027, h);
	c.close();
	c.moveTo(w * 0.5027, h);
	c.lineTo(w * 0.5865, h * 0.712);
	c.lineTo(w * 0.9176, h * 0.43);
	c.lineTo(w, h * 0.566);
	c.close();
	c.moveTo(0, h * 0.572);
	c.lineTo(w * 0.0892, h * 0.422);
	c.moveTo(w * 0.5027, h);
	c.lineTo(w * 0.4189, h * 0.708);
	c.moveTo(w * 0.9176, h * 0.43);
	c.lineTo(w * 0.9176, h * 0.29);
	c.stroke();

	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.setLineJoin('round');
	c.begin();
	c.moveTo(w * 0.2892, h * 0.2104);
	c.lineTo(w * 0.3595, h * 0.1503);
	c.lineTo(w * 0.3973, h * 0.1844);
	c.arcTo(w * 0.2703, h * 0.4008, 0, 0, 1, w * 0.4486, h * 0.1703);
	c.lineTo(w * 0.4486, h * 0.1242);
	c.lineTo(w * 0.5527, h * 0.1242);
	c.lineTo(w * 0.5527, h * 0.1703);
	c.arcTo(w * 0.2703, h * 0.4008, 0, 0, 1, w * 0.6149, h * 0.1924);
	c.lineTo(w * 0.6527, h * 0.1603);
	c.lineTo(w * 0.7257, h * 0.2224);
	c.lineTo(w * 0.6892, h * 0.2545);
	c.arcTo(w * 0.2027, h * 0.3006, 0, 0, 1, w * 0.7162, h * 0.3106);
	c.lineTo(w * 0.7676, h * 0.3106);
	c.lineTo(w * 0.7676, h * 0.3988);
	c.lineTo(w * 0.7162, h * 0.3988);
	c.arcTo(w * 0.2027, h * 0.3006, 0, 0, 1, w * 0.6973, h * 0.4409);
	c.lineTo(w * 0.7378, h * 0.475);
	c.lineTo(w * 0.6635, h * 0.5371);
	c.lineTo(w * 0.6297, h * 0.505);
	c.arcTo(w * 0.2703, h * 0.4008, 0, 0, 1, w * 0.5527, h * 0.5351);
	c.lineTo(w * 0.5527, h * 0.5812);
	c.lineTo(w * 0.45, h * 0.5812);
	c.lineTo(w * 0.45, h * 0.5351);
	c.arcTo(w * 0.2703, h * 0.4008, 0, 0, 1, w * 0.3878, h * 0.513);
	c.lineTo(w * 0.3514, h * 0.5431);
	c.lineTo(w * 0.2784, h * 0.481);
	c.lineTo(w * 0.3149, h * 0.4509);
	c.arcTo(w * 0.2027, h * 0.3006, 0, 0, 1, w * 0.2865, h * 0.3968);
	c.lineTo(w * 0.2351, h * 0.3968);
	c.lineTo(w * 0.2351, h * 0.3086);
	c.lineTo(w * 0.2865, h * 0.3086);
	c.arcTo(w * 0.2027, h * 0.3006, 0, 0, 1, w * 0.3203, h * 0.2425);
	c.close();
	c.moveTo(w * 0.4054, h * 0.2445);
	c.arcTo(w * 0.1351, h * 0.2004, 0, 0, 0, w * 0.3554, h * 0.2986);
	c.arcTo(w * 0.0676, h * 0.1002, 0, 0, 0, w * 0.3432, h * 0.3567);
	c.arcTo(w * 0.0811, h * 0.1202, 0, 0, 0, w * 0.3635, h * 0.4208);
	c.arcTo(w * 0.1351, h * 0.2004, 0, 0, 0, w * 0.4122, h * 0.4649);
	c.arcTo(w * 0.2027, h * 0.3006, 0, 0, 0, w * 0.4122, h * 0.4649);
	c.arcTo(w * 0.2027, h * 0.3006, 0, 0, 0, w * 0.5676, h * 0.4749);
	c.arcTo(w * 0.1351, h * 0.2004, 0, 0, 0, w * 0.6351, h * 0.4228);
	c.arcTo(w * 0.0676, h * 0.1002, 0, 0, 0, w * 0.6595, h * 0.3467);
	c.arcTo(w * 0.0811, h * 0.1202, 0, 0, 0, w * 0.6149, h * 0.2605);
	c.arcTo(w * 0.2027, h * 0.3006, 0, 0, 0, w * 0.5419, h * 0.2204);
	c.arcTo(w * 0.3378, h * 0.501, 0, 0, 0, w * 0.4649, h * 0.2184);
	c.arcTo(w * 0.2027, h * 0.3006, 0, 0, 0, w * 0.4054, h * 0.2445);
	c.close();
	c.moveTo(w * 0.473, h * 0.2806);
	c.arcTo(w * 0.2027, h * 0.3006, 0, 0, 1, w * 0.55, h * 0.2866);
	c.arcTo(w * 0.0676, h * 0.1002, 0, 0, 1, w * 0.5892, h * 0.3307);
	c.arcTo(w * 0.0338, h * 0.0501, 0, 0, 1, w * 0.5824, h * 0.3888);
	c.arcTo(w * 0.0946, h * 0.1403, 0, 0, 1, w * 0.5216, h * 0.4269);
	c.arcTo(w * 0.1622, h * 0.2405, 0, 0, 1, w * 0.4432, h * 0.4128);
	c.arcTo(w * 0.0541, h * 0.0802, 0, 0, 1, w * 0.4108, h * 0.3527);
	c.arcTo(w * 0.0541, h * 0.0802, 0, 0, 1, w * 0.4351, h * 0.2986);
	c.arcTo(w * 0.0811, h * 0.1202, 0, 0, 1, w * 0.473, h * 0.2806);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');

	c.begin();
	c.moveTo(0, h * 0.572);
	c.lineTo(w * 0.0865, h * 0.284);
	c.lineTo(w * 0.4203, 0);
	c.lineTo(w * 0.5865, 0);
	c.lineTo(w * 0.919, h * 0.286);
	c.lineTo(w, h * 0.566);
	c.lineTo(w * 0.5027, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dWorker.prototype.cst.WORKER, mxShapeAws3dWorker);

//**********************************************************************************************************************************************************
//Application
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dApplication2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dApplication2, mxShape);

mxShapeAws3dApplication2.prototype.cst = {
		APPLICATION2 : 'mxgraph.aws3d.application2',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dApplication2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 62;
	var strokeWidth2 = strokeWidth * h / 53.5;
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	c.setShadow(false);
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if (isShadow == 1)
	{
		c.setShadow(true);
	}
	
	c.begin();
	c.moveTo(0, h * 0.6766);
	c.lineTo(0, h * 0.3271);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.3271);
	c.lineTo(w, h * 0.6766);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dApplication2.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.3271);
	c.lineTo(w * 0.5, h * 0.6449);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.6766);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5, h * 0.6449);
	c.lineTo(w, h * 0.3271);
	c.lineTo(w, h * 0.6766);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.3271);
	c.lineTo(w * 0.5, h * 0.6449);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.6766);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w * 0.5, h * 0.6449);
	c.lineTo(w, h * 0.3271);
	c.lineTo(w, h * 0.6766);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
	
	c.setLineJoin('miter');
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.1742, h * 0.6355);
	c.lineTo(w * 0.1742, h * 0.4393);
	c.lineTo(w * 0.6726, h * 0.1121);
	c.lineTo(w * 0.7661, h * 0.1738);
	c.lineTo(w * 0.2661, h * 0.4991);
	c.lineTo(w * 0.2661, h * 0.6916);
	c.close();
	c.moveTo(w * 0.2871, h * 0.7084);
	c.lineTo(w * 0.2871, h * 0.514);
	c.lineTo(w * 0.7823, h * 0.1869);
	c.lineTo(w * 0.8629, h * 0.2374);
	c.lineTo(w * 0.379, h * 0.5626);
	c.lineTo(w * 0.379, h * 0.7607);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.6766);
	c.lineTo(0, h * 0.3271);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.3271);
	c.lineTo(w, h * 0.6766);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dApplication2.prototype.cst.APPLICATION2, mxShapeAws3dApplication2);

//**********************************************************************************************************************************************************
//Elastic Beanstalk
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dElasticBeanstalk(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dElasticBeanstalk, mxShape);

mxShapeAws3dElasticBeanstalk.prototype.cst = {
		ELASTIC_BEANSTALK : 'mxgraph.aws3d.elasticBeanstalk',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dElasticBeanstalk.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 181.5;
	var strokeWidth2 = strokeWidth * h / 140;
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	c.setShadow(false);
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if (isShadow == 1)
	{
		c.setShadow(true);
	}
	
	c.begin();
	c.moveTo(0, h * 0.6239);
	c.lineTo(0, h * 0.3754);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.3754);
	c.lineTo(w, h * 0.6239);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dElasticBeanstalk.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.3754);
	c.lineTo(w * 0.5, h * 0.7514);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.6239);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5, h * 0.7514);
	c.lineTo(w, h * 0.3754);
	c.lineTo(w, h * 0.6239);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.3754);
	c.lineTo(w * 0.5, h * 0.7514);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h * 0.6239);
	c.close();
	c.moveTo(w * 0.5, h * 0.7514);
	c.lineTo(w, h * 0.3754);
	c.lineTo(w, h * 0.6239);
	c.lineTo(w * 0.5, h);
	c.close();
	c.moveTo(w * 0.2485, h * 0.187);
	c.lineTo(w * 0.7493, h * 0.5623);
	c.lineTo(w * 0.7493, h * 0.8123);
	c.stroke();
	
	c.setLineJoin('miter');
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.7763, h * 0.2063);
	c.lineTo(w * 0.2749, h * 0.5817);
	c.lineTo(w * 0.2749, h * 0.8309);
	c.lineTo(w * 0.2204, h * 0.7894);
	c.lineTo(w * 0.2204, h * 0.5394);
	c.lineTo(w * 0.7185, h * 0.1619);
	c.close();
	c.fill();

	c.restore();
	c.begin();
	c.moveTo(w * 0.1713, h * 0.543);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.2028, h * 0.5723);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.2281, h * 0.6096);
	c.arcTo(w * 0.1102, h * 0.1433, 0, 0, 1, w * 0.2402, h * 0.644);
	c.arcTo(w * 0.1102, h * 0.1433, 0, 0, 1, w * 0.2424, h * 0.6848);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.216, h * 0.6612);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.1895, h * 0.6239);
	c.arcTo(w * 0.1102, h * 0.1433, 0, 0, 1, w * 0.1719, h * 0.5824);
	c.arcTo(w * 0.0826, h * 0.1074, 0, 0, 1, w * 0.1713, h * 0.543);
	c.close();
	c.moveTo(w * 0.2507, h * 0.7794);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.254, h * 0.7421);
	c.arcTo(w * 0.022, h * 0.0287, 0, 0, 1, w * 0.27, h * 0.7264);
	c.arcTo(w * 0.0551, h * 0.0716, 0, 0, 1, w * 0.2986, h * 0.73);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.3234, h * 0.7457);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.3218, h * 0.7815);
	c.arcTo(w * 0.022, h * 0.0287, 0, 0, 1, w * 0.3019, h * 0.7987);
	c.arcTo(w * 0.0826, h * 0.1074, 0, 0, 1, w * 0.27, h * 0.7923);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.2507, h * 0.7794);
	c.close();
	c.moveTo(w * 0.2799, h * 0.5265);
	c.arcTo(w * 0.1102, h * 0.1433, 0, 0, 1, w * 0.3003, h * 0.515);
	c.arcTo(w * 0.0826, h * 0.1074, 0, 0, 1, w * 0.3317, h * 0.515);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.3774, h * 0.5315);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.4033, h * 0.5487);
	c.arcTo(w * 0.0826, h * 0.1074, 0, 0, 1, w * 0.3906, h * 0.5595);
	c.arcTo(w * 0.0826, h * 0.1074, 0, 0, 1, w * 0.3493, h * 0.5616);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.3069, h * 0.5444);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.2799, h * 0.5265);
	c.close();
	c.moveTo(w * 0.2887, h * 0.3933);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.314, h * 0.414);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.3322, h * 0.4391);
	c.arcTo(w * 0.0193, h * 0.0251, 0, 0, 1, w * 0.3344, h * 0.4699);
	c.arcTo(w * 0.0551, h * 0.0716, 0, 0, 1, w * 0.3196, h * 0.485);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.2887, h * 0.4592);
	c.arcTo(w * 0.1102, h * 0.1433, 0, 0, 1, w * 0.27, h * 0.4269);
	c.arcTo(w * 0.0165, h * 0.0215, 0, 0, 1, w * 0.2727, h * 0.4054);
	c.arcTo(w * 0.0551, h * 0.0716, 0, 0, 1, w * 0.2887, h * 0.3933);
	c.close();
	c.moveTo(w * 0.4613, h * 0.262);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.4867, h * 0.2827);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.5049, h * 0.3078);
	c.arcTo(w * 0.0193, h * 0.0251, 0, 0, 1, w * 0.5071, h * 0.3386);
	c.arcTo(w * 0.0551, h * 0.0716, 0, 0, 1, w * 0.4922, h * 0.3537);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.4613, h * 0.3279);
	c.arcTo(w * 0.1102, h * 0.1433, 0, 0, 1, w * 0.4426, h * 0.2956);
	c.arcTo(w * 0.0165, h * 0.0215, 0, 0, 1, w * 0.4453, h * 0.2741);
	c.arcTo(w * 0.0551, h * 0.0716, 0, 0, 1, w * 0.4613, h * 0.262);
	c.close();
	c.moveTo(w * 0.4525, h * 0.3952);
	c.arcTo(w * 0.1102, h * 0.1433, 0, 0, 1, w * 0.4729, h * 0.3837);
	c.arcTo(w * 0.0826, h * 0.1074, 0, 0, 1, w * 0.5043, h * 0.3837);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.55, h * 0.4002);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.5759, h * 0.4174);
	c.arcTo(w * 0.0826, h * 0.1074, 0, 0, 1, w * 0.5633, h * 0.4282);
	c.arcTo(w * 0.0826, h * 0.1074, 0, 0, 1, w * 0.5219, h * 0.4303);
	c.arcTo(w * 0.1653, h * 0.1074, 0, 0, 1, w * 0.4795, h * 0.4131);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.4525, h * 0.3952);
	c.close();
	c.moveTo(w * 0.6217, h * 0.1426);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.6471, h * 0.1633);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.6652, h * 0.1884);
	c.arcTo(w * 0.0193, h * 0.0251, 0, 0, 1, w * 0.6674, h * 0.2192);
	c.arcTo(w * 0.0551, h * 0.0716, 0, 0, 1, w * 0.6526, h * 0.2342);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.6217, h * 0.2085);
	c.arcTo(w * 0.1102, h * 0.1433, 0, 0, 1, w * 0.603, h * 0.1762);
	c.arcTo(w * 0.0165, h * 0.0215, 0, 0, 1, w * 0.6057, h * 0.1547);
	c.arcTo(w * 0.0551, h * 0.0716, 0, 0, 1, w * 0.6217, h * 0.1426);
	c.close();
	c.moveTo(w * 0.6129, h * 0.2758);
	c.arcTo(w * 0.1102, h * 0.1433, 0, 0, 1, w * 0.6333, h * 0.2643);
	c.arcTo(w * 0.0826, h * 0.1433, 0, 0, 1, w * 0.6647, h * 0.2643);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.7104, h * 0.2808);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.7363, h * 0.298);
	c.arcTo(w * 0.0826, h * 0.2149, 0, 0, 1, w * 0.7363, h * 0.298);
	c.arcTo(w * 0.0826, h * 0.1074, 0, 0, 1, w * 0.6823, h * 0.3109);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.6399, h * 0.2937);
	c.arcTo(w * 0.1653, h * 0.2149, 0, 0, 1, w * 0.6129, h * 0.2758);
	c.close();
	c.fillAndStroke();
	
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.6239);
	c.lineTo(0, h * 0.3754);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.3754);
	c.lineTo(w, h * 0.6239);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dElasticBeanstalk.prototype.cst.ELASTIC_BEANSTALK, mxShapeAws3dElasticBeanstalk);

//**********************************************************************************************************************************************************
//SimpleDB 2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dSimpleDB2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dSimpleDB2, mxShape);

mxShapeAws3dSimpleDB2.prototype.cst = {
		SIMPLE_DB_2 : 'mxgraph.aws3d.simpleDb2',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dSimpleDB2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 181.5;
	var strokeWidth2 = strokeWidth * h / 210;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dSimpleDB2.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.8183);
	c.lineTo(0, h * 0.1848);
	c.lineTo(w * 0.3366, 0);
	c.lineTo(w * 0.6293, h * 0.0021);
	c.lineTo(w, h * 0.1833);
	c.lineTo(w, h * 0.8183);
	c.lineTo(w * 0.6694, h);
	c.lineTo(w * 0.4986, h * 0.9091);
	c.lineTo(w * 0.3333, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dSimpleDB2.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dSimpleDB2.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.1848);
	c.lineTo(w * 0.168, h * 0.1833);
	c.lineTo(0, h * 0.365);
	c.lineTo(w * 0.3333, h * 0.5467);
	c.lineTo(w * 0.3333, h);
	c.lineTo(0, h * 0.8183);
	c.close();
	c.moveTo(w * 0.4986, h * 0.9078);
	c.lineTo(w * 0.4986, h * 0.3655);
	c.lineTo(w * 0.6667, h * 0.5457);
	c.lineTo(w * 0.6667, h);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.3333, h * 0.5467);
	c.lineTo(w * 0.4986, h * 0.3655);
	c.lineTo(w * 0.4986, h * 0.9076);
	c.lineTo(w * 0.3333, h);
	c.close();
	c.moveTo(w * 0.8292, h * 0.1822);
	c.lineTo(w, h * 0.1848);
	c.lineTo(w, h * 0.8183);
	c.lineTo(w * 0.6667, h);
	c.lineTo(w * 0.6667, h * 0.5441);
	c.lineTo(w, h * 0.3666);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.1848);
	c.lineTo(w * 0.168, h * 0.1833);
	c.lineTo(0, h * 0.365);
	c.lineTo(w * 0.3333, h * 0.5467);
	c.lineTo(w * 0.3333, h);
	c.lineTo(0, h * 0.8183);
	c.close();
	c.moveTo(w * 0.4986, h * 0.9078);
	c.lineTo(w * 0.4986, h * 0.3655);
	c.lineTo(w * 0.6667, h * 0.5457);
	c.lineTo(w * 0.6667, h);
	c.close();
	c.moveTo(w * 0.3333, h * 0.5467);
	c.lineTo(w * 0.4986, h * 0.3655);
	c.lineTo(w * 0.4986, h * 0.9076);
	c.lineTo(w * 0.3333, h);
	c.close();
	c.moveTo(w * 0.8292, h * 0.1822);
	c.lineTo(w, h * 0.1848);
	c.lineTo(w, h * 0.8183);
	c.lineTo(w * 0.6667, h);
	c.lineTo(w * 0.6667, h * 0.5441);
	c.lineTo(w, h * 0.3666);
	c.close();
	c.moveTo(w * 0.1669, h * 0.1828);
	c.lineTo(w * 0.4986, h * 0.3655);
	c.lineTo(w * 0.8314, h * 0.1833);
	c.lineTo(w * 0.4986, h * 0.0031);
	c.close();
	c.stroke();

	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.2634, h * 0.1833);
	c.lineTo(w * 0.5003, h * 0.0535);
	c.lineTo(w * 0.7394, h * 0.1833);
	c.lineTo(w * 0.5003, h * 0.3136);
	c.close();
	c.fill();

	var fillColor = mxUtils.getValue(this.state.style, 'fillColor', '#000000');
	c.restore();
	c.setShadow(false);
	c.setStrokeWidth(3 * strokeWidth);
	c.setStrokeColor(fillColor);
	
	c.begin();
	c.moveTo(w * 0.3003, h * 0.2108);
	c.lineTo(w * 0.5642, h * 0.068);
	c.moveTo(w * 0.4429, h * 0.0693);
	c.lineTo(w * 0.7059, h * 0.2121);
	c.moveTo(w * 0.6667, h * 0.2458);
	c.lineTo(w * 0.3974, h * 0.0992);
	c.moveTo(w * 0.3499, h * 0.1277);
	c.lineTo(w * 0.6088, h * 0.2698);
	c.moveTo(w * 0.3009, h * 0.1556);
	c.lineTo(w * 0.5496, h * 0.2913);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.8183);
	c.lineTo(0, h * 0.1848);
	c.lineTo(w * 0.3366, 0);
	c.lineTo(w * 0.6293, h * 0.0021);
	c.lineTo(w, h * 0.1833);
	c.lineTo(w, h * 0.8183);
	c.lineTo(w * 0.6694, h);
	c.lineTo(w * 0.4986, h * 0.9091);
	c.lineTo(w * 0.3333, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dSimpleDB2.prototype.cst.SIMPLE_DB_2, mxShapeAws3dSimpleDB2);

//**********************************************************************************************************************************************************
//Workflow Service
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dWorkflowService(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dWorkflowService, mxShape);

mxShapeAws3dWorkflowService.prototype.cst = {
		WORKFLOW_SERVICE : 'mxgraph.aws3d.workflowService',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dWorkflowService.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 181.5;
	var strokeWidth2 = strokeWidth * h / 210;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dWorkflowService.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.6456);
	c.lineTo(w * 0.2481, 0);
	c.lineTo(w * 0.7497, 0);
	c.lineTo(w, h * 0.6456);
	c.lineTo(w * 0.4984, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dWorkflowService.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dWorkflowService.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.6456);
	c.lineTo(w * 0.2486, 0);
	c.lineTo(w * 0.2486, h * 0.3531);
	c.lineTo(w * 0.4984, h);
	c.close();
	c.moveTo(w * 0.7497, h * 0.3531);
	c.lineTo(w * 0.7497, 0);
	c.lineTo(w, h * 0.6456);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.4984, h);
	c.lineTo(w * 0.7486, h * 0.3531);
	c.lineTo(w, h * 0.6456);
	c.lineTo(w * 0.4967, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(w * 0.7497, h * 0.3531);
	c.lineTo(w * 0.7497, 0);
	c.lineTo(w, h * 0.6456);
	c.close();
	c.moveTo(0, h * 0.6456);
	c.lineTo(w * 0.2486, 0);
	c.lineTo(w * 0.2486, h * 0.3531);
	c.lineTo(w * 0.4984, h);
	c.lineTo(w * 0.7486, h * 0.3531);
	c.lineTo(w, h * 0.6456);
	c.lineTo(w * 0.4967, h);
	c.close();
	c.moveTo(w * 0.2486, h * 0.3531);
	c.lineTo(w * 0.7508, h * 0.3531);
	c.moveTo(w * 0.2488, h * 0.353);
	c.lineTo(0, h * 0.6486);
	c.stroke();

	c.restore();
	c.setShadow(false);
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	c.setStrokeWidth(2 * strokeWidth);

	c.begin();
	c.ellipse(w * 0.2925, h * 0.031, w * 0.4116, h * 0.2925);
	c.fill();
	
	var fillColor = mxUtils.getValue(this.state.style, 'fillColor', '#ffffff');
	c.setStrokeColor(fillColor);
	
	c.begin();
	c.moveTo(w * 0.5252, h * 0.0465);
	c.lineTo(w * 0.5873, h * 0.0903);
	c.lineTo(w * 0.5483, h * 0.1173);
	c.lineTo(w * 0.4874, h * 0.0728);
	c.close();
	c.moveTo(w * 0.4896, h * 0.1132);
	c.lineTo(w * 0.5005, h * 0.1705);
	c.lineTo(w * 0.4182, h * 0.1631);
	c.lineTo(w * 0.4122, h * 0.1058);
	c.close();
	c.moveTo(w * 0.3584, h * 0.1631);
	c.lineTo(w * 0.4204, h * 0.2062);
	c.lineTo(w * 0.3825, h * 0.2332);
	c.lineTo(w * 0.32, h * 0.19);
	c.close();
	c.moveTo(w * 0.4594, h * 0.2338);
	c.lineTo(w * 0.5214, h * 0.2783);
	c.lineTo(w * 0.4835, h * 0.3053);
	c.lineTo(w * 0.4215, h * 0.2608);
	c.close();
	c.moveTo(w * 0.5187, h * 0.0943);
	c.lineTo(w * 0.4879, h * 0.1152);
	c.moveTo(w * 0.421, h * 0.1624);
	c.lineTo(w * 0.3895, h * 0.1846);
	c.moveTo(w * 0.5, h * 0.1698);
	c.lineTo(w * 0.5554, h * 0.2089);
	c.lineTo(w * 0.4885, h * 0.2567);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.6456);
	c.lineTo(w * 0.2481, 0);
	c.lineTo(w * 0.7497, 0);
	c.lineTo(w, h * 0.6456);
	c.lineTo(w * 0.4984, h);
	c.close();
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dWorkflowService.prototype.cst.WORKFLOW_SERVICE, mxShapeAws3dWorkflowService);

//**********************************************************************************************************************************************************
//Decider
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dDecider(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dDecider, mxShape);

mxShapeAws3dDecider.prototype.cst = {
		DECIDER : 'mxgraph.aws3d.decider',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dDecider.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	var strokeWidth1 = strokeWidth * w / 74;
	var strokeWidth2 = strokeWidth * h / 50;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	
	c.setStrokeWidth(strokeWidth);
	c.setShadow(false);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if (isShadow == 1)
	{
		c.setShadow(true);
	}

	c.begin();
	c.moveTo(0, h * 0.572);
	c.lineTo(w * 0.0865, h * 0.284);
	c.lineTo(w * 0.4203, 0);
	c.lineTo(w * 0.5865, 0);
	c.lineTo(w * 0.919, h * 0.286);
	c.lineTo(w, h * 0.566);
	c.lineTo(w * 0.5027, h);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dDecider.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.566);
	c.lineTo(w * 0.0892, h * 0.282);
	c.lineTo(w * 0.0878, h * 0.426);
	c.lineTo(w * 0.4216, h * 0.712);
	c.lineTo(w * 0.5865, h * 0.712);
	c.lineTo(w * 0.5027, h);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5027, h);
	c.lineTo(w * 0.5865, h * 0.712);
	c.lineTo(w * 0.9176, h * 0.43);
	c.lineTo(w, h * 0.566);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.566);
	c.lineTo(w * 0.0892, h * 0.282);
	c.lineTo(w * 0.0878, h * 0.426);
	c.lineTo(w * 0.4216, h * 0.712);
	c.lineTo(w * 0.5865, h * 0.712);
	c.lineTo(w * 0.5027, h);
	c.close();
	c.moveTo(w * 0.5027, h);
	c.lineTo(w * 0.5865, h * 0.712);
	c.lineTo(w * 0.9176, h * 0.43);
	c.lineTo(w, h * 0.566);
	c.close();
	c.moveTo(0, h * 0.572);
	c.lineTo(w * 0.0892, h * 0.422);
	c.moveTo(w * 0.5027, h);
	c.lineTo(w * 0.4189, h * 0.708);
	c.moveTo(w * 0.9176, h * 0.43);
	c.lineTo(w * 0.9176, h * 0.29);
	c.stroke();

	c.setStrokeWidth(1.6 * strokeWidth);
	c.setLineJoin('square');
	c.begin();
	c.moveTo(w * 0.4973, h * 0.1523);
	c.lineTo(w * 0.5608, h * 0.0982);
	c.lineTo(w * 0.6581, h * 0.1844);
	c.lineTo(w * 0.5986, h * 0.2365);
	c.close();
	c.moveTo(w * 0.3784, h * 0.2164);
	c.lineTo(w * 0.5054, h * 0.2305);
	c.lineTo(w * 0.5203, h * 0.3407);
	c.lineTo(w * 0.3892, h * 0.3246);
	c.close();
	c.moveTo(w * 0.2932, h * 0.3246);
	c.lineTo(w * 0.3919, h * 0.4128);
	c.lineTo(w * 0.3334, h * 0.4647);
	c.lineTo(w * 0.2357, h * 0.38);
	c.close();
	c.moveTo(w * 0.4568, h * 0.4649);
	c.lineTo(w * 0.5554, h * 0.5511);
	c.lineTo(w * 0.4932, h * 0.6032);
	c.lineTo(w * 0.3946, h * 0.517);
	c.close();
	c.moveTo(w * 0.5473, h * 0.1924);
	c.lineTo(w * 0.5027, h * 0.2365);
	c.moveTo(w * 0.4, h * 0.3186);
	c.lineTo(w * 0.3446, h * 0.3667);
	c.moveTo(w * 0.5189, h * 0.3387);
	c.lineTo(w * 0.6081, h * 0.4148);
	c.lineTo(w * 0.5068, h * 0.501);
	c.stroke();

	c.setStrokeColor('#292929');

	c.begin();
	c.moveTo(0, h * 0.572);
	c.lineTo(w * 0.0865, h * 0.284);
	c.lineTo(w * 0.4203, 0);
	c.lineTo(w * 0.5865, 0);
	c.lineTo(w * 0.919, h * 0.286);
	c.lineTo(w, h * 0.566);
	c.lineTo(w * 0.5027, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dDecider.prototype.cst.DECIDER, mxShapeAws3dDecider);

//**********************************************************************************************************************************************************
//Search Engine
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dSearchEngine(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dSearchEngine, mxShape);

mxShapeAws3dSearchEngine.prototype.cst = {
		SEARCH_ENGINE : 'mxgraph.aws3d.searchEngine',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dSearchEngine.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 180;
	var strokeWidth2 = strokeWidth * h / 192;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dSearchEngine.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7281);
	c.lineTo(w * 0.1667, h * 0.5444);
	c.lineTo(w * 0.1667, h * 0.1832);
	c.lineTo(w * 0.5011, 0);
	c.lineTo(w * 0.8333, h * 0.1832);
	c.lineTo(w * 0.8333, h * 0.5446);
	c.lineTo(w, h * 0.7281);
	c.lineTo(w * 0.7486, h * 0.7735);
	c.lineTo(w * 0.5819, h * 0.8617);
	c.lineTo(w * 0.5011, h);
	c.lineTo(w * 0.4169, h * 0.8653);
	c.lineTo(w * 0.2475, h * 0.7704);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dSearchEngine.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dSearchEngine.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(w * 0.1672, h * 0.1837);
	c.lineTo(w * 0.4989, h * 0.3638);
	c.lineTo(w * 0.4989, h * 0.7291);
	c.lineTo(w * 0.5825, h * 0.8633);
	c.lineTo(w * 0.4989, h);
	c.lineTo(w * 0.4164, h * 0.8622);
	c.lineTo(w * 0.2458, h * 0.7719);
	c.lineTo(0, h * 0.7276);
	c.lineTo(w * 0.1661, h * 0.5454);
	c.close();
	c.moveTo(w * 0.7486, h * 0.7714);
	c.lineTo(w * 0.8317, h * 0.5459);
	c.lineTo(w, h * 0.727);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.4989, h * 0.3643);
	c.lineTo(w * 0.8317, h * 0.1827);
	c.lineTo(w * 0.8317, h * 0.5465);
	c.lineTo(w * 0.7508, h * 0.7714);
	c.lineTo(w * 0.5836, h * 0.8633);
	c.lineTo(w * 0.4989, h * 0.727);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(w * 0.1672, h * 0.1837);
	c.lineTo(w * 0.4989, h * 0.3638);
	c.lineTo(w * 0.4989, h * 0.7291);
	c.lineTo(w * 0.5825, h * 0.8633);
	c.lineTo(w * 0.4989, h);
	c.lineTo(w * 0.4164, h * 0.8622);
	c.lineTo(w * 0.2458, h * 0.7719);
	c.lineTo(0, h * 0.7276);
	c.lineTo(w * 0.1661, h * 0.5454);
	c.close();
	c.moveTo(w * 0.7486, h * 0.7714);
	c.lineTo(w * 0.8317, h * 0.5459);
	c.lineTo(w, h * 0.727);
	c.close();
	c.moveTo(w * 0.4989, h * 0.3643);
	c.lineTo(w * 0.8317, h * 0.1827);
	c.lineTo(w * 0.8317, h * 0.5465);
	c.lineTo(w * 0.7508, h * 0.7714);
	c.lineTo(w * 0.5836, h * 0.8633);
	c.lineTo(w * 0.4989, h * 0.727);
	c.close();
	c.moveTo(w * 0.1667, h * 0.5459);
	c.lineTo(w * 0.2486, h * 0.7704);
	c.moveTo(w * 0.4164, h * 0.8633);
	c.lineTo(w * 0.4989, h * 0.727);
	c.lineTo(w * 0.4989, h);
	c.stroke();

	c.restore();
	c.setShadow(false);
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	
	c.begin();
	c.moveTo(w * 0.3427, h * 0.179);
	c.arcTo(w * 0.0277, h * 0.0261, 0, 0, 1, w * 0.3267, h * 0.1487);
	c.arcTo(w * 0.0664, h * 0.0365, 0, 0, 1, w * 0.3621, h * 0.1227);
	c.arcTo(w * 0.1052, h * 0.0992, 0, 0, 1, w * 0.4247, h * 0.1195);
	c.arcTo(w * 0.1274, h * 0.12, 0, 0, 1, w * 0.4884, h * 0.1018);
	c.arcTo(w * 0.1329, h * 0.1253, 0, 0, 1, w * 0.5548, h * 0.1112);
	c.arcTo(w * 0.0377, h * 0.0344, 0, 0, 1, w * 0.572, h * 0.166);
	c.arcTo(w * 0.0388, h * 0.0365, 0, 0, 1, w * 0.6047, h * 0.1775);
	c.arcTo(w * 0.021, h * 0.0198, 0, 0, 1, w * 0.5936, h * 0.2046);
	c.arcTo(w * 0.0332, h * 0.0313, 0, 0, 1, w * 0.6008, h * 0.2416);
	c.arcTo(w * 0.072, h * 0.0678, 0, 0, 1, w * 0.5437, h * 0.2677);
	c.arcTo(w * 0.1052, h * 0.0939, 0, 0, 1, w * 0.4828, h * 0.2563);
	c.close();
	c.moveTo(w * 0.448, h * 0.2156);
	c.arcTo(w * 0.0111, h * 0.0104, 0, 0, 0, w * 0.459, h * 0.2255);
	c.arcTo(w * 0.0138, h * 0.013, 0, 0, 0, w * 0.4729, h * 0.2182);
	c.lineTo(w * 0.4773, h * 0.1874);
	c.arcTo(w * 0.0664, h * 0.0626, 0, 0, 0, w * 0.5116, h * 0.1759);
	c.arcTo(w * 0.0277, h * 0.0626, 0, 0, 0, w * 0.5233, h * 0.1503);
	c.arcTo(w * 0.0554, h * 0.0261, 0, 0, 0, w * 0.5022, h * 0.1336);
	c.arcTo(w * 0.0886, h * 0.0835, 0, 0, 0, w * 0.4607, h * 0.1305);
	c.arcTo(w * 0.0664, h * 0.0626, 0, 0, 0, w * 0.4313, h * 0.142);
	c.arcTo(w * 0.0332, h * 0.0313, 0, 0, 0, w * 0.4175, h * 0.1597);
	c.arcTo(w * 0.0249, h * 0.0235, 0, 0, 0, w * 0.4313, h * 0.1822);
	c.arcTo(w * 0.0443, h * 0.0418, 0, 0, 0, w * 0.4535, h * 0.1884);
	c.close();
	c.moveTo(w * 0.4718, h * 0.1764);
	c.arcTo(w * 0.0443, h * 0.0418, 0, 0, 1, w * 0.4496, h * 0.1754);
	c.arcTo(w * 0.0221, h * 0.0157, 0, 0, 1, w * 0.4369, h * 0.1634);
	c.arcTo(w * 0.0221, h * 0.0183, 0, 0, 1, w * 0.4496, h * 0.1467);
	c.arcTo(w * 0.0609, h * 0.0574, 0, 0, 1, w * 0.4759, h * 0.1414);
	c.arcTo(w * 0.0388, h * 0.0365, 0, 0, 1, w * 0.5033, h * 0.1514);
	c.arcTo(w * 0.0443, h * 0.0209, 0, 0, 1, w * 0.495, h * 0.1701);
	c.arcTo(w * 0.0388, h * 0.0365, 0, 0, 1, w * 0.4718, h * 0.1764);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7281);
	c.lineTo(w * 0.1667, h * 0.5444);
	c.lineTo(w * 0.1667, h * 0.1832);
	c.lineTo(w * 0.5011, 0);
	c.lineTo(w * 0.8333, h * 0.1832);
	c.lineTo(w * 0.8333, h * 0.5446);
	c.lineTo(w, h * 0.7281);
	c.lineTo(w * 0.7486, h * 0.7735);
	c.lineTo(w * 0.5819, h * 0.8617);
	c.lineTo(w * 0.5011, h);
	c.lineTo(w * 0.4169, h * 0.8653);
	c.lineTo(w * 0.2475, h * 0.7704);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dSearchEngine.prototype.cst.SEARCH_ENGINE, mxShapeAws3dSearchEngine);

//**********************************************************************************************************************************************************
//Security Token Service
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dSecurityTokenService(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dSecurityTokenService, mxShape);

mxShapeAws3dSecurityTokenService.prototype.cst = {
		SECURITY_TOKEN_SERVICE : 'mxgraph.aws3d.securityTokenService',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dSecurityTokenService.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 180;
	var strokeWidth2 = strokeWidth * h / 192;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dSecurityTokenService.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.7281);
	c.lineTo(w * 0.1667, h * 0.5444);
	c.lineTo(w * 0.1667, h * 0.1832);
	c.lineTo(w * 0.5011, 0);
	c.lineTo(w * 0.8333, h * 0.1832);
	c.lineTo(w * 0.8333, h * 0.5446);
	c.lineTo(w, h * 0.7281);
	c.lineTo(w * 0.7486, h * 0.7735);
	c.lineTo(w * 0.5819, h * 0.8617);
	c.lineTo(w * 0.5011, h);
	c.lineTo(w * 0.4169, h * 0.8653);
	c.lineTo(w * 0.2475, h * 0.7704);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dSecurityTokenService.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dSecurityTokenService.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(w * 0.1672, h * 0.1837);
	c.lineTo(w * 0.4989, h * 0.3638);
	c.lineTo(w * 0.4989, h * 0.7291);
	c.lineTo(w * 0.5825, h * 0.8633);
	c.lineTo(w * 0.4989, h);
	c.lineTo(w * 0.4164, h * 0.8622);
	c.lineTo(w * 0.2458, h * 0.7719);
	c.lineTo(0, h * 0.7276);
	c.lineTo(w * 0.1661, h * 0.5454);
	c.close();
	c.moveTo(w * 0.7486, h * 0.7714);
	c.lineTo(w * 0.8317, h * 0.5459);
	c.lineTo(w, h * 0.727);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.4989, h * 0.3643);
	c.lineTo(w * 0.8317, h * 0.1827);
	c.lineTo(w * 0.8317, h * 0.5465);
	c.lineTo(w * 0.7508, h * 0.7714);
	c.lineTo(w * 0.5836, h * 0.8633);
	c.lineTo(w * 0.4989, h * 0.727);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(w * 0.1672, h * 0.1837);
	c.lineTo(w * 0.4989, h * 0.3638);
	c.lineTo(w * 0.4989, h * 0.7291);
	c.lineTo(w * 0.5825, h * 0.8633);
	c.lineTo(w * 0.4989, h);
	c.lineTo(w * 0.4164, h * 0.8622);
	c.lineTo(w * 0.2458, h * 0.7719);
	c.lineTo(0, h * 0.7276);
	c.lineTo(w * 0.1661, h * 0.5454);
	c.close();
	c.moveTo(w * 0.7486, h * 0.7714);
	c.lineTo(w * 0.8317, h * 0.5459);
	c.lineTo(w, h * 0.727);
	c.close();
	c.moveTo(w * 0.4989, h * 0.3643);
	c.lineTo(w * 0.8317, h * 0.1827);
	c.lineTo(w * 0.8317, h * 0.5465);
	c.lineTo(w * 0.7508, h * 0.7714);
	c.lineTo(w * 0.5836, h * 0.8633);
	c.lineTo(w * 0.4989, h * 0.727);
	c.close();
	c.moveTo(w * 0.1667, h * 0.5459);
	c.lineTo(w * 0.2486, h * 0.7704);
	c.moveTo(w * 0.4164, h * 0.8633);
	c.lineTo(w * 0.4989, h * 0.727);
	c.lineTo(w * 0.4989, h);
	c.stroke();

	c.restore();
	c.setShadow(false);
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	
	c.begin();
	c.moveTo(w * 0.4773, h * 0.1915);
	c.arcTo(w * 0.1274, h * 0.12, 0, 0, 1, w * 0.4358, h * 0.1968);
	c.arcTo(w * 0.1107, h * 0.1044, 0, 0, 1, w * 0.3937, h * 0.1905);
	c.arcTo(w * 0.0554, h * 0.0522, 0, 0, 1, w * 0.3682, h * 0.1707);
	c.arcTo(w * 0.0332, h * 0.0313, 0, 0, 1, w * 0.3699, h * 0.1414);
	c.arcTo(w * 0.0775, h * 0.0731, 0, 0, 1, w * 0.4009, h * 0.118);
	c.arcTo(w * 0.1107, h * 0.1044, 0, 0, 1, w * 0.4524, h * 0.1059);
	c.arcTo(w * 0.1107, h * 0.1044, 0, 0, 1, w * 0.5028, h * 0.1112);
	c.arcTo(w * 0.0664, h * 0.0626, 0, 0, 1, w * 0.531, h * 0.1315);
	c.arcTo(w * 0.0332, h * 0.0313, 0, 0, 1, w * 0.531, h * 0.1597);
	c.lineTo(w * 0.5615, h * 0.1754);
	c.lineTo(w * 0.5526, h * 0.1905);
	c.lineTo(w * 0.5759, h * 0.1999);
	c.lineTo(w * 0.5753, h * 0.2109);
	c.lineTo(w * 0.5792, h * 0.2161);
	c.lineTo(w * 0.6135, h * 0.2182);
	c.lineTo(w * 0.6113, h * 0.2416);
	c.lineTo(w * 0.5819, h * 0.2474);
	c.close();

	c.moveTo(w * 0.4756, h * 0.1816);
	c.arcTo(w * 0.0554, h * 0.0522, 0, 0, 0, w * 0.5, h * 0.1691);
	c.arcTo(w * 0.0332, h * 0.0313, 0, 0, 0, w * 0.5144, h * 0.1435);
	c.arcTo(w * 0.0277, h * 0.0261, 0, 0, 0, w * 0.4967, h * 0.1247);
	c.arcTo(w * 0.0554, h * 0.0522, 0, 0, 0, w * 0.4729, h * 0.1174);
	c.arcTo(w * 0.1107, h * 0.1044, 0, 0, 0, w * 0.4452, h * 0.1169);
	c.arcTo(w * 0.0831, h * 0.0783, 0, 0, 0, w * 0.4197, h * 0.1232);
	c.arcTo(w * 0.0554, h * 0.0522, 0, 0, 0, w * 0.397, h * 0.1357);
	c.arcTo(w * 0.0388, h * 0.0365, 0, 0, 0, w * 0.3859, h * 0.1555);
	c.arcTo(w * 0.0305, h * 0.0287, 0, 0, 0, w * 0.4053, h * 0.178);
	c.arcTo(w * 0.072, h * 0.0678, 0, 0, 0, w * 0.4385, h * 0.1863);
	c.arcTo(w * 0.0831, h * 0.0783, 0, 0, 0, w * 0.4596, h * 0.1848);
	c.arcTo(w * 0.0664, h * 0.0626, 0, 0, 0, w * 0.4756, h * 0.1816);
	c.fill();

	c.setStrokeWidth(1.5 * strokeWidth);
	c.setLineJoin('round');
	c.setLineCap('round');
	c.begin();
	c.moveTo(w * 0.4939, h * 0.1326);
	c.lineTo(w * 0.4474, h * 0.1508);
	c.lineTo(w * 0.4812, h * 0.1576);
	c.moveTo(w * 0.4889, h * 0.1733);
	c.lineTo(w * 0.4939, h * 0.1775);
	c.moveTo(w * 0.5061, h * 0.1576);
	c.lineTo(w * 0.5199, h * 0.1597);
	c.moveTo(w * 0.5094, h * 0.1394);
	c.lineTo(w * 0.5244, h * 0.1378);
	c.moveTo(w * 0.4945, h * 0.1247);
	c.lineTo(w * 0.4994, h * 0.1185);
	c.moveTo(w * 0.4679, h * 0.1175);
	c.lineTo(w * 0.4707, h * 0.1117);
	c.moveTo(w * 0.4396, h * 0.1195);
	c.lineTo(w * 0.4374, h * 0.1138);
	c.moveTo(w * 0.412, h * 0.1284);
	c.lineTo(w * 0.4059, h * 0.1232);
	c.moveTo(w * 0.3948, h * 0.1441);
	c.lineTo(w * 0.3804, h * 0.1425);
	c.moveTo(w * 0.3931, h * 0.1608);
	c.lineTo(w * 0.3804, h * 0.1649);
	c.moveTo(w * 0.4059, h * 0.1754);
	c.lineTo(w * 0.3998, h * 0.1801);
	c.moveTo(w * 0.4308, h * 0.1822);
	c.lineTo(w * 0.4286, h * 0.1884);
	c.moveTo(w * 0.4618, h * 0.1827);
	c.lineTo(w * 0.4635, h * 0.1868);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');

	c.begin();
	c.moveTo(0, h * 0.7281);
	c.lineTo(w * 0.1667, h * 0.5444);
	c.lineTo(w * 0.1667, h * 0.1832);
	c.lineTo(w * 0.5011, 0);
	c.lineTo(w * 0.8333, h * 0.1832);
	c.lineTo(w * 0.8333, h * 0.5446);
	c.lineTo(w, h * 0.7281);
	c.lineTo(w * 0.7486, h * 0.7735);
	c.lineTo(w * 0.5819, h * 0.8617);
	c.lineTo(w * 0.5011, h);
	c.lineTo(w * 0.4169, h * 0.8653);
	c.lineTo(w * 0.2475, h * 0.7704);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dSecurityTokenService.prototype.cst.SECURITY_TOKEN_SERVICE, mxShapeAws3dSecurityTokenService);

//**********************************************************************************************************************************************************
//Glacier
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dGlacier(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dGlacier, mxShape);

mxShapeAws3dGlacier.prototype.cst = {
		GLACIER : 'mxgraph.aws3d.glacier',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dGlacier.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 180;
	var strokeWidth2 = strokeWidth * h / 192;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dGlacier.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.8177);
	c.lineTo(0, h * 0.5448);
	c.lineTo(w * 0.168, h * 0.1792);
	c.lineTo(w * 0.5008, 0);
	c.lineTo(w * 0.8309, h * 0.1812);
	c.lineTo(w, h * 0.5469);
	c.lineTo(w, h * 0.8188);
	c.lineTo(w * 0.6661, h);
	c.lineTo(w * 0.3333, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dGlacier.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dGlacier.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(w * 0.1658, h * 0.1802);
	c.lineTo(w * 0.5008, h * 0.3651);
	c.lineTo(w * 0.6661, h * 0.9089);
	c.lineTo(w * 0.6661, h);
	c.lineTo(w * 0.3339, h);
	c.lineTo(0, h * 0.8177);
	c.lineTo(0, h * 0.5427);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.5008, h * 0.362);
	c.lineTo(w * 0.8314, h * 0.1823);
	c.lineTo(w, h * 0.5469);
	c.lineTo(w, h * 0.8177);
	c.lineTo(w * 0.6661, h);
	c.lineTo(w * 0.6661, h * 0.9089);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(w * 0.1658, h * 0.1802);
	c.lineTo(w * 0.5008, h * 0.3651);
	c.lineTo(w * 0.6661, h * 0.9089);
	c.lineTo(w * 0.6661, h);
	c.lineTo(w * 0.3339, h);
	c.lineTo(0, h * 0.8177);
	c.lineTo(0, h * 0.5427);
	c.close();
	c.moveTo(w * 0.5008, h * 0.362);
	c.lineTo(w * 0.8314, h * 0.1823);
	c.lineTo(w, h * 0.5469);
	c.lineTo(w, h * 0.8177);
	c.lineTo(w * 0.6661, h);
	c.lineTo(w * 0.6661, h * 0.9089);
	c.close();
	c.moveTo(w * 0.1675, h * 0.1797);
	c.lineTo(0, h * 0.7281);
	c.lineTo(w * 0.3284, h * 0.9089);
	c.lineTo(w * 0.6661, h * 0.9089);
	c.lineTo(w, h * 0.7266);
	c.lineTo(w * 0.8309, h * 0.1823);
	c.moveTo(w * 0.5003, h * 0.362);
	c.lineTo(w * 0.3311, h * 0.9089);
	c.lineTo(w * 0.3311, h);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');

	c.begin();
	c.moveTo(0, h * 0.8177);
	c.lineTo(0, h * 0.5448);
	c.lineTo(w * 0.168, h * 0.1792);
	c.lineTo(w * 0.5008, 0);
	c.lineTo(w * 0.8309, h * 0.1812);
	c.lineTo(w, h * 0.5469);
	c.lineTo(w, h * 0.8188);
	c.lineTo(w * 0.6661, h);
	c.lineTo(w * 0.3333, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dGlacier.prototype.cst.GLACIER, mxShapeAws3dGlacier);

//**********************************************************************************************************************************************************
//Customer Gateway
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dCustomerGateway(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dCustomerGateway, mxShape);

mxShapeAws3dCustomerGateway.prototype.cst = {
		CUSTOMER_GATEWAY : 'mxgraph.aws3d.customerGateway',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dCustomerGateway.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 116.7;
	var strokeWidth2 = strokeWidth * h / 102.8;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dCustomerGateway.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.save();
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(w * 0.4199, h * 0.5447);
	c.lineTo(w * 0.4199, h * 0.035);
	c.lineTo(w * 0.8946, 0);
	c.lineTo(w, h * 0.0691);
	c.lineTo(w, h * 0.4134);
	c.lineTo(w * 0.6812, h * 0.7247);
	c.close();
	c.fillAndStroke();

	c.restore();
	c.save();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dCustomerGateway.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	c.begin();
	c.moveTo(w * 0.4199, h * 0.5447);
	c.lineTo(w * 0.4199, h * 0.035);
	c.lineTo(w * 0.6838, h * 0.2072);
	c.lineTo(w * 0.6838, h * 0.7247);
	c.close();
	c.fill();
	
	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.6838, h * 0.2072);
	c.lineTo(w, h * 0.0691);
	c.lineTo(w, h * 0.4134);
	c.lineTo(w * 0.6838, h * 0.7247);
	c.close();
	c.fill();

	c.restore();
	c.setShadow(false);
	c.begin();
	c.moveTo(w * 0.4199, h * 0.5447);
	c.lineTo(w * 0.4199, h * 0.035);
	c.lineTo(w * 0.6838, h * 0.2072);
	c.lineTo(w * 0.6838, h * 0.7247);
	c.close();
	c.stroke();

	c.restore();
	c.setLineJoin('round');
	c.setShadow(false);

	c.begin();
	c.moveTo(w * 0.6838, h * 0.2072);
	c.lineTo(w, h * 0.0691);
	c.lineTo(w, h * 0.4134);
	c.lineTo(w * 0.6838, h * 0.7247);
	c.close();
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	
	c.begin();
	c.moveTo(w * 0.4199, h * 0.5447);
	c.lineTo(w * 0.4199, h * 0.035);
	c.lineTo(w * 0.8946, 0);
	c.lineTo(w, h * 0.0691);
	c.lineTo(w, h * 0.4134);
	c.lineTo(w * 0.6812, h * 0.7247);
	c.close();
	c.stroke();

	c.restore();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.929);
	c.lineTo(0, h * 0.5866);
	c.lineTo(w * 0.3171, h * 0.1031);
	c.lineTo(w * 0.5784, h * 0.2753);
	c.lineTo(w * 0.5784, h * 0.7928);
	c.lineTo(w * 0.1054, h);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dCustomerGateway.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setShadow(false);
	c.setLineJoin('round');
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dCustomerGateway.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.929);
	c.lineTo(0, h * 0.5866);
	c.lineTo(w * 0.1054, h * 0.6537);
	c.lineTo(w * 0.1054, h);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.1054, h);
	c.lineTo(w * 0.1054, h * 0.6537);
	c.lineTo(w * 0.5784, h * 0.2753);
	c.lineTo(w * 0.5784, h * 0.7928);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.929);
	c.lineTo(0, h * 0.5866);
	c.lineTo(w * 0.1054, h * 0.6537);
	c.lineTo(w * 0.1054, h);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w * 0.1054, h);
	c.lineTo(w * 0.1054, h * 0.6537);
	c.lineTo(w * 0.5784, h * 0.2753);
	c.lineTo(w * 0.5784, h * 0.7928);
	c.close();
	c.stroke();
	
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.929);
	c.lineTo(0, h * 0.5866);
	c.lineTo(w * 0.3171, h * 0.1031);
	c.lineTo(w * 0.5784, h * 0.2753);
	c.lineTo(w * 0.5784, h * 0.7928);
	c.lineTo(w * 0.1054, h);
	c.close();
	c.stroke();
	
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.7575, h * 0.3969);
	c.arcTo(w * 0.2142, h * 0.2432, 0, 0, 1, w * 0.7686, h * 0.3259);
	c.arcTo(w * 0.2142, h * 0.2432, 0, 0, 1, w * 0.8055, h * 0.2481);
	c.arcTo(w * 0.2142, h * 0.2432, 0, 0, 1, w * 0.8406, h * 0.2091);
	c.lineTo(w * 0.8269, h * 0.2665);
	c.lineTo(w * 0.8372, h * 0.2607);
	c.lineTo(w * 0.8372, h * 0.3444);
	c.lineTo(w * 0.7832, h * 0.3804);
	c.lineTo(w * 0.7832, h * 0.3658);
	c.close();
	c.moveTo(w * 0.8466, h * 0.2082);
	c.arcTo(w * 0.0514, h * 0.0584, 0, 0, 1, w * 0.8766, h * 0.1955);
	c.arcTo(w * 0.0514, h * 0.0584, 0, 0, 1, w * 0.9186, h * 0.2286);
	c.arcTo(w * 0.12, h * 0.1362, 0, 0, 1, w * 0.9297, h * 0.2821);
	c.lineTo(w * 0.9006, h * 0.2831);
	c.lineTo(w * 0.9006, h * 0.3016);
	c.lineTo(w * 0.85, h * 0.3366);
	c.lineTo(w * 0.85, h * 0.251);
	c.lineTo(w * 0.8586, h * 0.2471);
	c.close();
	c.moveTo(w * 0.9297, h * 0.2967);
	c.arcTo(w * 0.2142, h * 0.2432, 0, 0, 1, w * 0.9195, h * 0.3667);
	c.arcTo(w * 0.2571, h * 0.2918, 0, 0, 1, w * 0.8869, h * 0.4436);
	c.arcTo(w * 0.1714, h * 0.1946, 0, 0, 1, w * 0.8466, h * 0.4903);
	c.lineTo(w * 0.8595, h * 0.4358);
	c.lineTo(w * 0.8492, h * 0.4416);
	c.lineTo(w * 0.8492, h * 0.357);
	c.lineTo(w * 0.9006, h * 0.32004);
	c.lineTo(w * 0.9006, h * 0.3346);
	c.close();
	c.moveTo(w * 0.838, h * 0.4942);
	c.arcTo(w * 0.0857, h * 0.0973, 0, 0, 1, w * 0.8072, h * 0.5049);
	c.arcTo(w * 0.0514, h * 0.0584, 0, 0, 1, w * 0.7712, h * 0.4815);
	c.arcTo(w * 0.1714, h * 0.1946, 0, 0, 1, w * 0.7566, h * 0.4163);
	c.lineTo(w * 0.7832, h * 0.4173);
	c.lineTo(w * 0.7832, h * 0.4008);
	c.lineTo(w * 0.8372, h * 0.3638);
	c.lineTo(w * 0.8372, h * 0.4494);
	c.lineTo(w * 0.8278, h * 0.4562);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeAws3dCustomerGateway.prototype.cst.CUSTOMER_GATEWAY, mxShapeAws3dCustomerGateway);

//**********************************************************************************************************************************************************
//Redshift
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dRedshift(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dRedshift, mxShape);

mxShapeAws3dRedshift.prototype.cst = {
		REDSHIFT : 'mxgraph.aws3d.redshift',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dRedshift.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 149.5;
	var strokeWidth2 = strokeWidth * h / 187.5;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dRedshift.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.6517);
	c.lineTo(0, h * 0.0912);
	c.lineTo(w * 0.0368, h * 0.0155);
	c.lineTo(w * 0.2047, 0);
	c.lineTo(w * 0.3378, h * 0.0619);
	c.lineTo(w * 0.3378, h * 0.0912);
	c.lineTo(w * 0.3819, h * 0.0693);
	c.lineTo(w * 0.6154, h * 0.0693);
	c.lineTo(w * 0.8502, h * 0.1776);
	c.lineTo(w * 0.8502, h * 0.3083);
	c.lineTo(w * 0.8682, h * 0.3061);
	c.lineTo(w, h * 0.3664);
	c.lineTo(w, h * 0.9099);
	c.lineTo(w * 0.9672, h * 0.9861);
	c.lineTo(w * 0.7926, h);
	c.lineTo(w * 0.6629, h * 0.9392);
	c.lineTo(w * 0.6629, h * 0.9099);
	c.lineTo(w * 0.6167, h * 0.9317);
	c.lineTo(w * 0.3813, h * 0.9317);
	c.lineTo(w * 0.1478, h * 0.8219);
	c.lineTo(w * 0.1478, h * 0.7093);
	c.lineTo(w * 0.1365, h * 0.7163);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dRedshift.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dRedshift.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.6541);
	c.lineTo(0, h * 0.0933);
	c.lineTo(w * 0.1371, h * 0.1573);
	c.lineTo(w * 0.1371, h * 0.7157);
	c.close();
	c.moveTo(w * 0.1485, h * 0.8219);
	c.lineTo(w * 0.1485, h * 0.2864);
	c.lineTo(w * 0.3846, h * 0.3941);
	c.lineTo(w * 0.3846, h * 0.9317);
	c.close();
	c.moveTo(w * 0.6642, h * 0.9392);
	c.lineTo(w * 0.6642, h * 0.4011);
	c.lineTo(w * 0.796, h * 0.4597);
	c.lineTo(w * 0.796, h);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.1371, h * 0.7157);
	c.lineTo(w * 0.1371, h * 0.1568);
	c.lineTo(w * 0.2027, h * 0.1525);
	c.lineTo(w * 0.1498, h * 0.1771);
	c.lineTo(w * 0.1498, h * 0.7061);
	c.close();
	c.moveTo(w * 0.3846, h * 0.3941);
	c.lineTo(w * 0.614, h * 0.3941);
	c.lineTo(w * 0.6809, h * 0.3632);
	c.lineTo(w * 0.6642, h * 0.4);
	c.lineTo(w * 0.6642, h * 0.9067);
	c.lineTo(w * 0.6191, h * 0.9317);
	c.lineTo(w * 0.3833, h * 0.9317);
	c.close();
	c.moveTo(w * 0.796, h * 0.4608);
	c.lineTo(w * 0.9639, h * 0.4469);
	c.lineTo(w, h * 0.3691);
	c.lineTo(w, h * 0.9077);
	c.lineTo(w * 0.9686, h * 0.9856);
	c.lineTo(w * 0.796, h);
	c.close();
	c.moveTo(w * 0.3378, h * 0.0608);
	c.lineTo(w * 0.3378, h * 0.0907);
	c.lineTo(w * 0.3197, h * 0.1008);
	c.close();
	c.moveTo(w * 0.8502, h * 0.2843);
	c.lineTo(w * 0.8502, h * 0.3083);
	c.lineTo(w * 0.794, h * 0.3136);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.6541);
	c.lineTo(0, h * 0.0933);
	c.lineTo(w * 0.1371, h * 0.1573);
	c.lineTo(w * 0.1371, h * 0.7157);
	c.close();
	c.moveTo(w * 0.1485, h * 0.8219);
	c.lineTo(w * 0.1485, h * 0.2864);
	c.lineTo(w * 0.3846, h * 0.3941);
	c.lineTo(w * 0.3846, h * 0.9317);
	c.close();
	c.moveTo(w * 0.6642, h * 0.9392);
	c.lineTo(w * 0.6642, h * 0.4011);
	c.lineTo(w * 0.796, h * 0.4597);
	c.lineTo(w * 0.796, h);
	c.close();
	c.moveTo(w * 0.1371, h * 0.7157);
	c.lineTo(w * 0.1371, h * 0.1568);
	c.lineTo(w * 0.2027, h * 0.1525);
	c.lineTo(w * 0.1498, h * 0.1771);
	c.lineTo(w * 0.1498, h * 0.7061);
	c.close();
	c.moveTo(w * 0.3846, h * 0.3941);
	c.lineTo(w * 0.614, h * 0.3941);
	c.lineTo(w * 0.6809, h * 0.3632);
	c.lineTo(w * 0.6642, h * 0.4);
	c.lineTo(w * 0.6642, h * 0.9067);
	c.lineTo(w * 0.6191, h * 0.9317);
	c.lineTo(w * 0.3833, h * 0.9317);
	c.close();
	c.moveTo(w * 0.796, h * 0.4608);
	c.lineTo(w * 0.9639, h * 0.4469);
	c.lineTo(w, h * 0.3691);
	c.lineTo(w, h * 0.9077);
	c.lineTo(w * 0.9686, h * 0.9856);
	c.lineTo(w * 0.796, h);
	c.close();
	c.moveTo(w * 0.3378, h * 0.0608);
	c.lineTo(w * 0.3378, h * 0.0907);
	c.lineTo(w * 0.3197, h * 0.1008);
	c.close();
	c.moveTo(w * 0.8502, h * 0.2843);
	c.lineTo(w * 0.8502, h * 0.3083);
	c.lineTo(w * 0.794, h * 0.3136);
	c.close();
	c.moveTo(w * 0.6167, h * 0.3941);
	c.lineTo(w * 0.6167, h * 0.9317);
	c.moveTo(w * 0.9652, h * 0.4448);
	c.lineTo(w * 0.9652, h * 0.9851);
	c.stroke();

	c.restore();
	c.setShadow(false);
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);
	
	c.begin();
	c.moveTo(w * 0.4903, h * 0.1259);
	c.arcTo(w * 0.01, h * 0.008, 0, 0, 1, w * 0.5023, h * 0.1189);
	c.arcTo(w * 0.2007, h * 0.16, 0, 0, 1, w * 0.5639, h * 0.1333);
	c.arcTo(w * 0.602, h * 0.48, 0, 0, 1, w * 0.7157, h * 0.2005);
	c.arcTo(w * 0.2006, h * 0.16, 0, 0, 1, w * 0.7565, h * 0.2315);
	c.arcTo(w * 0.01, h * 0.008, 0, 0, 1, w * 0.7445, h * 0.2421);
	c.arcTo(w * 0.2676, h * 0.2133, 0, 0, 1, w * 0.6742, h * 0.2251);
	c.arcTo(w * 0.602, h * 0.48, 0, 0, 1, w * 0.5204, h * 0.1541);
	c.arcTo(w * 0.1338, h * 0.1067, 0, 0, 1, w * 0.4903, h * 0.1259);
	c.close();
	c.moveTo(w * 0.4789, h * 0.1275);
	c.arcTo(w * 0.0334, h * 0.0267, 0, 0, 0, w * 0.487, h * 0.1461);
	c.arcTo(w * 0.1672, h * 0.1333, 0, 0, 0, w * 0.5237, h * 0.1728);
	c.arcTo(w * 0.6689, h * 0.5333, 0, 0, 0, w * 0.6609, h * 0.2352);
	c.arcTo(w * 0.2676, h * 0.2133, 0, 0, 0, w * 0.7244, h * 0.2501);
	c.arcTo(w * 0.0201, h * 0.016, 0, 0, 0, w * 0.7411, h * 0.2475);
	c.lineTo(w * 0.5385, h * 0.3408);
	c.arcTo(w * 0.0669, h * 0.05333, 0, 0, 1, w * 0.512, h * 0.3397);
	c.arcTo(w * 0.2676, h * 0.2133, 0, 0, 1, w * 0.4548, h * 0.3248);
	c.arcTo(w * 0.6689, h * 0.5333, 0, 0, 1, w * 0.3084, h * 0.2565);
	c.arcTo(w * 0.1672, h * 0.1333, 0, 0, 1, w * 0.2776, h * 0.2304);
	c.arcTo(w * 0.01, h * 0.008, 0, 0, 1, w * 0.2776, h * 0.2197);
	c.close();
	c.fill();

	var fillColor = mxUtils.getValue(this.state.style, 'fillColor', '#ffffff');
	c.setFillColor(fillColor);
	c.setLineJoin('round');
	c.setLineCap('round');
	c.begin();
	c.moveTo(w * 0.3398, h * 0.2421);
	c.lineTo(w * 0.4769, h * 0.1797);
	c.lineTo(w * 0.6341, h * 0.2512);
	c.lineTo(w * 0.4936, h * 0.3147);
	c.fill();

	c.begin();
	c.moveTo(w * 0.4334, h * 0.1941);
	c.lineTo(w * 0.6207, h * 0.2811);
	c.moveTo(w * 0.5338, h * 0.1995);
	c.lineTo(w * 0.3866, h * 0.2688);
	c.moveTo(w * 0.5873, h * 0.2235);
	c.lineTo(w * 0.4334, h * 0.2955);
	c.stroke();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');

	c.begin();
	c.moveTo(0, h * 0.6517);
	c.lineTo(0, h * 0.0912);
	c.lineTo(w * 0.0368, h * 0.0155);
	c.lineTo(w * 0.2047, 0);
	c.lineTo(w * 0.3378, h * 0.0619);
	c.lineTo(w * 0.3378, h * 0.0912);
	c.lineTo(w * 0.3819, h * 0.0693);
	c.lineTo(w * 0.6154, h * 0.0693);
	c.lineTo(w * 0.8502, h * 0.1776);
	c.lineTo(w * 0.8502, h * 0.3083);
	c.lineTo(w * 0.8682, h * 0.3061);
	c.lineTo(w, h * 0.3664);
	c.lineTo(w, h * 0.9099);
	c.lineTo(w * 0.9672, h * 0.9861);
	c.lineTo(w * 0.7926, h);
	c.lineTo(w * 0.6629, h * 0.9392);
	c.lineTo(w * 0.6629, h * 0.9099);
	c.lineTo(w * 0.6167, h * 0.9317);
	c.lineTo(w * 0.3813, h * 0.9317);
	c.lineTo(w * 0.1478, h * 0.8219);
	c.lineTo(w * 0.1478, h * 0.7093);
	c.lineTo(w * 0.1365, h * 0.7163);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dRedshift.prototype.cst.REDSHIFT, mxShapeAws3dRedshift);

//**********************************************************************************************************************************************************
//Lambda
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dLambda(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dLambda, mxShape);

mxShapeAws3dLambda.prototype.cst = {
		LAMBDA : 'mxgraph.aws3d.lambda',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dLambda.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 92;
	var strokeWidth2 = strokeWidth * h / 109.5;
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);

	this.background(c, 0, 0, w, h, strokeWidth);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h, strokeWidth);
};

mxShapeAws3dLambda.prototype.background = function(c, x, y, w, h, strokeWidth)
{
	c.setStrokeWidth(strokeWidth);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.1671);
	c.lineTo(w * 0.3424, 0);
	c.lineTo(w * 0.663, 0);
	c.lineTo(w, h * 0.1671);
	c.lineTo(w, h * 0.8365);
	c.lineTo(w * 0.663, h);
	c.lineTo(w * 0.3424, h);
	c.lineTo(0, h * 0.8365);
	c.close();
	c.fillAndStroke();
};

mxShapeAws3dLambda.prototype.foreground = function(c, x, y, w, h, strokeWidth)
{
	c.restore();
	c.setShadow(false);
	c.setFillColor('#000000');
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dLambda.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(0, h * 0.3242);
	c.lineTo(w * 0.3424, h * 0.4895);
	c.lineTo(w * 0.663, h * 0.4895);
	c.lineTo(w * 0.663, h);
	c.lineTo(w * 0.3424, h);
	c.lineTo(0, h * 0.8365);
	c.close();
	c.moveTo(w * 0., h * 0.);
	c.lineTo(w * 0., h * 0.);
	c.lineTo(w * 0., h * 0.);
	c.lineTo(w * 0., h * 0.);
	c.lineTo(w * 0., h * 0.);
	c.lineTo(w * 0., h * 0.);
	c.close();
	c.moveTo(w * 0., h * 0.);
	c.lineTo(w * 0., h * 0.);
	c.lineTo(w * 0., h * 0.);
	c.lineTo(w * 0., h * 0.);
	c.lineTo(w * 0., h * 0.);
	c.lineTo(w * 0., h * 0.);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.663, h * 0.4895);
	c.lineTo(w, h * 0.3242);
	c.lineTo(w, h * 0.8365);
	c.lineTo(w * 0.663, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h * 0.3242);
	c.lineTo(w * 0.3424, h * 0.4895);
	c.lineTo(w * 0.663, h * 0.4895);
	c.lineTo(w, h * 0.3242);
	c.moveTo(w * 0.3424, h * 0.4895);
	c.lineTo(w * 0.3424, h);
	c.moveTo(w * 0.663, h * 0.4895);
	c.lineTo(w * 0.663, h);
	c.stroke();

	c.setFillColor("#5E5E5E");
	
	c.begin();
	c.moveTo(w * 0.3804, h * 0.1169);
	c.arcTo(w * 0.5435, h * 0.4566, 0, 0, 1, w * 0.6087, h * 0.1123);
	c.arcTo(w * 0.33804, h * 0.3196, 0, 0, 1, w * 0.725, h * 0.1553);
	c.arcTo(w * 0.1304, h * 0.1096, 0, 0, 1, w * 0.7924, h * 0.2402);
	c.arcTo(w * 0.1522, h * 0.1279, 0, 0, 1, w * 0.725, h * 0.3333);
	c.arcTo(w * 0.4416, h * 0.274, 0, 0, 1, w * 0.6087, h * 0.3772);
	c.arcTo(w * 0.5435, h * 0.4566, 0, 0, 1, w * 0.3804, h * 0.3708);
	c.arcTo(w * 0.3804, h * 0.3196, 0, 0, 1, w * 0.2772, h * 0.3324);
	c.arcTo(w * 0.1522, h * 0.1279, 0, 0, 1, w * 0.2163, h * 0.2539);
	c.arcTo(w * 0.1522, h * 0.1279, 0, 0, 1, w * 0.2663, h * 0.1644);
	c.arcTo(w * 0.3804, h * 0.3196, 0, 0, 1, w * 0.3804, h * 0.1169);
	c.fill();

	c.setFillColor("#ffffff");

	c.begin();
	c.moveTo(w * 0.5565, h * 0.2174);
	c.arcTo(w * 0.0652, h * 0.0548, 0, 0, 0, w * 0.5837, h * 0.1945);
	c.arcTo(w * 0.0326, h * 0.0274, 0, 0, 0, w * 0.5793, h * 0.1671);
	c.arcTo(w * 0.0652, h * 0.0548, 0, 0, 0, w * 0.525, h * 0.1598);
	c.arcTo(w * 0.0652, h * 0.0548, 0, 0, 1, w * 0.5543, h * 0.1443);
	c.arcTo(w * 0.0761, h * 0.0639, 0, 0, 1, w * 0.6163, h * 0.1662);
	c.arcTo(w * 0.0598, h * 0.0502, 0, 0, 1, w * 0.6087, h * 0.2091);
	c.lineTo(w * 0.5, h * 0.3032);
	c.arcTo(w * 0.0978, h * 0.0822, 0, 0, 0, w * 0.4728, h * 0.3379);
	c.arcTo(w * 0.0272, h * 0.0228, 0, 0, 0, w * 0.4924, h * 0.3571);
	c.arcTo(w * 0.0326, h * 0.0274, 0, 0, 1, w * 0.4489, h * 0.3571);
	c.arcTo(w * 0.038, h * 0.032, 0, 0, 1, w * 0.437, h * 0.3242);
	c.arcTo(w * 0.1087, h * 0.0913, 0, 0, 1, w * 0.4674, h * 0.2886);
	c.lineTo(w * 0.5141, h * 0.2557);
	c.lineTo(w * 0.3185, h * 0.2895);
	c.lineTo(w * 0.2641, h * 0.2648);
	c.close();
	c.fill();

	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');

	c.begin();
	c.moveTo(0, h * 0.1671);
	c.lineTo(w * 0.3424, 0);
	c.lineTo(w * 0.663, 0);
	c.lineTo(w, h * 0.1671);
	c.lineTo(w, h * 0.8365);
	c.lineTo(w * 0.663, h);
	c.lineTo(w * 0.3424, h);
	c.lineTo(0, h * 0.8365);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dLambda.prototype.cst.LAMBDA, mxShapeAws3dLambda);

//**********************************************************************************************************************************************************
//EBS 2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws3dEbs2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws3dEbs2, mxShape);

mxShapeAws3dEbs2.prototype.cst = {
		EBS2 : 'mxgraph.aws3d.ebs2',
		SHADING_COLORS : 'shadingCols'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws3dEbs2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
	var strokeWidth1 = strokeWidth * w / 92;
	var strokeWidth2 = strokeWidth * h / 60;
	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
	
	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
	
	c.setStrokeWidth(strokeWidth);
	c.setShadow(false);
	c.save();
	c.save();
	c.setStrokeWidth(2 * strokeWidth);
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	if(isShadow == 1)
	{
		c.setShadow(true);
	}
	
	c.begin();
	c.moveTo(0, h * 0.5276);
	c.lineTo(0, h * 0.4188);
	c.lineTo(w * 0.071, h * 0.2898);
	c.lineTo(w * 0.4033, 0);
	c.lineTo(w * 0.9301, h * 0.464);
	c.lineTo(w, h * 0.5863);
	c.lineTo(w, h * 0.7035);
	c.lineTo(w * 0.6667, h);
	c.lineTo(w * 0.5355, h);
	c.close();
	c.fillAndStroke();
	
	c.restore();
	c.setFillColor('#000000');
	
	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dEbs2.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
	
	c.begin();
	c.moveTo(w * 0.071, h * 0.2948);
	c.lineTo(w * 0.6011, h * 0.7621);
	c.lineTo(w * 0.6667, h);
	c.lineTo(w * 0.5355, h);
	c.lineTo(0, h * 0.5276);
	c.lineTo(0, h * 0.4137);
	c.close();
	c.fill();

	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
	c.begin();
	c.moveTo(w * 0.6011, h * 0.7655);
	c.lineTo(w * 0.9344, h * 0.4724);
	c.lineTo(w, h * 0.7035);
	c.lineTo(w * 0.6667, h);
	c.close();
	c.fill();
	
	c.restore();
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(w * 0.071, h * 0.2948);
	c.lineTo(w * 0.6011, h * 0.7621);
	c.lineTo(w * 0.6667, h);
	c.lineTo(w * 0.5355, h);
	c.lineTo(0, h * 0.5276);
	c.lineTo(0, h * 0.4137);
	c.close();
	c.moveTo(w * 0.6011, h * 0.7655);
	c.lineTo(w * 0.9344, h * 0.4724);
	c.lineTo(w, h * 0.7035);
	c.lineTo(w * 0.6667, h);
	c.close();
	c.moveTo(w * 0.0033, h * 0.5276);
	c.lineTo(w * 0.071, h * 0.2898);
	c.moveTo(w * 0.5325, h * 0.9976);
	c.lineTo(w * 0.603, h * 0.7593);
	c.stroke();

	c.setStrokeWidth(2 * strokeWidth);
	c.setLineCap('round');
	
	c.begin();
	c.moveTo(w * 0.3388, h * 0.3802);
	c.lineTo(w * 0.5027, h * 0.2345);
	c.lineTo(w * 0.6667, h * 0.3802);
	c.lineTo(w * 0.5027, h * 0.526);
	c.close();
	c.moveTo(w * 0.4426, h * 0.3802);
	c.lineTo(w * 0.5027, h * 0.3266);
	c.lineTo(w * 0.5628, h * 0.3802);
	c.lineTo(w * 0.5027, h * 0.4338);
	c.close();
	c.moveTo(w * 0.3867, h * 0.3284);
	c.lineTo(w * 0.3541, h * 0.2998);
	c.moveTo(w * 0.4436, h * 0.2748);
	c.lineTo(w * 0.4077, h * 0.2412);
	c.moveTo(w * 0.5704, h * 0.2803);
	c.lineTo(w * 0.5992, h * 0.2513);
	c.moveTo(w * 0.6231, h * 0.3284);
	c.lineTo(w * 0.6503, h * 0.3032);
	c.moveTo(w * 0.622, h * 0.4338);
	c.lineTo(w * 0.6557, h * 0.4606);
	c.moveTo(w * 0.5667, h * 0.4845);
	c.lineTo(w * 0.5992, h * 0.5156);
	c.moveTo(w * 0.4414, h * 0.4874);
	c.lineTo(w * 0.412, h * 0.5159);
	c.moveTo(w * 0.3889, h * 0.4405);
	c.lineTo(w * 0.3607, h * 0.4657);
	c.stroke();
	
	c.setStrokeColor('#292929');
	c.setLineJoin('round');

	c.begin();
	c.moveTo(0, h * 0.5276);
	c.lineTo(0, h * 0.4188);
	c.lineTo(w * 0.071, h * 0.2898);
	c.lineTo(w * 0.4033, 0);
	c.lineTo(w * 0.9301, h * 0.464);
	c.lineTo(w, h * 0.5863);
	c.lineTo(w, h * 0.7035);
	c.lineTo(w * 0.6667, h);
	c.lineTo(w * 0.5355, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAws3dEbs2.prototype.cst.EBS2, mxShapeAws3dEbs2);

//**********************************************************************************************************************************************************
//Elasticache
//**********************************************************************************************************************************************************
///**
//* Extends mxShape.
//*/
//function mxShapeAws3dElasticache(bounds, fill, stroke, strokewidth)
//{
//	mxShape.call(this);
//	this.bounds = bounds;
//	this.fill = fill;
//	this.stroke = stroke;
//	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
//};
//
///**
//* Extends mxShape.
//*/
//mxUtils.extend(mxShapeAws3dElasticache, mxShape);
//
//mxShapeAws3dElasticache.prototype.cst = {
//		ELASTICACHE : 'mxgraph.aws3d.elasticache',
//		SHADING_COLORS : 'shadingCols'
//};
//
///**
//* Function: paintVertexShape
//* 
//* Paints the vertex shape.
//*/
//mxShapeAws3dElasticache.prototype.paintVertexShape = function(c, x, y, w, h)
//{
//	c.translate(x, y);
//
//	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
//	var strokeWidth1 = strokeWidth * w / 123;
//	var strokeWidth2 = strokeWidth * h / 143;
//	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
//	
//	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
//	
//	c.setStrokeWidth(strokeWidth);
//	c.setShadow(false);
//	c.save();
//	c.save();
//	c.setStrokeWidth(2 * strokeWidth);
//	c.setStrokeColor('#292929');
//	c.setLineJoin('round');
//
//	if(isShadow == 1)
//	{
//		c.setShadow(true);
//	}
//	
//	c.begin();
//	c.moveTo(0, h * 0.7483);
//	c.lineTo(0, h * 0.6294);
//	c.lineTo(w * 0.061, h * 0.5944);
//	c.lineTo(0, h * 0.563);
//	c.lineTo(0, h * 0.4406);
//	c.lineTo(w * 0.061, h * 0.4091);
//	c.lineTo(0, h * 0.3776);
//	c.lineTo(0, h * 0.2517);
//	c.lineTo(w * 0.5041, 0);
//	c.lineTo(w, h * 0.2483);
//	c.lineTo(w, h * 0.3741);
//	c.lineTo(w * 0.939, h * 0.4091);
//	c.lineTo(w, h * 0.4406);
//	c.lineTo(w, h * 0.563);
//	c.lineTo(w * 0.939, h * 0.5944);
//	c.lineTo(w, h * 0.6294);
//	c.lineTo(w, h * 0.751);
//	c.lineTo(w * 0.5041, h);
//	c.close();
//	c.fillAndStroke();
//	
//	c.restore();
//	c.setFillColor('#000000');
//	
//	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dElasticache.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
//	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
//	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
//	
//	c.begin();
//	c.moveTo(0, h * 0.2517);
//	c.lineTo(w * 0.5041, h * 0.4965);
//	c.lineTo(w * 0.5041, h * 0.6294);
//	c.lineTo(0, h * 0.3776);
//	c.close();
//	c.moveTo(0, h * 0.4406);
//	c.lineTo(w * 0.5041, h * 0.6853);
//	c.lineTo(w * 0.5041, h * 0.8112);
//	c.lineTo(0, h * 0.5629);
//	c.close();
//	c.moveTo(0, h * 0.6294);
//	c.lineTo(w * 0.5041, h * 0.8741);
//	c.lineTo(w * 0.5041, h);
//	c.lineTo(0, h * 0.7483);
//	c.close();
//	c.moveTo(w * 0.6179, h * 0.2517);
//	c.lineTo(w * 0.752, h * 0.1853);
//	c.lineTo(w * 0.752, h * 0.3217);
//	c.close();
//	c.fill();
//
//	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
//	c.begin();
//	c.moveTo(w * 0.5041, h * 0.4965);
//	c.lineTo(w, h * 0.2517);
//	c.lineTo(w, h * 0.3741);
//	c.lineTo(w * 0.5041, h * 0.6294);
//	c.close();
//	c.moveTo(w * 0.5041, h * 0.6853);
//	c.lineTo(w, h * 0.4406);
//	c.lineTo(w, h * 0.5629);
//	c.lineTo(w * 0.5041, h * 0.8112);
//	c.close();
//	c.moveTo(w * 0.5041, h * 0.8741);
//	c.lineTo(w, h * 0.6294);
//	c.lineTo(w, h * 0.7483);
//	c.lineTo(w * 0.5041, h);
//	c.close();
//	c.moveTo(w * 0.752, h * 0.1853);
//	c.lineTo(w * 0.8821, h * 0.2517);
//	c.lineTo(w * 0.752, h * 0.3217);
//	c.close();
//	c.fill();
//	
//	c.restore();
//	c.setLineJoin('round');
//	
//	c.begin();
//	c.moveTo(0, h * 0.2517);
//	c.lineTo(w * 0.5041, h * 0.4965);
//	c.lineTo(w * 0.5041, h * 0.6294);
//	c.lineTo(0, h * 0.3776);
//	c.close();
//	c.moveTo(0, h * 0.4406);
//	c.lineTo(w * 0.5041, h * 0.6853);
//	c.lineTo(w * 0.5041, h * 0.8112);
//	c.lineTo(0, h * 0.5629);
//	c.close();
//	c.moveTo(0, h * 0.6294);
//	c.lineTo(w * 0.5041, h * 0.8741);
//	c.lineTo(w * 0.5041, h);
//	c.lineTo(0, h * 0.7483);
//	c.close();
//	c.moveTo(w * 0.5041, h * 0.4965);
//	c.lineTo(w, h * 0.2517);
//	c.lineTo(w, h * 0.3741);
//	c.lineTo(w * 0.5041, h * 0.6294);
//	c.close();
//	c.moveTo(w * 0.5041, h * 0.6853);
//	c.lineTo(w, h * 0.4406);
//	c.lineTo(w, h * 0.5629);
//	c.lineTo(w * 0.5041, h * 0.8112);
//	c.close();
//	c.moveTo(w * 0.5041, h * 0.8741);
//	c.lineTo(w, h * 0.6294);
//	c.lineTo(w, h * 0.7483);
//	c.lineTo(w * 0.5041, h);
//	c.close();
//	c.stroke();
//
//	c.setStrokeWidth(2 * strokeWidth);
//	c.setLineCap('round');
//	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
//	c.setFillColor(strokeColor);
//
//	c.begin();
//	c.moveTo(w * 0.222, h * 0.2028);
//	c.arcTo(w * 0.1463, h * 0.1259, 0, 0, 1, w * 0.3154, h * 0.2014);
//	c.arcTo(w * 0.122, h * 0.1049, 0, 0, 1, w * 0.3642, h * 0.2245);
//	c.arcTo(w * 0.0325, h * 0.028, 0, 0, 1, w * 0.3618, h * 0.2552);
//	c.arcTo(w * 0.122, h * 0.1049, 0, 0, 1, w * 0.3252, h * 0.2798);
//	c.arcTo(w * 0.1626, h * 0.1399, 0, 0, 1, w * 0.2276, h * 0.2797);
//	c.arcTo(w * 0.0976, h * 0.0839, 0, 0, 1, w * 0.187, h * 0.2622);
//	c.arcTo(w * 0.0325, h * 0.028, 0, 0, 1, w * 0.187, h * 0.2238);
//	c.arcTo(w * 0.0976, h * 0.0839, 0, 0, 1, w * 0.222, h * 0.2028);
//	c.close();
//	c.moveTo(w * 0.3618, h * 0.1434);
//	c.lineTo(w * 0.4309, h * 0.1189);
//	c.lineTo(w * 0.4309, h * 0.0755);
//	c.lineTo(w * 0.4992, h * 0.1014);
//	c.lineTo(w * 0.5813, h * 0.0874);
//	c.lineTo(w * 0.5488, h * 0.1294);
//	c.lineTo(w * 0.6057, h * 0.1608);
//	c.lineTo(w * 0.5163, h * 0.1608);
//	c.lineTo(w * 0.4634, h * 0.2028);
//	c.lineTo(w * 0.4431, h * 0.1538);
//	c.close();
//	c.moveTo(w * 0.3821, h * 0.3601);
//	c.lineTo(w * 0.5894, h * 0.3322);
//	c.lineTo(w * 0.5325, h * 0.4394);
//	c.close();
//	c.fill();
//	
//	c.setStrokeColor('#292929');
//	c.setLineJoin('round');
//
//	c.begin();
//	c.moveTo(0, h * 0.7483);
//	c.lineTo(0, h * 0.6294);
//	c.lineTo(w * 0.061, h * 0.5944);
//	c.lineTo(0, h * 0.563);
//	c.lineTo(0, h * 0.4406);
//	c.lineTo(w * 0.061, h * 0.4091);
//	c.lineTo(0, h * 0.3776);
//	c.lineTo(0, h * 0.2517);
//	c.lineTo(w * 0.5041, 0);
//	c.lineTo(w, h * 0.2483);
//	c.lineTo(w, h * 0.3741);
//	c.lineTo(w * 0.939, h * 0.4091);
//	c.lineTo(w, h * 0.4406);
//	c.lineTo(w, h * 0.563);
//	c.lineTo(w * 0.939, h * 0.5944);
//	c.lineTo(w, h * 0.6294);
//	c.lineTo(w, h * 0.751);
//	c.lineTo(w * 0.5041, h);
//	c.close();
//	c.stroke();
//};
//
//mxCellRenderer.registerShape(mxShapeAws3dElasticache.prototype.cst.ELASTICACHE, mxShapeAws3dElasticache);

//**********************************************************************************************************************************************************
//Kinesis Stream
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
//function mxShapeAws3dKinesisStream(bounds, fill, stroke, strokewidth)
//{
//	mxShape.call(this);
//	this.bounds = bounds;
//	this.fill = fill;
//	this.stroke = stroke;
//	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
//};
//
///**
//* Extends mxShape.
//*/
//mxUtils.extend(mxShapeAws3dKinesisStream, mxShape);
//
//mxShapeAws3dKinesisStream.prototype.cst = {
//		KINESIS_STREAM : 'mxgraph.aws3d.kinesisStream',
//		SHADING_COLORS : 'shadingCols'
//};
//
///**
//* Function: paintVertexShape
//* 
//* Paints the vertex shape.
//*/
//mxShapeAws3dKinesisStream.prototype.paintVertexShape = function(c, x, y, w, h)
//{
//	c.translate(x, y);
//
//	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
//	var strokeWidth1 = strokeWidth * w / 220;
//	var strokeWidth2 = strokeWidth * h / 160;
//	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
//	
//	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
//	
//	c.setStrokeWidth(strokeWidth);
//	c.setShadow(false);
//	c.save();
//	c.save();
//	c.setStrokeWidth(2 * strokeWidth);
//	c.setStrokeColor('#292929');
//	c.setLineJoin('round');
//
//	if(isShadow == 1)
//	{
//		c.setShadow(true);
//	}
//	
//	c.begin();
//	c.moveTo(0, h * 0.5503);
//	c.lineTo(w * 0.0455, h * 0.4623);
//	c.lineTo(w * 0.6054, h * 0.0157);
//	c.lineTo(w * 0.6623, h * 0.0629);
//	c.lineTo(w * 0.7396, 0);
//	c.lineTo(w * 0.8239, h * 0.0692);
//	c.lineTo(w * 0.8671, h * 0.2233);
//	c.lineTo(w * 0.9513, h * 0.2943);
//	c.lineTo(w, h * 0.4528);
//	c.lineTo(w * 0.9595, h * 0.5365);
//	c.lineTo(w * 0.396, h * 0.9843);
//	c.lineTo(w * 0.3391, h * 0.9403);
//	c.lineTo(w * 0.2617, h);
//	c.lineTo(w * 0.173, h * 0.9308);
//	c.lineTo(w * 0.1297, h * 0.7736);
//	c.lineTo(w * 0.0432, h * 0.7044);
//	c.close();
//	c.fillAndStroke();
//	
//	c.restore();
//	c.setFillColor('#000000');
//	
//	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dKinesisStream.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
//	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
//	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
//	
//	c.begin();
//	c.moveTo(w * 0.0432, h * 0.4654);
//	c.lineTo(w * 0.132, h * 0.5314);
//	c.lineTo(w * 0.1775, h * 0.4465);
//	c.lineTo(w * 0.264, h * 0.5189);
//	c.lineTo(w * 0.3072, h * 0.673);
//	c.lineTo(w * 0.396, h * 0.7453);
//	c.lineTo(w * 0.4392, h * 0.8994);
//	c.lineTo(w * 0.396, h * 0.9843);
//	c.lineTo(w * 0.305, h * 0.9151);
//	c.lineTo(w * 0.2617, h);
//	c.lineTo(w * 0.173, h * 0.9308);
//	c.lineTo(w * 0.1297, h * 0.7736);
//	c.lineTo(w * 0.0432, h * 0.7044);
//	c.lineTo(0, h * 0.5503);
//	c.close();
//	c.fill();
//
//	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
//	c.begin();
//	c.moveTo(w * 0.264, h * 0.5204);
//	c.lineTo(w * 0.8239, h * 0.0676);
//	c.lineTo(w * 0.8694, h * 0.228);
//	c.lineTo(w * 0.3072, h * 0.673);
//	c.close();
//	c.moveTo(w * 0.3937, h * 0.7453);
//	c.lineTo(w * 0.9536, h * 0.2956);
//	c.lineTo(w, h * 0.4528);
//	c.lineTo(w * 0.9558, h * 0.5377);
//	c.lineTo(w * 0.396, h * 0.9843);
//	c.lineTo(w * 0.4392, h * 0.8994);
//	c.close();
//	c.moveTo(w * 0.2617, h);
//	c.lineTo(w * 0.305, h * 0.9151);
//	c.lineTo(w * 0.3368, h * 0.9403);
//	c.close();
//	c.fill();
//	
//	c.setAlpha('0.5');
//	c.begin();
//	c.moveTo(w * 0.0546, h * 0.5094);
//	c.lineTo(w * 0.1161, h * 0.5597);
//	c.lineTo(w * 0.1479, h * 0.6761);
//	c.lineTo(w * 0.1183, h * 0.7264);
//	c.lineTo(w * 0.0569, h * 0.6792);
//	c.lineTo(w * 0.025, h * 0.566);
//	c.close();
//	c.moveTo(w * 0.1889, h * 0.4937);
//	c.lineTo(w * 0.2503, h * 0.544);
//	c.lineTo(w * 0.2822, h * 0.6572);
//	c.lineTo(w * 0.2526, h * 0.717);
//	c.lineTo(w * 0.1934, h * 0.6667);
//	c.lineTo(w * 0.1593, h * 0.5566);
//	c.close();
//	c.moveTo(w * 0.3195, h * 0.7201);
//	c.lineTo(w * 0.3801, h * 0.7704);
//	c.lineTo(w * 0.4137, h * 0.8805);
//	c.lineTo(w * 0.3819, h * 0.9403);
//	c.lineTo(w * 0.3209, h * 0.8912);
//	c.lineTo(w * 0.2904, h * 0.783);
//	c.close();
//	c.moveTo(w * 0.1866, h * 0.7358);
//	c.lineTo(w * 0.2458, h * 0.783);
//	c.lineTo(w * 0.2776, h * 0.8962);
//	c.lineTo(w * 0.2481, h * 0.956);
//	c.lineTo(w * 0.1866, h * 0.9057);
//	c.lineTo(w * 0.157, h * 0.7893);
//	c.close();
//	c.fill();
//
//	c.restore();
//	c.setLineJoin('round');
//	
//	c.begin();
//	c.moveTo(w * 0.0432, h * 0.4654);
//	c.lineTo(w * 0.132, h * 0.5314);
//	c.lineTo(w * 0.1775, h * 0.4465);
//	c.lineTo(w * 0.264, h * 0.5189);
//	c.lineTo(w * 0.3072, h * 0.673);
//	c.lineTo(w * 0.396, h * 0.7453);
//	c.lineTo(w * 0.4392, h * 0.8994);
//	c.lineTo(w * 0.396, h * 0.9843);
//	c.lineTo(w * 0.305, h * 0.9151);
//	c.lineTo(w * 0.2617, h);
//	c.lineTo(w * 0.173, h * 0.9308);
//	c.lineTo(w * 0.1297, h * 0.7736);
//	c.lineTo(w * 0.0432, h * 0.7044);
//	c.lineTo(0, h * 0.5503);
//	c.close();
//	c.moveTo(w * 0.264, h * 0.5204);
//	c.lineTo(w * 0.8239, h * 0.0676);
//	c.lineTo(w * 0.8694, h * 0.228);
//	c.lineTo(w * 0.3072, h * 0.673);
//	c.close();
//	c.moveTo(w * 0.3937, h * 0.7453);
//	c.lineTo(w * 0.9536, h * 0.2956);
//	c.lineTo(w, h * 0.4528);
//	c.lineTo(w * 0.9558, h * 0.5377);
//	c.lineTo(w * 0.396, h * 0.9843);
//	c.lineTo(w * 0.4392, h * 0.8994);
//	c.close();
//	c.moveTo(w * 0.2617, h);
//	c.lineTo(w * 0.305, h * 0.9151);
//	c.lineTo(w * 0.3368, h * 0.9403);
//	c.close();
//	c.moveTo(w * 0.0546, h * 0.5094);
//	c.lineTo(w * 0.1161, h * 0.5597);
//	c.lineTo(w * 0.1479, h * 0.6761);
//	c.lineTo(w * 0.1183, h * 0.7264);
//	c.lineTo(w * 0.0569, h * 0.6792);
//	c.lineTo(w * 0.025, h * 0.566);
//	c.close();
//	c.moveTo(w * 0.1889, h * 0.4937);
//	c.lineTo(w * 0.2503, h * 0.544);
//	c.lineTo(w * 0.2822, h * 0.6572);
//	c.lineTo(w * 0.2526, h * 0.717);
//	c.lineTo(w * 0.1934, h * 0.6667);
//	c.lineTo(w * 0.1593, h * 0.5566);
//	c.close();
//	c.moveTo(w * 0.3195, h * 0.7201);
//	c.lineTo(w * 0.3801, h * 0.7704);
//	c.lineTo(w * 0.4137, h * 0.8805);
//	c.lineTo(w * 0.3819, h * 0.9403);
//	c.lineTo(w * 0.3209, h * 0.8912);
//	c.lineTo(w * 0.2904, h * 0.783);
//	c.close();
//	c.moveTo(w * 0.1866, h * 0.7358);
//	c.lineTo(w * 0.2458, h * 0.783);
//	c.lineTo(w * 0.2776, h * 0.8962);
//	c.lineTo(w * 0.2481, h * 0.956);
//	c.lineTo(w * 0.1866, h * 0.9057);
//	c.lineTo(w * 0.157, h * 0.7893);
//	c.close();
//	c.moveTo(w * 0.1775, h * 0.4465);
//	c.lineTo(w * 0.7374, 0);
//	c.moveTo(w * 0.4392, h * 0.8994);
//	c.lineTo(w, h * 0.4528);
//	c.moveTo(w * 0.1331, h * 0.533);
//	c.lineTo(w * 0.1809, h * 0.6934);
//	c.lineTo(w * 0.2617, h * 0.7626);
//	c.lineTo(w * 0.3061, h * 0.9151);
//	c.moveTo(w * 0.1295, h * 0.7764);
//	c.lineTo(w * 0.1807, h * 0.6928);
//	c.moveTo(w * 0.264, h * 0.7642);
//	c.lineTo(w * 0.3095, h * 0.673);
//	c.moveTo(w * 0.3641, h * 0.2327);
//	c.lineTo(w * 0.3241, h * 0.2673);
//	c.lineTo(w * 0.3619, h * 0.2987);
//	c.moveTo(w * 0.3468, h * 0.2736);
//	c.lineTo(w * 0.3596, h * 0.261);
//	c.moveTo(w * 0.3573, h * 0.283);
//	c.lineTo(w * 0.3823, h * 0.261);
//	c.moveTo(w * 0.4916, h * 0.217);
//	c.lineTo(w * 0.4483, h * 0.2547);
//	c.lineTo(w * 0.5052, h * 0.3019);
//	c.moveTo(w * 0.4679, h * 0.2591);
//	c.lineTo(w * 0.4802, h * 0.2478);
//	c.moveTo(w * 0.4811, h * 0.2673);
//	c.lineTo(w * 0.5098, h * 0.2421);
//	c.moveTo(w * 0.4939, h * 0.2767);
//	c.lineTo(w * 0.5121, h * 0.261);
//	c.moveTo(w * 0.5043, h * 0.2868);
//	c.lineTo(w * 0.5371, h * 0.2579);
//	c.moveTo(w * 0.6259, h * 0.4371);
//	c.lineTo(w * 0.5826, h * 0.4717);
//	c.lineTo(w * 0.6418, h * 0.522);
//	c.moveTo(w * 0.6039, h * 0.4755);
//	c.lineTo(w * 0.6187, h * 0.463);
//	c.moveTo(w * 0.6158, h * 0.4862);
//	c.lineTo(w * 0.6418, h * 0.4623);
//	c.moveTo(w * 0.6281, h * 0.4969);
//	c.lineTo(w * 0.6486, h * 0.478);
//	c.moveTo(w * 0.6395, h * 0.5063);
//	c.lineTo(w * 0.6736, h * 0.478);
//	
//	c.stroke();
//
//	c.setStrokeWidth(2 * strokeWidth);
//	c.setLineCap('round');
//
//	c.setStrokeColor('#292929');
//	c.setLineJoin('round');
//
//	c.begin();
//	c.moveTo(0, h * 0.5503);
//	c.lineTo(w * 0.0455, h * 0.4623);
//	c.lineTo(w * 0.6054, h * 0.0157);
//	c.lineTo(w * 0.6623, h * 0.0629);
//	c.lineTo(w * 0.7396, 0);
//	c.lineTo(w * 0.8239, h * 0.0692);
//	c.lineTo(w * 0.8671, h * 0.2233);
//	c.lineTo(w * 0.9513, h * 0.2943);
//	c.lineTo(w, h * 0.4528);
//	c.lineTo(w * 0.9595, h * 0.5365);
//	c.lineTo(w * 0.396, h * 0.9843);
//	c.lineTo(w * 0.3391, h * 0.9403);
//	c.lineTo(w * 0.2617, h);
//	c.lineTo(w * 0.173, h * 0.9308);
//	c.lineTo(w * 0.1297, h * 0.7736);
//	c.lineTo(w * 0.0432, h * 0.7044);
//	c.close();
//	c.stroke();
//};
//
//mxCellRenderer.registerShape(mxShapeAws3dKinesisStream.prototype.cst.KINESIS_STREAM, mxShapeAws3dKinesisStream);

//**********************************************************************************************************************************************************
//SQS 2
//**********************************************************************************************************************************************************
///**
//* Extends mxShape.
//*/
//function mxShapeAws3dSqs2(bounds, fill, stroke, strokewidth)
//{
//	mxShape.call(this);
//	this.bounds = bounds;
//	this.fill = fill;
//	this.stroke = stroke;
//	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
//};
//
///**
//* Extends mxShape.
//*/
//mxUtils.extend(mxShapeAws3dSqs2, mxShape);
//
//mxShapeAws3dSqs2.prototype.cst = {
//		SQS2 : 'mxgraph.aws3d.sqs2',
//		SHADING_COLORS : 'shadingCols'
//};
//
///**
//* Function: paintVertexShape
//* 
//* Paints the vertex shape.
//*/
//mxShapeAws3dSqs2.prototype.paintVertexShape = function(c, x, y, w, h)
//{
//	c.translate(x, y);
//
//	var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, 'strokeWidth', '1'));
//	var strokeWidth1 = strokeWidth * w / 160;
//	var strokeWidth2 = strokeWidth * h / 93;
//	var isShadow = parseFloat(mxUtils.getValue(this.state.style, 'shadow', '0'));
//	
//	strokeWidth = Math.min(strokeWidth1, strokeWidth2);
//	
//	c.setStrokeWidth(strokeWidth);
//	c.setShadow(false);
//	c.save();
//	c.save();
//	c.setStrokeWidth(2 * strokeWidth);
//	c.setStrokeColor('#292929');
//	c.setLineJoin('round');
//
//	if(isShadow == 1)
//	{
//		c.setShadow(true);
//	}
//	
//	c.begin();
//	c.moveTo(0, h * 0.4737);
//	c.lineTo(w * 0.4652, 0);
//	c.lineTo(w * 0.6231, h * 0.0602);
//	c.lineTo(w * 0.6231, h * 0.1676);
//	c.lineTo(w * 0.1567, h * 0.6316);
//	c.close();
//	c.moveTo(w * 0.3756, h * 0.8443);
//	c.lineTo(w * 0.3756, h * 0.7454);
//	c.lineTo(w * 0.8439, h * 0.275);
//	c.lineTo(w, h * 0.5328);
//	c.lineTo(w * 0.5311, h);
//	c.close();
//	c.fillAndStroke();
//	
//	c.restore();
//	c.setFillColor('#000000');
//	
//	var shading = mxUtils.getValue(this.state.style, mxShapeAws3dSqs2.prototype.cst.SHADING_COLORS, '0.1,0.3').toString().split(',');
//	var flipH = mxUtils.getValue(this.state.style, 'flipH', '0');
//	(flipH == '0') ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]); 
//	
//	c.begin();
//	c.moveTo(0, h * 0.4737);
//	c.lineTo(w * 0.1567, h * 0.5274);
//	c.lineTo(w * 0.1567, h * 0.6394);
//	c.close();
//	c.moveTo(w * 0.3756, h * 0.7454);
//	c.lineTo(w * 0.5311, h);
//	c.lineTo(w * 0.3756, h * 0.8443);
//	c.close();
//	c.fill();
//
//	(flipH == '0') ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]); 
//	c.begin();
//	c.moveTo(w * 0.1567, h * 0.5274);
//	c.lineTo(w * 0.6231, h * 0.0602);
//	c.lineTo(w * 0.6231, h * 0.1676);
//	c.lineTo(w * 0.1567, h * 0.6294);
//	c.close();
//	c.fill();
//	
//	c.restore();
//	c.setLineJoin('round');
//	
//	c.begin();
//	c.moveTo(0, h * 0.4737);
//	c.lineTo(w * 0.1567, h * 0.5274);
//	c.lineTo(w * 0.1567, h * 0.6294);
//	c.close();
//	c.moveTo(w * 0.3756, h * 0.7454);
//	c.lineTo(w * 0.5311, h);
//	c.lineTo(w * 0.3756, h * 0.8443);
//	c.close();
//	c.moveTo(w * 0.1567, h * 0.5274);
//	c.lineTo(w * 0.6231, h * 0.0602);
//	c.lineTo(w * 0.6231, h * 0.1676);
//	c.lineTo(w * 0.1567, h * 0.6294);
//	c.close();
//	c.stroke();
//
//	c.setStrokeWidth(2 * strokeWidth);
//	c.setLineCap('round');
//
//	c.setStrokeColor('#292929');
//	c.setLineJoin('round');
//
//	c.begin();
//	c.moveTo(0, h * 0.4737);
//	c.lineTo(w * 0.4652, 0);
//	c.lineTo(w * 0.6231, h * 0.0602);
//	c.lineTo(w * 0.6231, h * 0.1676);
//	c.lineTo(w * 0.1567, h * 0.6316);
//	c.close();
//	c.moveTo(w * 0.3756, h * 0.8443);
//	c.lineTo(w * 0.3756, h * 0.7454);
//	c.lineTo(w * 0.8439, h * 0.275);
//	c.lineTo(w, h * 0.5328);
//	c.lineTo(w * 0.5311, h);
//	c.close();
//	c.stroke();
//	
//	c.setFillColor('#F4B934');
//	
//	c.begin();
//	c.moveTo(w * 0.1256, h * 0.812);
//	c.lineTo(w * 0.24, h * 0.7605);
//	c.lineTo(w * 0.1853, h * 0.8829);
//	c.close();
//	c.moveTo(w * 0.2417, h * 0.6957);
//	c.lineTo(w * 0.3562, h * 0.6441);
//	c.lineTo(w * 0.3014, h * 0.7666);
//	c.close();
//	c.moveTo(w * 0.3588, h * 0.5793);
//	c.lineTo(w * 0.4733, h * 0.5277);
//	c.lineTo(w * 0.4185, h * 0.6502);
//	c.close();
//	c.moveTo(w * 0.477, h * 0.4611);
//	c.lineTo(w * 0.5914, h * 0.4096);
//	c.lineTo(w * 0.5367, h * 0.532);
//	c.close();
//	c.moveTo(w * 0.591, h * 0.343);
//	c.lineTo(w * 0.7054, h * 0.2914);
//	c.lineTo(w * 0.6507, h * 0.4139);
//	c.close();
//	c.moveTo(w * 0.7091, h * 0.2302);
//	c.lineTo(w * 0.8236, h * 0.1786);
//	c.lineTo(w * 0.7688, h * 0.3011);
//	c.close();
//	c.fillAndStroke();
//};
//
//mxCellRenderer.registerShape(mxShapeAws3dSqs2.prototype.cst.SQS2, mxShapeAws3dSqs2);


/**
 * $Id: mxAws4.js,v 1.0 2018/16/11 07:05:39 mate Exp $
 * Copyright (c) 2006-2018, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Product Icon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws4ProductIcon(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws4ProductIcon, mxShape);

mxShapeAws4ProductIcon.prototype.cst = {
		PRODUCT_ICON : 'mxgraph.aws4.productIcon'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws4ProductIcon.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var opacity = parseFloat(mxUtils.getValue(this.style, 'opacity', '100'));
	var op1 = opacity;
	var op2 = opacity;
	
	if (fillColor == 'none')
	{
		op1 = 0;
	}
	
	if (gradientColor == 'none')
	{
		op2 = 0;
	}

	var ind = 1;
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', 'none');
	c.setFillColor(strokeColor);

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fill();

	c.setShadow(false);
	var fillColor = mxUtils.getValue(this.state.style, 'fillColor', '#ffffff');
	var gradientColor = mxUtils.getValue(this.state.style, 'gradientColor', fillColor);
	var gradientDir = mxUtils.getValue(this.state.style, 'gradientDirection', 'south');
	
	c.setFillColor(fillColor);
	c.setGradient(fillColor, gradientColor, 0, 0, w, h, gradientDir, op1, op2);	

	c.begin();
	c.moveTo(ind, ind);
	c.lineTo(w - ind, ind);
	c.lineTo(w - ind, w - ind);
	c.lineTo(ind, w - ind);
	c.close();
	c.fill();
	

	var prIcon = mxUtils.getValue(this.state.style, 'prIcon', '');
	var stencil = mxStencilRegistry.getStencil(prIcon);

	if (stencil != null)
	{
		c.setFillColor(strokeColor);
		c.setStrokeColor('none');
//		stencil.drawShape(c, this, w * 0.1, h * 0.1, w * 0.8, h * 0.8);
		stencil.drawShape(c, this, ind + w * 0.15, ind + w * 0.15, w * 0.7 - 2 * ind, w * 0.7 - 2 * ind);
	}

};

mxCellRenderer.registerShape(mxShapeAws4ProductIcon.prototype.cst.PRODUCT_ICON, mxShapeAws4ProductIcon);

//**********************************************************************************************************************************************************
//Resource Icon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws4ResourceIcon(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws4ResourceIcon, mxShape);

mxShapeAws4ResourceIcon.prototype.cst = {
		RESOURCE_ICON : 'mxgraph.aws4.resourceIcon'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws4ResourceIcon.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fill();

	c.setShadow(false);
	
	var prIcon = mxUtils.getValue(this.state.style, 'resIcon', '');
	var stencil = mxStencilRegistry.getStencil(prIcon);

	if (stencil != null)
	{
		var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
		c.setFillColor(strokeColor);
		c.setStrokeColor('none');
		stencil.drawShape(c, this, w * 0.1, h * 0.1, w * 0.8, h * 0.8);
	}

};

mxCellRenderer.registerShape(mxShapeAws4ResourceIcon.prototype.cst.RESOURCE_ICON, mxShapeAws4ResourceIcon);

//**********************************************************************************************************************************************************
//Group
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws4Group(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws4Group, mxShape);

mxShapeAws4Group.prototype.cst = {
		GROUP : 'mxgraph.aws4.group'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws4Group.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var grStroke = mxUtils.getValue(this.state.style, 'grStroke', '1');
	
	var size = 25;

	if (this.style != null && mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1') == '0')
	{
		c.pointerEvents = false;
	}

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();

	if (grStroke == '1')
	{
		c.fillAndStroke();
	}
	else
	{
		c.fill();
	}
	
	c.pointerEvents = true;
	c.setShadow(false);

	var grIcon = mxUtils.getValue(this.state.style, 'grIcon', '');
	var stencil = mxStencilRegistry.getStencil(grIcon);

	if (stencil != null)
	{
		var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
		c.setFillColor(strokeColor);
		c.setStrokeColor('none');
		stencil.drawShape(c, this, 0, 0, size, size);
	}

};

mxCellRenderer.registerShape(mxShapeAws4Group.prototype.cst.GROUP, mxShapeAws4Group);

//**********************************************************************************************************************************************************
//Group Center
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws4GroupCenter(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws4GroupCenter, mxShape);

mxShapeAws4GroupCenter.prototype.cst = {
		GROUP_CENTER : 'mxgraph.aws4.groupCenter'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws4GroupCenter.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var grStroke = mxUtils.getValue(this.state.style, 'grStroke', '1');

	var size = 25;

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	
	if (grStroke == '1')
	{
		c.fillAndStroke();
	}
	else
	{
		c.fill();
	}
	
	c.setShadow(false);
	var grIcon = mxUtils.getValue(this.state.style, 'grIcon', '');
	var stencil = mxStencilRegistry.getStencil(grIcon);

	if (stencil != null)
	{
		var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
		c.setFillColor(strokeColor);
		c.setStrokeColor('none');
		stencil.drawShape(c, this, (w - size) * 0.5, 0, size, size);
	}

};

mxCellRenderer.registerShape(mxShapeAws4GroupCenter.prototype.cst.GROUP_CENTER, mxShapeAws4GroupCenter);

////**********************************************************************************************************************************************************
////Resource Icon
////**********************************************************************************************************************************************************
///**
//* Extends mxShape.
//*/
//function mxShapeAws4ResourceIcon(bounds, fill, stroke, strokewidth)
//{
//	mxShape.call(this);
//	this.bounds = bounds;
//	this.fill = fill;
//	this.stroke = stroke;
//	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
//};
//
///**
//* Extends mxShape.
//*/
//mxUtils.extend(mxShapeAws4ResourceIcon, mxShape);
//
//mxShapeAws4ResourceIcon.prototype.cst = {
//		RESOURCE_ICON : 'mxgraph.aws4.resourceIcon'
//};
//
///**
//* Function: paintVertexShape
//* 
//* Paints the vertex shape.
//*/
//mxShapeAws4ResourceIcon.prototype.paintVertexShape = function(c, x, y, w, h)
//{
//	c.translate(x, y);
//
//	c.begin();
//	c.moveTo(0, 0);
//	c.lineTo(w, 0);
//	c.lineTo(w, h);
//	c.lineTo(0, h);
//	c.close();
//	c.fillAndStroke();
//
//	var prIcon = mxUtils.getValue(this.state.style, 'resIcon', '');
//	var stencil = mxStencilRegistry.getStencil(prIcon);
//
//	if (stencil != null)
//	{
//		var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
//		c.setFillColor(strokeColor);
//		c.setStrokeColor('none');
//		stencil.drawShape(c, this, w * 0.1, h * 0.1, w * 0.8, h * 0.8);
//	}
//
//};

//**********************************************************************************************************************************************************
//Group2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAws4Group2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAws4Group2, mxShape);

mxShapeAws4Group2.prototype.cst = {
		GROUP2 : 'mxgraph.aws4.group2'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAws4Group2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var size = 25;

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();

	c.setShadow(false);

	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');
	c.setFillColor(strokeColor);

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(size, 0);
	c.lineTo(size, size);
	c.lineTo(0, size);
	c.close();
	c.fill();

	var grIcon = mxUtils.getValue(this.state.style, 'grIcon', '');
	var stencil = mxStencilRegistry.getStencil(grIcon);

	if (stencil != null)
	{
		c.setFillColor('#ffffff');
		c.setStrokeColor('none');
		stencil.drawShape(c, this, size * 0.1, size * 0.1, size * 0.8, size * 0.8);
	}

};

mxCellRenderer.registerShape(mxShapeAws4Group2.prototype.cst.GROUP2, mxShapeAws4Group2);


/**
 * $Id: mxAndroid.js,v 1.5 2014/01/21 12:32:06 mate Exp $
 * Copyright (c) 2006-2013, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Horizontal Tab Bar (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeAndroidTabBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeAndroidTabBar, mxShape);

mxShapeAndroidTabBar.prototype.cst = {
		MAIN_TEXT : 'mainText',
		SHAPE_TAB_BAR : 'mxgraph.android.tabBar',
		TEXT_COLOR : 'textColor',
		TEXT_COLOR2 : 'textColor2',
		STROKE_COLOR2 : 'strokeColor2',
		FILL_COLOR2 : 'fillColor2',
		SELECTED : '+',			//must be 1 char
		TEXT_SIZE : 'textSize'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeAndroidTabBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var textStrings = mxUtils.getValue(this.style, mxShapeAndroidTabBar.prototype.cst.MAIN_TEXT, '+Tab 1, Tab 2, Tab 3').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxShapeAndroidTabBar.prototype.cst.TEXT_COLOR, 'none');
	var selectedFontColor = mxUtils.getValue(this.style, mxShapeAndroidTabBar.prototype.cst.TEXT_COLOR2, 'none');
	var fontSize = mxUtils.getValue(this.style, mxShapeAndroidTabBar.prototype.cst.TEXT_SIZE, '17').toString();
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, 'none');
	var separatorColor = mxUtils.getValue(this.style, mxShapeAndroidTabBar.prototype.cst.STROKE_COLOR2, 'none');
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, 'none');
	var selectedFillColor = mxUtils.getValue(this.style, mxShapeAndroidTabBar.prototype.cst.FILL_COLOR2, 'none');
	var buttonNum = textStrings.length;
	var buttonWidths = new Array(buttonNum);
	var buttonTotalWidth = 0;
	var selectedButton = -1;
	var labelOffset = 5;

	for (var i = 0; i < buttonNum; i++)
	{
		var buttonText = textStrings[i];

		if(buttonText.charAt(0) === mxShapeAndroidTabBar.prototype.cst.SELECTED)
		{
			buttonText = textStrings[i].substring(1);
			selectedButton = i;
		}

		buttonWidths[i] = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		buttonTotalWidth += buttonWidths[i];
	}

	var trueH = Math.max(h, fontSize * 1.5, 7);
	var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
	var trueW = Math.max(w, minW);

	c.translate(x, y);
	this.background(c, trueW, trueH, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton);
	c.setShadow(false);

	c.setFontStyle(mxConstants.FONT_BOLD);
	var currWidth = 0;

	for (var i = 0; i < buttonNum; i++)
	{
		if (i === selectedButton)
		{
			c.setFontColor(selectedFontColor);
		}
		else
		{
			c.setFontColor(fontColor);
		}

		currWidth = currWidth + labelOffset;
		this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
		currWidth = currWidth + buttonWidths[i] + labelOffset;
	}
};

mxShapeAndroidTabBar.prototype.background = function(c, w, h, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton)
{
	c.begin();

	//draw the frame
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.rect(0, 0, w, h);
	c.fillAndStroke();

	//draw the button separators
	c.setStrokeColor(separatorColor);
	c.begin();
	for (var i = 1; i < buttonNum; i++)
	{
		if (i !== selectedButton && i !== (selectedButton + 1))
		{
			var currWidth = 0;

			for (var j = 0; j < i; j++)
			{
				currWidth += buttonWidths[j] + 2 * labelOffset;
			}

			currWidth = currWidth * w / minW;
			c.moveTo(currWidth, h * 0.2);
			c.lineTo(currWidth, h * 0.8);
		}
	}

	c.stroke();

	//draw the selected button
	var buttonLeft = 0;
	c.setFillColor(selectedFillColor);

	for (var i = 0; i < selectedButton; i++)
	{
		buttonLeft += buttonWidths[i] + 2 * labelOffset;
	}

	buttonLeft = buttonLeft * w / minW;
	var buttonRight = (buttonWidths[selectedButton] + 2 * labelOffset) * w / minW;
	buttonRight += buttonLeft;

	c.rect(buttonLeft, 0, buttonRight - buttonLeft, h);
	c.fill();

	c.setAlpha(1);
	c.setFillColor('#33b5e5');
	c.rect(buttonLeft, h * 0.9, buttonRight - buttonLeft, h * 0.1);
	c.fill();
};

mxShapeAndroidTabBar.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW)
{
	if(textString.charAt(0) === mxShapeAndroidTabBar.prototype.cst.SELECTED)
	{
		textString = textString.substring(1);
	}

	c.begin();
	c.setFontSize(fontSize);
	c.text((w + buttonWidth * 0.5) * trueW / minW, h * 0.5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeAndroidTabBar.prototype.cst.SHAPE_TAB_BAR, mxShapeAndroidTabBar);

//**********************************************************************************************************************************************************
//Android Phone Vertical
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidPhone(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidPhone, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidPhone.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var rSize = 25;

	c.roundrect(0, 0, w, h, rSize, rSize);
	c.fillAndStroke();
	
	c.setShadow(false);
	
	this.foreground(c, x, y, w, h, rSize);
};

mxShapeAndroidPhone.prototype.foreground = function(c, x, y, w, h, rSize)
{
	c.rect(w * 0.0625, h * 0.15, w * 0.875, h * 0.7);
	c.stroke();

	c.ellipse(w * 0.4875, h * 0.04125, w * 0.025, h * 0.0125);
	c.stroke();

	c.roundrect(w * 0.375, h * 0.075, w * 0.25, h * 0.01875, w * 0.02, h * 0.01);
	c.stroke();
	c.ellipse(w * 0.4, h * 0.875, w * 0.2, h * 0.1);
	c.stroke();
	c.roundrect(w * 0.4575, h * 0.905, w * 0.085, h * 0.04375, h * 0.00625, h * 0.00625);
	c.stroke();
};

mxCellRenderer.registerShape('mxgraph.android.phone', mxShapeAndroidPhone);

//**********************************************************************************************************************************************************
//Android Status Bar
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidStatusBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidStatusBar, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidStatusBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeAndroidStatusBar.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fill();
};

mxShapeAndroidStatusBar.prototype.foreground = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fill();

	c.setFontColor(mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, '#222222'));
	c.setFontSize(mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '5'));
	c.text(w - 30, h * 0.5 + 1, 0, 0, '12:00', mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setFillColor('#444444');
	c.begin();
	c.moveTo(w - 37, h * 0.5 + 6);
	c.lineTo(w - 37, h * 0.5 - 5);
	c.lineTo(w - 36, h * 0.5 - 5);
	c.lineTo(w - 36, h * 0.5 - 6);
	c.lineTo(w - 32, h * 0.5 - 6);
	c.lineTo(w - 32, h * 0.5 - 5);
	c.lineTo(w - 31, h * 0.5 - 5);
	c.lineTo(w - 31, h * 0.5 + 6);
	c.close();
	c.fill();
	
	c.setFillColor(mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, 'none'));
	c.ellipse(w - 56, h * 0.5 + 2, 2, 2);
	c.fillAndStroke();
	
	c.setStrokeWidth(2);
	c.begin();
	c.moveTo(w - 52, h * 0.5 + 1);
	c.arcTo(3.5, 3.5, 0, 0, 0, w - 58, h * 0.5 + 1);
	c.stroke();
	
	c.begin();
	c.moveTo(w - 50, h * 0.5 - 1);
	c.arcTo(6, 6, 0, 0, 0, w - 60, h * 0.5 - 1);
	c.stroke();
	
	c.setStrokeWidth(1);
	
	c.rect(w - 51, h * 0.5 + 5, 2, 1);
	c.fill();
	
	c.rect(w - 48, h * 0.5 + 2, 2, 4);
	c.fill();
	
	c.rect(w - 45, h * 0.5 - 1, 2, 7);
	c.fill();
	
	c.rect(w - 42, h * 0.5 - 4, 2, 10);
	c.fill();

	c.rect(w - 37, h * 0.5  - 2, 6, 8);
	c.fill();
	
};

mxCellRenderer.registerShape('mxgraph.android.statusBar', mxShapeAndroidStatusBar);

//**********************************************************************************************************************************************************
//Checkbox Button Group
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidCheckboxGroup(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidCheckboxGroup, mxShape);

mxShapeAndroidCheckboxGroup.prototype.cst = {
		STYLE_TEXTCOLOR2 : 'textColor2',
		STYLE_STROKECOLOR2 : 'strokeColor2',
		BUTTON_TEXT : 'buttonText',
		SELECTED : '+' 		//has to be one character long
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidCheckboxGroup.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var fontColor = mxUtils.getValue(this.style, mxConstants.STYLE_TEXTCOLOR, '#666666');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '8').toString();
	var optionText = mxUtils.getValue(this.style, mxShapeAndroidCheckboxGroup.prototype.cst.BUTTON_TEXT, 'Option 1').toString().split(',');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, 'none');
	var strokeColor2 = mxUtils.getValue(this.style, mxShapeAndroidCheckboxGroup.prototype.cst.STYLE_STROKECOLOR2, 'none');
	
	c.setStrokeColor(strokeColor2);
	var optionNum = optionText.length;
	var buttonSize = 5;
	var lineH = Math.max(fontSize * 1.5, buttonSize);
	var maxTextWidth = 0;
	var selected = -1;
	var labelOffset = 2.5;
	var minH = optionNum * lineH;
	var trueH = Math.max(h, minH);

	//get min width and selected option 
	for (var i = 0; i < optionNum; i++)
	{
		var currText = optionText[i];

		if(currText.charAt(0) === mxShapeAndroidCheckboxGroup.prototype.cst.SELECTED)
		{
			currText = optionText[i].substring(1);
			selected = i;
		}

		var currWidth = mxUtils.getSizeForString(currText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currWidth > maxTextWidth)
		{
			maxTextWidth = currWidth;
		}
	}

	var minW = 2 * labelOffset + maxTextWidth + 2 * buttonSize;
	var trueW = Math.max(w, minW);

	//draw the background
	c.roundrect(0, 0, trueW, trueH, 2.5, 2.5);
	c.fillAndStroke();
	c.setShadow(false);

	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.setStrokeColor(strokeColor);

	for (var i = 0; i < optionNum; i++)
	{
		var currHeight = (i * lineH + lineH * 0.5) * trueH / minH;

		var currText = optionText[i];

		if(currText.charAt(0) === mxShapeAndroidCheckboxGroup.prototype.cst.SELECTED)
		{
			currText = optionText[i].substring(1);
			selected = i;
		}

		c.text(buttonSize * 2 + labelOffset, currHeight, 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

		var iconX = buttonSize * 0.5;
		var iconY = currHeight - buttonSize * 0.5;

		if (selected === i)
		{
			c.rect(iconX, iconY, buttonSize, buttonSize);
			c.fillAndStroke();
			c.begin();
			c.moveTo(iconX + buttonSize * 0.25, iconY + buttonSize * 0.5);
			c.lineTo(iconX + buttonSize * 0.5, iconY + buttonSize * 0.75);
			c.lineTo(iconX + buttonSize * 0.75, iconY + buttonSize * 0.25);
			c.stroke();
		}
		else
		{
			c.rect(iconX, iconY, buttonSize, buttonSize);
			c.fillAndStroke();
		}

		selected = -1;
	}
};

mxCellRenderer.registerShape('mxgraph.android.checkboxGroup', mxShapeAndroidCheckboxGroup);

//**********************************************************************************************************************************************************
//Radio Button Group
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidRadioGroup(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidRadioGroup, mxShape);

mxShapeAndroidRadioGroup.prototype.cst = {
		STYLE_TEXTCOLOR2 : 'textColor2',
		STYLE_STROKECOLOR2 : 'strokeColor2',
		BUTTON_TEXT : 'buttonText',
		SELECTED : '+' 		//has to be one character long
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidRadioGroup.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var fontColor = mxUtils.getValue(this.style, mxConstants.STYLE_TEXTCOLOR, '#666666');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '8').toString();
	var optionText = mxUtils.getValue(this.style, mxShapeAndroidRadioGroup.prototype.cst.BUTTON_TEXT, 'Option 1').toString().split(',');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, 'none');
	var strokeColor2 = mxUtils.getValue(this.style, mxShapeAndroidRadioGroup.prototype.cst.STYLE_STROKECOLOR2, 'none');

	c.setStrokeColor(strokeColor2);

	var optionNum = optionText.length;
	var buttonSize = 5;
	var lineH = Math.max(fontSize * 1.5, buttonSize);
	var maxTextWidth = 0;
	var selected = -1;
	var labelOffset = 2.5;
	var minH = optionNum * lineH;
	var trueH = Math.max(h, minH);

	//get min width and selected option 
	for (var i = 0; i < optionNum; i++)
	{
		var currText = optionText[i];

		if(currText.charAt(0) === mxShapeAndroidRadioGroup.prototype.cst.SELECTED)
		{
			currText = optionText[i].substring(1);
			selected = i;
		}

		var currWidth = mxUtils.getSizeForString(currText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currWidth > maxTextWidth)
		{
			maxTextWidth = currWidth;
		}
	}

	var minW = 2 * labelOffset + maxTextWidth + 2 * buttonSize;
	var trueW = Math.max(w, minW);

	//draw the background
	c.roundrect(0, 0, trueW, trueH, 2.5, 2.5);
	c.fillAndStroke();
	c.setShadow(false);

	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.setStrokeColor(strokeColor);
	c.setFillColor(strokeColor);

	for (var i = 0; i < optionNum; i++)
	{
		var currHeight = (i * lineH + lineH * 0.5) * trueH / minH;

		var currText = optionText[i];

		if(currText.charAt(0) === mxShapeAndroidRadioGroup.prototype.cst.SELECTED)
		{
			currText = optionText[i].substring(1);
			selected = i;
		}

		c.text(buttonSize * 2 + labelOffset, currHeight, 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

		var iconX = buttonSize * 0.5;
		var iconY = currHeight - buttonSize * 0.5;

		if (selected === i)
		{
			c.ellipse(iconX, iconY, buttonSize, buttonSize);
			c.stroke();
			c.ellipse(iconX + buttonSize * 0.25, iconY + buttonSize * 0.25, buttonSize * 0.5, buttonSize * 0.5);
			c.fillAndStroke();
		}
		else
		{
			c.ellipse(iconX, iconY, buttonSize, buttonSize);
			c.stroke();
		}
	}
};

mxCellRenderer.registerShape('mxgraph.android.radioGroup', mxShapeAndroidRadioGroup);

//**********************************************************************************************************************************************************
//Menu Bar (LEGACY)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidMenuBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidMenuBar, mxShape);

mxShapeAndroidMenuBar.prototype.cst = {
		MENU_TEXT : 'menuText'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidMenuBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var textStrings = mxUtils.getValue(this.style, mxShapeAndroidMenuBar.prototype.cst.MENU_TEXT, 'Item 1, Item 2, Item 3').toString().split(',');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '12');
	var buttonNum = textStrings.length;
	var maxButtonWidth = 0;
	var labelOffset = 2.5;

	for (var i = 0; i < buttonNum; i++)
	{
		var buttonText = textStrings[i];

		var currWidth = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currWidth > maxButtonWidth)
		{
			maxButtonWidth = currWidth;
		}
	}

	var minButtonHeight =  fontSize * 1.5;
	var minH = buttonNum * minButtonHeight;
	var trueH = Math.max(h, minH);
	var minW = 2 * labelOffset + maxButtonWidth;
	var trueW = Math.max(w, minW);

	c.translate(x, y);

	c.rect(0, 0, w, trueH);
	c.fillAndStroke();

	c.setShadow(false);

	//draw the button separators
	c.begin();

	for (var i = 1; i < buttonNum; i++)
	{
			var currHeight = i * minButtonHeight * trueH / minH;
			c.moveTo(0, currHeight);
			c.lineTo(w, currHeight);
	}

	c.stroke();

	for (var i = 0; i < buttonNum; i++)
	{
		currWidth = currWidth + labelOffset;
		var currHeight = (i * minButtonHeight + minButtonHeight * 0.5) * trueH / minH;
		c.text(10, currHeight, 0, 0, textStrings[i], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
};

mxCellRenderer.registerShape('mxgraph.android.menuBar', mxShapeAndroidMenuBar);

//**********************************************************************************************************************************************************
//Text Selection Handles
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidTextSelHandles(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidTextSelHandles, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidTextSelHandles.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, 'none');
	c.translate(x, y);

	var handleSizeX = 15;
	var barH = Math.max(0, h - handleSizeX * 1.5);
	c.setAlpha(0.5);
	
	c.rect(handleSizeX, 0, w - 2 * handleSizeX, barH);
	c.fill();
	
	c.begin();
	c.moveTo(0, h - handleSizeX);
	c.lineTo(handleSizeX * 0.5, h - handleSizeX * 1.5);
	c.lineTo(handleSizeX, h - handleSizeX);
	c.close();
	c.moveTo(w - handleSizeX, h - handleSizeX);
	c.lineTo(w - handleSizeX * 0.5, h - handleSizeX * 1.5);
	c.lineTo(w, h - handleSizeX);
	c.close();
	c.fill();
	
	c.setFillColor(strokeColor);
	c.rect(0, h - handleSizeX, handleSizeX, handleSizeX);
	c.fill();
	c.rect(w - handleSizeX, h - handleSizeX, handleSizeX, handleSizeX);
	c.fill();
};

mxCellRenderer.registerShape('mxgraph.android.textSelHandles', mxShapeAndroidTextSelHandles);

//**********************************************************************************************************************************************************
//Android Indeterminate Spinner
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidIndeterminateSpinner(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidIndeterminateSpinner, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidIndeterminateSpinner.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxShapeAndroidIndeterminateSpinner.prototype.background = function(c, x, y, w, h)
{
	c.setGradient('#aaaaaa', '#dddddd', w * 0.325, 0, w * 0.675, h * 0.5, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.begin();
	c.moveTo(w * 0.5, h * 0.1);
	c.arcTo(w * 0.4, h * 0.4, 0, 0, 0, w * 0.5, h * 0.9);
	c.lineTo(w * 0.5, h);
	c.arcTo(w * 0.5, h * 0.5, 0, 0, 1, w * 0.5, 0);
	c.close();
	c.fill();

	c.setGradient('#ffffff', '#dddddd', w * 0.325, 0, w * 0.675, h * 0.5, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.begin();
	c.moveTo(w * 0.5, h * 0.1);
	c.arcTo(w * 0.4, h * 0.4, 0, 0, 1, w * 0.5, h * 0.9);
	c.lineTo(w * 0.5, h);
	c.arcTo(w * 0.5, h * 0.5, 0, 0, 0, w * 0.5, 0);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape('mxgraph.android.indeterminateSpinner', mxShapeAndroidIndeterminateSpinner);

//**********************************************************************************************************************************************************
//Anchor (a dummy shape without visuals used for anchoring)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidAnchor(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidAnchor, mxShape);

mxShapeAndroidAnchor.prototype.cst = {
		ANCHOR : 'mxgraph.android.anchor'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidAnchor.prototype.paintVertexShape = function(c, x, y, w, h)
{
};

mxCellRenderer.registerShape(mxShapeAndroidAnchor.prototype.cst.ANCHOR, mxShapeAndroidAnchor);

//**********************************************************************************************************************************************************
//Rounded rectangle (adjustable rounding)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidRRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidRRect, mxShape);

mxShapeAndroidRRect.prototype.cst = {
		RRECT : 'mxgraph.android.rrect',
		R_SIZE : 'rSize'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidRRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeAndroidRRect.prototype.cst.R_SIZE, '10'));
	c.roundrect(0, 0, w, h, rSize);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeAndroidRRect.prototype.cst.RRECT, mxShapeAndroidRRect);

//**********************************************************************************************************************************************************
//Checkbox
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidCheckbox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidCheckbox, mxShape);

mxShapeAndroidCheckbox.prototype.cst = {
		CHECKBOX : 'mxgraph.android.checkbox'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidCheckbox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.rect(0, 0, w, h);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w * 0.8, h * 0.2);
	c.lineTo(w * 0.4, h * 0.8);
	c.lineTo(w * 0.25, h * 0.6);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAndroidCheckbox.prototype.cst.CHECKBOX, mxShapeAndroidCheckbox);

//**********************************************************************************************************************************************************
//Progress Bar
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidProgressBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx1 = 0.8;
	this.dx2 = 0.6;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidProgressBar, mxShape);

mxShapeAndroidProgressBar.prototype.customProperties = [
	{name: 'dx1', dispName: 'Middle Bar Length', type: 'float', min:0, max:1, defVal:0.8},
	{name: 'dx2', dispName: 'Left Bar Length', type: 'float', min:0, max:1, defVal:0.6}
];

mxShapeAndroidProgressBar.prototype.cst = {
		PROGRESS_BAR : 'mxgraph.android.progressBar'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidProgressBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var dx1 = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dx2 = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));

	c.translate(x, y);
	
	c.save();
	c.save();
	c.setStrokeColor('#444444');
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w , h * 0.5);
	c.stroke();
	
	c.restore();
	c.setShadow(false);
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(dx1, h * 0.5);
	c.stroke();
	
	c.setStrokeColor('#000000');
	c.setAlpha('0.2');
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(dx1, h * 0.5);
	c.stroke();
	
	c.restore();
	c.setShadow(false);
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(dx2, h * 0.5);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeAndroidProgressBar.prototype.cst.PROGRESS_BAR, mxShapeAndroidProgressBar);

mxShapeAndroidProgressBar.prototype.constraints = null;

Graph.handleFactory[mxShapeAndroidProgressBar.prototype.cst.PROGRESS_BAR] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx1'], function(bounds)
			{
				var dx1 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1))));

				return new mxPoint(bounds.x + dx1 * bounds.width, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx1'] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100;
			})];

	var handle2 = Graph.createHandle(state, ['dx2'], function(bounds)
			{
				var dx2 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx1))));

				return new mxPoint(bounds.x + dx2 * bounds.width, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx2'] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100;
			});
	
	handles.push(handle2);

	return handles;
}

//**********************************************************************************************************************************************************
//Progress Scrubber Disabled
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidProgressScrubberDisabled(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.3;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidProgressScrubberDisabled, mxShape);

mxShapeAndroidProgressScrubberDisabled.prototype.customProperties = [
	{name: 'dx', dispName: 'Handle Position', type: 'float', min:0, max:1, defVal:0.3}
];

mxShapeAndroidProgressScrubberDisabled.prototype.cst = {
		PROGRESS_SCRUBBER_DISABLED : 'mxgraph.android.progressScrubberDisabled'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidProgressScrubberDisabled.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	c.translate(x, y);
	
	c.save();
	c.save();
	c.setStrokeColor('#444444');
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.stroke();
	
	c.restore();
	c.setShadow(false);
	c.setAlpha('0.5');
	c.setFillColor('#666666');
	c.begin();
	var r = Math.min(h, w * 0.1) / 2;
	c.ellipse(dx - r, h * 0.5 - r, 2 * r, 2 * r);
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.begin();
	var r = Math.min(h, w * 0.1) / 8;
	c.ellipse(dx - r, h * 0.5 - r, 2 * r, 2 * r);
	c.fill();
	
};

mxCellRenderer.registerShape(mxShapeAndroidProgressScrubberDisabled.prototype.cst.PROGRESS_SCRUBBER_DISABLED, mxShapeAndroidProgressScrubberDisabled);

mxShapeAndroidProgressScrubberDisabled.prototype.constraints = null;

Graph.handleFactory[mxShapeAndroidProgressScrubberDisabled.prototype.cst.PROGRESS_SCRUBBER_DISABLED] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
			{
				var dx = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

				return new mxPoint(bounds.x + dx * bounds.width, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100;
			})];

	return handles;
}

//**********************************************************************************************************************************************************
//Progress Scrubber Focused
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidProgressScrubberFocused(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.3;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidProgressScrubberFocused, mxShape);

mxShapeAndroidProgressScrubberFocused.prototype.customProperties = [
	{name: 'dx', dispName: 'Handle Position', type: 'float', min:0, max:1, defVal:0.3}
];

mxShapeAndroidProgressScrubberFocused.prototype.cst = {
		PROGRESS_SCRUBBER_FOCUSED : 'mxgraph.android.progressScrubberFocused'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidProgressScrubberFocused.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var fillColor = mxUtils.getValue(this.style, 'fillColor', '#ffffff');

	c.translate(x, y);
	
	c.save();
	c.save();
	c.setStrokeColor('#444444');
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.stroke();
	
	c.restore();
	c.setShadow(false);
	c.setAlpha('0.75');
	c.begin();
	var r = Math.min(h, w * 0.1) / 2;
	c.ellipse(dx - r, h * 0.5 - r, 2 * r, 2 * r);
	c.fill();
	
	c.restore();
	c.setShadow(false);
	c.setStrokeColor(fillColor);
	
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(dx, h * 0.5);
	c.stroke();
	
	c.begin();
	var r = Math.min(h, w * 0.1) / 8;
	c.ellipse(dx - r, h * 0.5 - r, 2 * r, 2 * r);
	c.fill();
	
};

mxCellRenderer.registerShape(mxShapeAndroidProgressScrubberFocused.prototype.cst.PROGRESS_SCRUBBER_FOCUSED, mxShapeAndroidProgressScrubberFocused);

mxShapeAndroidProgressScrubberFocused.prototype.constraints = null;

Graph.handleFactory[mxShapeAndroidProgressScrubberFocused.prototype.cst.PROGRESS_SCRUBBER_FOCUSED] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
			{
				var dx = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

				return new mxPoint(bounds.x + dx * bounds.width, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100;
			})];

	return handles;
}

//**********************************************************************************************************************************************************
//Progress Scrubber Pressed
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidProgressScrubberPressed(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.3;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidProgressScrubberPressed, mxShape);

mxShapeAndroidProgressScrubberPressed.prototype.customProperties = [
	{name: 'dx', dispName: 'Handle Position', type: 'float', min:0, max:1, defVal:0.3}
];

mxShapeAndroidProgressScrubberPressed.prototype.cst = {
		PROGRESS_SCRUBBER_PRESSED : 'mxgraph.android.progressScrubberPressed'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidProgressScrubberPressed.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var fillColor = mxUtils.getValue(this.style, 'fillColor', '#ffffff');

	c.translate(x, y);
	
	c.save();
	c.save();
	c.setStrokeColor('#444444');
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.stroke();
	
	c.restore();
	c.setShadow(false);
	c.setStrokeColor(fillColor);
	c.setAlpha('0.5');
	c.begin();
	var r = Math.min(h, w * 0.1) / 2;
	c.ellipse(dx - r, h * 0.5 - r, 2 * r, 2 * r);
	c.fillAndStroke();
	
	c.restore();
	c.setShadow(false);
	c.setStrokeColor(fillColor);
	
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(dx, h * 0.5);
	c.stroke();
	
	c.begin();
	var r = Math.min(h, w * 0.1) / 8;
	c.ellipse(dx - r, h * 0.5 - r, 2 * r, 2 * r);
	c.fill();
	
};

mxCellRenderer.registerShape(mxShapeAndroidProgressScrubberPressed.prototype.cst.PROGRESS_SCRUBBER_PRESSED, mxShapeAndroidProgressScrubberPressed);

mxShapeAndroidProgressScrubberPressed.prototype.constraints = null;

Graph.handleFactory[mxShapeAndroidProgressScrubberPressed.prototype.cst.PROGRESS_SCRUBBER_PRESSED] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
			{
				var dx = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

				return new mxPoint(bounds.x + dx * bounds.width, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100;
			})];

	return handles;
}

//**********************************************************************************************************************************************************
//Quickscroll
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidQuickscroll2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidQuickscroll2, mxShape);

mxShapeAndroidQuickscroll2.prototype.customProperties = [
	{name: 'dy', dispName: 'Handle Position', type: 'float', min:0, max:1, defVal:0.5}
];

mxShapeAndroidQuickscroll2.prototype.cst = {
		QUICKSCROLL : 'mxgraph.android.quickscroll2'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidQuickscroll2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var dy = Math.min(h - 20, Math.max(20, h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))))));
	var fillColor = mxUtils.getValue(this.style, 'fillColor', '#ffffff');

	c.translate(x, y);
	
	c.save();
	c.save();
	c.setStrokeColor('#cccccc');
	c.begin();
	c.moveTo(w - 3, 0);
	c.lineTo(w - 3, h);
	c.stroke();
	
	c.restore();
	c.begin();
	c.roundrect(w - 6, dy - 10, 6, 20, 1, 1);
	c.fillAndStroke();
	
	c.setFillColor('#cccccc');
	c.begin();
	c.rect(0, dy - 20, w - 18, 40);
	c.fill();
	
	c.setFillColor('#666666');
	c.begin();
	c.moveTo(w - 18, dy - 20);
	c.lineTo(w - 6, dy);
	c.lineTo(w - 18, dy + 20);
	c.close();
	c.fill();
	
	c.setFontSize('12');
	c.text((w - 18) * 0.5, dy, 0, 0, 'Aa', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeAndroidQuickscroll2.prototype.cst.QUICKSCROLL, mxShapeAndroidQuickscroll2);

mxShapeAndroidQuickscroll2.prototype.constraints = null;

Graph.handleFactory[mxShapeAndroidQuickscroll2.prototype.cst.QUICKSCROLL] = function(state)
{
	var handles = [Graph.createHandle(state, ['dy'], function(bounds)
			{
				var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

				return new mxPoint(bounds.x + bounds.width - 3, bounds.y + Math.min(bounds.height - 20, Math.max(20, dy * bounds.height)));
			}, function(bounds, pt)
			{
				this.state.style['dy'] = Math.round(1000 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1000;
			})];

	return handles;
}

//**********************************************************************************************************************************************************
//Quickscroll2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidQuickscroll3(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidQuickscroll3, mxShape);

mxShapeAndroidQuickscroll3.prototype.customProperties = [
	{name: 'dy', dispName: 'Handle Position', type: 'float', min:0, max:1, defVal:0.5}
];

mxShapeAndroidQuickscroll3.prototype.cst = {
		QUICKSCROLL : 'mxgraph.android.quickscroll3'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidQuickscroll3.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var dy = Math.min(h - 10, Math.max(10, h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))))));
	var fillColor = mxUtils.getValue(this.style, 'fillColor', '#ffffff');

	c.translate(x, y);
	
	c.save();
	c.setStrokeColor('#cccccc');
	c.begin();
	c.moveTo(w * 0.5, 0);
	c.lineTo(w * 0.5, h);
	c.stroke();
	
	c.restore();
	c.begin();
	c.roundrect(w * 0.5 - 3, dy - 10, 6, 20, 1, 1);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeAndroidQuickscroll3.prototype.cst.QUICKSCROLL, mxShapeAndroidQuickscroll3);

mxShapeAndroidQuickscroll3.prototype.constraints = null;

Graph.handleFactory[mxShapeAndroidQuickscroll3.prototype.cst.QUICKSCROLL] = function(state)
{
	var handles = [Graph.createHandle(state, ['dy'], function(bounds)
			{
				var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

				return new mxPoint(bounds.x + bounds.width * 0.5, bounds.y + Math.min(bounds.height - 10, Math.max(10, dy * bounds.height)));
			}, function(bounds, pt)
			{
				this.state.style['dy'] = Math.round(1000 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1000;
			})];

	return handles;
}

//**********************************************************************************************************************************************************
//Scrollbars
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidScrollbars2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidScrollbars2, mxShape);

mxShapeAndroidScrollbars2.prototype.cst = {
		SCROLLBARS : 'mxgraph.android.scrollbars2'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidScrollbars2.prototype.paintVertexShape = function(c, x, y, w, h)
{

	c.translate(x, y);
	
	c.begin();
	c.rect(w - 5, 0, 5, h - 7);
	c.fillAndStroke();

	c.begin();
	c.rect(0, h - 5, w - 7, 5);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeAndroidScrollbars2.prototype.cst.SCROLLBARS, mxShapeAndroidScrollbars2);

mxShapeAndroidScrollbars2.prototype.constraints = null;

//**********************************************************************************************************************************************************
//Spinner
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeAndroidSpinner2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeAndroidSpinner2, mxShape);

mxShapeAndroidSpinner2.prototype.cst = {
		SPINNER : 'mxgraph.android.spinner2'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeAndroidSpinner2.prototype.paintVertexShape = function(c, x, y, w, h)
{

	c.translate(x, y);
	
	c.begin();
	c.moveTo(0, h);
	c.lineTo(w, h);
	c.stroke();
	
	var s = Math.min(w / 10, h)
	c.begin();
	c.moveTo(w - s, h);
	c.lineTo(w, h - s);
	c.lineTo(w, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeAndroidSpinner2.prototype.cst.SPINNER, mxShapeAndroidSpinner2);

mxShapeAndroidSpinner2.prototype.constraints = null;


/**
 * $Id: mxArchiMate.js,v 1.0 2014/03/17 07:05:39 mate Exp $
 * Copyright (c) 2006-2014, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Location
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMateLocation(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMateLocation, mxShape);

mxArchiMateLocation.prototype.cst = {
		LOCATION : 'mxgraph.archimate.location'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMateLocation.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	c.translate(w - 20, 5);
	this.foreground(c, w - 20, 5, 15, 15);
};

mxArchiMateLocation.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxArchiMateLocation.prototype.foreground = function(c, x, y, w, h)
{
	c.setDashed(false);
	
	c.translate(3 ,0);
	w = w - 6;
	c.begin();
	c.moveTo(w * 0.5, h);
	c.arcTo(w * 0.1775, h * 0.3, 0, 0, 0, w * 0.345, h * 0.7);
	c.arcTo(w * 0.538, h * 0.364, 0, 0, 1, w * 0.5, 0);
	c.arcTo(w * 0.538, h * 0.364, 0, 0, 1, w * 0.655, h * 0.7);
	c.arcTo(w * 0.1775, h * 0.3, 0, 0, 0, w * 0.5, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxArchiMateLocation.prototype.cst.LOCATION, mxArchiMateLocation);

mxArchiMateLocation.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Business
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMateBusiness(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMateBusiness, mxShape);

mxArchiMateBusiness.prototype.cst = {
		BUSINESS : 'mxgraph.archimate.business',
		TYPE : 'busType',
		PROCESS : 'process',
		FUNCTION : 'function',
		INTERACTION : 'interaction',
		EVENT : 'event',
		SERVICE : 'service'
};

mxArchiMateBusiness.prototype.customProperties = [
	{name: 'busType', dispName: 'Business Type', type: 'enum', 
		enumList: [{val: 'process', dispName: 'Process'}, 
				   {val: 'function', dispName: 'Function'}, 
				   {val: 'interaction', dispName: 'Interaction'}, 
				   {val: 'event', dispName: 'Event'}, 
				   {val: 'service', dispName: 'Service'}]
	}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMateBusiness.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	c.translate(w - 20, 5);
	this.foreground(c, w - 20, 5, 15, 15);
};

mxArchiMateBusiness.prototype.background = function(c, x, y, w, h)
{
	c.roundrect(0, 0, w, h, 10, 10);
	c.fillAndStroke();
};

mxArchiMateBusiness.prototype.foreground = function(c, x, y, w, h)
{
	var type = mxUtils.getValue(this.style, mxArchiMateBusiness.prototype.cst.TYPE, mxArchiMateBusiness.prototype.cst.PROCESS);
	
	c.setDashed(false);
	
	if (type === mxArchiMateBusiness.prototype.cst.PROCESS)
	{
		c.translate(0, 2);
		h = h - 4;
	
		c.begin();
		c.moveTo(0, h * 0.15);
		c.lineTo(w * 0.65, h * 0.15);
		c.lineTo(w * 0.65, 0);
		c.lineTo(w, h * 0.5);
		c.lineTo(w * 0.65, h);
		c.lineTo(w * 0.65, h * 0.85);
		c.lineTo(0, h * 0.85);
		c.close();
		c.stroke();
	}
	else if (type === mxArchiMateBusiness.prototype.cst.FUNCTION)
	{
		c.translate(2, 0);
		w = w - 4;
		
		c.begin();
		c.moveTo(0, h * 0.15);
		c.lineTo(w * 0.5, 0);
		c.lineTo(w, h * 0.15);
		c.lineTo(w, h);
		c.lineTo(w * 0.5, h * 0.85);
		c.lineTo(0, h);
		c.close();
		c.stroke();
	}
	else if (type === mxArchiMateBusiness.prototype.cst.INTERACTION)
	{
		c.begin();
		c.moveTo(w * 0.55, 0);
		c.arcTo(w * 0.45, h * 0.5, 0, 0, 1, w * 0.55, h);
		c.close();
		c.moveTo(w * 0.45, 0);
		c.arcTo(w * 0.45, h * 0.5, 0, 0, 0, w * 0.45, h);
		c.close();
		c.stroke();
	}
	else if (type === mxArchiMateBusiness.prototype.cst.EVENT)
	{
		c.translate(0, 3);
		h = h - 6;
		
		c.begin();
		c.moveTo(w - h * 0.5, 0);
		c.arcTo(h * 0.5, h * 0.5, 0, 0, 1, w - h * 0.5, h);
		c.lineTo(0, h);
		c.arcTo(h * 0.5, h * 0.5, 0, 0, 0, 0, 0);
		c.close();
		c.stroke();
	}
	else if (type === mxArchiMateBusiness.prototype.cst.SERVICE)
	{
		c.translate(0, 3);
		h = h - 6;
		
		c.begin();
		c.moveTo(w - h * 0.5, 0);
		c.arcTo(h * 0.5, h * 0.5, 0, 0, 1, w - h * 0.5, h);
		c.lineTo(0, h);
		c.arcTo(h * 0.5, h * 0.5, 0, 0, 1, 0, 0);
		c.close();
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxArchiMateBusiness.prototype.cst.BUSINESS, mxArchiMateBusiness);

mxArchiMateBusiness.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2.9, 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, -2.9, 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false, null, -2.9, -2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, 2.9, -2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Business Object
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMateBusinessObject(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMateBusinessObject, mxShape);

mxArchiMateBusinessObject.prototype.cst = {
		BUSINESS_OBJECT : 'mxgraph.archimate.businessObject'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMateBusinessObject.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h);
};

mxArchiMateBusinessObject.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxArchiMateBusinessObject.prototype.foreground = function(c, x, y, w, h)
{
	if (h >= 15)
	{
		c.begin();
		c.moveTo(0, 15);
		c.lineTo(w, 15);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxArchiMateBusinessObject.prototype.cst.BUSINESS_OBJECT, mxArchiMateBusinessObject);

mxArchiMateBusinessObject.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2.9, 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, -2.9, 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false, null, -2.9, -2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, 2.9, -2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Representation
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMateRepresentation(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMateRepresentation, mxShape);

mxArchiMateRepresentation.prototype.cst = {
		REPRESENTATION : 'mxgraph.archimate.representation'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMateRepresentation.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
};

mxArchiMateRepresentation.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h * 0.85);
	c.arcTo(w * 0.35, h * 0.35, 0, 0, 0, w * 0.5, h * 0.85);
	c.arcTo(w * 0.35, h * 0.35, 0, 0, 1, 0, h * 0.85);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMateRepresentation.prototype.cst.REPRESENTATION, mxArchiMateRepresentation);

mxArchiMateRepresentation.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.85), false, null));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0.745), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.85), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0.955), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.85), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Product
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMateProduct(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMateProduct, mxShape);

mxArchiMateProduct.prototype.cst = {
		PRODUCT : 'mxgraph.archimate.product'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMateProduct.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h);
};

mxArchiMateProduct.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxArchiMateProduct.prototype.foreground = function(c, x, y, w, h)
{
	if (h >= 15)
	{
		c.begin();
		c.moveTo(0, 15);
		c.lineTo(w * 0.6, 15);
		c.lineTo(w * 0.6, 0);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxArchiMateProduct.prototype.cst.PRODUCT, mxArchiMateProduct);

//**********************************************************************************************************************************************************
//Application
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMateApplication(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMateApplication, mxShape);

mxArchiMateApplication.prototype.cst = {
		APPLICATION : 'mxgraph.archimate.application',
		TYPE : 'appType',
		COMPONENT : 'comp',
		INTERFACE : 'interface',
		INTERFACE2 : 'interface2',
		FUNCTION : 'function',
		INTERACTION : 'interaction',
		SERVICE : 'service',
		NODE : 'node',
		NETWORK : 'network',
		COMM_PATH : 'commPath',
		SYS_SW : 'sysSw',
		ARTIFACT : 'artifact',
		ACTOR : 'actor',
		ROLE : 'role',
		COLLABORATION : 'collab'
};

mxArchiMateApplication.prototype.customProperties = [
	{name: 'appType', dispName: 'App Type', type: 'enum', 
		enumList: [{val: 'comp', dispName: 'Component'}, 
				   {val: 'interface', dispName: 'Interface'}, 
				   {val: 'interface2', dispName: 'Interface2'}, 
				   {val: 'function', dispName: 'Function'}, 
				   {val: 'interaction', dispName: 'Interaction'}, 
				   {val: 'service', dispName: 'Service'}, 
				   {val: 'node', dispName: 'Node'}, 
				   {val: 'network', dispName: 'Network'}, 
				   {val: 'commPath', dispName: 'Comm Path'}, 
				   {val: 'artifact', dispName: 'Artifact'}, 
				   {val: 'sysSw', dispName: 'System Sw'}, 
				   {val: 'path', dispName: 'Path'},
				   {val: 'actor', dispName: 'Actor'}, 
				   {val: 'role', dispName: 'Role'}, 
				   {val: 'collab', dispName: 'Collaboration'}]
	}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMateApplication.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	c.translate(w - 20, 5);
	this.foreground(c, w - 20, 5, 15, 15);
};

mxArchiMateApplication.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxArchiMateApplication.prototype.foreground = function(c, x, y, w, h)
{
	var type = mxUtils.getValue(this.style, mxArchiMateApplication.prototype.cst.TYPE, mxArchiMateApplication.prototype.cst.COMPONENT);
	
	c.setDashed(false);
	
	if (type === mxArchiMateApplication.prototype.cst.COMPONENT)
	{
		c.translate(1, 0);
		w = w - 2;

		c.rect(w * 0.25, 0, w * 0.75, h);
		c.stroke();
		
		c.rect(0, h * 0.25, w * 0.5, h * 0.15);
		c.fillAndStroke();
		
		c.rect(0, h * 0.6, w * 0.5, h * 0.15);
		c.fillAndStroke();
	}
	else if (type === mxArchiMateApplication.prototype.cst.COLLABORATION)
	{
		c.translate(0, 3);
		h = h - 6;
		
		c.ellipse(0, 0, w * 0.6, h);
		c.stroke();
		c.ellipse(w * 0.4, 0, w * 0.6, h);
		c.fillAndStroke();
	}
	else if (type === mxArchiMateApplication.prototype.cst.INTERFACE)
	{
		c.translate(0, 4);
		h = h - 8;
		
		c.ellipse(w * 0.5, 0, w * 0.5, h);
		c.stroke();
		
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w * 0.5, h * 0.5);
		c.stroke();
	}
	else if (type === mxArchiMateApplication.prototype.cst.INTERFACE2)
	{
		c.translate(0, 1);
		h = h - 2;
		
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w * 0.6, h * 0.5);
		c.moveTo(w, 0);
		c.arcTo(w * 0.4, h * 0.5, 0, 0, 0, w, h);
		c.stroke();
	}
	else if (type === mxArchiMateApplication.prototype.cst.FUNCTION)
	{
		c.begin();
		c.moveTo(w * 0.5, 0);
		c.lineTo(w, h * 0.2);
		c.lineTo(w, h);
		c.lineTo(w * 0.5, h * 0.8);
		c.lineTo(0, h);
		c.lineTo(0, h * 0.2);
		c.close();
		c.stroke();
	}
	else if (type === mxArchiMateApplication.prototype.cst.INTERACTION)
	{
		c.begin();
		c.moveTo(w * 0.55, 0);
		c.arcTo(w * 0.45, h * 0.5, 0, 0, 1, w * 0.55, h);
		c.close();
		c.moveTo(w * 0.45, 0);
		c.arcTo(w * 0.45, h * 0.5, 0, 0, 0, w * 0.45, h);
		c.close();
		c.stroke();
	}
	else if (type === mxArchiMateApplication.prototype.cst.SERVICE)
	{
		c.translate(0, 3);
		h = h - 6;
		
		c.begin();
		c.moveTo(w - h * 0.5, 0);
		c.arcTo(h * 0.5, h * 0.5, 0, 0, 1, w - h * 0.5, h);
		c.lineTo(0, h);
		c.arcTo(h * 0.5, h * 0.5, 0, 0, 1, 0, 0);
		c.close();
		c.stroke();
	}
	else if (type === mxArchiMateApplication.prototype.cst.NODE)
	{
		c.begin();
		c.moveTo(0, h * 0.25);
		c.lineTo(w * 0.25, 0);
		c.lineTo(w, 0);
		c.lineTo(w, h * 0.75);
		c.lineTo(w * 0.75, h);
		c.lineTo(0, h);
		c.close();
		c.moveTo(0, h * 0.25);
		c.lineTo(w * 0.75, h * 0.25);
		c.lineTo(w * 0.75, h);
		c.moveTo(w, 0);
		c.lineTo(w * 0.75, h * 0.25);
		c.stroke();
	}
	else if (type === mxArchiMateApplication.prototype.cst.NETWORK)
	{
		c.translate(0, 2);
		h = h - 4;
		
		c.begin();
		c.moveTo(w * 0.4, h * 0.2);
		c.lineTo(w * 0.85, h * 0.2);
		c.lineTo(w * 0.6, h * 0.8);
		c.lineTo(w * 0.15, h * 0.8);
		c.close();
		c.stroke();
		
		var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
		c.setFillColor(strokeColor);
		
		c.ellipse(w * 0.25, 0, w * 0.3, h * 0.4);
		c.fill();
		
		c.ellipse(w * 0.7, 0, w * 0.3, h * 0.4);
		c.fill();
		
		c.ellipse(0, h * 0.6, w * 0.3, h * 0.4);
		c.fill();
		
		c.ellipse(w * 0.45, h * 0.6, w * 0.3, h * 0.4);
		c.fill();
	}
	else if (type === mxArchiMateApplication.prototype.cst.COMM_PATH)
	{
		c.translate(0, 5);
		h = h - 10;
		
		c.begin();
		c.moveTo(w * 0.1, 0);
		c.lineTo(0, h * 0.5);
		c.lineTo(w * 0.1, h);
		c.moveTo(w * 0.9, 0);
		c.lineTo(w, h * 0.5);
		c.lineTo(w * 0.9, h);
		c.stroke();
		
		c.setDashed(true);
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
	else if (type === mxArchiMateApplication.prototype.cst.SYS_SW)
	{
		c.ellipse(w * 0.3, 0, w * 0.7, h * 0.7);
		c.stroke();
		
		c.ellipse(0, h * 0.02, w * 0.98, h * 0.98);
		c.fillAndStroke();
	}
	else if (type === mxArchiMateApplication.prototype.cst.ARTIFACT)
	{
		c.translate(2, 0);
		w = w - 4;

		c.begin();
		c.moveTo(0, 0);
		c.lineTo(w * 0.7, 0);
		c.lineTo(w, h * 0.22);
		c.lineTo(w, h);
		c.lineTo(0, h);
		c.close();
		c.moveTo(w * 0.7, 0);
		c.lineTo(w * 0.7, h * 0.22);
		c.lineTo(w, h * 0.22);
		c.stroke();
	}
	else if (type === mxArchiMateApplication.prototype.cst.ACTOR)
	{
		c.translate(3, 0);
		w = w - 6;
		c.ellipse(w * 0.2, 0, w * 0.6, h * 0.3);
		c.stroke();
		
		c.begin();
		c.moveTo(w * 0.5, h * 0.3);
		c.lineTo(w * 0.5, h * 0.75);
		c.moveTo(0, h * 0.45);
		c.lineTo(w, h * 0.45);
		c.moveTo(0, h);
		c.lineTo(w * 0.5, h * 0.75);
		c.lineTo(w, h);
		c.stroke();
	}
	if (type === mxArchiMateApplication.prototype.cst.ROLE)
	{
		c.translate(0, 4);
		h = h - 8;

		c.begin();
		c.moveTo(w * 0.8, 0);
		c.lineTo(w * 0.2, 0);
		c.arcTo(w * 0.2, h * 0.5, 0, 0, 0, w * 0.2, h);
		c.lineTo(w * 0.8, h);
		c.stroke();
		
		c.ellipse(w * 0.6, 0, w * 0.4, h);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxArchiMateApplication.prototype.cst.APPLICATION, mxArchiMateApplication);

mxArchiMateApplication.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Tech
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMateTech(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMateTech, mxShape);

mxArchiMateTech.prototype.cst = {
		TECH : 'mxgraph.archimate.tech',
		TYPE : 'techType',
		DEVICE : 'device',
		PLATEAU : 'plateau'
};

mxArchiMateTech.prototype.customProperties = [
	{name: 'techType', dispName: 'Tech Type', type: 'enum', 
		enumList: [{val: 'device', dispName: 'Device'}, 
				   {val: 'plateau', dispName: 'Plateau'}]
	}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMateTech.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	c.translate(w - 30, 15);
	this.foreground(c, w - 30, 15, 15, 15);
};

mxArchiMateTech.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 10);
	c.lineTo(10, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h - 10);
	c.lineTo(w - 10, h);
	c.lineTo(0, h);
	c.close();
	c.moveTo(0, 10);
	c.lineTo(w - 10, 10);
	c.lineTo(w - 10, h);
	c.moveTo(w, 0);
	c.lineTo(w - 10, 10);
	c.fillAndStroke();
};

mxArchiMateTech.prototype.foreground = function(c, x, y, w, h)
{
	var type = mxUtils.getValue(this.style, mxArchiMateTech.prototype.cst.TYPE, mxArchiMateTech.prototype.cst.DEVICE);
	
	c.setDashed(false);
	
	if (type === mxArchiMateTech.prototype.cst.DEVICE)
	{
		c.roundrect(0, 0, w, h * 0.88, w * 0.05, h * 0.05);
		c.stroke();
		c.begin();
		c.moveTo(w * 0.1, h * 0.88);
		c.lineTo(0, h);
		c.lineTo(w, h);
		c.lineTo(w * 0.9, h * 0.88);
		c.stroke();
	}
	else if (type === mxArchiMateTech.prototype.cst.PLATEAU)
	{
		var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
		c.setFillColor(strokeColor);
		
		c.rect(w * 0.4, 0, w * 0.6, h * 0.2);
		c.fill();
		
		c.rect(w * 0.2, h * 0.4, w * 0.6, h * 0.2);
		c.fill();
		
		c.rect(0, h * 0.8, w * 0.6, h * 0.2);
		c.fill();
	}
};

mxCellRenderer.registerShape(mxArchiMateTech.prototype.cst.TECH, mxArchiMateTech);

mxArchiMateTech.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, 10));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 10, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false, null, 0, -10));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false, null, -10, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Motivational
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMateMotivational(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMateMotivational, mxShape);

mxArchiMateMotivational.prototype.cst = {
		MOTIV : 'mxgraph.archimate.motiv',
		TYPE : 'motivType',
		STAKE : 'stake',
		DRIVER : 'driver',
		ASSESSMENT : 'assess',
		GOAL : 'goal',
		REQUIREMENT : 'req',
		CONSTRAINT : 'const',
		PRINCIPLE : 'princ'
};

mxArchiMateMotivational.prototype.customProperties = [
	{name: 'motivType', dispName: 'Motivational Type', type: 'enum', 
		enumList: [{val: 'stake', dispName: 'Stake'}, 
				   {val: 'driver', dispName: 'Driver'},
				   {val: 'assess', dispName: 'Assessment'},
				   {val: 'goal', dispName: 'Goal'},
				   {val: 'req', dispName: 'Requirement'},
				   {val: 'const', dispName: 'Constraint'},
				   {val: 'princ', dispName: 'Principle'}]
	}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMateMotivational.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	c.translate(w - 20, 5);
	this.foreground(c, w - 20, 5, 15, 15);
};

mxArchiMateMotivational.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(10, 0);
	c.lineTo(w - 10, 0);
	c.lineTo(w, 10);
	c.lineTo(w, h - 10);
	c.lineTo(w - 10, h);
	c.lineTo(10, h);
	c.lineTo(0, h - 10);
	c.lineTo(0, 10);
	c.close();
	c.fillAndStroke();
};

mxArchiMateMotivational.prototype.foreground = function(c, x, y, w, h)
{
	var type = mxUtils.getValue(this.style, mxArchiMateMotivational.prototype.cst.TYPE, mxArchiMateMotivational.prototype.cst.STAKE);
	
	c.setDashed(false);
	
	if (type === mxArchiMateMotivational.prototype.cst.STAKE)
	{
		c.translate(0, 4);
		h = h - 8;

		c.begin();
		c.moveTo(w * 0.8, 0);
		c.lineTo(w * 0.2, 0);
		c.arcTo(w * 0.2, h * 0.5, 0, 0, 0, w * 0.2, h);
		c.lineTo(w * 0.8, h);
		c.stroke();
		
		c.ellipse(w * 0.6, 0, w * 0.4, h);
		c.stroke();
	}
	else if (type === mxArchiMateMotivational.prototype.cst.DRIVER)
	{
		c.ellipse(w * 0.1, h * 0.1, w * 0.8, h * 0.8);
		c.stroke();
		
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.moveTo(w * 0.5, 0);
		c.lineTo(w * 0.5, h);
		c.moveTo(w * 0.145, h * 0.145);
		c.lineTo(w * 0.855, h * 0.855);
		c.moveTo(w * 0.145, h * 0.855);
		c.lineTo(w * 0.855, h * 0.145);
		c.stroke();
		
		var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
		c.setFillColor(strokeColor);
		
		c.ellipse(w * 0.35, h * 0.35, w * 0.3, h * 0.3);
		c.fillAndStroke();
	}
	else if (type === mxArchiMateMotivational.prototype.cst.ASSESSMENT)
	{
		c.ellipse(w * 0.2, 0, w * 0.8, h * 0.8);
		c.stroke();
		
		c.begin();
		c.moveTo(0, h);
		c.lineTo(w * 0.32, h * 0.68);
		c.stroke();
	}
	else if (type === mxArchiMateMotivational.prototype.cst.GOAL)
	{
		c.ellipse(0, 0, w, h);
		c.stroke();
		c.ellipse(w * 0.15, h * 0.15, w * 0.7, h * 0.7);
		c.stroke();
		var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
		c.setFillColor(strokeColor);
		c.ellipse(w * 0.3, h * 0.3, w * 0.4, h * 0.4);
		c.fillAndStroke();
	}
	else if (type === mxArchiMateMotivational.prototype.cst.REQUIREMENT)
	{
		c.translate(0, 4);
		h = h - 8;

		c.begin();
		c.moveTo(w * 0.25, 0);
		c.lineTo(w, 0);
		c.lineTo(w * 0.75, h);
		c.lineTo(0, h);
		c.close();
		c.stroke();
	}
	else if (type === mxArchiMateMotivational.prototype.cst.CONSTRAINT)
	{
		c.translate(0, 4);
		h = h - 8;

		c.begin();
		c.moveTo(w * 0.25, 0);
		c.lineTo(w, 0);
		c.lineTo(w * 0.75, h);
		c.lineTo(0, h);
		c.close();
		c.moveTo(w * 0.45, 0);
		c.lineTo(w * 0.2, h);
		c.stroke();
	}
	else if (type === mxArchiMateMotivational.prototype.cst.PRINCIPLE)
	{
		c.begin();
		c.moveTo(w * 0.05, h * 0.05);
		c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * 0.95, h * 0.05);
		c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * 0.95, h * 0.95);
		c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * 0.05, h * 0.95);
		c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * 0.05, h * 0.05);
		c.close();
		c.stroke();
		
		var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
		c.setFillColor(strokeColor);
		
		c.begin();
		c.moveTo(w * 0.45, h * 0.7);
		c.lineTo(w * 0.42, h * 0.15);
		c.lineTo(w * 0.58, h * 0.15);
		c.lineTo(w * 0.55, h * 0.7);
		c.close();
		c.fill();
		
		c.rect(w * 0.45, h * 0.75, w * 0.1, h * 0.1);
		c.fill();
	}
};

mxCellRenderer.registerShape(mxArchiMateMotivational.prototype.cst.MOTIV, mxArchiMateMotivational);

mxArchiMateMotivational.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 5, 5));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, -5, 5));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false, null, -5, -5));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, 5, -5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Gap
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMateGap(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMateGap, mxShape);

mxArchiMateGap.prototype.cst = {
		GAP : 'mxgraph.archimate.gap'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMateGap.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	c.translate(w - 20, 5);
	this.foreground(c, w - 20, 5, 15, 15);
};

mxArchiMateGap.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h * 0.85);
	c.arcTo(w * 0.35, h * 0.35, 0, 0, 0, w * 0.5, h * 0.85);
	c.arcTo(w * 0.35, h * 0.35, 0, 0, 1, 0, h * 0.85);
	c.close();
	c.fillAndStroke();
};

mxArchiMateGap.prototype.foreground = function(c, x, y, w, h)
{
	c.setDashed(false);
	
	c.translate(0, 2);
	h = h - 4;

	c.ellipse(w * 0.15, 0, w * 0.7, h);
	c.stroke();
	
	c.begin();
	c.moveTo(0, h * 0.35);
	c.lineTo(w, h * 0.35);
	c.moveTo(0, h * 0.65);
	c.lineTo(w, h * 0.65);
	c.stroke();
};

mxCellRenderer.registerShape(mxArchiMateGap.prototype.cst.GAP, mxArchiMateGap);

mxArchiMateGap.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.85), false, null));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0.745), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.85), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0.955), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.85), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

/**
 * $Id: mxArchiMate3.js,v 1.0 2016/08/18 07:05:39 mate Exp $
 * Copyright (c) 2006-2016, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Application
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Application(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Application, mxShape);

mxArchiMate3Application.prototype.cst = {
		APPLICATION : 'mxgraph.archimate3.application',
		TYPE : 'appType',
		COMPONENT : 'comp',
		COLLABORATION : 'collab',
		INTERFACE : 'interface',
		INTERFACE2 : 'interface2',
		LOCATION : 'location',
		FUNCTION : 'func',
		INTERACTION : 'interaction',
		SERVICE : 'serv',
		EVENT : 'event',
		EVENT2 : 'event2',
		NODE : 'node',
		NETWORK : 'netw',
		COMM_PATH : 'commPath',
		ACTOR : 'actor',
		ASSESSMENT : 'assess',
		GOAL : 'goal',
		OUTCOME : 'outcome',
		ROLE : 'role',
		PROCESS : 'proc',
		DRIVER : 'driver',
		PRINCIPLE : 'principle',
		REQUIREMENT : 'requirement',
		CONSTRAINT : 'constraint',
		RESOURCE : 'resource',
		CAPABILITY : 'capability',
		COURSE : 'course',
		MATERIAL : 'material',
		DISTRIBUTION : 'distribution',
		SYS_SW : 'sysSw',
		ARTIFACT : 'artifact',
		PATH : 'path',
		ARCHI_TYPE : 'archiType',
		TYPE_SQUARE : 'square',
		TYPE_ROUNDED : 'rounded',
		TYPE_OCT : 'oct'
};

mxArchiMate3Application.prototype.customProperties = [
	{name: 'archiType', dispName: 'Type', type: 'enum', 
		enumList: [{val: 'square', dispName: 'Square'}, 
			       {val: 'rounded', dispName: 'Rounded'}, 
			       {val: 'oct', dispName: 'Octagonal'}]
	},
	{name: 'appType', dispName: 'App Type', type: 'enum', 
		enumList: [{val: 'comp', dispName: 'Component'}, 
				   {val: 'collab', dispName: 'Collaboration'}, 
				   {val: 'interface', dispName: 'Interface'}, 
				   {val: 'interface2', dispName: 'Interface2'}, 
				   {val: 'func', dispName: 'Function'}, 
				   {val: 'interaction', dispName: 'Interaction'}, 
				   {val: 'location', dispName: 'Location'}, 
				   {val: 'serv', dispName: 'Service'}, 
				   {val: 'event', dispName: 'Event'}, 
				   {val: 'event2', dispName: 'Event2'}, 
				   {val: 'node', dispName: 'Node'}, 
				   {val: 'netw', dispName: 'Network'}, 
				   {val: 'commPath', dispName: 'Comm Path'}, 
				   {val: 'actor', dispName: 'Actor'}, 
				   {val: 'assess', dispName: 'Assessment'}, 
				   {val: 'goal', dispName: 'Goal'}, 
				   {val: 'outcome', dispName: 'Outcome'}, 
				   {val: 'role', dispName: 'Role'}, 
				   {val: 'proc', dispName: 'Process'}, 
				   {val: 'driver', dispName: 'Driver'}, 
				   {val: 'principle', dispName: 'Principle'}, 
				   {val: 'requirement', dispName: 'Requirement'}, 
				   {val: 'constraint', dispName: 'Constraint'}, 
				   {val: 'resource', dispName: 'Resource'}, 
				   {val: 'capability', dispName: 'Capability'}, 
				   {val: 'course', dispName: 'Course'}, 
				   {val: 'material', dispName: 'Material'}, 
				   {val: 'distribution', dispName: 'Distribution'}, 
				   {val: 'sysSw', dispName: 'System Sw'}, 
				   {val: 'artifact', dispName: 'Artifact'}, 
				   {val: 'path', dispName: 'Path'}]
}];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Application.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	c.translate(w - 20, 5);
	this.foreground(c, w - 20, 5, 15, 15);
};

mxArchiMate3Application.prototype.background = function(c, x, y, w, h)
{
	var archiType = mxUtils.getValue(this.style, mxArchiMate3Application.prototype.cst.ARCHI_TYPE, 'square');

	if (archiType === 'rounded')
	{
		c.roundrect(0, 0, w, h, 10, 10);
	}
	else if ((archiType === 'oct') && w >= 20 && h >= 20)
	{
		c.begin();
		c.moveTo(0, 10);
		c.lineTo(10, 0);
		c.lineTo(w - 10, 0);
		c.lineTo(w, 10);
		c.lineTo(w, h - 10);
		c.lineTo(w - 10, h);
		c.lineTo(10, h);
		c.lineTo(0, h - 10);
		c.close();
		c.fillAndStroke();
	}
	else
	{
		c.rect(0, 0, w, h);
	}

	c.fillAndStroke();
};

mxArchiMate3Application.prototype.foreground = function(c, x, y, w, h)
{
	var type = mxUtils.getValue(this.style, mxArchiMate3Application.prototype.cst.TYPE, '');
	
	c.setDashed(false);
	
	if (type === mxArchiMate3Application.prototype.cst.COMPONENT)
	{
		c.translate(1, 0);
		w = w - 2;

		mxArchiMate3Component.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.COLLABORATION)
	{
		c.translate(0, 3);
		h = h - 6;
		
		mxArchiMate3Collaboration.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.INTERFACE)
	{
		c.translate(0, 4);
		h = h - 8;
		
		mxArchiMate3Interface.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.INTERFACE2)
	{
		c.translate(0, 1);
		h = h - 2;
		
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w * 0.6, h * 0.5);
		c.moveTo(w, 0);
		c.arcTo(w * 0.4, h * 0.5, 0, 0, 0, w, h);
		c.stroke();
	}
	else if (type === mxArchiMate3Application.prototype.cst.FUNCTION)
	{
		mxArchiMate3Function.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.INTERACTION)
	{
		mxArchiMate3Interaction.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.LOCATION)
	{
		c.translate(3, 0);
		w = w - 6;
		c.begin();
		c.moveTo(w * 0.5, h);
		c.arcTo(w * 0.1775, h * 0.3, 0, 0, 0, w * 0.345, h * 0.7);
		c.arcTo(w * 0.538, h * 0.364, 0, 0, 1, w * 0.5, 0);
		c.arcTo(w * 0.538, h * 0.364, 0, 0, 1, w * 0.655, h * 0.7);
		c.arcTo(w * 0.1775, h * 0.3, 0, 0, 0, w * 0.5, h);
		c.stroke();
	}
	else if (type === mxArchiMate3Application.prototype.cst.SERVICE)
	{
		c.translate(0, 3);
		h = h - 6;
		
		mxArchiMate3Service.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.EVENT)
	{
		c.translate(0, 3);
		h = h - 6;
		
		mxArchiMate3Event.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.EVENT2)
	{
		c.translate(0, 3);
		h = h - 6;
		
		mxArchiMate3Event2.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.NODE)
	{
		mxArchiMate3Node.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.NETWORK)
	{
		c.translate(0, 2);
		h = h - 4;
		
		c.begin();
		c.moveTo(w * 0.4, h * 0.2);
		c.lineTo(w * 0.85, h * 0.2);
		c.lineTo(w * 0.6, h * 0.8);
		c.lineTo(w * 0.15, h * 0.8);
		c.close();
		c.stroke();
		
		var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
		c.setFillColor(strokeColor);
		
		c.ellipse(w * 0.25, 0, w * 0.3, h * 0.4);
		c.fill();
		
		c.ellipse(w * 0.7, 0, w * 0.3, h * 0.4);
		c.fill();
		
		c.ellipse(0, h * 0.6, w * 0.3, h * 0.4);
		c.fill();
		
		c.ellipse(w * 0.45, h * 0.6, w * 0.3, h * 0.4);
		c.fill();
	}
	else if (type === mxArchiMate3Application.prototype.cst.COMM_PATH)
	{
		c.translate(0, 5);
		h = h - 10;
		
		c.begin();
		c.moveTo(w * 0.1, 0);
		c.lineTo(0, h * 0.5);
		c.lineTo(w * 0.1, h);
		c.moveTo(w * 0.9, 0);
		c.lineTo(w, h * 0.5);
		c.lineTo(w * 0.9, h);
		c.stroke();
		
		c.setDashed(true);
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
	else if (type === mxArchiMate3Application.prototype.cst.ARTIFACT)
	{
		c.translate(2, 0);
		w = w - 4;

		c.begin();
		c.moveTo(0, 0);
		c.lineTo(w * 0.7, 0);
		c.lineTo(w, h * 0.22);
		c.lineTo(w, h);
		c.lineTo(0, h);
		c.close();
		c.moveTo(w * 0.7, 0);
		c.lineTo(w * 0.7, h * 0.22);
		c.lineTo(w, h * 0.22);
		c.stroke();
	}
	else if (type === mxArchiMate3Application.prototype.cst.ACTOR)
	{
		c.translate(3, 0);
		w = w - 6;
		
		mxArchiMate3Actor.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.ROLE)
	{
		c.translate(0, 4);
		h = h - 8;

		mxArchiMate3Role.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.PROCESS)
	{
		c.translate(0, 3);
		h = h - 6;

		mxArchiMate3Process.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.DRIVER)
	{
		c.ellipse(w * 0.1, h * 0.1, w * 0.8, h * 0.8);
		c.stroke();
		
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.moveTo(w * 0.5, 0);
		c.lineTo(w * 0.5, h);
		c.moveTo(w * 0.145, h * 0.145);
		c.lineTo(w * 0.855, h * 0.855);
		c.moveTo(w * 0.145, h * 0.855);
		c.lineTo(w * 0.855, h * 0.145);
		c.stroke();
		
		var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
		c.setFillColor(strokeColor);
		
		c.ellipse(w * 0.35, h * 0.35, w * 0.3, h * 0.3);
		c.fillAndStroke();
	}
	else if (type === mxArchiMate3Application.prototype.cst.ASSESSMENT)
	{
		c.ellipse(w * 0.2, 0, w * 0.8, h * 0.8);
		c.stroke();
		
		c.begin();
		c.moveTo(0, h);
		c.lineTo(w * 0.32, h * 0.68);
		c.stroke();
	}
	else if (type === mxArchiMate3Application.prototype.cst.GOAL)
	{
		c.ellipse(0, 0, w, h);
		c.stroke();
		c.ellipse(w * 0.15, h * 0.15, w * 0.7, h * 0.7);
		c.stroke();
		var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
		c.setFillColor(strokeColor);
		c.ellipse(w * 0.3, h * 0.3, w * 0.4, h * 0.4);
		c.fillAndStroke();
	}
	else if (type === mxArchiMate3Application.prototype.cst.OUTCOME)
	{
		c.ellipse(0, w * 0.2, w * 0.8, h * 0.8);
		c.stroke();
		c.ellipse(w * 0.15, w * 0.35, w * 0.5, h * 0.5);
		c.stroke();
		c.ellipse(w * 0.3, w * 0.5, w * 0.2, h * 0.2);
		c.stroke();
		
		c.begin();
		c.moveTo(w * 0.4, h * 0.6);
		c.lineTo(w * 0.9, h * 0.1);
		c.moveTo(w * 0.42, h * 0.4);
		c.lineTo(w * 0.4, h * 0.6);
		c.lineTo(w * 0.6, h * 0.58);
		c.moveTo(w * 0.8, 0);
		c.lineTo(w * 0.75, h * 0.25);
		c.lineTo(w, h * 0.2);
		c.stroke();
	}
	else if (type === mxArchiMate3Application.prototype.cst.PRINCIPLE)
	{
		c.begin();
		c.moveTo(w * 0.05, h * 0.05);
		c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * 0.95, h * 0.05);
		c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * 0.95, h * 0.95);
		c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * 0.05, h * 0.95);
		c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * 0.05, h * 0.05);
		c.close();
		c.stroke();
		
		var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
		c.setFillColor(strokeColor);
		
		c.begin();
		c.moveTo(w * 0.45, h * 0.7);
		c.lineTo(w * 0.42, h * 0.15);
		c.lineTo(w * 0.58, h * 0.15);
		c.lineTo(w * 0.55, h * 0.7);
		c.close();
		c.fill();
		
		c.rect(w * 0.45, h * 0.75, w * 0.1, h * 0.1);
		c.fill();
	}
	else if (type === mxArchiMate3Application.prototype.cst.REQUIREMENT)
	{
		c.translate(0, 4);
		h = h - 8;

		mxArchiMate3Requirement.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.CONSTRAINT)
	{
		c.translate(0, 4);
		h = h - 8;

		mxArchiMate3Constraint.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.MATERIAL)
	{
		c.translate(0, 1);
		h = h - 2;
		
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w * 0.25, 0);
		c.lineTo(w * 0.75, 0);
		c.lineTo(w, h * 0.5);
		c.lineTo(w * 0.75, h);
		c.lineTo(w * 0.25, h);
		c.close();
		c.moveTo(w * 0.15, h * 0.5);
		c.lineTo(w * 0.31, h * 0.2);
		c.moveTo(w * 0.69, h * 0.2);
		c.lineTo(w * 0.85, h * 0.5);
		c.moveTo(w * 0.68, h * 0.80);
		c.lineTo(w * 0.32, h * 0.80);
		c.stroke();
	}
	else if (type === mxArchiMate3Application.prototype.cst.DISTRIBUTION)
	{
		c.translate(0, 4);
		h = h - 8;
		
		mxArchiMate3Distribution.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.RESOURCE)
	{
		c.translate(0, 1);
		h = h - 2;
		
		mxArchiMate3Resource.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.CAPABILITY)
	{
		mxArchiMate3Capability.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.COURSE)
	{
		mxArchiMate3Course.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.SYS_SW)
	{
		mxArchiMate3SysSw.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.ARTIFACT)
	{
		c.translate(2, 0);
		w = w - 4;
		
		mxArchiMate3Artifact.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Application.prototype.cst.PATH)
	{
		c.translate(0, 5);
		h = h - 10;
		
		mxArchiMate3Path.prototype.background(c, x, y, w, h);
	}
};

mxCellRenderer.registerShape(mxArchiMate3Application.prototype.cst.APPLICATION, mxArchiMate3Application);

mxArchiMate3Application.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var archiType = mxUtils.getValue(this.style, mxArchiMate3Application.prototype.cst.ARCHI_TYPE, 'square');

	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	if (archiType === 'rounded')
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2.9, 2.9));
		constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, -2.9, 2.9));
		constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false, null, -2.9, -2.9));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, 2.9, -2.9));
	}
	else if ((archiType === 'oct') && w >= 20 && h >= 20)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 5, 5));
		constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, -5, 5));
		constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false, null, -5, -5));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, 5, -5));
	}
	else
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
		constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
		constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	}

	return (constr);
};

//**********************************************************************************************************************************************************
//Component
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Component(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Component, mxShape);

mxArchiMate3Component.prototype.cst = {
		COMPONENT : 'mxgraph.archimate3.component'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Component.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Component.prototype.background = function(c, x, y, w, h)
{
	c.rect(w * 0.25, 0, w * 0.75, h);
	c.fillAndStroke();
	
	c.rect(0, h * 0.25, w * 0.5, h * 0.15);
	c.fillAndStroke();
	
	c.rect(0, h * 0.6, w * 0.5, h * 0.15);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3Component.prototype.cst.COMPONENT, mxArchiMate3Component);

mxArchiMate3Component.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.625, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.625, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.325), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.675), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Collaboration
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Collaboration(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Collaboration, mxShape);

mxArchiMate3Collaboration.prototype.cst = {
		COLLABORATION : 'mxgraph.archimate3.collaboration'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Collaboration.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Collaboration.prototype.background = function(c, x, y, w, h)
{
	c.ellipse(0, 0, w * 0.6, h);
	c.fillAndStroke();
	c.ellipse(w * 0.4, 0, w * 0.6, h);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3Collaboration.prototype.cst.COLLABORATION, mxArchiMate3Collaboration);

mxArchiMate3Collaboration.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.11, 0.11), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.125), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.89, 0.11), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.11, 0.89), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.875), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.89, 0.89), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.3, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.7, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.3, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.7, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Interface
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Interface(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Interface, mxShape);

mxArchiMate3Interface.prototype.cst = {
		INTERFACE : 'mxgraph.archimate3.interface'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Interface.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Interface.prototype.background = function(c, x, y, w, h)
{
	c.ellipse(w * 0.5, 0, w * 0.5, h);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w * 0.5, h * 0.5);
	c.stroke();
};

mxCellRenderer.registerShape(mxArchiMate3Interface.prototype.cst.INTERFACE, mxArchiMate3Interface);

mxArchiMate3Interface.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Process
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Process(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Process, mxShape);

mxArchiMate3Process.prototype.cst = {
		PROCESS : 'mxgraph.archimate3.process'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Process.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Process.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, h * 0.3);
	c.lineTo(w * 0.6, h * 0.3);
	c.lineTo(w * 0.6, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w * 0.6, h);
	c.lineTo(w * 0.6, h * 0.7);
	c.lineTo(0, h * 0.7);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3Process.prototype.cst.PROCESS, mxArchiMate3Process);

mxArchiMate3Process.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.3), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.3, 0.3), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.6, 0.3), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.6, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.6, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.6, 0.7), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.3, 0.7), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.7), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Function
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Function(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Function, mxShape);

mxArchiMate3Function.prototype.cst = {
		FUNCTION : 'mxgraph.archimate3.function'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Function.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Function.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(w * 0.5, 0);
	c.lineTo(w, h * 0.2);
	c.lineTo(w, h);
	c.lineTo(w * 0.5, h * 0.8);
	c.lineTo(0, h);
	c.lineTo(0, h * 0.2);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3Function.prototype.cst.FUNCTION, mxArchiMate3Function);

mxArchiMate3Function.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.2), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.6), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.8), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.6), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.2), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Interaction
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Interaction(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Interaction, mxShape);

mxArchiMate3Interaction.prototype.cst = {
		INTERACTION : 'mxgraph.archimate3.interaction'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Interaction.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Interaction.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(w * 0.55, 0);
	c.arcTo(w * 0.45, h * 0.5, 0, 0, 1, w * 0.55, h);
	c.close();
	c.moveTo(w * 0.45, 0);
	c.arcTo(w * 0.45, h * 0.5, 0, 0, 0, w * 0.45, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3Interaction.prototype.cst.INTERACTION, mxArchiMate3Interaction);

mxArchiMate3Interaction.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.86, 0.14), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.86, 0.86), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.14, 0.86), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.14, 0.14), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Service
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Service(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Service, mxShape);

mxArchiMate3Service.prototype.cst = {
		SERVICE : 'mxgraph.archimate3.service'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Service.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Service.prototype.background = function(c, x, y, w, h)
{
	var w1 = Math.max(w - h * 0.5, w * 0.5);
	var w2 = Math.min(h * 0.5, w * 0.5);
	
	c.begin();
	c.moveTo(w1, 0);
	c.arcTo(h * 0.5, h * 0.5, 0, 0, 1, w1, h);
	c.lineTo(w2, h);
	c.arcTo(h * 0.5, h * 0.5, 0, 0, 1, w2, 0);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3Service.prototype.cst.SERVICE, mxArchiMate3Service);

mxArchiMate3Service.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var w1 = Math.max(w - h * 0.5, w * 0.5);
	var w2 = Math.min(h * 0.5, w * 0.5);
	
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w1, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w1, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w2, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w2, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w1 + h * 0.355, h * 0.145));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w1 + h * 0.5, h * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w1 + h * 0.355, h * 0.855));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w2 - h * 0.355, h * 0.145));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w2 - h * 0.5, h * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w2 - h * 0.355, h * 0.855));

	return (constr);
};

//**********************************************************************************************************************************************************
//Requirement
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Requirement(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Requirement, mxShape);

mxArchiMate3Requirement.prototype.cst = {
		REQUIREMENT : 'mxgraph.archimate3.requirement'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Requirement.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Requirement.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(w * 0.25, 0);
	c.lineTo(w, 0);
	c.lineTo(w * 0.75, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3Requirement.prototype.cst.REQUIREMENT, mxArchiMate3Requirement);

mxArchiMate3Requirement.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.9375, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.875, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.8125, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.0625, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.125, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.1875, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Constraint
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Constraint(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Constraint, mxShape);

mxArchiMate3Constraint.prototype.cst = {
		CONSTRAINT : 'mxgraph.archimate3.constraint'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Constraint.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Constraint.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(w * 0.25, 0);
	c.lineTo(w, 0);
	c.lineTo(w * 0.75, h);
	c.lineTo(0, h);
	c.close();
	c.moveTo(w * 0.45, 0);
	c.lineTo(w * 0.2, h);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3Constraint.prototype.cst.CONSTRAINT, mxArchiMate3Constraint);

mxArchiMate3Constraint.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.9375, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.875, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.8125, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.0625, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.125, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.1875, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Event
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Event(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Event, mxShape);

mxArchiMate3Event.prototype.cst = {
		EVENT : 'mxgraph.archimate3.event'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Event.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Event.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(w - h * 0.5, 0);
	c.arcTo(h * 0.5, h * 0.5, 0, 0, 1, w - h * 0.5, h);
	c.lineTo(0, h);
	c.lineTo(h * 0.5, h * 0.5);
	c.lineTo(0, 0);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3Event.prototype.cst.EVENT, mxArchiMate3Event);

mxArchiMate3Event.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var w1 = Math.max(w - h * 0.5, w * 0.5);
	var w2 = Math.min(h * 0.5, w * 0.5);
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - h * 0.5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - h * 0.5, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, h * 0.5, h * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - h * 0.5) * 0.5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - h * 0.5) * 0.5, h));

	return (constr);
};

//**********************************************************************************************************************************************************
//Event 2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Event2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Event2, mxShape);

mxArchiMate3Event2.prototype.cst = {
		EVENT2 : 'mxgraph.archimate3.event2'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Event2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Event2.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(w - h * 0.5, 0);
	c.arcTo(h * 0.5, h * 0.5, 0, 0, 1, w - h * 0.5, h);
	c.lineTo(0, h);
	c.arcTo(h * 0.5, h * 0.5, 0, 0, 0, 0, 0);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3Event2.prototype.cst.EVENT2, mxArchiMate3Event2);

//**********************************************************************************************************************************************************
//Actor
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Actor(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Actor, mxShape);

mxArchiMate3Actor.prototype.cst = {
		ACTOR : 'mxgraph.archimate3.actor'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Actor.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Actor.prototype.background = function(c, x, y, w, h)
{
	c.ellipse(w * 0.2, 0, w * 0.6, h * 0.3);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w * 0.5, h * 0.3);
	c.lineTo(w * 0.5, h * 0.75);
	c.moveTo(0, h * 0.45);
	c.lineTo(w, h * 0.45);
	c.moveTo(0, h);
	c.lineTo(w * 0.5, h * 0.75);
	c.lineTo(w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxArchiMate3Actor.prototype.cst.ACTOR, mxArchiMate3Actor);

mxArchiMate3Actor.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	
	constr.push(new mxConnectionConstraint(new mxPoint(0.2, 0.15), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.8, 0.15), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.45), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.45), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Role
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Role(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Role, mxShape);

mxArchiMate3Role.prototype.cst = {
		ROLE : 'mxgraph.archimate3.role'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Role.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Role.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(w * 0.8, 0);
	c.lineTo(w * 0.2, 0);
	c.arcTo(w * 0.2, h * 0.5, 0, 0, 0, w * 0.2, h);
	c.lineTo(w * 0.8, h);
	c.fillAndStroke();

	c.ellipse(w * 0.6, 0, w * 0.4, h);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3Role.prototype.cst.ROLE, mxArchiMate3Role);

mxArchiMate3Role.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	
	constr.push(new mxConnectionConstraint(new mxPoint(0.2, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.8, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.8, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.2, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Business Object
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3BusinessObject(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3BusinessObject, mxShape);

mxArchiMate3BusinessObject.prototype.cst = {
		BUSINESS_OBJECT : 'mxgraph.archimate3.businessObject'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3BusinessObject.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h);
};

mxArchiMate3BusinessObject.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxArchiMate3BusinessObject.prototype.foreground = function(c, x, y, w, h)
{
	if (h >= 15)
	{
		c.begin();
		c.moveTo(0, 15);
		c.lineTo(w, 15);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxArchiMate3BusinessObject.prototype.cst.BUSINESS_OBJECT, mxArchiMate3BusinessObject);

mxArchiMate3BusinessObject.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Contract
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Contract(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Contract, mxShape);

mxArchiMate3Contract.prototype.cst = {
		CONTRACT : 'mxgraph.archimate3.contract'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Contract.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h);
};

mxArchiMate3Contract.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxArchiMate3Contract.prototype.foreground = function(c, x, y, w, h)
{
	if (h >= 15)
	{
		c.begin();
		c.moveTo(0, 15);
		c.lineTo(w, 15);
		c.stroke();
	}
	
	if (h >= 30)
	{
		c.begin();
		c.moveTo(0, h - 15);
		c.lineTo(w,  h - 15);
		c.stroke();
	}

};

mxCellRenderer.registerShape(mxArchiMate3Contract.prototype.cst.CONTRACT, mxArchiMate3Contract);

mxArchiMate3Contract.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Product
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Product(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Product, mxShape);

mxArchiMate3Product.prototype.cst = {
		PRODUCT : 'mxgraph.archimate3.product'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Product.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h);
};

mxArchiMate3Product.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxArchiMate3Product.prototype.foreground = function(c, x, y, w, h)
{
	if (h >= 15)
	{
		c.begin();
		c.moveTo(0, 15);
		c.lineTo(w * 0.6, 15);
		c.lineTo(w * 0.6, 0);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxArchiMate3Product.prototype.cst.PRODUCT, mxArchiMate3Product);

mxArchiMate3Product.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Representation
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Representation(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Representation, mxShape);

mxArchiMate3Representation.prototype.cst = {
		REPRESENTATION : 'mxgraph.archimate3.representation'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Representation.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
};

mxArchiMate3Representation.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h * 0.85);
	c.arcTo(w * 0.35, h * 0.35, 0, 0, 0, w * 0.5, h * 0.85);
	c.arcTo(w * 0.35, h * 0.35, 0, 0, 1, 0, h * 0.85);
	c.close();
	c.fillAndStroke();
	
	if (h >= 20)
	c.begin();
	c.moveTo(0, 15);
	c.lineTo(w, 15);
	c.stroke();
};

mxCellRenderer.registerShape(mxArchiMate3Representation.prototype.cst.REPRESENTATION, mxArchiMate3Representation);

mxArchiMate3Representation.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.85), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0.745), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.85), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0.955), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.85), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Deliverable
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Deliverable(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Deliverable, mxShape);

mxArchiMate3Deliverable.prototype.cst = {
		DELIVERABLE : 'mxgraph.archimate3.deliverable'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Deliverable.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
};

mxArchiMate3Deliverable.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h * 0.85);
	c.arcTo(w * 0.35, h * 0.35, 0, 0, 0, w * 0.5, h * 0.85);
	c.arcTo(w * 0.35, h * 0.35, 0, 0, 1, 0, h * 0.85);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3Deliverable.prototype.cst.DELIVERABLE, mxArchiMate3Deliverable);

mxArchiMate3Deliverable.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.85), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0.745), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.85), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0.955), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.85), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Location
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Location(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Location, mxShape);

mxArchiMate3Location.prototype.cst = {
		LOCATION : 'mxgraph.archimate3.location'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Location.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	c.translate(w - 20, 5);
	this.foreground(c, w - 20, 5, 15, 15);
};

mxArchiMate3Location.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxArchiMate3Location.prototype.foreground = function(c, x, y, w, h)
{
	c.setDashed(false);
	
	c.translate(3 ,0);
	w = w - 6;
	c.begin();
	c.moveTo(w * 0.5, h);
	c.arcTo(w * 0.1775, h * 0.3, 0, 0, 0, w * 0.345, h * 0.7);
	c.arcTo(w * 0.538, h * 0.364, 0, 0, 1, w * 0.5, 0);
	c.arcTo(w * 0.538, h * 0.364, 0, 0, 1, w * 0.655, h * 0.7);
	c.arcTo(w * 0.1775, h * 0.3, 0, 0, 0, w * 0.5, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxArchiMate3Location.prototype.cst.LOCATION, mxArchiMate3Location);

//**********************************************************************************************************************************************************
//Gap
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Gap(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Gap, mxShape);

mxArchiMate3Gap.prototype.cst = {
		GAP : 'mxgraph.archimate3.gap'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Gap.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	c.translate(w - 20, 5);
	this.foreground(c, w - 20, 5, 15, 15);
};

mxArchiMate3Gap.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h * 0.85);
	c.arcTo(w * 0.35, h * 0.35, 0, 0, 0, w * 0.5, h * 0.85);
	c.arcTo(w * 0.35, h * 0.35, 0, 0, 1, 0, h * 0.85);
	c.close();
	c.fillAndStroke();
};

mxArchiMate3Gap.prototype.foreground = function(c, x, y, w, h)
{
	c.setDashed(false);
	
	c.translate(0, 2);
	h = h - 4;

	c.ellipse(w * 0.15, 0, w * 0.7, h);
	c.stroke();
	
	c.begin();
	c.moveTo(0, h * 0.35);
	c.lineTo(w, h * 0.35);
	c.moveTo(0, h * 0.65);
	c.lineTo(w, h * 0.65);
	c.stroke();
};

mxCellRenderer.registerShape(mxArchiMate3Gap.prototype.cst.GAP, mxArchiMate3Gap);

mxArchiMate3Gap.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.85), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0.745), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.85), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0.955), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.85), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Tech
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Tech(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Tech, mxShape);

mxArchiMate3Tech.prototype.cst = {
		TECH : 'mxgraph.archimate3.tech',
		TYPE : 'techType',
		DEVICE : 'device',
		PLATEAU : 'plateau',
		FACILITY : 'facility',
		EQUIPMENT : 'equipment',
		SYS_SW : 'sysSw'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Tech.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	c.translate(w - 30, 15);
	this.foreground(c, w - 30, 15, 15, 15);
};

mxArchiMate3Tech.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 10);
	c.lineTo(10, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h - 10);
	c.lineTo(w - 10, h);
	c.lineTo(0, h);
	c.close();
	c.moveTo(0, 10);
	c.lineTo(w - 10, 10);
	c.lineTo(w - 10, h);
	c.moveTo(w, 0);
	c.lineTo(w - 10, 10);
	c.fillAndStroke();
};

mxArchiMate3Tech.prototype.foreground = function(c, x, y, w, h)
{
	var type = mxUtils.getValue(this.style, mxArchiMate3Tech.prototype.cst.TYPE, mxArchiMate3Tech.prototype.cst.DEVICE);
	
	c.setDashed(false);
	
	if (type === mxArchiMate3Tech.prototype.cst.PLATEAU)
	{
		var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
		c.setFillColor(strokeColor);
		
		c.rect(w * 0.4, 0, w * 0.6, h * 0.2);
		c.fill();
		
		c.rect(w * 0.2, h * 0.4, w * 0.6, h * 0.2);
		c.fill();
		
		c.rect(0, h * 0.8, w * 0.6, h * 0.2);
		c.fill();
	}
	else if (type === mxArchiMate3Tech.prototype.cst.FACILITY)
	{
		c.begin();
		c.moveTo(0, h);
		c.lineTo(0, 0);
		c.lineTo(w * 0.13, 0);
		c.lineTo(w * 0.13, h * 0.7);
		c.lineTo(w * 0.42, h * 0.55);
		c.lineTo(w * 0.42, h * 0.7);
		c.lineTo(w * 0.71, h * 0.55);
		c.lineTo(w * 0.71, h * 0.7);
		c.lineTo(w, h * 0.55);
		c.lineTo(w, h);
		c.close();
		c.stroke();
	}
	else if (type === mxArchiMate3Tech.prototype.cst.EQUIPMENT)
	{
		c.begin();
		c.moveTo(w * 0.72, h * 0.38);
		c.curveTo(w * 0.78, w * 0.38, w * 0.85, h * 0.34, w * 0.85, h * 0.26);
		c.curveTo(w * 0.85, w * 0.18, w * 0.78, h * 0.14, w * 0.73, h * 0.14);
		c.curveTo(w * 0.64, w * 0.14, w * 0.59, h * 0.2, w * 0.59, h * 0.26);
		c.curveTo(w * 0.59, h * 0.33, w * 0.65, w * 0.38, w * 0.72, h * 0.38);
		c.close();
		c.moveTo(w * 0.68, h * 0.52);
		c.lineTo(w * 0.67, h * 0.45);
		c.lineTo(w * 0.61, h * 0.43);
		c.lineTo(w * 0.56, h * 0.48);
		c.lineTo(w * 0.5, h * 0.42);
		c.lineTo(w * 0.54, h * 0.36);
		c.lineTo(w * 0.52, h * 0.31);
		c.lineTo(w * 0.45, h * 0.31);
		c.lineTo(w * 0.45, h * 0.22);
		c.lineTo(w * 0.52, h * 0.21);
		c.lineTo(w * 0.54, h * 0.16);
		c.lineTo(w * 0.5, h * 0.11);
		c.lineTo(w * 0.56, h * 0.05);
		c.lineTo(w * 0.62, h * 0.09);
		c.lineTo(w * 0.67, h * 0.07);
		c.lineTo(w * 0.68, 0);
		c.lineTo(w * 0.77, 0);
		c.lineTo(w * 0.78, h * 0.07);
		c.lineTo(w * 0.83, h * 0.09);
		c.lineTo(w * 0.89, h * 0.05);
		c.lineTo(w * 0.95, h * 0.11);
		c.lineTo(w * 0.91, h * 0.16);
		c.lineTo(w * 0.93, h * 0.21);
		c.lineTo(w, h * 0.22);
		c.lineTo(w, h * 0.31);
		c.lineTo(w * 0.93, h * 0.31);
		c.lineTo(w * 0.91, h * 0.36);
		c.lineTo(w * 0.95, h * 0.41);
		c.lineTo(w * 0.89, h * 0.47);
		c.lineTo(w * 0.83, h * 0.43);
		c.lineTo(w * 0.78, h * 0.45);
		c.lineTo(w * 0.77, h * 0.52);
		c.lineTo(w * 0.68, h * 0.52);
		c.close();
		c.moveTo(w * 0.36, h * 0.81);
		c.curveTo(w * 0.44, h * 0.81, w * 0.52, h * 0.75, w * 0.52, h * 0.67);
		c.curveTo(w * 0.52, h * 0.59, w * 0.45, h * 0.51, w * 0.35, h * 0.51);
		c.curveTo(w * 0.27, h * 0.51, w * 0.19, h * 0.58, w * 0.19, h * 0.67);
		c.curveTo(w * 0.19, h * 0.74, w * 0.27, h * 0.82, w * 0.36, h * 0.81);
		c.close();
		c.moveTo(w * 0.21, h * 0.98);
		c.lineTo(w * 0.22, h * 0.89);
		c.lineTo(w * 0.16, h * 0.85);
		c.lineTo(w * 0.08, h * 0.88);
		c.lineTo(w * 0.02, h * 0.79);
		c.lineTo(w * 0.09, h * 0.74);
		c.lineTo(w * 0.08, h * 0.67);
		c.lineTo(0, h * 0.63);
		c.lineTo(w * 0.03, h * 0.53);
		c.lineTo(w * 0.12, h * 0.54);
		c.lineTo(w * 0.16, h * 0.48);
		c.lineTo(w * 0.13, h * 0.4);
		c.lineTo(w * 0.22, h * 0.35);
		c.lineTo(w * 0.28, h * 0.42);
		c.lineTo(w * 0.36, h * 0.41);
		c.lineTo(w * 0.39, h * 0.33);
		c.lineTo(w * 0.5, h * 0.36);
		c.lineTo(w * 0.49, h * 0.45);
		c.lineTo(w * 0.55, h * 0.49);
		c.lineTo(w * 0.63, h * 0.45);
		c.lineTo(w * 0.69, h * 0.54);
		c.lineTo(w * 0.62, h * 0.6);
		c.lineTo(w * 0.63, h * 0.67);
		c.lineTo(w * 0.71, h * 0.7);
		c.lineTo(w * 0.68, h * 0.8);
		c.lineTo(w * 0.59, h * 0.79);
		c.lineTo(w * 0.55, h * 0.85);
		c.lineTo(w * 0.59, h * 0.79);
		c.lineTo(w * 0.55, h * 0.85);
		c.lineTo(w * 0.59, h * 0.93);
		c.lineTo(w * 0.49, h * 0.98);
		c.lineTo(w * 0.43, h * 0.91);
		c.lineTo(w * 0.36, h * 0.92);
		c.lineTo(w * 0.32, h);
		c.lineTo(w * 0.21, h * 0.98);
		c.close();
		c.stroke();
	}
	else if (type === mxArchiMate3Tech.prototype.cst.SYS_SW)
	{
		mxArchiMate3SysSw.prototype.background(c, x, y, w, h);
	}
	else if (type === mxArchiMate3Tech.prototype.cst.DEVICE)
	{
		mxArchiMate3Device.prototype.background(c, x, y, w, h);
	}
};

mxCellRenderer.registerShape(mxArchiMate3Tech.prototype.cst.TECH, mxArchiMate3Tech);

mxArchiMate3Tech.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 10, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false, null, 0, -10));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false, null, -10, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, 10));

	return (constr);
};

//**********************************************************************************************************************************************************
//Distribution
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Distribution(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Distribution, mxShape);

mxArchiMate3Distribution.prototype.cst = {
		DISTRIBUTION : 'mxgraph.archimate3.distribution'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Distribution.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Distribution.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(w * 0.1, h * 0.25);
	c.lineTo(w * 0.9, h * 0.25);
	c.lineTo(w, h * 0.5);
	c.lineTo(w * 0.9, h * 0.75);
	c.lineTo(w * 0.1, h * 0.75);
	c.lineTo(0, h * 0.5);
	c.fillAndStroke();
	c.begin();
	c.moveTo(w * 0.2, 0);
	c.lineTo(0, h * 0.5);
	c.lineTo(w * 0.2, h);
	c.moveTo(w * 0.8, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w * 0.8, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxArchiMate3Distribution.prototype.cst.DISTRIBUTION, mxArchiMate3Distribution);

mxArchiMate3Distribution.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.2, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.8, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.8, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.2, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Resource
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Resource(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Resource, mxShape);

mxArchiMate3Resource.prototype.cst = {
		RESOURCE : 'mxgraph.archimate3.resource'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Resource.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Resource.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(w * 0.51, h * 0.34);
	c.lineTo(w * 0.51, h * 0.65);
	c.moveTo(w * 0.35, h * 0.34);
	c.lineTo(w * 0.35, h * 0.65);
	c.moveTo(w * 0.19, h * 0.34);
	c.lineTo(w * 0.19, h * 0.65);
	c.moveTo(w * 0.91, h * 0.4);
	c.curveTo(w * 0.93, h * 0.39, w * 0.95, h * 0.39, w * 0.97, h * 0.40);
	c.curveTo(w * 0.99, h * 0.4, w, h * 0.41, w, h * 0.43);
	c.curveTo(w, h * 0.48, w, h * 0.52, w, h * 0.57);
	c.curveTo(w, h * 0.58, w * 0.99, h * 0.59, w * 0.98, h * 0.6);
	c.curveTo(w * 0.96, h * 0.6, w * 0.93, h * 0.6, w * 0.91, h * 0.6);
	c.moveTo(0, h * 0.73);
	c.curveTo(0, h * 0.6, 0, h * 0.43, 0, h * 0.27);
	c.curveTo(0, h * 0.24, w * 0.03, h * 0.21, w * 0.08, h * 0.21);
	c.curveTo(w * 0.33, h * 0.2, w * 0.61, h * 0.2, w * 0.84, h * 0.21);
	c.curveTo(w * 0.88, h * 0.22, w * 0.89, h * 0.24, w * 0.9, h * 0.26);
	c.curveTo(w * 0.91, h * 0.41, w * 0.91, h * 0.57, w * 0.9, h * 0.72);
	c.curveTo(w * 0.9, h * 0.74, w * 0.88, h * 0.78, w * 0.83, h * 0.79);
	c.curveTo(w * 0.57, h * 0.79, w * 0.32, h * 0.79, w * 0.06, h * 0.79);
	c.curveTo(w * 0.02, h * 0.78, 0, h * 0.76, 0, h * 0.73);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxArchiMate3Resource.prototype.cst.RESOURCE, mxArchiMate3Resource);

//**********************************************************************************************************************************************************
//Capability
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Capability(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Capability, mxShape);

mxArchiMate3Capability.prototype.cst = {
		CAPABILITY : 'mxgraph.archimate3.capability'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Capability.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Capability.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.lineTo(0, h * 0.67);
	c.lineTo(w * 0.33, h * 0.67);
	c.lineTo(w * 0.33, h * 0.33);
	c.lineTo(w * 0.67, h * 0.33);
	c.lineTo(w * 0.67, 0);
	c.close();
	c.moveTo(w * 0.67, h * 0.33);
	c.lineTo(w, h * 0.33);
	c.moveTo(w * 0.33, h * 0.67);
	c.lineTo(w, h * 0.67);
	c.moveTo(w * 0.33, h * 0.67);
	c.lineTo(w * 0.33, h);
	c.moveTo(w * 0.67, h * 0.33);
	c.lineTo(w * 0.67, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxArchiMate3Capability.prototype.cst.CAPABILITY, mxArchiMate3Capability);

//**********************************************************************************************************************************************************
//Course of Action
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Course(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Course, mxShape);

mxArchiMate3Course.prototype.cst = {
		COURSE : 'mxgraph.archimate3.course'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Course.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Course.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, h);
	c.arcTo(w * 0.7, h * 0.7, 0, 0, 1, w * 0.41, h * 0.56);
	c.moveTo(w * 0.14, h * 0.54);
	c.lineTo(w * 0.41, h * 0.56);
	c.lineTo(w * 0.3, h * 0.78);
	c.stroke();
	
	c.ellipse(w * 0.4, 0, w * 0.6, h * 0.6);
	c.stroke();
	c.ellipse(w * 0.5, h * 0.1, w * 0.4, h * 0.4);
	c.stroke();
	
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#000000');
	c.setFillColor(fillColor);
	c.ellipse(w * 0.6, h * 0.2, w * 0.2, h * 0.2);
	c.fill();
};

mxCellRenderer.registerShape(mxArchiMate3Course.prototype.cst.COURSE, mxArchiMate3Course);

//**********************************************************************************************************************************************************
//Node
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Node(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Node, mxShape);

mxArchiMate3Node.prototype.cst = {
		NODE : 'mxgraph.archimate3.node'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Node.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Node.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, h * 0.25);
	c.lineTo(w * 0.25, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h * 0.75);
	c.lineTo(w * 0.75, h);
	c.lineTo(0, h);
	c.close();
	c.moveTo(0, h * 0.25);
	c.lineTo(w * 0.75, h * 0.25);
	c.lineTo(w * 0.75, h);
	c.moveTo(w, 0);
	c.lineTo(w * 0.75, h * 0.25);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3Node.prototype.cst.NODE, mxArchiMate3Node);

mxArchiMate3Node.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Device
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Device(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Device, mxShape);

mxArchiMate3Device.prototype.cst = {
		DEVICE : 'mxgraph.archimate3.device'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Device.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Device.prototype.background = function(c, x, y, w, h)
{
	c.roundrect(0, 0, w, h * 0.88, w * 0.1, h * 0.1);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w * 0.1, h * 0.88);
	c.lineTo(0, h);
	c.lineTo(w, h);
	c.lineTo(w * 0.9, h * 0.88);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3Device.prototype.cst.DEVICE, mxArchiMate3Device);

mxArchiMate3Device.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.03, 0.03), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.97, 0.03), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//System Software
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3SysSw(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3SysSw, mxShape);

mxArchiMate3SysSw.prototype.cst = {
		SYS_SW : 'mxgraph.archimate3.sysSw'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3SysSw.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3SysSw.prototype.background = function(c, x, y, w, h)
{
	c.ellipse(w * 0.3, 0, w * 0.7, h * 0.7);
	c.stroke();
	
	c.ellipse(0, h * 0.02, w * 0.98, h * 0.98);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxArchiMate3SysSw.prototype.cst.SYS_SW, mxArchiMate3SysSw);

//**********************************************************************************************************************************************************
//Artifact
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Artifact(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Artifact, mxShape);

mxArchiMate3Artifact.prototype.cst = {
		ARTIFACT : 'mxgraph.archimate3.artifact'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Artifact.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Artifact.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w * 0.7, 0);
	c.lineTo(w, h * 0.22);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w * 0.7, 0);
	c.lineTo(w * 0.7, h * 0.22);
	c.lineTo(w, h * 0.22);
	c.stroke();
};

mxCellRenderer.registerShape(mxArchiMate3Artifact.prototype.cst.ARTIFACT, mxArchiMate3Artifact);

mxArchiMate3Artifact.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.7, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.85, 0.11), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.22), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Communication Network
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3CommNetw(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3CommNetw, mxShape);

mxArchiMate3CommNetw.prototype.cst = {
		COMM_NETW : 'mxgraph.archimate3.commNetw'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3CommNetw.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3CommNetw.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(w * 0.2, h);
	c.lineTo(0, h * 0.5);
	c.lineTo(w * 0.2, 0);
	c.moveTo(w * 0.8, h);
	c.lineTo(w, h * 0.5);
	c.lineTo(w * 0.8, 0);
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.stroke();
};

mxCellRenderer.registerShape(mxArchiMate3CommNetw.prototype.cst.COMM_NETW, mxArchiMate3CommNetw);

mxArchiMate3CommNetw.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Path
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxArchiMate3Path(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxArchiMate3Path, mxShape);

mxArchiMate3Path.prototype.cst = {
		PATH : 'mxgraph.archimate3.path'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxArchiMate3Path.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
};

mxArchiMate3Path.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(w * 0.2, h);
	c.lineTo(0, h * 0.5);
	c.lineTo(w * 0.2, 0);
	c.moveTo(w * 0.8, h);
	c.lineTo(w, h * 0.5);
	c.lineTo(w * 0.8, 0);
	c.stroke();
	
	c.setDashed(true);
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.stroke();
};

mxCellRenderer.registerShape(mxArchiMate3Path.prototype.cst.PATH, mxArchiMate3Path);

mxArchiMate3Path.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));

	return (constr);
};

/**
 * $Id: mxArrows.js,v 1.5 2016/03/23 12:32:06 mate Exp $
 * Copyright (c) 2006-2016, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2Arrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.notch = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2Arrow, mxActor);

mxShapeArrows2Arrow.prototype.customProperties = [
	{name: 'dx', dispName: 'Arrowhead Length', type: 'float', min: 0, defVal: 40},
	{name: 'dy', dispName: 'Arrow Width', type: 'float', min:0, max:1, defVal: 0.6},
	{name: 'notch', dispName: 'Notch', type: 'float', min:0, defVal: 0},
	{name: 'headCrossline', dispName: 'Head Crossline', type: 'bool', defVal: false},
	{name: 'tailCrossline', dispName: 'Tail Crossline', type: 'bool', defVal: false}
];

mxShapeArrows2Arrow.prototype.cst = {
		ARROW : 'mxgraph.arrows2.arrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2Arrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var headCrossline = mxUtils.getValue(this.style, 'headCrossline', false);
	var tailCrossline = mxUtils.getValue(this.style, 'tailCrossline', false);

	c.begin();
	c.moveTo(0, dy);
	c.lineTo(w - dx, dy);
	c.lineTo(w - dx, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - dx, h);
	c.lineTo(w - dx, h - dy);
	c.lineTo(0, h - dy);
	c.lineTo(notch, h * 0.5);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	
	if (headCrossline)
	{
		c.begin();
		c.moveTo(w - dx, dy);
		c.lineTo(w - dx, h - dy);
		c.stroke();
	}
	
	if (tailCrossline)
	{
		c.begin();
		c.moveTo(notch, dy);
		c.lineTo(notch, h - dy);
		c.stroke();
	}
};

mxShapeArrows2Arrow.prototype.getLabelBounds = function(rect)
{
	if (mxUtils.getValue(this.style, "boundedLbl", false))
	{
		var w = rect.width;
		var h = rect.height;
		
		var dy, dx;
		var direction = this.direction || mxConstants.DIRECTION_EAST;
		
		if (mxUtils.getValue(this.style, "flipH", false))
		{
			if (direction == mxConstants.DIRECTION_WEST)
				direction = mxConstants.DIRECTION_EAST;
			else if (direction == mxConstants.DIRECTION_EAST)
				direction = mxConstants.DIRECTION_WEST;
		}
		
		if (mxUtils.getValue(this.style, "flipV", false))
		{
			if (direction == mxConstants.DIRECTION_NORTH)
				direction = mxConstants.DIRECTION_SOUTH;
			else if (direction == mxConstants.DIRECTION_SOUTH)
				direction = mxConstants.DIRECTION_NORTH;
		}
		
		
		if (direction == mxConstants.DIRECTION_NORTH
				|| direction == mxConstants.DIRECTION_SOUTH)
		{
			dy = w * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
			dx = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
		}
		else
		{
			dy = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
			dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
		}
		
		if (direction == mxConstants.DIRECTION_EAST)
		{
			return new mxRectangle(rect.x, rect.y + dy, w - dx, h - 2 * dy);
		}
		else if (direction == mxConstants.DIRECTION_WEST)
		{
			return new mxRectangle(rect.x + dx, rect.y + dy, w - dx, h - 2 * dy);
		}
		else if (direction == mxConstants.DIRECTION_NORTH)
		{
			return new mxRectangle(rect.x + dy, rect.y + dx, w - 2 * dy, h - dx);
		}
		else
		{
			return new mxRectangle(rect.x + dy, rect.y, w - 2 * dy, h - dx);
		}
	}
	
	return rect;
};

mxCellRenderer.registerShape(mxShapeArrows2Arrow.prototype.cst.ARROW, mxShapeArrows2Arrow);

Graph.handleFactory[mxShapeArrows2Arrow.prototype.cst.ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
			{
				var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + dy * bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch)), bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(1, (((pt.y - bounds.y) / bounds.height) * 2)))) / 100;
			})];
			
	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
			{
				var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

				return new mxPoint(bounds.x + notch, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx)), pt.x - bounds.x))) / 100;
			});
	
	handles.push(handle2);
	
	return handles;

}

mxShapeArrows2Arrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));

	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, notch, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx) * 0.5, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx) * 0.5, h - dy));

	return (constr);
};

//**********************************************************************************************************************************************************
//Two Way Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2TwoWayArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2TwoWayArrow, mxActor);

mxShapeArrows2TwoWayArrow.prototype.cst = {
		TWO_WAY_ARROW : 'mxgraph.arrows2.twoWayArrow'
};

mxShapeArrows2TwoWayArrow.prototype.customProperties = [
	{name: 'dx', dispName: 'Arrowhead Length', type: 'float', min:0, defVal: 35},
	{name: 'dy', dispName: 'Arrow Width', type: 'float', min:0, max:1, defVal: 0.6}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2TwoWayArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	c.begin();
	c.moveTo(dx, dy);
	c.lineTo(w - dx, dy);
	c.lineTo(w - dx, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - dx, h);
	c.lineTo(w - dx, h - dy);
	c.lineTo(dx, h - dy);
	c.lineTo(dx, h);
	c.lineTo(0, h * 0.5);
	c.lineTo(dx, 0);
	c.close();
	c.fillAndStroke();
};

mxShapeArrows2TwoWayArrow.prototype.getLabelBounds = function(rect)
{
	if (mxUtils.getValue(this.style, "boundedLbl", false))
	{
		var w = rect.width;
		var h = rect.height;
		var vertical = this.direction == mxConstants.DIRECTION_NORTH
						|| this.direction == mxConstants.DIRECTION_SOUTH;

		var dy, dx;
		
		if (vertical)
		{
			dy = w * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
			dx = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
		}
		else
		{
			dy = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
			dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
		}
		
		if (vertical)
		{
			return new mxRectangle(rect.x + dy, rect.y + dx, w - 2 * dy, h - 2 * dx);
		}
		else
		{
			return new mxRectangle(rect.x + dx, rect.y + dy, w - 2 * dx, h - 2 * dy);
		}
	}
	
	return rect;
};

mxCellRenderer.registerShape(mxShapeArrows2TwoWayArrow.prototype.cst.TWO_WAY_ARROW, mxShapeArrows2TwoWayArrow);

mxShapeArrows2TwoWayArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2TwoWayArrow.prototype.cst.TWO_WAY_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
			{
				var dx = Math.max(0, Math.min(bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + dy * bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width / 2, bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(1, (((pt.y - bounds.y) / bounds.height) * 2)))) / 100;
			})];
	
	return handles;

}

mxShapeArrows2TwoWayArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, 0, h - dy));

	return (constr);
};

//**********************************************************************************************************************************************************
//Stylised Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2StylisedArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.notch = 0;
	this.feather = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2StylisedArrow, mxActor);

mxShapeArrows2StylisedArrow.prototype.customProperties = [
	{name: 'dx', dispName: 'Arrowhead Length', type: 'float', min:0, defVal:40},
	{name: 'dy', dispName: 'Arrow Width', type: 'float', min:0, max:1, defVal:0.6},
	{name: 'notch', dispName: 'Notch', type: 'float', min:0, defVal:0},
	{name: 'feather', dispName: 'Feather', type: 'float', min:0, max:1, defVal:0.4},
];

mxShapeArrows2StylisedArrow.prototype.cst = {
		STYLISED_ARROW : 'mxgraph.arrows2.stylisedArrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2StylisedArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var feather = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'feather', this.feather))));

	c.begin();
	c.moveTo(0, feather);
	c.lineTo(w - dx, dy);
	c.lineTo(w - dx - 10, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - dx - 10, h);
	c.lineTo(w - dx, h - dy);
	c.lineTo(0, h - feather);
	c.lineTo(notch, h * 0.5);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2StylisedArrow.prototype.cst.STYLISED_ARROW, mxShapeArrows2StylisedArrow);

mxShapeArrows2StylisedArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2StylisedArrow.prototype.cst.STYLISED_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
			{
				var dx = Math.max(0, Math.min(bounds.width - 10, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + dy * bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width - 10, bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch)), bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(1, (((pt.y - bounds.y) / bounds.height) * 2)))) / 100;
			})];
			
	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
			{
				var notch = Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx)), parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

				return new mxPoint(bounds.x + notch, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx)), pt.x - bounds.x))) / 100;
			});
	
	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['feather'], function(bounds)
			{
				var feather = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'feather', this.dy))));

				return new mxPoint(bounds.x, bounds.y + feather * bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['feather'] = Math.round(100 * Math.max(0, Math.min(1, (((pt.y - bounds.y) / bounds.height) * 2)))) / 100;
			});
	
	handles.push(handle3);
	
	return handles;

}

mxShapeArrows2StylisedArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var feather = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'feather', this.feather))));

	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, notch, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, feather));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - feather));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx - 10, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx - 10, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx) * 0.5, (dy + feather) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx) * 0.5, h - (dy + feather) * 0.5));

	return (constr);
};

//**********************************************************************************************************************************************************
//Sharp Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2SharpArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy1 = 0.5;
	this.dx1 = 0.5;
	this.dx2 = 0.5;
	this.notch = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2SharpArrow, mxActor);

mxShapeArrows2SharpArrow.prototype.cst = {
		SHARP_ARROW : 'mxgraph.arrows2.sharpArrow'
};

mxShapeArrows2SharpArrow.prototype.customProperties = [
	{name: 'dx1', dispName: 'Arrowhead Arrow Width', type: 'float', min:0, defVal:18},
	{name: 'dy1', dispName: 'Arrow Arrow Width', type: 'float', min:0, max:1, defVal:0.67},
	{name: 'dx2', dispName: 'Arrowhead Angle', type: 'float', min:0, defVal:18},
	{name: 'notch', dispName: 'Notch', type: 'float', min:0, defVal:0}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2SharpArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy1 = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));
	var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var dx1a = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dy1a = h * 0.5 * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));
	var x2 = 0;
	
	if (h != 0)
	{
		x2 = dx1a + dx2 * dy1a * 2 / h;
	}
	
	c.begin();
	c.moveTo(0, dy1);
	c.lineTo(w - dx1, dy1);
	c.lineTo(w - x2, 0);
	c.lineTo(w - dx2, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - dx2, h);
	c.lineTo(w - x2, h);
	c.lineTo(w - dx1, h - dy1);
	c.lineTo(0, h - dy1);
	c.lineTo(notch, h * 0.5);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2SharpArrow.prototype.cst.SHARP_ARROW, mxShapeArrows2SharpArrow);

mxShapeArrows2SharpArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2SharpArrow.prototype.cst.SHARP_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx1', 'dy1'], function(bounds)
			{
				var dx1 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1))));
				var dy1 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1))));

				return new mxPoint(bounds.x + bounds.width - dx1, bounds.y + dy1 * bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx1'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch)), bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy1'] = Math.round(100 * Math.max(0, Math.min(1, (((pt.y - bounds.y) / bounds.height) * 2)))) / 100;
			})];
			
	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
			{
				var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

				return new mxPoint(bounds.x + notch, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1)), pt.x - bounds.x))) / 100;
			});
	
	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['dx2'], function(bounds)
			{
				var dx2 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2))));

				return new mxPoint(bounds.x + bounds.width - dx2, bounds.y);
			}, function(bounds, pt)
			{
				this.state.style['dx2'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch)), bounds.x + bounds.width - pt.x))) / 100;
			});
	
	handles.push(handle3);
	
	return handles;
};

mxShapeArrows2SharpArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy1 = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));
	var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var dx1a = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dy1a = h * 0.5 * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));
	var x2 = 0;
	
	if (h != 0)
	{
		x2 = dx1a + dx2 * dy1a * 2 / h;
	}
	
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, notch, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx1, dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - x2, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx2, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx1, h - dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - x2, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx2, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx1) * 0.5, dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx1) * 0.5, h - dy1));

	return (constr);
};

//**********************************************************************************************************************************************************
//Sharp Arrow2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2SharpArrow2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy1 = 0.5;
	this.dx1 = 0.5;
	this.dx2 = 0.5;
	this.dy3 = 0.5;
	this.dx3 = 0.5;

	this.notch = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2SharpArrow2, mxActor);

mxShapeArrows2SharpArrow2.prototype.customProperties = [
	{name: 'dx1', dispName: 'Arrowhead Arrow Width', type: 'float', min:0, defVal:18},
	{name: 'dy1', dispName: 'Arrow Width', type: 'float', min:0, max:1, defVal:0.67},
	{name: 'dx2', dispName: 'Arrowhead Angle', type: 'float', min:0, defVal:18},
	{name: 'dx3', dispName: 'Arrowhead Edge X', type: 'float', min:0, defVal:27},
	{name: 'dy3', dispName: 'Arrowhead Edge Y', type: 'float', min:0, max:1, defVal:0.15},
	{name: 'notch', dispName: 'Notch', type: 'float', min:0, defVal:0}
];

mxShapeArrows2SharpArrow2.prototype.cst = {
		SHARP_ARROW2 : 'mxgraph.arrows2.sharpArrow2'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2SharpArrow2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy1 = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));
	var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var dy3 = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy3', this.dy3))));
	var dx3 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx3', this.dx3))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var dx1a = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dy1a = h * 0.5 * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));

	c.begin();
	c.moveTo(0, dy1);
	c.lineTo(w - dx1, dy1);
	c.lineTo(w - dx3, dy3);
	c.lineTo(w - dx2, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - dx2, h);
	c.lineTo(w - dx3, h - dy3);
	c.lineTo(w - dx1, h - dy1);
	c.lineTo(0, h - dy1);
	c.lineTo(notch, h * 0.5);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2SharpArrow2.prototype.cst.SHARP_ARROW2, mxShapeArrows2SharpArrow2);

mxShapeArrows2SharpArrow2.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2SharpArrow2.prototype.cst.SHARP_ARROW2] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx1', 'dy1'], function(bounds)
			{
				var dx1 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1))));
				var dy1 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1))));

				return new mxPoint(bounds.x + bounds.width - dx1, bounds.y + dy1 * bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx1'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch)), bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy1'] = Math.round(100 * Math.max(0, Math.min(1, (((pt.y - bounds.y) / bounds.height) * 2)))) / 100;
			})];
			
	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
			{
				var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

				return new mxPoint(bounds.x + notch, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1)), pt.x - bounds.x))) / 100;
			});
	
	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['dx2'], function(bounds)
			{
				var dx2 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2))));

				return new mxPoint(bounds.x + bounds.width - dx2, bounds.y);
			}, function(bounds, pt)
			{
				this.state.style['dx2'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch)), bounds.x + bounds.width - pt.x))) / 100;
			});
	
	handles.push(handle3);

	var handle4 = Graph.createHandle(state, ['dx3', 'dy3'], function(bounds)
			{
				var dx3 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx3', this.dx3))));
				var dy3 = Math.max(0, Math.min(1 - parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1)) / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy3', this.dy3))));

				return new mxPoint(bounds.x + bounds.width - dx3, bounds.y + dy3 * bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx3'] = Math.round(100 * Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2)), Math.min(bounds.width, bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy3'] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1)), (((pt.y - bounds.y) / bounds.height) * 2)))) / 100;
			});

	handles.push(handle4);

	return handles;
};

mxShapeArrows2SharpArrow2.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy1 = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));
	var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var dy3 = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy3', this.dy3))));
	var dx3 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx3', this.dx3))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var dx1a = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dy1a = h * 0.5 * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));

	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, notch, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx1, dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx3, dy3));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx2, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx1, h - dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx3, h - dy3));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx2, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx1) * 0.5, dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx1) * 0.5, h - dy1));

	return (constr);
};

//**********************************************************************************************************************************************************
//Callout Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2CalloutArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.notch = 0;
	this.arrowHead = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2CalloutArrow, mxActor);

mxShapeArrows2CalloutArrow.prototype.customProperties = [
	{name: 'dx', dispName: 'Arrowhead Length', type: 'float', min:0, defVal:20},
	{name: 'arrowHead', dispName: 'Arrowhead Width', type: 'float', min:0, defVal:10},
	{name: 'dy', dispName: 'Arrow Width', type: 'float', min:0, defVal:10},
	{name: 'notch', dispName: 'Rectangle Width', type: 'float', min:0, defVal:60}
];

mxShapeArrows2CalloutArrow.prototype.cst = {
		CALLOUT_ARROW : 'mxgraph.arrows2.calloutArrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2CalloutArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(notch, 0);
	c.lineTo(notch, h * 0.5 - dy);
	c.lineTo(w - dx, h * 0.5 - dy);
	c.lineTo(w - dx, h * 0.5 - dy - arrowHead);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - dx, h * 0.5 + dy + arrowHead);
	c.lineTo(w - dx, h * 0.5 + dy);
	c.lineTo(notch, h * 0.5 + dy);
	c.lineTo(notch, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2CalloutArrow.prototype.cst.CALLOUT_ARROW, mxShapeArrows2CalloutArrow);

mxShapeArrows2CalloutArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2CalloutArrow.prototype.cst.CALLOUT_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy = Math.max(0, Math.min(bounds.height / 2 - arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + bounds.height / 2 - dy);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch)), bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)), bounds.y + bounds.height / 2 - pt.y))) / 100;
				
			})];
			
	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
			{
				var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

				return new mxPoint(bounds.x + notch, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx)), pt.x - bounds.x))) / 100;
			});

	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['arrowHead'], function(bounds)
			{
				var dx = 		Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy =        Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
				var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + bounds.height / 2 - dy - arrowHead);
			}, function(bounds, pt)
			{
			this.state.style['arrowHead'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)), bounds.y + bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)) - pt.y))) / 100;
			});

	handles.push(handle3);
	
	return handles;
};

mxShapeArrows2CalloutArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, notch, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null,notch, h * 0.5 - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h * 0.5 - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h * 0.5 - dy - arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h * 0.5 + dy + arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h * 0.5 + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, notch, h * 0.5 + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, notch, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, notch * 0.5 , 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, notch * 0.5 , h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, (notch + w - dx) * 0.5, -dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, (notch + w - dx) * 0.5, dy));

	return (constr);
};

//**********************************************************************************************************************************************************
//Bend Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2BendArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.notch = 0;
	this.arrowHead = 40;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2BendArrow, mxActor);

mxShapeArrows2BendArrow.prototype.customProperties = [
	{name: 'dx', dispName: 'Arrowhead Length', type: 'float', min:0, defVal: 38},
	{name: 'dy', dispName: 'Arrow Width', type: 'float', min:0, defVal: 15},
	{name: 'notch', dispName: 'Notch', type: 'float', min:0, defVal: 0},
	{name: 'arrowHead', dispName: 'Arrowhead Width', type: 'float', min:0, defVal:55},
	{name: 'rounded', dispName: 'Rounded', type: 'boolean', defVal: false}
];

mxShapeArrows2BendArrow.prototype.cst = {
		BEND_ARROW : 'mxgraph.arrows2.bendArrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2BendArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var notch = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));
	var rounded = mxUtils.getValue(this.style, 'rounded', '0');

	c.begin();
	c.moveTo(w - dx, 0);
	c.lineTo(w, arrowHead * 0.5);
	c.lineTo(w - dx, arrowHead);
	c.lineTo(w - dx, arrowHead / 2 + dy);
	
	if (rounded == '1')
	{
		c.lineTo(dy * 2.2, arrowHead / 2 + dy);
		c.arcTo(dy * 0.2, dy * 0.2, 0, 0, 0, dy * 2, arrowHead / 2 + dy * 1.2);
	}
	else
	{
		c.lineTo(dy * 2, arrowHead / 2 + dy);
	}
	
	c.lineTo(dy * 2, h);
	c.lineTo(dy, h - notch);
	c.lineTo(0, h);
	
	if (rounded == '1')
	{
		c.lineTo(0, arrowHead / 2 + dy);
		c.arcTo(dy * 2, dy * 2, 0, 0, 1, dy * 2, arrowHead / 2 - dy);
	}
	else
	{
		c.lineTo(0, arrowHead / 2 - dy);
	}

	c.lineTo(w - dx, arrowHead / 2 - dy);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2BendArrow.prototype.cst.BEND_ARROW, mxShapeArrows2BendArrow);

mxShapeArrows2BendArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2BendArrow.prototype.cst.BEND_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
		
				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + arrowHead / 2 - dy);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)) * 2.2, bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)) / 2, bounds.y + parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)) / 2 - pt.y))) / 100;
				
			})];
			
	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
				
				var notch = Math.max(0, Math.min(bounds.height - arrowHead / 2 - dy, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

				return new mxPoint(bounds.x + dy, bounds.y + bounds.height - notch);
			}, function(bounds, pt)
			{
				this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.height - parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)) / 2 - parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)), bounds.y + bounds.height - pt.y))) / 100;
			});
	
	handles.push(handle2);

	var handle3 = Graph.createHandle(state, ['arrowHead'], function(bounds)
			{
				var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + arrowHead);
			}, function(bounds, pt)
			{
				this.state.style['arrowHead'] = Math.round(100 * Math.max(2 * parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)), Math.min(bounds.height, pt.y - bounds.y))) / 100;
			});
	
	handles.push(handle3);

	return handles;
};

mxShapeArrows2BendArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var notch = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));
	var rounded = mxUtils.getValue(this.style, 'rounded', '0');

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx + dy * 2) * 0.5, arrowHead / 2 - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, arrowHead / 2 - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, arrowHead * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, arrowHead / 2 + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx + dy * 2) * 0.5, arrowHead / 2 + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dy * 2, (h - arrowHead / 2 - dy) * 0.5 + arrowHead / 2 + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dy * 2, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dy, h - notch));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - arrowHead / 2 - dy) * 0.5 + arrowHead / 2 + dy));

	if (rounded == '1')
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dy * 0.586, arrowHead / 2 - dy * 0.414));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2 * dy  + dy * 0.0586, arrowHead / 2 + dy + dy * 0.0586));
	}
	else
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, arrowHead / 2 - dy));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dy * 2, arrowHead / 2 + dy));
	}
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Bend Double Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2BendDoubleArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.notch = 0;
	this.arrowHead = 40;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2BendDoubleArrow, mxActor);

mxShapeArrows2BendDoubleArrow.prototype.customProperties = [
	{name: 'dx', dispName: 'Arrowhead Length', type: 'float', min:0, defVal:38},
	{name: 'dy', dispName: 'Arrow Width', type: 'float', min:0, defVal:15},
	{name: 'arrowHead', dispName: 'Arrowhead Width', type: 'float', min:0, defVal:55},
	{name: 'rounded', dispName: 'Rounded', type: 'boolean', defVal:false}
];

mxShapeArrows2BendDoubleArrow.prototype.cst = {
		BEND_DOUBLE_ARROW : 'mxgraph.arrows2.bendDoubleArrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2BendDoubleArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var arrowHead = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));
	var rounded = mxUtils.getValue(this.style, 'rounded', '0');

	c.begin();
	c.moveTo(w - dx, 0);
	c.lineTo(w, arrowHead * 0.5);
	c.lineTo(w - dx, arrowHead);
	c.lineTo(w - dx, arrowHead / 2 + dy);

	if (rounded == '1')
	{
		c.lineTo(arrowHead / 2 + dy * 1.2, arrowHead / 2 + dy);
		c.arcTo(dy * 0.2, dy * 0.2, 0, 0, 0, arrowHead /2 + dy, arrowHead / 2 + dy * 1.2);
	}
	else
	{
		c.lineTo(arrowHead / 2 + dy, arrowHead / 2 + dy);
	}
	
	c.lineTo(arrowHead / 2 + dy, h - dx);
	c.lineTo(arrowHead, h - dx);
	c.lineTo(arrowHead / 2, h);
	c.lineTo(0, h - dx);
	c.lineTo(arrowHead / 2 - dy, h - dx);
	
	if (rounded == '1')
	{
		c.lineTo(arrowHead / 2 - dy, arrowHead / 2 + dy);
		c.arcTo(dy * 2, dy * 2, 0, 0, 1, arrowHead / 2 + dy, arrowHead / 2 - dy);
	}
	else
	{
		c.lineTo(arrowHead / 2 - dy, arrowHead / 2 - dy);
	}

	c.lineTo(w - dx, arrowHead / 2 - dy);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2BendDoubleArrow.prototype.cst.BEND_DOUBLE_ARROW, mxShapeArrows2BendDoubleArrow);

mxShapeArrows2BendDoubleArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2BendDoubleArrow.prototype.cst.BEND_DOUBLE_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(Math.min(bounds.height, bounds.width) - parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx)), parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dx = Math.max(0, Math.min(Math.min(bounds.width, bounds.height) - arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
		
				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + arrowHead / 2 - dy);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(Math.min(bounds.width, bounds.height) - parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)), bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)) / 2, bounds.y + parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)) / 2 - pt.y))) / 100;
				
			})];
			
	var handle2 = Graph.createHandle(state, ['arrowHead'], function(bounds)
			{
				var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var arrowHead = Math.max(0, Math.min(Math.min(bounds.height, bounds.width) - dx, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + arrowHead);
			}, function(bounds, pt)
			{
				this.state.style['arrowHead'] = Math.round(100 * Math.max(2 * parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)), Math.min(Math.min(bounds.height, bounds.width) - parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx)), pt.y - bounds.y))) / 100;
			});
	
	handles.push(handle2);

	return handles;
};

mxShapeArrows2BendDoubleArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var arrowHead = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));
	var rounded = mxUtils.getValue(this.style, 'rounded', '0');

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx , 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, arrowHead * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, arrowHead / 2 + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (arrowHead / 2 + dy + w - dx) * 0.5, arrowHead / 2 + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (arrowHead / 2 + dy + w - dx) * 0.5, arrowHead / 2 - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, arrowHead / 2 + dy, (arrowHead / 2 + dy + h - dx) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, arrowHead / 2 - dy, (arrowHead / 2 + dy + h - dx) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, arrowHead / 2 + dy, h - dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, arrowHead, h - dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, arrowHead / 2, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, arrowHead / 2 - dy, h - dx));

	if (rounded == '1')
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, arrowHead / 2 - dy * 0.414, arrowHead / 2 - dy * 0.414));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, arrowHead / 2 + dy + dy * 0.0586, arrowHead / 2 + dy + dy * 0.0586));
	}
	else
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, arrowHead / 2 - dy, arrowHead / 2 - dy));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, arrowHead / 2 + dy, arrowHead / 2 + dy));
	}
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Callout Double Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2CalloutDoubleArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.notch = 0;
	this.arrowHead = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2CalloutDoubleArrow, mxActor);

mxShapeArrows2CalloutDoubleArrow.prototype.customProperties = [
	{name: 'dx', dispName: 'Arrowhead Length', type: 'float', min:0, defVal:20},
	{name: 'dy', dispName: 'Arrow Width', type: 'float', min:0, defVal:10},
	{name: 'arrowHead', dispName: 'Arrowhead Width', type: 'float', min:0, defVal:10},
	{name: 'notch', dispName: 'Rect Size', type: 'float', min:0, defVal:24}
];

mxShapeArrows2CalloutDoubleArrow.prototype.cst = {
		CALLOUT_DOUBLE_ARROW : 'mxgraph.arrows2.calloutDoubleArrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2CalloutDoubleArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));

	c.begin();
	c.moveTo(w / 2 - notch, 0);
	c.lineTo(w / 2 + notch, 0);
	c.lineTo(w / 2 + notch, h * 0.5 - dy);
	c.lineTo(w - dx, h * 0.5 - dy);
	c.lineTo(w - dx, h * 0.5 - dy - arrowHead);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - dx, h * 0.5 + dy + arrowHead);
	c.lineTo(w - dx, h * 0.5 + dy);
	c.lineTo(w / 2 + notch, h * 0.5 + dy);
	c.lineTo(w / 2 + notch, h);
	c.lineTo(w / 2 - notch, h);
	c.lineTo(w / 2 - notch, h * 0.5 + dy);
	c.lineTo(dx, h * 0.5 + dy);
	c.lineTo(dx, h * 0.5 + dy + arrowHead);
	c.lineTo(0, h * 0.5);
	c.lineTo(dx, h * 0.5 - dy - arrowHead);
	c.lineTo(dx, h * 0.5 - dy);
	c.lineTo(w / 2 - notch, h * 0.5 - dy);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2CalloutDoubleArrow.prototype.cst.CALLOUT_DOUBLE_ARROW, mxShapeArrows2CalloutDoubleArrow);

mxShapeArrows2CalloutDoubleArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2CalloutDoubleArrow.prototype.cst.CALLOUT_DOUBLE_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy = Math.max(0, Math.min(bounds.height / 2 - arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + bounds.height / 2 - dy);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width / 2 - parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch)), bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)), bounds.y + bounds.height / 2 - pt.y))) / 100;
				
			})];
			
	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
			{
				var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

				return new mxPoint(bounds.x + bounds.width / 2 + notch, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.width / 2 - parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx)), pt.x - bounds.x - bounds.width / 2))) / 100;
			});

	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['arrowHead'], function(bounds)
			{
				var dx = 		Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy =        Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
				var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + bounds.height / 2 - dy - arrowHead);
			}, function(bounds, pt)
			{
				this.state.style['arrowHead'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)), bounds.y + bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)) - pt.y))) / 100;
			});

	handles.push(handle3);
	
	return handles;
};

mxShapeArrows2CalloutDoubleArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));

	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w / 2 - notch, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w / 2 + notch, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, w / 2 - notch, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, w / 2 + notch, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h * 0.5 - dy - arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h * 0.5 + dy + arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h * 0.5 - dy - arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h * 0.5 + dy + arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w * 1.5 - dx + notch) * 0.5, h * 0.5 - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w * 1.5 - dx + notch) * 0.5, h * 0.5 + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w * 0.5 + dx - notch) * 0.5, h * 0.5 - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w * 0.5 + dx - notch) * 0.5, h * 0.5 + dy));
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Callout Quad Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2CalloutQuadArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.notch = 0;
	this.arrowHead = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2CalloutQuadArrow, mxActor);

mxShapeArrows2CalloutQuadArrow.prototype.customProperties = [
	{name: 'dx', dispName: 'Arrowhead Length', type: 'float', min:0, defVal:20},
	{name: 'dy', dispName: 'Arrow Width', type: 'float', min:0, defVal: 10},
	{name: 'notch', dispName: 'Rect Size', type: 'float', min:0, defVal:24},
	{name: 'arrowHead', dispName: 'Arrowhead Width', type: 'float', min:0, defVal:10}
];

mxShapeArrows2CalloutQuadArrow.prototype.cst = {
		CALLOUT_QUAD_ARROW : 'mxgraph.arrows2.calloutQuadArrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2CalloutQuadArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));

	c.begin();
	c.moveTo(w * 0.5 + dy, h * 0.5 - notch);
	c.lineTo(w * 0.5 + notch, h * 0.5 - notch);
	c.lineTo(w * 0.5 + notch, h * 0.5 - dy);
	c.lineTo(w - dx, h * 0.5 - dy);
	c.lineTo(w - dx, h * 0.5 - dy - arrowHead);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - dx, h * 0.5 + dy + arrowHead);
	c.lineTo(w - dx, h * 0.5 + dy);
	c.lineTo(w * 0.5 + notch, h * 0.5 + dy);
	c.lineTo(w * 0.5 + notch, h * 0.5 + notch);
	c.lineTo(w * 0.5 + dy, h * 0.5 + notch);
	c.lineTo(w * 0.5 + dy, h - dx);
	c.lineTo(w * 0.5 + dy + arrowHead, h - dx);
	c.lineTo(w * 0.5, h);
	c.lineTo(w * 0.5 - dy - arrowHead, h - dx);
	c.lineTo(w * 0.5 - dy, h - dx);
	c.lineTo(w * 0.5 - dy, h * 0.5 + notch);
	c.lineTo(w * 0.5 - notch, h * 0.5 + notch);
	c.lineTo(w * 0.5 - notch, h * 0.5 + dy);
	c.lineTo(dx, h * 0.5 + dy);
	c.lineTo(dx, h * 0.5 + dy + arrowHead);
	c.lineTo(0, h * 0.5);
	c.lineTo(dx, h * 0.5 - dy - arrowHead);
	c.lineTo(dx, h * 0.5 - dy);
	c.lineTo(w * 0.5 - notch, h * 0.5 - dy);
	c.lineTo(w * 0.5 - notch, h * 0.5 - notch);
	c.lineTo(w * 0.5 - dy, h * 0.5 - notch);
	c.lineTo(w * 0.5 - dy, dx);
	c.lineTo(w * 0.5 - dy - arrowHead, dx);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w * 0.5 + dy + arrowHead, dx);
	c.lineTo(w * 0.5 + dy, dx);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2CalloutQuadArrow.prototype.cst.CALLOUT_QUAD_ARROW, mxShapeArrows2CalloutQuadArrow);

mxShapeArrows2CalloutQuadArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2CalloutQuadArrow.prototype.cst.CALLOUT_QUAD_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + bounds.height / 2 - dy);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(Math.min(bounds.width, bounds.height) / 2 - Math.max(parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch)), parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))), bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch)), bounds.y + bounds.height / 2 - pt.y))) / 100;
				
			})];
			
	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
			{
				var notch = Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)), Math.min(Math.min(bounds.width, bounds.height), parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

				return new mxPoint(bounds.x + bounds.width / 2 + notch, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['notch'] = Math.round(100 * Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)), Math.min(Math.min(bounds.width, bounds.height) / 2 - parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx)), pt.x - bounds.x - bounds.width / 2))) / 100;
			});

	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['arrowHead'], function(bounds)
			{
				var dx = 		Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy =        Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
				var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + bounds.height / 2 - dy - arrowHead);
			}, function(bounds, pt)
			{
				this.state.style['arrowHead'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)), bounds.y + bounds.height / 2 - pt.y))) / 100;
			});

	handles.push(handle3);
	
	return handles;
};

mxShapeArrows2CalloutQuadArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));

	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + dy, h * 0.5 - notch));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + notch, h * 0.5 - notch));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + notch, h * 0.5 - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + dy, h * 0.5 + notch));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + notch, h * 0.5 + notch));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + notch, h * 0.5 + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - dy, h * 0.5 + notch));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - notch, h * 0.5 + notch));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - notch, h * 0.5 + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - dy, h * 0.5 - notch));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - notch, h * 0.5 - notch));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - notch, h * 0.5 - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h * 0.5 - dy - arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h * 0.5 + dy + arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - dy - arrowHead, h - dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + dy + arrowHead, h - dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h * 0.5 - dy - arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h * 0.5 + dy + arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - dy - arrowHead, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + dy + arrowHead, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.75 + (notch - dx) * 0.5, h * 0.5 - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.75 + (notch - dx) * 0.5, h * 0.5 + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - dy, h * 0.75 + (notch - dx) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + dy, h * 0.75 + (notch - dx) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.25 - (notch - dx) * 0.5, h * 0.5 - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.25 - (notch - dx) * 0.5, h * 0.5 + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - dy, h * 0.25 - (notch - dx) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + dy, h * 0.25 - (notch - dx) * 0.5));
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Callout Double 90 Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2CalloutDouble90Arrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy1 = 0.5;
	this.dx1 = 0.5;
	this.dx2 = 0;
	this.dy2 = 0;
	this.arrowHead = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2CalloutDouble90Arrow, mxActor);

mxShapeArrows2CalloutDouble90Arrow.prototype.customProperties = [
	{name: 'dx1', dispName: 'Arrowhead Length', type: 'float', min:0, defVal:20},
	{name: 'dy1', dispName: 'Arrow Width', type: 'float', min:0, defVal: 10},
	{name: 'dx2', dispName: 'Callout Width', type: 'float', min:0, defVal:70},
	{name: 'dy2', dispName: 'Callout Height', type: 'float', min:0, defVal:70},
	{name: 'arrowHead', dispName: 'ArrowHead Width', type: 'float', min:0, defVal:10}
];

mxShapeArrows2CalloutDouble90Arrow.prototype.cst = {
		CALLOUT_DOUBLE_90_ARROW : 'mxgraph.arrows2.calloutDouble90Arrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2CalloutDouble90Arrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy1 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));
	var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var dy2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dy2', this.dy2))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(dx2, 0);
	c.lineTo(dx2, dy2 * 0.5 - dy1);
	c.lineTo(w - dx1, dy2 * 0.5 - dy1);
	c.lineTo(w - dx1, dy2 * 0.5 - dy1 - arrowHead);
	c.lineTo(w, dy2 * 0.5);
	c.lineTo(w - dx1, dy2 * 0.5 + dy1 + arrowHead);
	c.lineTo(w - dx1, dy2 * 0.5 + dy1);
	c.lineTo(dx2, dy2 * 0.5 + dy1);
	c.lineTo(dx2, dy2);
	c.lineTo(dx2 / 2 + dy1, dy2);
	c.lineTo(dx2 / 2 + dy1, h - dx1);
	c.lineTo(dx2 / 2 + dy1 + arrowHead, h - dx1);
	c.lineTo(dx2 / 2, h);
	c.lineTo(dx2 / 2 - dy1 - arrowHead, h - dx1);
	c.lineTo(dx2 / 2 - dy1, h - dx1);
	c.lineTo(dx2 / 2 - dy1, dy2);
	c.lineTo(0, dy2);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2CalloutDouble90Arrow.prototype.cst.CALLOUT_DOUBLE_90_ARROW, mxShapeArrows2CalloutDouble90Arrow);

mxShapeArrows2CalloutDouble90Arrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2CalloutDouble90Arrow.prototype.cst.CALLOUT_DOUBLE_90_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx1', 'dy1'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2)) / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dx1 = Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2)), parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1))));
				var dy1 = Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2)) / 2 - arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1))));

				return new mxPoint(bounds.x + bounds.width - dx1, bounds.y + parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2)) / 2 - dy1);
			}, function(bounds, pt)
			{
				this.state.style['dx1'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2)), bounds.height - parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2)), bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy1'] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2)) / 2 - parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)), bounds.y + parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2)) / 2 - pt.y))) / 100;
				
			})];
			
	var handle2 = Graph.createHandle(state, ['dx2', 'dy2'], function(bounds)
			{
				var dx2 = Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1)) + parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)), Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1)), parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2))));
				var dy2 = Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1)) + parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)), Math.min(bounds.height - parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1)), parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2))));

				return new mxPoint(bounds.x + dx2, bounds.y + dy2);
			}, function(bounds, pt)
			{
				this.state.style['dx2'] = Math.round(100 * Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1)) + parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)), Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1)), pt.x - bounds.x))) / 100;
				this.state.style['dy2'] = Math.round(100 * Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1)) + parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)), Math.min(bounds.height - parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1)), pt.y - bounds.y))) / 100;
			});

	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['arrowHead'], function(bounds)
			{
				var dx1 = 		Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1))));
				var dy1 =        Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2)) / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1))));
				var arrowHead = Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2)) / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));

				return new mxPoint(bounds.x + bounds.width - dx1, bounds.y + parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2)) / 2 - dy1 - arrowHead);
			}, function(bounds, pt)
			{
				this.state.style['arrowHead'] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2)) / 2 - parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1)), bounds.y + parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2)) / 2 - parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1)) - pt.y))) / 100;
			});

	handles.push(handle3);
	
	return handles;
};

mxShapeArrows2CalloutDouble90Arrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy1 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));
	var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var dy2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dy2', this.dy2))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 * 0.5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx1 + dx2) * 0.5, dy2 * 0.5 - dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx1, dy2 * 0.5 - dy1 - arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, dy2 * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx1, dy2 * 0.5 + dy1 + arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx1 + dx2) * 0.5, dy2 * 0.5 + dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2, dy2));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 * 0.5 + dy1, (h - dx1 + dy2) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 * 0.5 - dy1, (h - dx1 + dy2) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 / 2 + dy1 + arrowHead, h - dx1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 / 2, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 / 2 - dy1 - arrowHead, h - dx1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy2));
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Quad Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2QuadArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.notch = 0;
	this.arrowHead = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2QuadArrow, mxActor);

mxShapeArrows2QuadArrow.prototype.customProperties = [
	{name: 'dx', dispName: 'Arrowhead Length', type: 'float', min:0, defVal:20},
	{name: 'dy', dispName: 'Arrow Width', type: 'float', min:0, defVal:10},
	{name: 'arrowHead', dispName: 'Arrowhead Width', type: 'float', min:0, defVal:10}
];

mxShapeArrows2QuadArrow.prototype.cst = {
		QUAD_ARROW : 'mxgraph.arrows2.quadArrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2QuadArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));

	c.begin();
	c.moveTo(w * 0.5 + dy, h * 0.5 - dy);
	c.lineTo(w - dx, h * 0.5 - dy);
	c.lineTo(w - dx, h * 0.5 - dy - arrowHead);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - dx, h * 0.5 + dy + arrowHead);
	c.lineTo(w - dx, h * 0.5 + dy);
	c.lineTo(w * 0.5 + dy, h * 0.5 + dy);
	c.lineTo(w * 0.5 + dy, h - dx);
	c.lineTo(w * 0.5 + dy + arrowHead, h - dx);
	c.lineTo(w * 0.5, h);
	c.lineTo(w * 0.5 - dy - arrowHead, h - dx);
	c.lineTo(w * 0.5 - dy, h - dx);
	c.lineTo(w * 0.5 - dy, h * 0.5 + dy);
	c.lineTo(dx, h * 0.5 + dy);
	c.lineTo(dx, h * 0.5 + dy + arrowHead);
	c.lineTo(0, h * 0.5);
	c.lineTo(dx, h * 0.5 - dy - arrowHead);
	c.lineTo(dx, h * 0.5 - dy);
	c.lineTo(w * 0.5 - dy, h * 0.5 - dy);
	c.lineTo(w * 0.5 - dy, dx);
	c.lineTo(w * 0.5 - dy - arrowHead, dx);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w * 0.5 + dy + arrowHead, dx);
	c.lineTo(w * 0.5 + dy, dx);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2QuadArrow.prototype.cst.QUAD_ARROW, mxShapeArrows2QuadArrow);

mxShapeArrows2QuadArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2QuadArrow.prototype.cst.QUAD_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + bounds.height / 2 - dy);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(Math.min(bounds.width, bounds.height) / 2 - parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)) - parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)), bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)), bounds.y + bounds.height / 2 - pt.y))) / 100;
				
			})];
			
	var handle2 = Graph.createHandle(state, ['arrowHead'], function(bounds)
			{
				var dx = 		Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy =        Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
				var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + bounds.height / 2 - dy - arrowHead);
			}, function(bounds, pt)
			{
				this.state.style['arrowHead'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)), bounds.y + bounds.height / 2 - pt.y))) / 100;
			});

	handles.push(handle2);
	
	return handles;
};

mxShapeArrows2QuadArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));

	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h * 0.5 - dy - arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h * 0.5 + dy + arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h * 0.5 - dy - arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h * 0.5 + dy + arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - dy - arrowHead, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + dy + arrowHead, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - dy - arrowHead, h - dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + dy + arrowHead, h - dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - dy, (dx - dy) * 0.5 + h * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + dy, (dx - dy) * 0.5 + h * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - dy, (dy - dx) * 0.5 + h * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + dy, (dy - dx) * 0.5 + h * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (dx - dy) * 0.5 + w * 0.25, h * 0.5 - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (dx - dy) * 0.5 + w * 0.25, h * 0.5 + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (dy - dx) * 0.5 + w * 0.75, h * 0.5 - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (dy - dx) * 0.5 + w * 0.75, h * 0.5 + dy));
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Triad Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2TriadArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.arrowHead = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2TriadArrow, mxActor);

mxShapeArrows2TriadArrow.prototype.customProperties = [
	{name: 'dx', dispName: 'Arrowhead Length', type: 'float', min:0, defVal:20},
	{name: 'dy', dispName: 'Arrow Width', type: 'float', min:0, defVal:10},
	{name: 'arrowHead', dispName: 'Arrowhead Width', type: 'float', min:0, defVal:40}
];

mxShapeArrows2TriadArrow.prototype.cst = {
		TRIAD_ARROW : 'mxgraph.arrows2.triadArrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2TriadArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));

	c.begin();
	c.moveTo(w * 0.5 + arrowHead * 0.5 - dy, h - arrowHead + dy);
	c.lineTo(w - dx, h - arrowHead + dy);
	c.lineTo(w - dx, h - arrowHead);
	c.lineTo(w, h - arrowHead * 0.5);
	c.lineTo(w - dx, h);
	c.lineTo(w - dx, h - dy);
	c.lineTo(dx, h - dy);
	c.lineTo(dx, h);
	c.lineTo(0, h - arrowHead * 0.5);
	c.lineTo(dx, h - arrowHead);
	c.lineTo(dx, h - arrowHead + dy);
	c.lineTo(w * 0.5 - arrowHead * 0.5 + dy, h - arrowHead + dy);
	c.lineTo(w * 0.5 - arrowHead * 0.5 + dy, dx);
	c.lineTo(w * 0.5 - arrowHead * 0.5, dx);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w * 0.5 + arrowHead * 0.5, dx);
	c.lineTo(w * 0.5 + arrowHead * 0.5 - dy, dx);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2TriadArrow.prototype.cst.TRIAD_ARROW, mxShapeArrows2TriadArrow);

mxShapeArrows2TriadArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2TriadArrow.prototype.cst.TRIAD_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + bounds.height - dy);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(Math.min(bounds.height - parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)), bounds.width / 2 - parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)) / 2), bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)) / 2, bounds.y + bounds.height - pt.y))) / 100;
				
			})];
			
	var handle2 = Graph.createHandle(state, ['arrowHead'], function(bounds)
			{
				var dx = 		Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy =        Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
				var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + bounds.height - arrowHead);
			}, function(bounds, pt)
			{
				this.state.style['arrowHead'] = Math.round(100 * Math.max(2 * parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)), Math.min(bounds.height - parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx)), bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx)) * 2, bounds.y + bounds.height - pt.y))) / 100;
			});

	handles.push(handle2);
	
	return handles;
};

mxShapeArrows2TriadArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));

	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, - arrowHead * 0.5, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, arrowHead * 0.5, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h - arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h - arrowHead * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h - arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - arrowHead * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w * 1.5 - dx + arrowHead * 0.5 - dy) * 0.5, h - arrowHead + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w * 1.5 - dx + arrowHead * 0.5 - dy) * 0.5, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w * 0.5 + dx - arrowHead * 0.5 + dy) * 0.5, h - arrowHead + dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w * 0.5 + dx - arrowHead * 0.5 + dy) * 0.5, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - arrowHead * 0.5 + dy, (dx + h - arrowHead + dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + arrowHead * 0.5 - dy, (dx + h - arrowHead + dy) * 0.5));
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Tailed Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2TailedArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.notch = 0;
	this.arrowHead = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2TailedArrow, mxActor);

mxShapeArrows2TailedArrow.prototype.customProperties = [
	{name: 'dx1', dispName: 'Arrowhead Length', type: 'float', min:0, defVal: 20},
	{name: 'dy1', dispName: 'Arrow Width', type: 'float', min:0, defVal: 10},
	{name: 'dx2', dispName: 'Tail Length', type: 'float', min:0, defVal: 25},
	{name: 'dy2', dispName: 'Tail Width', type: 'float', min:0, defVal:30},
	{name: 'notch', dispName: 'Notch', type: 'float', min:0, defVal: 0},
	{name: 'arrowHead', dispName: 'Arrowhead Width', type: 'float', min:0, defVal:20}
];

mxShapeArrows2TailedArrow.prototype.cst = {
		TAILED_ARROW : 'mxgraph.arrows2.tailedArrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2TailedArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy1 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));
	var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dy2 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy2', this.dy2))));
	var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));
	var x2 = 0;
	
	if (dy2 != 0)
	{
		x2 = dx2 + dy2 * (dy2 - dy1) / dy2;
	}

	c.begin();
	c.moveTo(0, h * 0.5 - dy2);
	c.lineTo(dx2, h * 0.5 - dy2);
	c.lineTo(x2, h * 0.5 - dy1);
	c.lineTo(w - dx1, h * 0.5 - dy1);
	c.lineTo(w - dx1, h * 0.5 - dy1 - arrowHead);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - dx1, h * 0.5 + dy1 + arrowHead);
	c.lineTo(w - dx1, h * 0.5 + dy1);
	c.lineTo(x2, h * 0.5 + dy1);
	c.lineTo(dx2, h * 0.5 + dy2);
	c.lineTo(0, h * 0.5 + dy2);
	c.lineTo(notch, h * 0.5);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2TailedArrow.prototype.cst.TAILED_ARROW, mxShapeArrows2TailedArrow);

mxShapeArrows2TailedArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2TailedArrow.prototype.cst.TAILED_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx1', 'dy1'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dx1 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1))));
				var dy1 = Math.max(0, Math.min(bounds.height / 2 - arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1))));

				return new mxPoint(bounds.x + bounds.width - dx1, bounds.y + bounds.height / 2 - dy1);
			}, function(bounds, pt)
			{
				this.state.style['dx1'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch)), bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2)), bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy1'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)), parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2)), bounds.y + bounds.height / 2 - pt.y))) / 100;
				
			})];
			
	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
			{
				var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

				return new mxPoint(bounds.x + notch, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1)), parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2)), pt.x - bounds.x))) / 100;
			});

	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['arrowHead'], function(bounds)
			{
				var dx1 = 		Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1))));
				var dy1 =        Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1))));
				var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));

				return new mxPoint(bounds.x + bounds.width - dx1, bounds.y + bounds.height / 2 - dy1 - arrowHead);
			}, function(bounds, pt)
			{
				this.state.style['arrowHead'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1)), bounds.y + bounds.height / 2 - pt.y))) / 100;
			});

	handles.push(handle3);
	
	var handle4 = Graph.createHandle(state, ['dx2', 'dy2'], function(bounds)
			{
				var dx2 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2))));
				var dy2 = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2))));

				return new mxPoint(bounds.x + dx2, bounds.y + bounds.height / 2 - dy2);
			}, function(bounds, pt)
			{
				this.state.style['dx2'] = Math.round(100 * Math.max(parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch)), Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1)) - parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2)) + parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1)) - 1, pt.x - bounds.x))) / 100;
				this.state.style['dy2'] = Math.round(100 * Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1)), Math.min(bounds.height / 2, bounds.y + bounds.height / 2 - pt.y))) / 100;
				
			});

	handles.push(handle4);

	return handles;
};

mxShapeArrows2TailedArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy1 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));
	var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dy2 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy2', this.dy2))));
	var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));
	var x2 = 0;
	
	if (dy2 != 0)
	{
		x2 = dx2 + dy2 * (dy2 - dy1) / dy2;
	}

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, notch, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h * 0.5 - dy2));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2, h * 0.5 - dy2));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx1 + x2) * 0.5, h * 0.5 - dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx1, h * 0.5 - dy1 - arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h * 0.5 + dy2));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2, h * 0.5 + dy2));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx1 + x2) * 0.5, h * 0.5 + dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx1, h * 0.5 + dy1 + arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Tailed Arrow with Notch
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2TailedNotchedArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.notch = 0;
	this.arrowHead = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2TailedNotchedArrow, mxActor);

mxShapeArrows2TailedNotchedArrow.prototype.customProperties = [
	{name: 'dx1', dispName: 'Arrowhead Length', type: 'float', mix:0, defVal:20},
	{name: 'dy1', dispName: 'Arrow Width', type: 'float', min:0, defVal:10},
	{name: 'dx2', dispName: 'Tail Length', type: 'float', min:0, defVal:25},
	{name: 'dy2', dispName: 'Tail Width', type: 'float', min:0, defVal:30},
	{name: 'notch', dispName: 'Notch', type: 'float', min:0, defVal:20},
	{name: 'arrowHead', dispName: 'Arrowhead Width', type: 'float', min:0, defVal:20}
];

mxShapeArrows2TailedNotchedArrow.prototype.cst = {
		TAILED_NOTCHED_ARROW : 'mxgraph.arrows2.tailedNotchedArrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2TailedNotchedArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy1 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));
	var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dy2 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy2', this.dy2))));
	var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));
	var x2 = 0;
	
	if (dy2 != 0)
	{
		x2 = dx2 + notch * (dy2 - dy1) / dy2;
	}

	c.begin();
	c.moveTo(0, h * 0.5 - dy2);
	c.lineTo(dx2, h * 0.5 - dy2);
	c.lineTo(x2, h * 0.5 - dy1);
	c.lineTo(w - dx1, h * 0.5 - dy1);
	c.lineTo(w - dx1, h * 0.5 - dy1 - arrowHead);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - dx1, h * 0.5 + dy1 + arrowHead);
	c.lineTo(w - dx1, h * 0.5 + dy1);
	c.lineTo(x2, h * 0.5 + dy1);
	c.lineTo(dx2, h * 0.5 + dy2);
	c.lineTo(0, h * 0.5 + dy2);
	c.lineTo(notch, h * 0.5);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2TailedNotchedArrow.prototype.cst.TAILED_NOTCHED_ARROW, mxShapeArrows2TailedNotchedArrow);

mxShapeArrows2TailedNotchedArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2TailedNotchedArrow.prototype.cst.TAILED_NOTCHED_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx1', 'dy1'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dx1 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1))));
				var dy1 = Math.max(0, Math.min(bounds.height / 2 - arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1))));

				return new mxPoint(bounds.x + bounds.width - dx1, bounds.y + bounds.height / 2 - dy1);
			}, function(bounds, pt)
			{
				this.state.style['dx1'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))- parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2)), bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy1'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)), parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2)), bounds.y + bounds.height / 2 - pt.y))) / 100;
				
			})];
			
	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
			{
				var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

				return new mxPoint(bounds.x + notch, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1)), pt.x - bounds.x))) / 100;
			});

	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['arrowHead'], function(bounds)
			{
				var dx1 = 		Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1))));
				var dy1 =        Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1))));
				var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));

				return new mxPoint(bounds.x + bounds.width - dx1, bounds.y + bounds.height / 2 - dy1 - arrowHead);
			}, function(bounds, pt)
			{
				this.state.style['arrowHead'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1)), bounds.y + bounds.height / 2 - pt.y))) / 100;
			});

	handles.push(handle3);
	
	var handle4 = Graph.createHandle(state, ['dx2', 'dy2'], function(bounds)
			{
				var dx2 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2))));
				var dy2 = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2))));

				return new mxPoint(bounds.x + dx2, bounds.y + bounds.height / 2 - dy2);
			}, function(bounds, pt)
			{
				this.state.style['dx2'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch)) - parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1)), pt.x - bounds.x))) / 100;
				this.state.style['dy2'] = Math.round(100 * Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1)), Math.min(bounds.height / 2, bounds.y + bounds.height / 2 - pt.y))) / 100;
				
			});

	handles.push(handle4);

	return handles;
};

mxShapeArrows2TailedNotchedArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy1 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));
	var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dy2 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy2', this.dy2))));
	var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));
	var x2 = 0;
	
	if (dy2 != 0)
	{
		x2 = dx2 + notch * (dy2 - dy1) / dy2;
	}

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, notch, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h * 0.5 - dy2));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2, h * 0.5 - dy2));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx1 + x2) * 0.5, h * 0.5 - dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx1, h * 0.5 - dy1 - arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h * 0.5 + dy2));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2, h * 0.5 + dy2));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx1 + x2) * 0.5, h * 0.5 + dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx1, h * 0.5 + dy1 + arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Striped Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2StripedArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.notch = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2StripedArrow, mxActor);

mxShapeArrows2StripedArrow.prototype.customProperties = [
	{name: 'dx', dispName: 'Arrowhead Length', type: 'float', min:0, defVal:40},
	{name: 'dy', dispName: 'Arrow Width', type: 'float', min:0, max:1, defVal:0.6},
	{name: 'notch', dispName: 'Stripes Length', type: 'float', min:0, defVal:25}
];

mxShapeArrows2StripedArrow.prototype.cst = {
		STRIPED_ARROW : 'mxgraph.arrows2.stripedArrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2StripedArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));

	c.begin();
	c.moveTo(notch, dy);
	c.lineTo(w - dx, dy);
	c.lineTo(w - dx, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - dx, h);
	c.lineTo(w - dx, h - dy);
	c.lineTo(notch, h - dy);
	c.close();
	c.moveTo(0, h - dy);
	c.lineTo(notch * 0.16, h - dy);
	c.lineTo(notch * 0.16, dy);
	c.lineTo(0, dy);
	c.close();
	c.moveTo(notch * 0.32, h - dy);
	c.lineTo(notch * 0.8, h - dy);
	c.lineTo(notch * 0.8, dy);
	c.lineTo(notch * 0.32, dy);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2StripedArrow.prototype.cst.STRIPED_ARROW, mxShapeArrows2StripedArrow);

mxShapeArrows2StripedArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2StripedArrow.prototype.cst.STRIPED_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
			{
				var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + dy * bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch)), bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(1, (((pt.y - bounds.y) / bounds.height) * 2)))) / 100;
			})];
			
	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
			{
				var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

				return new mxPoint(bounds.x + notch, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx)), pt.x - bounds.x))) / 100;
			});
	
	handles.push(handle2);
	
	return handles;
};

mxShapeArrows2StripedArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = h * 0.5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));

	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, 0, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx) * 0.5, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx) * 0.5, h - dy));
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Jump-In Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2JumpInArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.arrowHead = 40;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2JumpInArrow, mxActor);

mxShapeArrows2JumpInArrow.prototype.customProperties = [
	{name: 'dx', dispName: 'Arrowhead Length', type: 'float', min:0, defVal:38},
	{name: 'dy', dispName: 'Arrow Width', type: 'float', min:0, defVal:15},
	{name: 'arrowHead', dispName: 'Arrowhead Width', type: 'float', min:0, defVal:55}
];

mxShapeArrows2JumpInArrow.prototype.cst = {
		JUMP_IN_ARROW : 'mxgraph.arrows2.jumpInArrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2JumpInArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));

	c.begin();
	c.moveTo(w - dx, 0);
	c.lineTo(w, arrowHead * 0.5);
	c.lineTo(w - dx, arrowHead);
	c.lineTo(w - dx, arrowHead / 2 + dy);
	c.arcTo(w - dx, h - arrowHead / 2 - dy, 0, 0, 0, 0, h);
	c.arcTo(w - dx, h - arrowHead / 2 + dy, 0, 0, 1, w - dx, arrowHead / 2 - dy);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2JumpInArrow.prototype.cst.JUMP_IN_ARROW, mxShapeArrows2JumpInArrow);

mxShapeArrows2JumpInArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2JumpInArrow.prototype.cst.JUMP_IN_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
		
				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + arrowHead / 2 - dy);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width, bounds.x + bounds.width - pt.x))) / 100;
				this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)) / 2, bounds.y + parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)) / 2 - pt.y))) / 100;
				
			})];
			
	var handle2 = Graph.createHandle(state, ['arrowHead'], function(bounds)
			{
				var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
				var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));

				return new mxPoint(bounds.x + bounds.width - dx, bounds.y + arrowHead);
			}, function(bounds, pt)
			{
				this.state.style['arrowHead'] = Math.round(100 * Math.max(2 * parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)), Math.min(bounds.height, pt.y - bounds.y))) / 100;
			});
	
	handles.push(handle2);

	return handles;
};

mxShapeArrows2JumpInArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));

	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, arrowHead * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, arrowHead));
	
	return (constr);
};

//**********************************************************************************************************************************************************
//U Turn Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeArrows2UTurnArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.arrowHead = 40;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeArrows2UTurnArrow, mxActor);

mxShapeArrows2UTurnArrow.prototype.customProperties = [
	{name: 'dx2', dispName: 'Arrowhead Length', type: 'float', min:0, defVal:25},
	{name: 'dy', dispName: 'Arrow Width', type: 'float', min:0, defVal:11},
	{name: 'arrowHead', dispName: 'Arrowhead Width', type: 'float', min:0, defVal:43}
];

mxShapeArrows2UTurnArrow.prototype.cst = {
		U_TURN_ARROW : 'mxgraph.arrows2.uTurnArrow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeArrows2UTurnArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));
	var dx = (h - arrowHead / 2 + dy) / 2;
	var dx2 = Math.max(0, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2)));
	
	c.begin();
	c.moveTo(dx, 0);
	c.lineTo(dx + dx2, arrowHead * 0.5);
	c.lineTo(dx, arrowHead);
	c.lineTo(dx, arrowHead / 2 + dy);
	c.arcTo(dx - 2 * dy, dx - 2 * dy, 0, 0, 0, dx, h - 2 * dy);
	c.lineTo(Math.max(w, dx), h - 2 * dy);
	c.lineTo(Math.max(w, dx), h);
	c.lineTo(dx, h);
	c.arcTo(dx, dx, 0, 0, 1, dx, arrowHead / 2 - dy);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeArrows2UTurnArrow.prototype.cst.U_TURN_ARROW, mxShapeArrows2UTurnArrow);

mxShapeArrows2UTurnArrow.prototype.constraints = null;

Graph.handleFactory[mxShapeArrows2UTurnArrow.prototype.cst.U_TURN_ARROW] = function(state)
{
	var handles = [Graph.createHandle(state, ['dy'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
				var dx = (bounds.height - arrowHead / 2 + dy) / 2;

				return new mxPoint(bounds.x + dx, bounds.y + arrowHead / 2 - dy);
			}, function(bounds, pt)
			{
				this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)) / 2, bounds.y + parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead)) / 2 - pt.y))) / 100;
				
			})];

	var handle2 = Graph.createHandle(state, ['dx2'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
				var dx = (bounds.height - arrowHead / 2 + dy) / 2;
				
				var dx2 = Math.max(0, Math.min(bounds.width - dx, parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2))));

				return new mxPoint(bounds.x + dx + dx2, bounds.y + arrowHead / 2);
			}, function(bounds, pt)
			{
				var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
				var dx = (bounds.height - arrowHead / 2 + dy) / 2;
				this.state.style['dx2'] = Math.round(100 * Math.max(0, Math.min(Math.max(bounds.width, dx), pt.x - bounds.x - dx))) / 100;
			});
	
	handles.push(handle2);

	var handle3 = Graph.createHandle(state, ['arrowHead'], function(bounds)
			{
				var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'arrowHead', this.arrowHead))));
				var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
				var dx = (bounds.height - arrowHead / 2 + dy) / 2;

				return new mxPoint(bounds.x + dx, bounds.y + arrowHead);
			}, function(bounds, pt)
			{
				this.state.style['arrowHead'] = Math.round(100 * Math.max(2 * parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)), Math.min(bounds.height / 2, pt.y - bounds.y))) / 100;
			});
	
	handles.push(handle3);

	return handles;
};

mxShapeArrows2UTurnArrow.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'arrowHead', this.arrowHead))));
	var dx = (h - arrowHead / 2 + dy) / 2;
	var dx2 = Math.max(0, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2)));
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx + dx2, arrowHead * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, arrowHead));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (dx + w) * 0.5, h - 2 * dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, Math.max(w, dx), h - 2 * dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, Math.max(w, dx), h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, Math.max(w, dx), h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (dx + w) * 0.5, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h + arrowHead * 0.5 - dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, arrowHead - 2 * dy, (h + arrowHead * 0.5 - dy) * 0.5));
	
	return (constr);
};

/**
 * $Id: mxAtlassian.js,v 1.0 2018/24/05 12:32:06 mate Exp $
 * Copyright (c) 2006-2018, JGraph Ltd
 */
//**********************************************************************************************************************************************************
// Issue
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxAtlassianJiraIssue(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxAtlassianJiraIssue, mxRectangleShape);

mxAtlassianJiraIssue.prototype.customProperties = [
	{name: 'issueType', dispName: 'Issue Type', type: 'enum', 
		enumList: [{val: 'story', dispName: 'Story'}, 
				   {val: 'task', dispName: 'Task'}, 
				   {val: 'subTask', dispName: 'Sub-Task'}, 
				   {val: 'feature', dispName: 'Feature'}, 
				   {val: 'bug', dispName: 'Bug'}, 
				   {val: 'techTask', dispName: 'Tech Task'}, 
				   {val: 'epic', dispName: 'Epic'}, 
				   {val: 'improvement', dispName: 'Improvement'}, 
				   {val: 'fault', dispName: 'Fault'}, 
				   {val: 'change', dispName: 'Change'}, 
				   {val: 'access', dispName: 'Access'}, 
				   {val: 'purchase', dispName: 'Purchase'}, 
				   {val: 'itHelp', dispName: 'IT Help'}] 
	},
	{name: 'issuePriority', dispName: 'Issue Priority', type: 'enum', 
		enumList: [{val: 'blocker', dispName: 'Blocker'}, 
				   {val: 'critical', dispName: 'Critical'}, 
				   {val: 'major', dispName: 'Major'}, 
				   {val: 'minor', dispName: 'Minor'}, 
				   {val: 'trivial', dispName: 'Trivial'}] 
	},
	{name: 'issueStatus', dispName: 'Issue Status', type: 'enum', 
		enumList: [{val: 'todo', dispName: 'TODO'}, 
				   {val: 'inProgress', dispName: 'In Progress'}, 
				   {val: 'inReview', dispName: 'In Review'}, 
				   {val: 'done', dispName: 'Done'}] 
	}
];

mxAtlassianJiraIssue.prototype.cst = {ISSUE : 'mxgraph.atlassian.issue'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxAtlassianJiraIssue.prototype.paintForeground = function(c, x, y, w, h)
{
	c.translate(x, y);

	var issueType = mxUtils.getValue(this.style, 'issueType', 'task');
	var issuePriority = mxUtils.getValue(this.style, 'issuePriority', 'minor');
	var issueStatus = mxUtils.getValue(this.style, 'issueStatus', 'todo');

	c.setStrokeColor('none');
	
	switch (issueType) {
		case 'story':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.story');
			
			if (stencil != null)
			{
				c.setFillColor('#61B659');
				stencil.drawShape(c, this, 5, 5, 10, 10);
			}
			
			break;
		case 'task':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.task');
			
			if (stencil != null)
			{
				c.setFillColor('#5EA3E4');
				stencil.drawShape(c, this, 5, 5, 10, 10);
			}
			
			break;
		case 'subTask':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.subtask');
			
			if (stencil != null)
			{
				c.setFillColor('#5EA3E4');
				stencil.drawShape(c, this, 5, 5, 10, 10);
			}
			
			break;
		case 'feature':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.new_feature');
			
			if (stencil != null)
			{
				c.setFillColor('#61B659');
				stencil.drawShape(c, this, 5, 5, 10, 10);
			}
			
			break;
		case 'bug':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.bug');
			
			if (stencil != null)
			{
				c.setFillColor('#CE0000');
				stencil.drawShape(c, this, 5, 5, 10, 10);
			}
			
			break;
		case 'techTask':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.tech_task');
			
			if (stencil != null)
			{
				c.setFillColor('#999C95');
				stencil.drawShape(c, this, 5, 5, 10, 10);
			}
			
			break;
		case 'epic':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.epic');
			
			if (stencil != null)
			{
				c.setFillColor('#9E4ADD');
				stencil.drawShape(c, this, 5, 5, 10, 10);
			}
			
			break;
		case 'improvement':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.improvement');
			
			if (stencil != null)
			{
				c.setFillColor('#61B659');
				stencil.drawShape(c, this, 5, 5, 10, 10);
			}
			
			break;
		case 'fault':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.fault');
			
			if (stencil != null)
			{
				c.setFillColor('#F8902F');
				stencil.drawShape(c, this, 5, 5, 10, 10);
			}
			
			break;
		case 'change':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.change');
			
			if (stencil != null)
			{
				c.setFillColor('#9E4ADD');
				stencil.drawShape(c, this, 5, 5, 10, 10);
			}
			
			break;
		case 'access':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.access');
			
			if (stencil != null)
			{
				c.setFillColor('#F8902F');
				stencil.drawShape(c, this, 5, 5, 10, 10);
			}
			
			break;
		case 'purchase':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.purchase');
			
			if (stencil != null)
			{
				c.setFillColor('#61B659');
				stencil.drawShape(c, this, 5, 5, 10, 10);
			}
			
			break;
		case 'itHelp':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.it_help');
			
			if (stencil != null)
			{
				c.setFillColor('#5EA3E4');
				stencil.drawShape(c, this, 5, 5, 10, 10);
			}
			
			break;
	}

	switch (issuePriority) {
		case 'blocker':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.no');
			
			if (stencil != null)
			{
				c.setFillColor('#CE0000');
				stencil.drawShape(c, this, 85, 5, 10, 10);
			}
			break;
		case 'critical':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.critical');
			
			if (stencil != null)
			{
				c.setFillColor('#CE0000');
				stencil.drawShape(c, this, 86, 3, 8, 14);
			}
			break;
		case 'major':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.double_up');
			
			if (stencil != null)
			{
				c.setFillColor('#CE0000');
				stencil.drawShape(c, this, 85, 5, 10, 10);
			}
			break;
		case 'minor':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.double');
			
			if (stencil != null)
			{
				c.setFillColor('#2A8735');
				stencil.drawShape(c, this, 85, 5, 10, 10);
			}
			break;
		case 'trivial':
			var stencil = mxStencilRegistry.getStencil('mxgraph.atlassian.single');
			
			if (stencil != null)
			{
				c.setFillColor('#9AA1B2');
				stencil.drawShape(c, this, 85, 5, 10, 10);
			}
			break;
	}

	c.setFillColor('#FFFFFD');
	c.setFontColor('#4E6B89');
	
	switch (issueStatus) {
		case 'todo':
			c.rect(w - 45, 5, 40, 20);
			c.fill();
			
			c.text(w - 25, 15, 0, 0, 'TO DO', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			break;
		case 'inProgress':
			c.rect(w - 85, 5, 80, 20);
			c.fill();
			
			c.text(w - 45, 15, 0, 0, 'IN PROGRESS', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			break;
		case 'inReview':
			c.rect(w - 75, 5, 70, 20);
			c.fill();
			
			c.text(w - 40, 15, 0, 0, 'IN REVIEW', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			break;
		case 'done':
			c.rect(w - 45, 5, 40, 20);
			c.fill();
			
			c.text(w - 25, 15, 0, 0, 'DONE', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			break;
	    default:
	    	var tw = mxUtils.getValue(this.style, 'issueStatusWidth', issueStatus.length * 6.5);
			c.rect(w - tw - 5, 5, tw, 20);
			c.fill();
	    	c.text(w - 7, 15, 0, 0, issueStatus, mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
};

mxCellRenderer.registerShape(mxAtlassianJiraIssue.prototype.cst.ISSUE, mxAtlassianJiraIssue);

/**
 * $Id: mxBasic.js,v 1.5 2016/04/1 12:32:06 mate Exp $
 * Copyright (c) 2006-2018, JGraph Ltd
 */
//**********************************************************************************************************************************************************
// Cross
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicCross(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicCross, mxActor);

mxShapeBasicCross.prototype.cst = {CROSS : 'mxgraph.basic.cross2'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicCross.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	c.begin();
	c.moveTo(w * 0.5 + dx, 0);
	c.lineTo(w * 0.5 + dx, h * 0.5 - dx);
	c.lineTo(w, h * 0.5 - dx);
	c.lineTo(w, h * 0.5 + dx);
	c.lineTo(w * 0.5 + dx, h * 0.5 + dx);
	c.lineTo(w * 0.5 + dx, h);
	c.lineTo(w * 0.5 - dx, h);
	c.lineTo(w * 0.5 - dx, h * 0.5 + dx);
	c.lineTo(0, h * 0.5 + dx);
	c.lineTo(0, h * 0.5 - dx);
	c.lineTo(w * 0.5 - dx, h * 0.5 - dx);
	c.lineTo(w * 0.5 - dx, 0);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicCross.prototype.cst.CROSS, mxShapeBasicCross);

mxShapeBasicCross.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicCross.prototype.cst.CROSS] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + bounds.width / 2 + dx, bounds.y + bounds.height / 2 - dx);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x - bounds.width / 2))) / 100;
	})];
			
	return handles;
};

//**********************************************************************************************************************************************************
// Rectangular Callout
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicRectCallout(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicRectCallout, mxActor);

mxShapeBasicRectCallout.prototype.customProperties = [
	{name: 'dx', dispName: 'Callout Position', type: 'float', min:0, defVal:30},
	{name: 'dy', dispName: 'Callout Size', type: 'float', min:0, defVal:15}
];

mxShapeBasicRectCallout.prototype.cst = {RECT_CALLOUT : 'mxgraph.basic.rectCallout'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicRectCallout.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));

	c.begin();
	c.moveTo(dx - dy * 0.5, h - dy);
	c.lineTo(0, h - dy);
	c.lineTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h - dy);
	c.lineTo(dx + dy * 0.5, h - dy);
	c.lineTo(dx - dy, h);
	c.close();
	c.fillAndStroke();
};

mxShapeBasicRectCallout.prototype.getLabelMargins = function()
{
	if (mxUtils.getValue(this.style, 'boundedLbl', false))
	{
		return new mxRectangle(0, 0, 0, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy)) * this.scale);
	}
	
	return null;
};

mxCellRenderer.registerShape(mxShapeBasicRectCallout.prototype.cst.RECT_CALLOUT, mxShapeBasicRectCallout);

mxShapeBasicRectCallout.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicRectCallout.prototype.cst.RECT_CALLOUT] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + dx, bounds.y + bounds.height - dy);
	}, function(bounds, pt)
	{
		var y = parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)) * 0.6;
		this.state.style['dx'] = Math.round(100 * Math.max(y, Math.min(bounds.width - y, pt.x - bounds.x))) / 100;
		this.state.style['dy'] = Math.round(Math.max(0, Math.min(bounds.height, bounds.y + bounds.height - pt.y)));
	})];
			
	return handles;
};

mxShapeBasicRectCallout.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, (h - dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx - dy, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - dy) * 0.5));

	return (constr);
}

//**********************************************************************************************************************************************************
// Rounded Rectangular Callout
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicRoundRectCallout(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.size = 10;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicRoundRectCallout, mxActor);

mxShapeBasicRoundRectCallout.prototype.cst = {ROUND_RECT_CALLOUT : 'mxgraph.basic.roundRectCallout'};

mxShapeBasicRoundRectCallout.prototype.getLabelMargins = mxShapeBasicRectCallout.prototype.getLabelMargins;

mxShapeBasicRoundRectCallout.prototype.customProperties = [
	{name: 'size', dispName: 'Arc Size', type: 'float', min:0, defVal:5},
	{name: 'dx', dispName: 'Callout Position', type: 'float', min:0, defVal:30},
	{name: 'dy', dispName: 'Callout Size', type: 'float', min:0, defVal:15}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicRoundRectCallout.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var r = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));

	r = Math.min((h - dy) / 2, w / 2, r);
	dx = Math.max(r + dy * 0.5, dx);
	dx = Math.min(w - r - dy * 0.5, dx);
	
	c.begin();
	c.moveTo(dx - dy * 0.5, h - dy);
	c.lineTo(r, h - dy);
	c.arcTo(r, r, 0, 0, 1, 0, h - dy - r);
	c.lineTo(0, r);
	c.arcTo(r, r, 0, 0, 1, r, 0);
	c.lineTo(w - r, 0);
	c.arcTo(r, r, 0, 0, 1, w, r);
	c.lineTo(w, h - dy - r);
	c.arcTo(r, r, 0, 0, 1, w - r, h - dy);
	c.lineTo(dx + dy * 0.5, h - dy);
	c.arcTo(1.9 * dy, 1.4 * dy, 0, 0, 1, dx - dy, h);
	c.arcTo(0.9 * dy, 1.4 * dy, 0, 0, 0, dx - dy * 0.5, h - dy);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicRoundRectCallout.prototype.cst.ROUND_RECT_CALLOUT, mxShapeBasicRoundRectCallout);

mxShapeBasicRoundRectCallout.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicRoundRectCallout.prototype.cst.ROUND_RECT_CALLOUT] = function(state)
{
	return [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + dx, bounds.y + bounds.height - dy);
	}, function(bounds, pt)
	{
		var y = parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)) * 0.6;
		this.state.style['dx'] = Math.round(100 * Math.max(y, Math.min(bounds.width - y, pt.x - bounds.x))) / 100;
		this.state.style['dy'] = Math.round(Math.max(0, Math.min(bounds.height, bounds.y + bounds.height - pt.y)));
	}), Graph.createHandle(state, ['size'], function(bounds)
	{
		var size = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'size', this.size))));

		return new mxPoint(bounds.x + bounds.width - size, bounds.y + 10);
	}, function(bounds, pt)
	{
		var dy = parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy));
		this.state.style['size'] = Math.round(100 * Math.max(0, Math.min(bounds.width / 2, (bounds.height - dy) / 2, bounds.x + bounds.width - pt.x))) / 100;
	})];
};

mxShapeBasicRoundRectCallout.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var r = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));

	r = Math.min((h - dy) / 2, w / 2, r);
	dx = Math.max(r + dy * 0.5, dx);
	dx = Math.min(w - r - dy * 0.5, dx);
	
	if (r < w * 0.25)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
		constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	}
	
	if (r < (h - dy) * 0.25)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, (h - dy) * 0.25));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, (h - dy) * 0.75));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - dy) * 0.25));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - dy) * 0.75));
	}

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, r * 0.293, r * 0.293));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - r * 0.293, r * 0.293));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, (h - dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - r * 0.293, h - dy - r * 0.293));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, r * 0.293, h - dy - r * 0.293));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx - dy, h));

	return (constr);
}

//**********************************************************************************************************************************************************
// Wave
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicWave(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicWave, mxActor);

mxShapeBasicWave.prototype.customProperties = [
	{name: 'dy', dispName: 'Wave Size', type: 'float', min:0, max:1, defVal: 0.3}
];

mxShapeBasicWave.prototype.cst = {WAVE : 'mxgraph.basic.wave2'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicWave.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var fy = 1.4
	
	c.begin();
	c.moveTo(0, dy / 2);
	c.quadTo(w / 6, dy * (1 - fy), w / 3, dy / 2);
	c.quadTo(w / 2, dy * fy, w * 2 / 3, dy / 2);
	c.quadTo(w * 5 / 6, dy * (1 - fy), w, dy / 2);
	c.lineTo(w, h - dy / 2);
	c.quadTo(w * 5 / 6, h - dy * fy, w * 2 / 3, h - dy / 2);
	c.quadTo(w / 2, h - dy * (1 - fy), w / 3, h - dy / 2);
	c.quadTo(w / 6, h - dy * fy, 0, h - dy / 2);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicWave.prototype.cst.WAVE, mxShapeBasicWave);

mxShapeBasicWave.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicWave.prototype.cst.WAVE] = function(state)
{
	var handles = [Graph.createHandle(state, ['dy'], function(bounds)
	{
		var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + bounds.width / 2, bounds.y + dy * bounds.height);
	}, function(bounds, pt)
	{
		this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 100;
	})];

	return handles;
};

mxShapeBasicWave.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var fy = 1.4
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w / 6, h * 0.015));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w / 3, dy * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5, dy * 0.95));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.67, dy * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.83, h * 0.015));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, dy * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h - dy * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.83, h - dy * 0.95));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.67, h - dy * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5, h - dy * 0.04));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w / 3, h - dy * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w / 6, h - dy * 0.95));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - dy * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h * 0.5));

	return (constr);
}

//**********************************************************************************************************************************************************
//Octagon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicOctagon(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicOctagon, mxActor);

mxShapeBasicOctagon.prototype.customProperties = [
	{name: 'dx', dispName: 'Cutoff Size', type: 'float', min:0, defVal:15}
];

mxShapeBasicOctagon.prototype.cst = {OCTAGON : 'mxgraph.basic.octagon2'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicOctagon.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx)))) * 2;

	dx = Math.min(w * 0.5, h * 0.5, dx);
	
	c.begin();
	c.moveTo(dx, 0);
	c.lineTo(w - dx, 0);
	c.lineTo(w, dx);
	c.lineTo(w, h - dx);
	c.lineTo(w - dx, h);
	c.lineTo(dx, h);
	c.lineTo(0, h - dx);
	c.lineTo(0, dx);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicOctagon.prototype.cst.OCTAGON, mxShapeBasicOctagon);

mxShapeBasicOctagon.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicOctagon.prototype.cst.OCTAGON] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx, bounds.y + dx);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

mxShapeBasicOctagon.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx)))) * 2;

	dx = Math.min(w * 0.5, h * 0.5, dx) * 0.5;
	
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h - dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h - dx));

	return (constr);
}

//**********************************************************************************************************************************************************
//Isometric Cube
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicIsoCube(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.isoAngle = 15;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicIsoCube, mxActor);

mxShapeBasicIsoCube.prototype.customProperties = [
	{name: 'isoAngle', dispName: 'Perspective Angle', type: 'float', min:0, defVal:15}
];

mxShapeBasicIsoCube.prototype.cst = {ISO_CUBE : 'mxgraph.basic.isocube'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicIsoCube.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var isoAngle = Math.max(0.01, Math.min(94, parseFloat(mxUtils.getValue(this.style, 'isoAngle', this.isoAngle)))) * Math.PI / 200 ;
	var isoH = Math.min(w * Math.tan(isoAngle), h * 0.5);
	
	c.begin();
	c.moveTo(w * 0.5, 0);
	c.lineTo(w, isoH);
	c.lineTo(w, h - isoH);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h - isoH);
	c.lineTo(0, isoH);
	c.close();
	c.fillAndStroke();

	c.setShadow(false);
	
	c.begin();
	c.moveTo(0, isoH);
	c.lineTo(w * 0.5, 2 * isoH);
	c.lineTo(w, isoH);
	c.moveTo(w * 0.5, 2 * isoH);
	c.lineTo(w * 0.5, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeBasicIsoCube.prototype.cst.ISO_CUBE, mxShapeBasicIsoCube);

mxShapeBasicIsoCube.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicIsoCube.prototype.cst.ISO_CUBE] = function(state)
{
	var handles = [Graph.createHandle(state, ['isoAngle'], function(bounds)
	{
		var isoAngle = Math.max(0.01, Math.min(94, parseFloat(mxUtils.getValue(this.state.style, 'isoAngle', this.isoAngle)))) * Math.PI / 200 ;
		var isoH = Math.min(bounds.width * Math.tan(isoAngle), bounds.height * 0.5);

		return new mxPoint(bounds.x, bounds.y + isoH);
	}, function(bounds, pt)
	{
		this.state.style['isoAngle'] = Math.round(100 * Math.max(0, Math.min(100, pt.y - bounds.y))) / 100;
	})];
			
	return handles;
};

mxShapeBasicIsoCube.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var isoAngle = Math.max(0.01, Math.min(94, parseFloat(mxUtils.getValue(this.style, 'isoAngle', this.isoAngle)))) * Math.PI / 200 ;
	var isoH = Math.min(w * Math.tan(isoAngle), h * 0.5);
	
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, isoH));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h - isoH));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - isoH));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, isoH));

	return (constr);
}

//**********************************************************************************************************************************************************
//Acute Triangle
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicTriangleAcute(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicTriangleAcute, mxActor);

mxShapeBasicTriangleAcute.prototype.customProperties = [
	{name: 'dx', dispName: 'Top', type: 'float', min:0, max:1, defVal:0.5}
];

mxShapeBasicTriangleAcute.prototype.cst = {ACUTE_TRIANGLE : 'mxgraph.basic.acute_triangle'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicTriangleAcute.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	
	c.begin();
	c.moveTo(0, h);
	c.lineTo(dx, 0);
	c.lineTo(w, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicTriangleAcute.prototype.cst.ACUTE_TRIANGLE, mxShapeBasicTriangleAcute);

mxShapeBasicTriangleAcute.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicTriangleAcute.prototype.cst.ACUTE_TRIANGLE] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx * bounds.width, bounds.y + 10);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100;
	})];

	return handles;
};

mxShapeBasicTriangleAcute.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx * 0.5, h * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - (w - dx) * 0.5, h * 0.5));

	return (constr);
}

//**********************************************************************************************************************************************************
//Obtuse Triangle
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicTriangleObtuse(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicTriangleObtuse, mxActor);

mxShapeBasicTriangleObtuse.prototype.customProperties = [
	{name: 'dx', dispName: 'Bottom', type: 'float', min:0, max:1, defVal:0.25}
];

mxShapeBasicTriangleObtuse.prototype.cst = {OBTUSE_TRIANGLE : 'mxgraph.basic.obtuse_triangle'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicTriangleObtuse.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	
	c.begin();
	c.moveTo(dx, h);
	c.lineTo(0, 0);
	c.lineTo(w, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicTriangleObtuse.prototype.cst.OBTUSE_TRIANGLE, mxShapeBasicTriangleObtuse);

mxShapeBasicTriangleObtuse.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicTriangleObtuse.prototype.cst.OBTUSE_TRIANGLE] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx * bounds.width, bounds.y + bounds.height - 10);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100;
	})];

	return handles;
};

mxShapeBasicTriangleObtuse.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5, h * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w + dx) * 0.5, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx * 0.5, h * 0.5));

	return (constr);
}

//**********************************************************************************************************************************************************
//Drop
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicDrop(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicDrop, mxActor);

mxShapeBasicDrop.prototype.cst = {DROP : 'mxgraph.basic.drop'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicDrop.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var r = Math.min(h, w) * 0.5;
	var d = h - r;
	var a = Math.sqrt(d * d - r * r);
	
	var angle = Math.atan(a / r);
	
	var x1 = r * Math.sin(angle);
	var y1 = r * Math.cos(angle);
	
	c.begin();
	c.moveTo(w * 0.5, 0);
	c.lineTo(w * 0.5 + x1, h - r - y1);
	c.arcTo(r, r, 0, 0, 1, w * 0.5 + r, h - r);
	c.arcTo(r, r, 0, 0, 1, w * 0.5, h);
	c.arcTo(r, r, 0, 0, 1, w * 0.5 - r, h - r);
	c.arcTo(r, r, 0, 0, 1, w * 0.5 - x1, h - r - y1);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicDrop.prototype.cst.DROP, mxShapeBasicDrop);

mxShapeBasicDrop.prototype.constraints = null;

//**********************************************************************************************************************************************************
//Cone 2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicCone2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
	this.dy = 0.9;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicCone2, mxActor);

mxShapeBasicCone2.prototype.customProperties = [
	{name: 'dx', dispName: 'Top', type: 'float', min:0, max:1, defVal:0.5},
	{name: 'dy', dispName: 'Bottom', type: 'float', min:0, max:1, defVal:0.9}
];

mxShapeBasicCone2.prototype.cst = {CONE2 : 'mxgraph.basic.cone2'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicCone2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	
	var ry = h - dy;
	
	c.begin();
	c.moveTo(dx, 0);
	
	if (ry > 0)
	{
		c.lineTo(w, h - ry);
		c.arcTo(w * 0.5, ry, 0, 0, 1, w * 0.5, h);
		c.arcTo(w * 0.5, ry, 0, 0, 1, 0, h - ry);
	}
	else
	{
		c.lineTo(w, h);
		c.lineTo(0, h);
	}
	
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicCone2.prototype.cst.CONE2, mxShapeBasicCone2);

mxShapeBasicCone2.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicCone2.prototype.cst.CONE2] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx * bounds.width, bounds.y + 10);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100;
	})];

	var handle2 = Graph.createHandle(state, ['dy'], function(bounds)
	{
		var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + 10, bounds.y + dy * bounds.height);
	}, function(bounds, pt)
	{
		this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 100;
	});
	
	handles.push(handle2);
	
	return handles;
};

mxShapeBasicCone2.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var ry = h - dy;
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h - ry));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - ry));

	return (constr);
}

//**********************************************************************************************************************************************************
//Pyramid
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicPyramid(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx1 = 0.5;
	this.dx2 = 0.6;
	this.dy1 = 0.9;
	this.dy2 = 0.8;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicPyramid, mxActor);

mxShapeBasicPyramid.prototype.customProperties = [
	{name: 'dx1', dispName: 'Top', type: 'float', min:0, max:1, defVal:0.4},
	{name: 'dx2', dispName: 'Bottom', type: 'float', min:0, max:1, defVal:0.6},
	{name: 'dy1', dispName: 'Perspective Left', type: 'float', min:0, max:1, defVal:0.9},
	{name: 'dy2', dispName: 'Perspective Right', type: 'float', min:0, max:1, defVal:0.8}
];

mxShapeBasicPyramid.prototype.cst = {PYRAMID : 'mxgraph.basic.pyramid'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicPyramid.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx1 = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dx2 = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var dy1 = h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));
	var dy2 = h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy2', this.dy2))));
	
	c.begin();
	c.moveTo(dx1, 0);
	c.lineTo(w, dy2);
	c.lineTo(dx2, h);
	c.lineTo(0, dy1);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	
	c.begin();
	c.moveTo(dx1, 0);
	c.lineTo(dx2, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeBasicPyramid.prototype.cst.PYRAMID, mxShapeBasicPyramid);

mxShapeBasicPyramid.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicPyramid.prototype.cst.PYRAMID] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx1'], function(bounds)
	{
		var dx1 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1))));

		return new mxPoint(bounds.x + dx1 * bounds.width, bounds.y + 10);
	}, function(bounds, pt)
	{
		this.state.style['dx1'] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100;
	})];

	var handle2 = Graph.createHandle(state, ['dx2'], function(bounds)
	{
		var dx2 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2))));

		return new mxPoint(bounds.x + dx2 * bounds.width, bounds.y + bounds.height - 10);
	}, function(bounds, pt)
	{
		this.state.style['dx2'] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100;
	});
	
	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['dy1'], function(bounds)
	{
		var dy1 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dy1', this.dy1))));

		return new mxPoint(bounds.x + 10, bounds.y + dy1 * bounds.height);
	}, function(bounds, pt)
	{
		this.state.style['dy1'] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 100;
	});
	
	handles.push(handle3);
	
	var handle4 = Graph.createHandle(state, ['dy2'], function(bounds)
	{
		var dy2 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dy2', this.dy2))));

		return new mxPoint(bounds.x + bounds.width - 10, bounds.y + dy2 * bounds.height);
	}, function(bounds, pt)
	{
		this.state.style['dy2'] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 100;
	});
	
	handles.push(handle4);
	
	return handles;
};

mxShapeBasicPyramid.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx1 = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));
	var dx2 = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var dy1 = h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy1', this.dy1))));
	var dy2 = h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy2', this.dy2))));
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx1, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w + dx1) * 0.5, dy2 * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, dy2));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w + dx2) * 0.5, (h + dy2) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 * 0.5, (h + dy1) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx1 * 0.5, dy1 * 0.5));

	return (constr);
}

//**********************************************************************************************************************************************************
//4 Point Star 2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasic4PointStar2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.8;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasic4PointStar2, mxActor);

mxShapeBasic4PointStar2.prototype.customProperties = [
	{name: 'dx', dispName: 'Thickness', type: 'float', min:0, max:1, defVal:0.8}
];

mxShapeBasic4PointStar2.prototype.cst = {FOUR_POINT_STAR_2 : 'mxgraph.basic.4_point_star_2'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasic4PointStar2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = 0.5 * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(dx * w, dx * h);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w - dx * w, dx * h);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - dx * w, h - dx * h);
	c.lineTo(w * 0.5, h);
	c.lineTo(dx * w, h - dx * h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasic4PointStar2.prototype.cst.FOUR_POINT_STAR_2, mxShapeBasic4PointStar2);

mxShapeBasic4PointStar2.prototype.constraints = null;

Graph.handleFactory[mxShapeBasic4PointStar2.prototype.cst.FOUR_POINT_STAR_2] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx * bounds.width / 2, bounds.y + dx * bounds.height / 2);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(1, 2 * (pt.x - bounds.x) / bounds.width))) / 100;
	})];

	return handles;
};

mxShapeBasic4PointStar2.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = 0.5 * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(dx, dx), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1 - dx, dx), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1 - dx, 1 - dx), false));
	constr.push(new mxConnectionConstraint(new mxPoint(dx, 1 - dx), false));

	return (constr);
}

//**********************************************************************************************************************************************************
//Diagonal Snip Rectangle
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicDiagSnipRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicDiagSnipRect, mxActor);

mxShapeBasicDiagSnipRect.prototype.customProperties = [
	{name: 'dx', dispName: 'Snip', type: 'float', min:0, deVal:6},
];

mxShapeBasicDiagSnipRect.prototype.cst = {DIAG_SNIP_RECT : 'mxgraph.basic.diag_snip_rect'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicDiagSnipRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx)))) * 2;

	dx = Math.min(w * 0.5, h * 0.5, dx);
	
	c.begin();
	c.moveTo(dx, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h - dx);
	c.lineTo(w - dx, h);
	c.lineTo(0, h);
	c.lineTo(0, dx);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicDiagSnipRect.prototype.cst.DIAG_SNIP_RECT, mxShapeBasicDiagSnipRect);

mxShapeBasicDiagSnipRect.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicDiagSnipRect.prototype.cst.DIAG_SNIP_RECT] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx, bounds.y + dx);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

mxShapeBasicDiagSnipRect.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx)))) * 2;

	dx = Math.min(w * 0.5, h * 0.5, dx) * 0.5;

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h - dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
}

//**********************************************************************************************************************************************************
//Diagonal Round Rectangle
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicDiagRoundRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicDiagRoundRect, mxActor);

mxShapeBasicDiagRoundRect.prototype.customProperties = [
	{name: 'dx', dispName: 'Rounding Size', type: 'float', min:0, defVal:6},
];

mxShapeBasicDiagRoundRect.prototype.cst = {DIAG_ROUND_RECT : 'mxgraph.basic.diag_round_rect'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicDiagRoundRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx)))) * 2;

	dx = Math.min(w * 0.5, h * 0.5, dx);
	
	c.begin();
	c.moveTo(dx, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h - dx);
	c.arcTo(dx, dx, 0, 0, 1, w - dx, h);
	c.lineTo(0, h);
	c.lineTo(0, dx);
	c.arcTo(dx, dx, 0, 0, 1, dx, 0);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicDiagRoundRect.prototype.cst.DIAG_ROUND_RECT, mxShapeBasicDiagRoundRect);

mxShapeBasicDiagRoundRect.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicDiagRoundRect.prototype.cst.DIAG_ROUND_RECT] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx, bounds.y + dx);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

mxShapeBasicDiagRoundRect.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
}

//**********************************************************************************************************************************************************
//Corner Round Rectangle
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicCornerRoundRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicCornerRoundRect, mxActor);

mxShapeBasicCornerRoundRect.prototype.customProperties = [
	{name: 'dx', dispName: 'Rounding Size', type: 'float', min:0, defVal:6},
];

mxShapeBasicCornerRoundRect.prototype.cst = {CORNER_ROUND_RECT : 'mxgraph.basic.corner_round_rect'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicCornerRoundRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx)))) * 2;

	dx = Math.min(w * 0.5, h * 0.5, dx);
	
	c.begin();
	c.moveTo(dx, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.lineTo(0, dx);
	c.arcTo(dx, dx, 0, 0, 1, dx, 0);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicCornerRoundRect.prototype.cst.CORNER_ROUND_RECT, mxShapeBasicCornerRoundRect);

mxShapeBasicCornerRoundRect.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicCornerRoundRect.prototype.cst.CORNER_ROUND_RECT] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx, bounds.y + dx);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

mxShapeBasicCornerRoundRect.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
}

//**********************************************************************************************************************************************************
//Plaque
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicPlaque(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicPlaque, mxActor);

mxShapeBasicPlaque.prototype.customProperties = [
	{name: 'dx', dispName: 'Cutoff Size', type: 'float', min:0, defVal:6},
];

mxShapeBasicPlaque.prototype.cst = {PLAQUE : 'mxgraph.basic.plaque'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicPlaque.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx)))) * 2;

	dx = Math.min(w * 0.5, h * 0.5, dx);
	
	c.begin();
	c.moveTo(w - dx, 0);
	c.arcTo(dx, dx, 0, 0, 0, w, dx);
	c.lineTo(w, h - dx);
	c.arcTo(dx, dx, 0, 0, 0, w - dx, h);
	c.lineTo(dx, h);
	c.arcTo(dx, dx, 0, 0, 0, 0, h - dx);
	c.lineTo(0, dx);
	c.arcTo(dx, dx, 0, 0, 0, dx, 0);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicPlaque.prototype.cst.PLAQUE, mxShapeBasicPlaque);

mxShapeBasicPlaque.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicPlaque.prototype.cst.PLAQUE] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx * 1.41, bounds.y + dx * 1.41);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

mxShapeBasicPlaque.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
}

//**********************************************************************************************************************************************************
//Frame
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicFrame(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicFrame, mxActor);

mxShapeBasicFrame.prototype.customProperties = [
	{name: 'dx', dispName: 'Width', type: 'float', min:0, defVal:10},
];

mxShapeBasicFrame.prototype.cst = {FRAME : 'mxgraph.basic.frame'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicFrame.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	dx = Math.min(w * 0.5, h * 0.5, dx);
	
	c.begin();
	c.moveTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.lineTo(0, 0);
	c.close();
	c.moveTo(dx, dx);
	c.lineTo(dx, h - dx);
	c.lineTo(w - dx, h - dx);
	c.lineTo(w - dx, dx);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicFrame.prototype.cst.FRAME, mxShapeBasicFrame);

mxShapeBasicFrame.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicFrame.prototype.cst.FRAME] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx, bounds.y + dx);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

mxShapeBasicFrame.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	dx = Math.min(w * 0.5, h * 0.5, dx);

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.25, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.75, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.75, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.25, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - 2 * dx)* 0.25 + dx, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, 0, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w * 1.5 - dx) * 0.5, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, -dx, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, (h - 2 * dx)* 0.25 + dx));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false, null, -dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, (h  - 2 * dx) * 0.75 + dx));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false, null, -dx, -dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - 2 * dx) * 0.75 + dx, h - dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false, null, 0, -dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w  - 2 * dx) * 0.25 + dx, h - dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, dx, -dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, (h - 2 * dx) * 0.75 + dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, (h - 2 * dx) * 0.25 + dx));

	return (constr);
}

//**********************************************************************************************************************************************************
//Plaque Frame
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicPlaqueFrame(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
*/
mxUtils.extend(mxShapeBasicPlaqueFrame, mxActor);

mxShapeBasicPlaqueFrame.prototype.customProperties = [
	{name: 'dx', dispName: 'Width', type: 'float', mix:0, defVal:10},
];

mxShapeBasicPlaqueFrame.prototype.cst = {PLAQUE_FRAME : 'mxgraph.basic.plaque_frame'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicPlaqueFrame.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	dx = Math.min(w * 0.25, h * 0.25, dx);
	
	c.begin();
	c.moveTo(w - dx, 0);
	c.arcTo(dx, dx, 0, 0, 0, w, dx);
	c.lineTo(w, h - dx);
	c.arcTo(dx, dx, 0, 0, 0, w - dx, h);
	c.lineTo(dx, h);
	c.arcTo(dx, dx, 0, 0, 0, 0, h - dx);
	c.lineTo(0, dx);
	c.arcTo(dx, dx, 0, 0, 0, dx, 0);
	c.close();
	
	c.moveTo(dx * 2, dx);
	c.arcTo(dx * 2, dx * 2, 0, 0, 1, dx, dx * 2);
	c.lineTo(dx, h - 2 * dx);
	c.arcTo(dx * 2, dx * 2, 0, 0, 1, dx * 2, h - dx);
	c.lineTo(w - 2 * dx, h - dx);
	c.arcTo(dx * 2, dx * 2, 0, 0, 1, w - dx, h - 2 * dx);
	c.lineTo(w - dx, dx * 2);
	c.arcTo(dx * 2, dx * 2, 0, 0, 1, w - 2 * dx, dx);
	c.close();

	c.fillAndStroke();

};

mxCellRenderer.registerShape(mxShapeBasicPlaqueFrame.prototype.cst.PLAQUE_FRAME, mxShapeBasicPlaqueFrame);

mxShapeBasicPlaqueFrame.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicPlaqueFrame.prototype.cst.PLAQUE_FRAME] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx, bounds.y + dx);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

mxShapeBasicPlaqueFrame.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	dx = Math.min(w * 0.5, h * 0.5, dx);

	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, 0, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false, null, -dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false, null, 0, -dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, dx, 0));

	return (constr);
}

//**********************************************************************************************************************************************************
//Rounded Frame
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicRoundedFrame(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicRoundedFrame, mxActor);

mxShapeBasicRoundedFrame.prototype.customProperties = [
	{name: 'dx', dispName: 'Width', type: 'float', min:0, defVal:10},
];

mxShapeBasicRoundedFrame.prototype.cst = {ROUNDED_FRAME : 'mxgraph.basic.rounded_frame'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicRoundedFrame.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	dx = Math.min(w * 0.25, h * 0.25, dx);
	
	c.begin();
	c.moveTo(w - 2 * dx, 0);
	c.arcTo(dx * 2, dx * 2, 0, 0, 1, w, 2 * dx);
	c.lineTo(w, h - 2 * dx);
	c.arcTo(dx * 2, dx * 2, 0, 0, 1, w - 2 * dx, h);
	c.lineTo(dx * 2, h);
	c.arcTo(dx * 2, dx * 2, 0, 0, 1, 0, h - 2 * dx);
	c.lineTo(0, 2 * dx);
	c.arcTo(dx * 2, dx * 2, 0, 0, 1, 2 * dx, 0);
	c.close();
	
	c.moveTo(dx * 2, dx);
	c.arcTo(dx, dx, 0, 0, 0, dx, dx * 2);
	c.lineTo(dx, h - 2 * dx);
	c.arcTo(dx, dx, 0, 0, 0, dx * 2, h - dx);
	c.lineTo(w - 2 * dx, h - dx);
	c.arcTo(dx, dx, 0, 0, 0, w - dx, h - 2 * dx);
	c.lineTo(w - dx, dx * 2);
	c.arcTo(dx, dx, 0, 0, 0, w - 2 * dx, dx);
	c.close();

	c.fillAndStroke();

};

mxCellRenderer.registerShape(mxShapeBasicRoundedFrame.prototype.cst.ROUNDED_FRAME, mxShapeBasicRoundedFrame);

mxShapeBasicRoundedFrame.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicRoundedFrame.prototype.cst.ROUNDED_FRAME] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx, bounds.y + dx);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

mxShapeBasicRoundedFrame.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	dx = Math.min(w * 0.5, h * 0.5, dx);

	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, 0, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false, null, -dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false, null, 0, -dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, dx, 0));

	return (constr);
}

//**********************************************************************************************************************************************************
//Frame Corner
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicFrameCorner(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicFrameCorner, mxActor);

mxShapeBasicFrameCorner.prototype.customProperties = [
	{name: 'dx', dispName: 'Width', type: 'float', min:0, defVal:10},
];

mxShapeBasicFrameCorner.prototype.cst = {FRAME_CORNER : 'mxgraph.basic.frame_corner'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicFrameCorner.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	dx = Math.min(w * 0.5, h * 0.5, dx);
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w - dx, dx);
	c.lineTo(dx, dx);
	c.lineTo(dx, h - dx);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicFrameCorner.prototype.cst.FRAME_CORNER, mxShapeBasicFrameCorner);

mxShapeBasicFrameCorner.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicFrameCorner.prototype.cst.FRAME_CORNER] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx, bounds.y + dx);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

mxShapeBasicFrameCorner.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	dx = Math.min(w * 0.5, h * 0.5, dx);
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, -dx, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - 2 * dx) * 0.5 + dx, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, (h - 2 * dx) * 0.5 + dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, dx, -dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
}

//**********************************************************************************************************************************************************
//Diagonal Stripe
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicDiagStripe(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicDiagStripe, mxActor);

mxShapeBasicDiagStripe.prototype.customProperties = [
	{name: 'dx', dispName: 'Width', type: 'float', mix:0, defVal:10},
];

mxShapeBasicDiagStripe.prototype.cst = {DIAG_STRIPE : 'mxgraph.basic.diag_stripe'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicDiagStripe.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	dx = Math.min(w, h, dx);
	
	c.begin();
	c.moveTo(0, h);
	c.lineTo(w, 0);
	c.lineTo(w, Math.min(dx * 100 / w, h));
	c.lineTo(Math.min(dx * 100 / h, w), h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicDiagStripe.prototype.cst.DIAG_STRIPE, mxShapeBasicDiagStripe);

mxShapeBasicDiagStripe.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicDiagStripe.prototype.cst.DIAG_STRIPE] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx, bounds.y + bounds.height);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

mxShapeBasicDiagStripe.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	dx = Math.min(w, h, dx);
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, Math.min(dx * 100 / w, h) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, Math.min(dx * 100 / w, h)));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w + Math.min(dx * 100 / h, w)) * 0.5, (Math.min(dx * 100 / w, h) + h) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, Math.min(dx * 100 / h, w), h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, Math.min(dx * 100 / h, w) * 0.5, h));

	return (constr);
}

//**********************************************************************************************************************************************************
//Donut
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicDonut(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicDonut, mxActor);

mxShapeBasicDonut.prototype.customProperties = [
	{name: 'dx', dispName: 'Width', type: 'float', min:0, defVal:25}
];

mxShapeBasicDonut.prototype.cst = {DONUT : 'mxgraph.basic.donut'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicDonut.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	dx = Math.min(w * 0.5, h * 0.5, dx);
	
	c.begin();
	c.moveTo(0, h * 0.5);
	c.arcTo(w * 0.5, h * 0.5, 0, 0, 1, w * 0.5, 0);
	c.arcTo(w * 0.5, h * 0.5, 0, 0, 1, w, h * 0.5);
	c.arcTo(w * 0.5, h * 0.5, 0, 0, 1, w * 0.5, h);
	c.arcTo(w * 0.5, h * 0.5, 0, 0, 1, 0, h * 0.5);
	c.close();
	c.moveTo(w * 0.5, dx);
	c.arcTo(w * 0.5 - dx, h * 0.5 - dx, 0, 0, 0, dx, h * 0.5);
	c.arcTo(w * 0.5 - dx, h * 0.5 - dx, 0, 0, 0, w * 0.5, h - dx);
	c.arcTo(w * 0.5 - dx, h * 0.5 - dx, 0, 0, 0, w - dx, h * 0.5);
	c.arcTo(w * 0.5 - dx, h * 0.5 - dx, 0, 0, 0, w * 0.5, dx);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicDonut.prototype.cst.DONUT, mxShapeBasicDonut);

mxShapeBasicDonut.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicDonut.prototype.cst.DONUT] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx, bounds.y + bounds.height / 2);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

//**********************************************************************************************************************************************************
//Layered Rect
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicLayeredRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicLayeredRect, mxActor);

mxShapeBasicLayeredRect.prototype.customProperties = [
	{name: 'dx', dispName: 'Layer Distance', type: 'float', mix:0, defVal:10}
];

mxShapeBasicLayeredRect.prototype.cst = {LAYERED_RECT : 'mxgraph.basic.layered_rect'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicLayeredRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	dx = Math.min(w * 0.5, h * 0.5, dx);
	
	c.begin();
	c.moveTo(dx, dx);
	c.lineTo(w, dx);
	c.lineTo(w, h);
	c.lineTo(dx, h);
	c.close();
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(dx * 0.5, dx * 0.5);
	c.lineTo(w - dx * 0.5, dx * 0.5);
	c.lineTo(w - dx * 0.5, h - dx * 0.5);
	c.lineTo(dx * 0.5, h - dx * 0.5);
	c.close();
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w - dx, 0);
	c.lineTo(w - dx, h - dx);
	c.lineTo(0, h - dx);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicLayeredRect.prototype.cst.LAYERED_RECT, mxShapeBasicLayeredRect);

mxShapeBasicLayeredRect.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicLayeredRect.prototype.cst.LAYERED_RECT] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + bounds.width - dx, bounds.y + bounds.height - dx);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, - pt.x + bounds.width + bounds.x))) / 100;
	})];
			
	return handles;
};

mxShapeBasicLayeredRect.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	dx = Math.min(w * 0.5, h * 0.5, dx);
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx) * 0.25, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx) * 0.5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx) * 0.75, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx * 0.5, dx * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, (h - dx) * 0.25 + dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, (h - dx) * 0.5 + dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, (h - dx) * 0.75 + dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx) * 0.75 + dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx) * 0.5 + dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - dx) * 0.25 + dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx * 0.5, h - dx * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - dx) * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - dx) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - dx) * 0.25));

	return (constr);
}

//**********************************************************************************************************************************************************
//Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicButton, mxActor);

mxShapeBasicButton.prototype.customProperties = [
	{name: 'dx', dispName: 'Button Height', type: 'float', min:0, defVal:10}
];

mxShapeBasicButton.prototype.cst = {BUTTON : 'mxgraph.basic.button'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	dx = Math.min(w * 0.5, h * 0.5, dx);
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	c.setLineJoin('round');
	
	c.begin();
	c.moveTo(0, h);
	c.lineTo(0, 0);
	c.lineTo(dx, dx);
	c.lineTo(dx, h - dx);
	c.close();
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w - dx, dx);
	c.lineTo(dx, dx);
	c.close();
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(w - dx, h - dx);
	c.lineTo(w - dx, dx);
	c.close();
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(0, h);
	c.lineTo(dx, h - dx);
	c.lineTo(w - dx, h - dx);
	c.lineTo(w, h);
	c.close();
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(0, h);
	c.lineTo(0, 0);
	c.lineTo(dx, dx);
	c.lineTo(dx, h - dx);
	c.close();
	c.fillAndStroke();
	
	
};

mxCellRenderer.registerShape(mxShapeBasicButton.prototype.cst.BUTTON, mxShapeBasicButton);

mxShapeBasicButton.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicButton.prototype.cst.BUTTON] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx, bounds.y + dx);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

//**********************************************************************************************************************************************************
//Shaded Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicShadedButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicShadedButton, mxActor);

mxShapeBasicShadedButton.prototype.customProperties = [
	{name: 'dx', dispName: 'Button Height', type: 'float', min:0, defVal:10}
];

mxShapeBasicShadedButton.prototype.cst = {SHADED_BUTTON : 'mxgraph.basic.shaded_button'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicShadedButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.setShadow(false);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	dx = Math.min(w * 0.5, h * 0.5, dx);
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fill();
	
	c.setFillColor('#ffffff');
	c.setAlpha(0.25);
	c.begin();
	c.moveTo(0, h);
	c.lineTo(0, 0);
	c.lineTo(dx, dx);
	c.lineTo(dx, h - dx);
	c.close();
	c.fill();
	
	c.setAlpha(0.5);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w - dx, dx);
	c.lineTo(dx, dx);
	c.close();
	c.fill();
	
	c.setFillColor('#000000');
	c.setAlpha(0.25);
	c.begin();
	c.moveTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(w - dx, h - dx);
	c.lineTo(w - dx, dx);
	c.close();
	c.fill();
	
	c.setAlpha(0.5);
	c.begin();
	c.moveTo(0, h);
	c.lineTo(dx, h - dx);
	c.lineTo(w - dx, h - dx);
	c.lineTo(w, h);
	c.close();
	c.fill();
	
	
};

mxCellRenderer.registerShape(mxShapeBasicShadedButton.prototype.cst.SHADED_BUTTON, mxShapeBasicShadedButton);

mxShapeBasicShadedButton.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicShadedButton.prototype.cst.SHADED_BUTTON] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx, bounds.y + dx);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

//**********************************************************************************************************************************************************
//Pie
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicPie(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.startAngle = 0.25;
	this.endAngle = 0.75;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicPie, mxActor);

mxShapeBasicPie.prototype.customProperties = [
	{name: 'startAngle', dispName: 'Start Angle', type: 'float', min:0, max:1, defVal: 0.2},
	{name: 'endAngle', dispName: 'End Angle', type: 'float', min:0, max:1, defVal: 0.9}
];

mxShapeBasicPie.prototype.cst = {PIE : 'mxgraph.basic.pie'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicPie.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var startAngleSource = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'startAngle', this.startAngle))));
	var endAngleSource = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'endAngle', this.endAngle))));
	var startAngle = 2 * Math.PI * startAngleSource;
	var endAngle = 2 * Math.PI * endAngleSource;
	var rx = w * 0.5;
	var ry = h * 0.5;
	
	var startX = rx + Math.sin(startAngle) * rx;
	var startY = ry - Math.cos(startAngle) * ry;
	var endX = rx + Math.sin(endAngle) * rx;
	var endY = ry - Math.cos(endAngle) * ry;
	
	var angDiff = endAngle - startAngle;
	
	if (angDiff < 0)
	{
		angDiff = angDiff + Math.PI * 2;
	}
		
	var bigArc = 0;
	
	if (angDiff >= Math.PI)
	{
		bigArc = 1;
	}
		
	c.begin();
	var startAngleDiff = startAngleSource % 1;
	var endAngleDiff = endAngleSource % 1;
	
	if (startAngleDiff == 0 && endAngleDiff == 0.5)
	{
		c.moveTo(rx, ry);
		c.lineTo(startX, startY);
		c.arcTo(rx, ry, 0, 0, 1, w, h * 0.5);
		c.arcTo(rx, ry, 0, 0, 1, w * 0.5, h);
	}
	else if (startAngleDiff == 0.5 && endAngleDiff == 0)
	{
		c.moveTo(rx, ry);
		c.lineTo(startX, startY);
		c.arcTo(rx, ry, 0, 0, 1, 0, h * 0.5);
		c.arcTo(rx, ry, 0, 0, 1, w * 0.5, 0);
	}
	else
	{
		c.moveTo(rx, ry);
		c.lineTo(startX, startY);
		c.arcTo(rx, ry, 0, bigArc, 1, endX, endY);
	}
	
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicPie.prototype.cst.PIE, mxShapeBasicPie);

mxShapeBasicPie.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicPie.prototype.cst.PIE] = function(state)
{
	var handles = [Graph.createHandle(state, ['startAngle'], function(bounds)
	{
		var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'startAngle', this.startAngle))));

		return new mxPoint(bounds.x + bounds.width * 0.5 + Math.sin(startAngle) * bounds.width * 0.5, bounds.y + bounds.height * 0.5 - Math.cos(startAngle) * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * 0.5) / (bounds.width * 0.5)))) / 100;
		var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * 0.5) / (bounds.height * 0.5)))) / 100;
		
		var res =  0.5 * Math.atan2(handleX, handleY) / Math.PI;
		
		if (res < 0)
		{
			res = 1 + res;
		}

		this.state.style['startAngle'] = res;
		
	})];

	var handle2 = Graph.createHandle(state, ['endAngle'], function(bounds)
	{
		var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'endAngle', this.endAngle))));

		return new mxPoint(bounds.x + bounds.width * 0.5 + Math.sin(endAngle) * bounds.width * 0.5, bounds.y + bounds.height * 0.5 - Math.cos(endAngle) * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * 0.5) / (bounds.width * 0.5)))) / 100;
		var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * 0.5) / (bounds.height * 0.5)))) / 100;
		
		var res =  0.5 * Math.atan2(handleX, handleY) / Math.PI;
		
		if (res < 0)
		{
			res = 1 + res;
		}
		
		this.state.style['endAngle'] = res;
	});
	
	handles.push(handle2);
	
	return handles;
};

//**********************************************************************************************************************************************************
//Arc
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicArc(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.startAngle = 0.25;
	this.endAngle = 0.75;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicArc, mxActor);

mxShapeBasicArc.prototype.customProperties = [
	{name: 'startAngle', dispName: 'Start Angle', type: 'float', min:0, max:1, defVal: 0.3},
	{name: 'endAngle', dispName: 'End Angle', type: 'float', min:0, max:1, defVal:0.1}
];

mxShapeBasicArc.prototype.cst = {ARC : 'mxgraph.basic.arc'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicArc.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var startAngleSource = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'startAngle', this.startAngle))));
	var endAngleSource = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'endAngle', this.endAngle))));
	var startAngle = 2 * Math.PI * startAngleSource;
	var endAngle = 2 * Math.PI * endAngleSource;
	var rx = w * 0.5;
	var ry = h * 0.5;
	
	var startX = rx + Math.sin(startAngle) * rx;
	var startY = ry - Math.cos(startAngle) * ry;
	var endX = rx + Math.sin(endAngle) * rx;
	var endY = ry - Math.cos(endAngle) * ry;
	
	var angDiff = endAngle - startAngle;
	
	if (angDiff < 0)
	{
		angDiff = angDiff + Math.PI * 2;
	}
		
	var bigArc = 0;
	
	if (angDiff > Math.PI)
	{
		bigArc = 1;
	}
		
	c.begin();
	
	var startAngleDiff = startAngleSource % 1;
	var endAngleDiff = endAngleSource % 1;
	
	if (startAngleDiff == 0 && endAngleDiff == 0.5)
	{
		c.moveTo(startX, startY);
		c.arcTo(rx, ry, 0, 0, 1, w, h * 0.5);
		c.arcTo(rx, ry, 0, 0, 1, w * 0.5, h);
	}
	else if (startAngleDiff == 0.5 && endAngleDiff == 0)
	{
		c.moveTo(startX, startY);
		c.arcTo(rx, ry, 0, 0, 1, 0, h * 0.5);
		c.arcTo(rx, ry, 0, 0, 1, w * 0.5, 0);
	}
	else
	{
		c.moveTo(startX, startY);
		c.arcTo(rx, ry, 0, bigArc, 1, endX, endY);
	}

	c.stroke();
};

mxCellRenderer.registerShape(mxShapeBasicArc.prototype.cst.ARC, mxShapeBasicArc);

mxShapeBasicArc.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicArc.prototype.cst.ARC] = function(state)
{
	var handles = [Graph.createHandle(state, ['startAngle'], function(bounds)
	{
		var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'startAngle', this.startAngle))));

		return new mxPoint(bounds.x + bounds.width * 0.5 + Math.sin(startAngle) * bounds.width * 0.5, bounds.y + bounds.height * 0.5 - Math.cos(startAngle) * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * 0.5) / (bounds.width * 0.5)))) / 100;
		var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * 0.5) / (bounds.height * 0.5)))) / 100;
		
		var res =  0.5 * Math.atan2(handleX, handleY) / Math.PI;
		
		if (res < 0)
		{
			res = 1 + res;
		}

		this.state.style['startAngle'] = res;
		
	})];

	var handle2 = Graph.createHandle(state, ['endAngle'], function(bounds)
	{
		var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'endAngle', this.endAngle))));

		return new mxPoint(bounds.x + bounds.width * 0.5 + Math.sin(endAngle) * bounds.width * 0.5, bounds.y + bounds.height * 0.5 - Math.cos(endAngle) * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * 0.5) / (bounds.width * 0.5)))) / 100;
		var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * 0.5) / (bounds.height * 0.5)))) / 100;
		
		var res =  0.5 * Math.atan2(handleX, handleY) / Math.PI;
		
		if (res < 0)
		{
			res = 1 + res;
		}
		
		this.state.style['endAngle'] = res;
	});
	
	handles.push(handle2);
	
	return handles;
};

//**********************************************************************************************************************************************************
//Partial Concentric Ellipse
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicPartConcEllipse(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.startAngle = 0.25;
	this.endAngle = 0.75;
	this.arcWidth = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicPartConcEllipse, mxActor);

mxShapeBasicPartConcEllipse.prototype.customProperties = [
	{name: 'startAngle', dispName: 'Start Angle', type: 'float', min:0, max:1, defVal:0.25},
	{name: 'endAngle', dispName: 'End Angle', type: 'float', min:0, max:1, defVal:0.1},
	{name: 'arcWidth', dispName: 'Arc Width', type: 'float', min:0, max:1, defVal:0.5}
];

mxShapeBasicPartConcEllipse.prototype.cst = {PART_CONC_ELLIPSE : 'mxgraph.basic.partConcEllipse'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicPartConcEllipse.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'startAngle', this.startAngle))));
	var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'endAngle', this.endAngle))));
	var arcWidth = 1 - Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arcWidth', this.arcWidth))));
	var rx = w * 0.5;
	var ry = h * 0.5;
	var rx2 = rx * arcWidth;
	var ry2 = ry * arcWidth;
	
	var angDiff = endAngle - startAngle;
	
	if (angDiff < 0)
	{
		angDiff = angDiff + Math.PI * 2;
	}
	else if (angDiff == Math.PI)
	{
		endAngle = endAngle + 0.00001;
	}
	
	var startX = rx + Math.sin(startAngle) * rx;
	var startY = ry - Math.cos(startAngle) * ry;
	var innerStartX = rx + Math.sin(startAngle) * rx2;
	var innerStartY = ry - Math.cos(startAngle) * ry2;
	var endX = rx + Math.sin(endAngle) * rx;
	var endY = ry - Math.cos(endAngle) * ry;
	var innerEndX = rx + Math.sin(endAngle) * rx2;
	var innerEndY = ry - Math.cos(endAngle) * ry2;
	
		
	var bigArc = 0;
	
	if (angDiff >= Math.PI)
	{
		bigArc = 1;
	}
		
	c.begin();
	c.moveTo(startX, startY);
	c.arcTo(rx, ry, 0, bigArc, 1, endX, endY);
	c.lineTo(innerEndX, innerEndY);
	c.arcTo(rx2, ry2, 0, bigArc, 0, innerStartX, innerStartY);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicPartConcEllipse.prototype.cst.PART_CONC_ELLIPSE, mxShapeBasicPartConcEllipse);

mxShapeBasicPartConcEllipse.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicPartConcEllipse.prototype.cst.PART_CONC_ELLIPSE] = function(state)
{
	var handles = [Graph.createHandle(state, ['startAngle'], function(bounds)
	{
		var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'startAngle', this.startAngle))));

		return new mxPoint(bounds.x + bounds.width * 0.5 + Math.sin(startAngle) * bounds.width * 0.5, bounds.y + bounds.height * 0.5 - Math.cos(startAngle) * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * 0.5) / (bounds.width * 0.5)))) / 100;
		var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * 0.5) / (bounds.height * 0.5)))) / 100;
		
		var res =  0.5 * Math.atan2(handleX, handleY) / Math.PI;
		
		if (res < 0)
		{
			res = 1 + res;
		}

		this.state.style['startAngle'] = res;
		
	})];

	var handle2 = Graph.createHandle(state, ['endAngle'], function(bounds)
	{
		var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'endAngle', this.endAngle))));

		return new mxPoint(bounds.x + bounds.width * 0.5 + Math.sin(endAngle) * bounds.width * 0.5, bounds.y + bounds.height * 0.5 - Math.cos(endAngle) * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * 0.5) / (bounds.width * 0.5)))) / 100;
		var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * 0.5) / (bounds.height * 0.5)))) / 100;
		
		var res =  0.5 * Math.atan2(handleX, handleY) / Math.PI;
		
		if (res < 0)
		{
			res = 1 + res;
		}
		
		this.state.style['endAngle'] = res;
	});
	
	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['arcWidth'], function(bounds)
	{
		var arcWidth = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'arcWidth', this.arcWidth))));

		return new mxPoint(bounds.x + bounds.width / 2, bounds.y + arcWidth * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		this.state.style['arcWidth'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, (pt.y - bounds.y) / (bounds.height * 0.5)))) / 100;
	});
			
	handles.push(handle3);
	
	return handles;
};

//**********************************************************************************************************************************************************
//Numbered entry (vertical)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicNumEntryVert(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicNumEntryVert, mxActor);

mxShapeBasicNumEntryVert.prototype.cst = {NUM_ENTRY_VERT : 'mxgraph.basic.numberedEntryVert'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicNumEntryVert.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));

	var inset = 5;

	var d = Math.min(dy, w - 2 * inset, h - inset);
	
	c.ellipse(w * 0.5 - d * 0.5, 0, d, d);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(0, d * 0.5);
	c.lineTo(w * 0.5 - d * 0.5 - inset, d * 0.5);
	c.arcTo(d * 0.5 + inset, d * 0.5 + inset, 0, 0, 0, w * 0.5 + d * 0.5 + inset, d * 0.5);
	c.lineTo(w, d * 0.5);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicNumEntryVert.prototype.cst.NUM_ENTRY_VERT, mxShapeBasicNumEntryVert);

mxShapeBasicNumEntryVert.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicNumEntryVert.prototype.cst.NUM_ENTRY_VERT] = function(state)
{
	var handles = [Graph.createHandle(state, ['dy'], function(bounds)
	{
		var dy = Math.max(0, Math.min(bounds.width, bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + bounds.width / 2, bounds.y + dy);
	}, function(bounds, pt)
	{
		this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height, bounds.width, pt.y - bounds.y))) / 100;
	})];
			
	return handles;
};

//**********************************************************************************************************************************************************
//Bending Arch
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicBendingArch(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.startAngle = 0.25;
	this.endAngle = 0.75;
	this.arcWidth = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicBendingArch, mxActor);

mxShapeBasicBendingArch.prototype.cst = {BENDING_ARCH : 'mxgraph.basic.bendingArch'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicBendingArch.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'startAngle', this.startAngle))));
	var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'endAngle', this.endAngle))));
	var arcWidth = 1 - Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arcWidth', this.arcWidth))));
	var rx = w * 0.5;
	var ry = h * 0.5;
	var rx2 = rx * arcWidth;
	var ry2 = ry * arcWidth;
	
	var startX = rx + Math.sin(startAngle) * rx;
	var startY = ry - Math.cos(startAngle) * ry;
	var innerStartX = rx + Math.sin(startAngle) * rx2;
	var innerStartY = ry - Math.cos(startAngle) * ry2;
	var endX = rx + Math.sin(endAngle) * rx;
	var endY = ry - Math.cos(endAngle) * ry;
	var innerEndX = rx + Math.sin(endAngle) * rx2;
	var innerEndY = ry - Math.cos(endAngle) * ry2;
	
	var angDiff = endAngle - startAngle;
	
	if (angDiff < 0)
	{
		angDiff = angDiff + Math.PI * 2;
	}
		
	var bigArc = 0;
	
	if (angDiff > Math.PI)
	{
		bigArc = 1;
	}

	var rx3 = rx2 - 5;
	var ry3 = ry2 - 5;

	c.ellipse(w * 0.5 - rx3, h * 0.5 - ry3, 2 * rx3, 2 * ry3);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(startX, startY);
	c.arcTo(rx, ry, 0, bigArc, 1, endX, endY);
	c.lineTo(innerEndX, innerEndY);
	c.arcTo(rx2, ry2, 0, bigArc, 0, innerStartX, innerStartY);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicBendingArch.prototype.cst.BENDING_ARCH, mxShapeBasicBendingArch);

mxShapeBasicBendingArch.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicBendingArch.prototype.cst.BENDING_ARCH] = function(state)
{
	var handles = [Graph.createHandle(state, ['startAngle'], function(bounds)
	{
		var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'startAngle', this.startAngle))));

		return new mxPoint(bounds.x + bounds.width * 0.5 + Math.sin(startAngle) * bounds.width * 0.5, bounds.y + bounds.height * 0.5 - Math.cos(startAngle) * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * 0.5) / (bounds.width * 0.5)))) / 100;
		var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * 0.5) / (bounds.height * 0.5)))) / 100;
		
		var res =  0.5 * Math.atan2(handleX, handleY) / Math.PI;
		
		if (res < 0)
		{
			res = 1 + res;
		}

		this.state.style['startAngle'] = res;
		
	})];

	var handle2 = Graph.createHandle(state, ['endAngle'], function(bounds)
	{
		var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'endAngle', this.endAngle))));

		return new mxPoint(bounds.x + bounds.width * 0.5 + Math.sin(endAngle) * bounds.width * 0.5, bounds.y + bounds.height * 0.5 - Math.cos(endAngle) * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * 0.5) / (bounds.width * 0.5)))) / 100;
		var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * 0.5) / (bounds.height * 0.5)))) / 100;
		
		var res =  0.5 * Math.atan2(handleX, handleY) / Math.PI;
		
		if (res < 0)
		{
			res = 1 + res;
		}
		
		this.state.style['endAngle'] = res;
	});
	
	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['arcWidth'], function(bounds)
	{
		var arcWidth = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'arcWidth', this.arcWidth))));

		return new mxPoint(bounds.x + bounds.width / 2, bounds.y + arcWidth * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		this.state.style['arcWidth'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, (pt.y - bounds.y) / (bounds.height * 0.5)))) / 100;
	});
			
	handles.push(handle3);
	
	return handles;
};

//**********************************************************************************************************************************************************
//Three Corner Round Rectangle
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicThreeCornerRoundRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicThreeCornerRoundRect, mxActor);

mxShapeBasicThreeCornerRoundRect.prototype.customProperties = [
	{name: 'dx', dispName: 'Rounding Size', type: 'float', min:0, defVal:6}
];

mxShapeBasicThreeCornerRoundRect.prototype.cst = {THREE_CORNER_ROUND_RECT : 'mxgraph.basic.three_corner_round_rect'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicThreeCornerRoundRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx)))) * 2;

	dx = Math.min(w * 0.5, h * 0.5, dx);
	
	c.begin();
	c.moveTo(dx, 0);
	c.lineTo(w - dx, 0);
	c.arcTo(dx, dx, 0, 0, 1, w, dx);
	c.lineTo(w, h - dx);
	c.arcTo(dx, dx, 0, 0, 1, w - dx, h);
	c.lineTo(0, h);
	c.lineTo(0, dx);
	c.arcTo(dx, dx, 0, 0, 1, dx, 0);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBasicThreeCornerRoundRect.prototype.cst.THREE_CORNER_ROUND_RECT, mxShapeBasicThreeCornerRoundRect);

mxShapeBasicThreeCornerRoundRect.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicThreeCornerRoundRect.prototype.cst.THREE_CORNER_ROUND_RECT] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx, bounds.y + dx);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

mxShapeBasicThreeCornerRoundRect.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
}

//**********************************************************************************************************************************************************
//Rectangle v2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBasicRect2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.rectStyle = 'square';
	this.size = 10;
	this.absoluteCornerSize = true;
	this.indent = 2;
	this.rectOutline = 'single';
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBasicRect2, mxActor);

mxShapeBasicRect2.prototype.cst = {RECT2 : 'mxgraph.basic.rect'};

mxShapeBasicRect2.prototype.customProperties = [
	{name: 'rectStyle', dispName: 'Style', type: 'enum', defVal:'square',
		enumList:[
			{val:'square', dispName:'Square'},
			{val:'rounded', dispName:'Round'},
			{val:'snip', dispName:'Snip'},
			{val:'invRound', dispName:'Inv. Round'},
			{val:'fold', dispName:'Fold'}
		]},
	{name: 'size', dispName: 'Corner Size', type: 'float', defVal:10},
	{name: 'absoluteCornerSize', dispName: 'Abs. Corner Size', type: 'bool', defVal:true},
	{name: 'indent', dispName:'Indent', type:'float', defVal:2},
	{name: 'rectOutline', dispName: 'Outline', type: 'enum', defVal:'single',
		enumList:[
			{val:'single', dispName:'Single'},
			{val:'double', dispName:'Double'},
			{val:'frame', dispName:'Frame'}
		]},
	{name: 'fillColor2', dispName:'Inside Fill Color', type:'color', defVal:'none'},
	{name: 'gradientColor2', dispName:'Inside Gradient Color', type:'color', defVal:'none'},
	{name: 'gradientDirection2', dispName: 'Inside Gradient Direction', type: 'enum', defVal:'south',
		enumList:[
			{val:'south', dispName:'South'},
			{val:'west', dispName:'West'},
			{val:'north', dispName:'North'},
			{val:'east', dispName:'East'}
	]},
	{name: 'top', dispName:'Top Line', type:'bool', defVal:true},
	{name: 'right', dispName:'Right', type:'bool', defVal:true},
	{name: 'bottom', dispName:'Bottom Line', type:'bool', defVal:true},
	{name: 'left', dispName:'Left ', type:'bool', defVal:true},
	{name: 'topLeftStyle', dispName: 'Top Left Style', type: 'enum', defVal:'default',
	enumList:[
		{val:'default', dispName:'Default'},
		{val:'square', dispName:'Square'},
		{val:'rounded', dispName:'Round'},
		{val:'snip', dispName:'Snip'},
		{val:'invRound', dispName:'Inv. Round'},
		{val:'fold', dispName:'Fold'}
	]},
	{name: 'topRightStyle', dispName: 'Top Right Style', type: 'enum', defVal:'default',
		enumList:[
			{val:'default', dispName:'Default'},
			{val:'square', dispName:'Square'},
			{val:'rounded', dispName:'Round'},
			{val:'snip', dispName:'Snip'},
			{val:'invRound', dispName:'Inv. Round'},
			{val:'fold', dispName:'Fold'}
	]},
	{name: 'bottomRightStyle', dispName: 'Bottom Right Style', type: 'enum', defVal:'default',
		enumList:[
			{val:'default', dispName:'Default'},
			{val:'square', dispName:'Square'},
			{val:'rounded', dispName:'Round'},
			{val:'snip', dispName:'Snip'},
			{val:'invRound', dispName:'Inv. Round'},
			{val:'fold', dispName:'Fold'}
	]},
	{name: 'bottomLeftStyle', dispName: 'Bottom Left Style', type: 'enum', defVal:'default',
		enumList:[
			{val:'default', dispName:'Default'},
			{val:'square', dispName:'Square'},
			{val:'rounded', dispName:'Round'},
			{val:'snip', dispName:'Snip'},
			{val:'invRound', dispName:'Inv. Round'},
			{val:'fold', dispName:'Fold'}
	]},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBasicRect2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rectStyle = mxUtils.getValue(this.style, 'rectStyle', this.rectStyle);
	var absoluteCornerSize = mxUtils.getValue(this.style, 'absoluteCornerSize', this.absoluteCornerSize);
	
	var size = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
	var relSize = Math.max(0, Math.min(50, size));
	
	size = Math.min(h * 0.5, w * 0.5, size);
	
	if (!absoluteCornerSize)
	{
		size = relSize * Math.min(w, h) / 100;
	}
	
	var rectOutline = mxUtils.getValue(this.style, 'rectOutline', this.rectOutline);
	var indent = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'indent', this.indent))));
	var relIndent = Math.max(0, Math.min(50, indent));
		
	size = Math.min(size, Math.min(w, h) * 0.5);
	
	if (!absoluteCornerSize)
	{
		indent = Math.min(relIndent * Math.min(w, h) / 100);
	}

//	indent = Math.min(indent, 2 * size, Math.min(w, h) - size);
	indent = Math.min(indent, Math.min(w, h) * 0.5 - size);
	
	var top = mxUtils.getValue(this.style, 'top', true);
	var right = mxUtils.getValue(this.style, 'right', true);
	var bottom = mxUtils.getValue(this.style, 'bottom', true);
	var left = mxUtils.getValue(this.style, 'left', true);

	var topLeftStyle = mxUtils.getValue(this.style, 'topLeftStyle', 'default');
	var topRightStyle = mxUtils.getValue(this.style, 'topRightStyle', 'default');
	var bottomRightStyle = mxUtils.getValue(this.style, 'bottomRightStyle', 'default');
	var bottomLeftStyle = mxUtils.getValue(this.style, 'bottomLeftStyle', 'default');
	var fillColor = mxUtils.getValue(this.style, 'fillColor', 'none');
	var fillColor2 = mxUtils.getValue(this.style, 'fillColor2', 'none');
	var gradientColor2 = mxUtils.getValue(this.style, 'gradientColor2', 'none');
	var gdir2 = mxUtils.getValue(this.style, 'gradientDirection2', 'south');
	var opacity = mxUtils.getValue(this.style, 'opacity', '100');
	
	if ((top || right || bottom || left) && rectOutline != 'frame')
	{
		
		//outline fill
		c.begin();
		if (!top)
		{
			c.moveTo(0,0);
		}
		else
		{
			mxShapeBasicRect2.prototype.moveNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
		}
		
		if (top)
		{
			mxShapeBasicRect2.prototype.paintNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
		}

		mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
		
		if (right)
		{
			mxShapeBasicRect2.prototype.paintNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
		}

		mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
		
		if (bottom)
		{
			mxShapeBasicRect2.prototype.paintSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
		}
		
		mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
		
		if (left)
		{
			mxShapeBasicRect2.prototype.paintSW(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom);
		}

		mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
		c.close();
		c.fill();

		c.setShadow(false);

		//inner fill
		var fillColor2 = mxUtils.getValue(this.style, 'fillColor2', 'none');
		c.setFillColor(fillColor2);
		var op1 = opacity;
		var op2 = opacity;
		
		if (fillColor2 == 'none')
		{
			op1 = 0;
		}
		
		if (gradientColor2 == 'none')
		{
			op2 = 0;
		}
		
		
		c.setGradient(fillColor2, gradientColor2, 0, 0, w, h, gdir2, op1, op2);
		
		c.begin();

		if (!top)
		{
			c.moveTo(indent,0);
		}
		else
		{
			mxShapeBasicRect2.prototype.moveNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, top, left);
		}

		mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
		
		if (left && bottom)
		{
			mxShapeBasicRect2.prototype.paintSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom);
		}

		mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
		
		if (bottom && right)
		{
			mxShapeBasicRect2.prototype.paintSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent);
		}
		
		mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
		
		if (right && top)
		{
			mxShapeBasicRect2.prototype.paintNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent);
		}

		mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
		
		if (top && left)
		{
			mxShapeBasicRect2.prototype.paintNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent);
		}

		c.fill();

		if (fillColor == 'none')
		{
			c.begin();
			mxShapeBasicRect2.prototype.paintFolds(c, x, y, w, h, rectStyle, topLeftStyle, topRightStyle, bottomRightStyle, bottomLeftStyle, size, top, right, bottom, left);
			c.stroke();
		}
	}

	//draw all the combinations
	if (!top && !right && !bottom && left)
	{
		
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveSW(c, x, y, w, h, rectStyle, topLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);

			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, top, left);
				mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveSW(c, x, y, w, h, rectStyle, topLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
			mxShapeBasicRect2.prototype.lineNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, top, left);
			mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (!top && !right && bottom && !left)
	{
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
	
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, left);
				mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
			mxShapeBasicRect2.prototype.lineSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, left);
			mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (!top && !right && bottom && left)
	{
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintSW(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
	
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, top, left);
				mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
				mxShapeBasicRect2.prototype.paintSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom);
				mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintSW(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
			mxShapeBasicRect2.prototype.lineNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, top, left);
			mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
			mxShapeBasicRect2.prototype.paintSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom);
			mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (!top && right && !bottom && !left)
	{
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
	
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, bottom);
				mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
			mxShapeBasicRect2.prototype.lineSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, bottom);
			mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (!top && right && !bottom && left)
	{
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveSW(c, x, y, w, h, rectStyle, topLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
	
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, top, left);
				mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
			}
			
			c.stroke();
			
			c.begin();
			mxShapeBasicRect2.prototype.moveNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
	
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, bottom);
				mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveSW(c, x, y, w, h, rectStyle, topLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
			mxShapeBasicRect2.prototype.lineNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, top, left);
			mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
			c.close();
			c.fillAndStroke();
			
			c.begin();
			mxShapeBasicRect2.prototype.moveNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
			mxShapeBasicRect2.prototype.lineSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, bottom);
			mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (!top && right && bottom && !left)
	{
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);

			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, left);
				mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
				mxShapeBasicRect2.prototype.paintSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent);
				mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
			mxShapeBasicRect2.prototype.lineSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, left);
			mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
			mxShapeBasicRect2.prototype.paintSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent);
			mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (!top && right && bottom && left)
	{
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintSW(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
	
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, top, left);
				mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
				mxShapeBasicRect2.prototype.paintSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom);
				mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
				mxShapeBasicRect2.prototype.paintSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent);
				mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintSW(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
			mxShapeBasicRect2.prototype.lineNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, top, left);
			mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
			mxShapeBasicRect2.prototype.paintSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom);
			mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
			mxShapeBasicRect2.prototype.paintSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent);
			mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (top && !right && !bottom && !left)
	{
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
	
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, right);
				mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
			mxShapeBasicRect2.prototype.lineNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, right);
			mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (top && !right && !bottom && left)
	{
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveSW(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
			mxShapeBasicRect2.prototype.paintNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
	
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, right);
				mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
				mxShapeBasicRect2.prototype.paintNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent);
				mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveSW(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
			mxShapeBasicRect2.prototype.paintNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
			mxShapeBasicRect2.prototype.lineNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, right);
			mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
			mxShapeBasicRect2.prototype.paintNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent);
			mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (top && !right && bottom && !left)
	{
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
	
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, right);
				mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
			}
			
			c.stroke();
	
			c.begin();
			mxShapeBasicRect2.prototype.moveSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
	
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, left);
				mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
			mxShapeBasicRect2.prototype.lineNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, right);
			mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
			c.close();
			c.fillAndStroke();
	
			c.begin();
			mxShapeBasicRect2.prototype.moveSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
			mxShapeBasicRect2.prototype.lineSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, left);
			mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (top && !right && bottom && left)
	{
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintSW(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
			mxShapeBasicRect2.prototype.paintNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
	
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, right);
				mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
				mxShapeBasicRect2.prototype.paintNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent);
				mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
				mxShapeBasicRect2.prototype.paintSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom);
				mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintSW(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
			mxShapeBasicRect2.prototype.paintNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
			mxShapeBasicRect2.prototype.lineNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, right);
			mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
			mxShapeBasicRect2.prototype.paintNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent);
			mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
			mxShapeBasicRect2.prototype.paintSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom);
			mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (top && right && !bottom && !left)
	{
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
	
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, bottom);
				mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
				mxShapeBasicRect2.prototype.paintNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent);
				mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
			mxShapeBasicRect2.prototype.lineSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, bottom);
			mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
			mxShapeBasicRect2.prototype.paintNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent);
			mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (top && right && !bottom && left)
	{
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveSW(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
			mxShapeBasicRect2.prototype.paintNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
	
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, bottom);
				mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
				mxShapeBasicRect2.prototype.paintNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent);
				mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
				mxShapeBasicRect2.prototype.paintNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent);
				mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveSW(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
			mxShapeBasicRect2.prototype.paintNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
			mxShapeBasicRect2.prototype.lineSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, bottom);
			mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
			mxShapeBasicRect2.prototype.paintNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent);
			mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
			mxShapeBasicRect2.prototype.paintNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent);
			mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (top && right && bottom && !left)
	{
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
	
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, left);
				mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
				mxShapeBasicRect2.prototype.paintSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent);
				mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
				mxShapeBasicRect2.prototype.paintNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent);
				mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
			mxShapeBasicRect2.prototype.lineSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, left);
			mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
			mxShapeBasicRect2.prototype.paintSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent);
			mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
			mxShapeBasicRect2.prototype.paintNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent);
			mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (top && right && bottom && left)
	{
		if (rectOutline != 'frame')
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintSW(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
			c.close();
			
			if (rectOutline == 'double')
			{
				mxShapeBasicRect2.prototype.moveSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, left);
				mxShapeBasicRect2.prototype.paintSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom);
				mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
				mxShapeBasicRect2.prototype.paintSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent);
				mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
				mxShapeBasicRect2.prototype.paintNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent);
				mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
				mxShapeBasicRect2.prototype.paintNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent);
				mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
				c.close();
			}
			
			c.stroke();
		}
		else
		{
			c.begin();
			mxShapeBasicRect2.prototype.moveNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintNW(c, x, y, w, h, rectStyle, topLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintTop(c, x, y, w, h, rectStyle, topRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintNE(c, x, y, w, h, rectStyle, topRightStyle, size, top);
			mxShapeBasicRect2.prototype.paintRight(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintSE(c, x, y, w, h, rectStyle, bottomRightStyle, size, right);
			mxShapeBasicRect2.prototype.paintBottom(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left);
			mxShapeBasicRect2.prototype.paintSW(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom);
			mxShapeBasicRect2.prototype.paintLeft(c, x, y, w, h, rectStyle, topLeftStyle, size, top);
			c.close();
			mxShapeBasicRect2.prototype.moveSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, left);
			mxShapeBasicRect2.prototype.paintSWInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom);
			mxShapeBasicRect2.prototype.paintBottomInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom);
			mxShapeBasicRect2.prototype.paintSEInner(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent);
			mxShapeBasicRect2.prototype.paintRightInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right);
			mxShapeBasicRect2.prototype.paintNEInner(c, x, y, w, h, rectStyle, topRightStyle, size, indent);
			mxShapeBasicRect2.prototype.paintTopInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top);
			mxShapeBasicRect2.prototype.paintNWInner(c, x, y, w, h, rectStyle, topLeftStyle, size, indent);
			mxShapeBasicRect2.prototype.paintLeftInner(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left);
			c.close();
			c.fillAndStroke();
		}
	}

	c.begin();
	mxShapeBasicRect2.prototype.paintFolds(c, x, y, w, h, rectStyle, topLeftStyle, topRightStyle, bottomRightStyle, bottomLeftStyle, size, top, right, bottom, left);
	c.stroke();
};

mxShapeBasicRect2.prototype.moveNW = function(c, x, y, w, h, rectStyle, topLeftStyle, size, left)
{
	if((topLeftStyle == 'square' || (topLeftStyle == 'default' && rectStyle == 'square' )) || !left)
	{
		c.moveTo(0, 0);
	}
	else
	{
		c.moveTo(0, size);
	}
};

mxShapeBasicRect2.prototype.moveNE = function(c, x, y, w, h, rectStyle, topRightStyle, size, top)
{
	if((topRightStyle == 'square' || (topRightStyle == 'default' && rectStyle == 'square' )) || !top)
	{
		c.moveTo(w, 0);
	}
	else
	{
		c.moveTo(w - size, 0);
	}
};

mxShapeBasicRect2.prototype.moveSE = function(c, x, y, w, h, rectStyle, bottomRightStyle, size, right)
{
	if((bottomRightStyle == 'square' || (bottomRightStyle == 'default' && rectStyle == 'square' )) || !right)
	{
		c.moveTo(w, h);
	}
	else
	{
		c.moveTo(w, h - size);
	}
};

mxShapeBasicRect2.prototype.moveSW = function(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom)
{
	if((bottomLeftStyle == 'square' || (bottomLeftStyle == 'default' && rectStyle == 'square' )) || !bottom)
	{
		c.moveTo(0, h);
	}
	else
	{
		c.moveTo(size, h);
	}
};

mxShapeBasicRect2.prototype.paintNW = function(c, x, y, w, h, rectStyle, topLeftStyle, size, left)
{
	if (!left)
	{
		c.lineTo(0, 0);
	}
	else if((topLeftStyle == 'rounded' || (topLeftStyle == 'default' && rectStyle == 'rounded' )) ||
			(topLeftStyle == 'invRound' || (topLeftStyle == 'default' && rectStyle == 'invRound' )) )
	{
		var inv = 0;
		
		if (topLeftStyle == 'rounded' || (topLeftStyle == 'default' && rectStyle == 'rounded' ))
		{
			inv = 1;
		}
		
		c.arcTo(size, size, 0, 0, inv, size, 0);
	}
	else if((topLeftStyle == 'snip' || (topLeftStyle == 'default' && rectStyle == 'snip' )) ||
			(topLeftStyle == 'fold' || (topLeftStyle == 'default' && rectStyle == 'fold' )))
	{
		c.lineTo(size, 0);
	}
};

mxShapeBasicRect2.prototype.paintTop = function(c, x, y, w, h, rectStyle, topRightStyle, size, right)
{
	if((topRightStyle == 'square' || (topRightStyle == 'default' && rectStyle == 'square' )) || !right)
	{
		c.lineTo(w, 0);
	}
	else
	{
		c.lineTo(w - size, 0);
	}
};

mxShapeBasicRect2.prototype.paintNE = function(c, x, y, w, h, rectStyle, topRightStyle, size, top)
{
	if (!top)
	{
		c.lineTo(w, 0);
	}
	else if((topRightStyle == 'rounded' || (topRightStyle == 'default' && rectStyle == 'rounded' )) ||
			(topRightStyle == 'invRound' || (topRightStyle == 'default' && rectStyle == 'invRound' )) )
	{
		var inv = 0;
		
		if (topRightStyle == 'rounded' || (topRightStyle == 'default' && rectStyle == 'rounded' ))
		{
			inv = 1;
		}
		
		c.arcTo(size, size, 0, 0, inv, w, size);
	}
	else if((topRightStyle == 'snip' || (topRightStyle == 'default' && rectStyle == 'snip' )) ||
			(topRightStyle == 'fold' || (topRightStyle == 'default' && rectStyle == 'fold' )))
	{
		c.lineTo(w, size);
	}
};

mxShapeBasicRect2.prototype.paintRight = function(c, x, y, w, h, rectStyle, bottomRightStyle, size, bottom)
{
	if((bottomRightStyle == 'square' || (bottomRightStyle == 'default' && rectStyle == 'square' )) || !bottom)
	{
		c.lineTo(w, h);
	}
	else
	{
		c.lineTo(w, h - size);
	}
};

mxShapeBasicRect2.prototype.paintLeft = function(c, x, y, w, h, rectStyle, topLeftStyle, size, top)
{
	if((topLeftStyle == 'square' || (topLeftStyle == 'default' && rectStyle == 'square' )) || !top)
	{
		c.lineTo(0, 0);
	}
	else
	{
		c.lineTo(0, size);
	}
};

mxShapeBasicRect2.prototype.paintSE = function(c, x, y, w, h, rectStyle, bottomRightStyle, size, right)
{
	if (!right)
	{
		c.lineTo(w, h);
	}
	else if((bottomRightStyle == 'rounded' || (bottomRightStyle == 'default' && rectStyle == 'rounded' )) ||
			(bottomRightStyle == 'invRound' || (bottomRightStyle == 'default' && rectStyle == 'invRound' )) )
	{
		var inv = 0;
		
		if (bottomRightStyle == 'rounded' || (bottomRightStyle == 'default' && rectStyle == 'rounded' ))
		{
			inv = 1;
		}
		
		c.arcTo(size, size, 0, 0, inv, w - size, h);
	}
	else if((bottomRightStyle == 'snip' || (bottomRightStyle == 'default' && rectStyle == 'snip' )) ||
			(bottomRightStyle == 'fold' || (bottomRightStyle == 'default' && rectStyle == 'fold' )))
	{
		c.lineTo(w - size, h);
	}
};

mxShapeBasicRect2.prototype.paintBottom = function(c, x, y, w, h, rectStyle, bottomLeftStyle, size, left)
{
	if((bottomLeftStyle == 'square' || (bottomLeftStyle == 'default' && rectStyle == 'square' )) || !left)
	{
		c.lineTo(0, h);
	}
	else
	{
		c.lineTo(size, h);
	}
};

mxShapeBasicRect2.prototype.paintSW = function(c, x, y, w, h, rectStyle, bottomLeftStyle, size, bottom)
{
	if (!bottom)
	{
		c.lineTo(0, h);
	}
	else if((bottomLeftStyle == 'rounded' || (bottomLeftStyle == 'default' && rectStyle == 'rounded' )) ||
			(bottomLeftStyle == 'invRound' || (bottomLeftStyle == 'default' && rectStyle == 'invRound' )) )
	{
		var inv = 0;
		
		if (bottomLeftStyle == 'rounded' || (bottomLeftStyle == 'default' && rectStyle == 'rounded' ))
		{
			inv = 1;
		}
		
		c.arcTo(size, size, 0, 0, inv, 0, h - size);
	}
	else if((bottomLeftStyle == 'snip' || (bottomLeftStyle == 'default' && rectStyle == 'snip' )) ||
			(bottomLeftStyle == 'fold' || (bottomLeftStyle == 'default' && rectStyle == 'fold' )))
	{
		c.lineTo(0, h - size);
	}
};

mxShapeBasicRect2.prototype.paintNWInner = function(c, x, y, w, h, rectStyle, topLeftStyle, size, indent)
{
	if(topLeftStyle == 'rounded' || (topLeftStyle == 'default' && rectStyle == 'rounded' ))
	{
		c.arcTo(size - indent * 0.5, size - indent * 0.5, 0, 0, 0, indent, indent * 0.5 + size);
	}
	else if(topLeftStyle == 'invRound' || (topLeftStyle == 'default' && rectStyle == 'invRound' ))
	{
		c.arcTo(size + indent, size + indent, 0, 0, 1, indent, indent + size);
	}
	else if(topLeftStyle == 'snip' || (topLeftStyle == 'default' && rectStyle == 'snip' ))
	{
		c.lineTo(indent, indent * 0.5 + size);
	}
	else if(topLeftStyle == 'fold' || (topLeftStyle == 'default' && rectStyle == 'fold' ))
	{
		c.lineTo(indent + size, indent + size);
		c.lineTo(indent, indent + size);
	}
};

mxShapeBasicRect2.prototype.paintTopInner = function(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, left, top)
{
	if (!left && !top)
	{
		c.lineTo(0, 0);
	}
	else if (!left && top)
	{
		c.lineTo(0, indent);
	}
	else if (left && !top)
	{
		c.lineTo(indent, 0);
	}
	else if (!left)
	{
		c.lineTo(0, indent);
	}
	else if(topLeftStyle == 'square' || (topLeftStyle == 'default' && rectStyle == 'square' ))
	{
		c.lineTo(indent, indent);
	}
	else if((topLeftStyle == 'rounded' || (topLeftStyle == 'default' && rectStyle == 'rounded' )) ||
			(topLeftStyle == 'snip' || (topLeftStyle == 'default' && rectStyle == 'snip' )))
	{
		c.lineTo(size + indent * 0.5, indent);
	}
	else
	{
		c.lineTo(size + indent, indent);
	}
};

mxShapeBasicRect2.prototype.paintNEInner = function(c, x, y, w, h, rectStyle, topRightStyle, size, indent)
{
	if(topRightStyle == 'rounded' || (topRightStyle == 'default' && rectStyle == 'rounded' ))
	{
		c.arcTo(size - indent * 0.5, size - indent * 0.5, 0, 0, 0, w - size - indent * 0.5, indent);
	}
	else if(topRightStyle == 'invRound' || (topRightStyle == 'default' && rectStyle == 'invRound' ))
	{
		c.arcTo(size + indent, size + indent, 0, 0, 1, w - size - indent, indent);
	}
	else if(topRightStyle == 'snip' || (topRightStyle == 'default' && rectStyle == 'snip' ))
	{
		c.lineTo(w - size - indent * 0.5, indent);
	}
	else if(topRightStyle == 'fold' || (topRightStyle == 'default' && rectStyle == 'fold' ))
	{
		c.lineTo(w - size - indent, size + indent);
		c.lineTo(w - size - indent, indent);
	}
};

mxShapeBasicRect2.prototype.paintRightInner = function(c, x, y, w, h, rectStyle, topRightStyle, size, indent, top, right)
{
	if (!top && !right)
	{
		c.lineTo(w, 0);
	}
	else if (!top && right)
	{
		c.lineTo(w - indent, 0);
	}
	else if (top && !right)
	{
		c.lineTo(w, indent);
	}
	else if (!top)
	{
		c.lineTo(w - indent, 0);
	}
	else if(topRightStyle == 'square' || (topRightStyle == 'default' && rectStyle == 'square' ))
	{
		c.lineTo(w - indent, indent);
	}
	else if((topRightStyle == 'rounded' || (topRightStyle == 'default' && rectStyle == 'rounded' )) ||
			(topRightStyle == 'snip' || (topRightStyle == 'default' && rectStyle == 'snip' )))
	{
		c.lineTo(w - indent, size + indent * 0.5);
	}
	else
	{
		c.lineTo(w - indent, size + indent);
	}
};

mxShapeBasicRect2.prototype.paintLeftInner = function(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom, left)
{
	if (!bottom && !left)
	{
		c.lineTo(0, h);
	}
	else if (!bottom && left)
	{
		c.lineTo(indent, h);
	}
	else if (bottom && !left)
	{
		c.lineTo(0, h - indent);
	}
	else if (!bottom)
	{
		c.lineTo(indent, h);
	}
	else if(bottomLeftStyle == 'square' || (bottomLeftStyle == 'default' && rectStyle == 'square' ))
	{
		c.lineTo(indent, h - indent);
	}
	else if((bottomLeftStyle == 'rounded' || (bottomLeftStyle == 'default' && rectStyle == 'rounded' )) ||
			(bottomLeftStyle == 'snip' || (bottomLeftStyle == 'default' && rectStyle == 'snip' )))
	{
		c.lineTo(indent, h - size - indent * 0.5);
	}
	else
	{
		c.lineTo(indent, h - size - indent);
	}
};

mxShapeBasicRect2.prototype.paintSEInner = function(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent)
{
	if(bottomRightStyle == 'rounded' || (bottomRightStyle == 'default' && rectStyle == 'rounded' ))
	{
		c.arcTo(size - indent * 0.5, size - indent * 0.5, 0, 0, 0, w - indent, h - size - indent * 0.5);
	}
	else if(bottomRightStyle == 'invRound' || (bottomRightStyle == 'default' && rectStyle == 'invRound' ))
	{
		c.arcTo(size + indent, size + indent, 0, 0, 1, w - indent, h - size - indent);
	}
	else if(bottomRightStyle == 'snip' || (bottomRightStyle == 'default' && rectStyle == 'snip' ))
	{
		c.lineTo(w - indent, h - size - indent * 0.5);
	}
	else if(bottomRightStyle == 'fold' || (bottomRightStyle == 'default' && rectStyle == 'fold' ))
	{
		c.lineTo(w - size - indent, h - size - indent);
		c.lineTo(w - indent, h - size - indent);
	}
};

mxShapeBasicRect2.prototype.paintBottomInner = function(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, right, bottom)
{
	if (!right && !bottom)
	{
		c.lineTo(w, h);
	}
	else if (!right && bottom)
	{
		c.lineTo(w, h - indent);
	}
	else if (right && !bottom)
	{
		c.lineTo(w - indent, h);
	}
	else if((bottomRightStyle == 'square' || (bottomRightStyle == 'default' && rectStyle == 'square' )) || !right)
	{
		c.lineTo(w - indent, h - indent);
	}
	else if((bottomRightStyle == 'rounded' || (bottomRightStyle == 'default' && rectStyle == 'rounded' )) ||
			(bottomRightStyle == 'snip' || (bottomRightStyle == 'default' && rectStyle == 'snip' )))
	{
		c.lineTo(w - size - indent * 0.5, h - indent);
	}
	else
	{
		c.lineTo(w - size - indent, h - indent);
	}
};

mxShapeBasicRect2.prototype.paintSWInner = function(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, bottom)
{
	if (!bottom)
	{
		c.lineTo(indent, h);
	}
	else if(bottomLeftStyle == 'square' || (bottomLeftStyle == 'default' && rectStyle == 'square' ))
	{
		c.lineTo(indent, h - indent);
	}
	else if(bottomLeftStyle == 'rounded' || (bottomLeftStyle == 'default' && rectStyle == 'rounded' ))
	{
		c.arcTo(size - indent * 0.5, size - indent * 0.5, 0, 0, 0, size + indent * 0.5, h - indent);
	}
	else if(bottomLeftStyle == 'invRound' || (bottomLeftStyle == 'default' && rectStyle == 'invRound' ))
	{
		c.arcTo(size + indent, size + indent, 0, 0, 1, size + indent, h - indent);
	}
	else if(bottomLeftStyle == 'snip' || (bottomLeftStyle == 'default' && rectStyle == 'snip' ))
	{
		c.lineTo(size + indent * 0.5, h - indent);
	}
	else if(bottomLeftStyle == 'fold' || (bottomLeftStyle == 'default' && rectStyle == 'fold' ))
	{
		c.lineTo(indent + size, h - size - indent);
		c.lineTo(indent + size, h - indent);
	}
};

mxShapeBasicRect2.prototype.moveSWInner = function(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, left)
{
	if (!left)
	{
		c.moveTo(0, h - indent);
	}
	else if(bottomLeftStyle == 'square' || (bottomLeftStyle == 'default' && rectStyle == 'square' ))
	{
		c.moveTo(indent, h - indent);
	}
	else if((bottomLeftStyle == 'rounded' || (bottomLeftStyle == 'default' && rectStyle == 'rounded' )) ||
			(bottomLeftStyle == 'snip' || (bottomLeftStyle == 'default' && rectStyle == 'snip' )))
	{
		c.moveTo(indent, h - size - indent * 0.5);
	}
	else if((bottomLeftStyle == 'invRound' || (bottomLeftStyle == 'default' && rectStyle == 'invRound' )) ||
			(bottomLeftStyle == 'fold' || (bottomLeftStyle == 'default' && rectStyle == 'fold' )))
	{
		c.moveTo(indent, h - size - indent);
	}
};

mxShapeBasicRect2.prototype.lineSWInner = function(c, x, y, w, h, rectStyle, bottomLeftStyle, size, indent, left)
{
	if (!left)
	{
		c.lineTo(0, h - indent);
	}
	else if(bottomLeftStyle == 'square' || (bottomLeftStyle == 'default' && rectStyle == 'square' ))
	{
		c.lineTo(indent, h - indent);
	}
	else if((bottomLeftStyle == 'rounded' || (bottomLeftStyle == 'default' && rectStyle == 'rounded' )) ||
			(bottomLeftStyle == 'snip' || (bottomLeftStyle == 'default' && rectStyle == 'snip' )))
	{
		c.lineTo(indent, h - size - indent * 0.5);
	}
	else if((bottomLeftStyle == 'invRound' || (bottomLeftStyle == 'default' && rectStyle == 'invRound' )) ||
			(bottomLeftStyle == 'fold' || (bottomLeftStyle == 'default' && rectStyle == 'fold' )))
	{
			c.lineTo(indent, h - size - indent);
	}
};

mxShapeBasicRect2.prototype.moveSEInner = function(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, bottom)
{
	if (!bottom)
	{
		c.moveTo(w - indent, h);
	}
	else if(bottomRightStyle == 'square' || (bottomRightStyle == 'default' && rectStyle == 'square' ))
	{
		c.moveTo(w - indent, h - indent);
	}
	else if((bottomRightStyle == 'rounded' || (bottomRightStyle == 'default' && rectStyle == 'rounded' )) ||
			(bottomRightStyle == 'snip' || (bottomRightStyle == 'default' && rectStyle == 'snip' )))
	{
		c.moveTo(w - indent, h - size - indent * 0.5);
	}
	else if((bottomRightStyle == 'invRound' || (bottomRightStyle == 'default' && rectStyle == 'invRound' )) ||
			(bottomRightStyle == 'fold' || (bottomRightStyle == 'default' && rectStyle == 'fold' )))
	{
		c.moveTo(w - indent, h - size - indent);
	}
};

mxShapeBasicRect2.prototype.lineSEInner = function(c, x, y, w, h, rectStyle, bottomRightStyle, size, indent, bottom)
{
	if (!bottom)
	{
		c.lineTo(w - indent, h);
	}
	else if(bottomRightStyle == 'square' || (bottomRightStyle == 'default' && rectStyle == 'square' ))
	{
		c.lineTo(w - indent, h - indent);
	}
	else if((bottomRightStyle == 'rounded' || (bottomRightStyle == 'default' && rectStyle == 'rounded' )) ||
			(bottomRightStyle == 'snip' || (bottomRightStyle == 'default' && rectStyle == 'snip' )))
	{
		c.lineTo(w - indent, h - size - indent * 0.5);
	}
	else if((bottomRightStyle == 'invRound' || (bottomRightStyle == 'default' && rectStyle == 'invRound' )) ||
			(bottomRightStyle == 'fold' || (bottomRightStyle == 'default' && rectStyle == 'fold' )))
	{
		c.lineTo(w - indent, h - size - indent);
	}
};

mxShapeBasicRect2.prototype.moveNEInner = function(c, x, y, w, h, rectStyle, topRightStyle, size, indent, right)
{
	if (!right)
	{
		c.moveTo(w, indent);
	}
	else if((topRightStyle == 'square' || (topRightStyle == 'default' && rectStyle == 'square' )) || right)
	{
		c.moveTo(w - indent, indent);
	}
	else if((topRightStyle == 'rounded' || (topRightStyle == 'default' && rectStyle == 'rounded' )) ||
			(topRightStyle == 'snip' || (topRightStyle == 'default' && rectStyle == 'snip' )))
	{
		c.moveTo(w - indent, size + indent * 0.5);
	}
	else if((topRightStyle == 'invRound' || (topRightStyle == 'default' && rectStyle == 'invRound' )) ||
			(topRightStyle == 'fold' || (topRightStyle == 'default' && rectStyle == 'fold' )))
	{
		c.moveTo(w - indent, size + indent);
	}
};

mxShapeBasicRect2.prototype.lineNEInner = function(c, x, y, w, h, rectStyle, topRightStyle, size, indent, right)
{
	if (!right)
	{
		c.lineTo(w, indent);
	}
	else if((topRightStyle == 'square' || (topRightStyle == 'default' && rectStyle == 'square' )) || right)
	{
		c.lineTo(w - indent, indent);
	}
	else if((topRightStyle == 'rounded' || (topRightStyle == 'default' && rectStyle == 'rounded' )) ||
			(topRightStyle == 'snip' || (topRightStyle == 'default' && rectStyle == 'snip' )))
	{
		c.lineTo(w - indent, size + indent * 0.5);
	}
	else if((topRightStyle == 'invRound' || (topRightStyle == 'default' && rectStyle == 'invRound' )) ||
			(topRightStyle == 'fold' || (topRightStyle == 'default' && rectStyle == 'fold' )))
	{
		c.lineTo(w - indent, size + indent);
	}
};

mxShapeBasicRect2.prototype.moveNWInner = function(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, top, left)
{
	if (!top && !left)
	{
		c.moveTo(0, 0);
	}
	else if (!top && left)
	{
		c.moveTo(indent, 0);
	}
	else if (top && !left)
	{
		c.moveTo(0, indent);
	}
	else if(topLeftStyle == 'square' || (topLeftStyle == 'default' && rectStyle == 'square' ))
	{
		c.moveTo(indent, indent);
	}
	else if((topLeftStyle == 'rounded' || (topLeftStyle == 'default' && rectStyle == 'rounded' )) ||
			(topLeftStyle == 'snip' || (topLeftStyle == 'default' && rectStyle == 'snip' )))
	{
		c.moveTo(indent, size + indent * 0.5);
	}
	else if((topLeftStyle == 'invRound' || (topLeftStyle == 'default' && rectStyle == 'invRound' )) ||
			(topLeftStyle == 'fold' || (topLeftStyle == 'default' && rectStyle == 'fold' )))
	{
		c.moveTo(indent, size + indent);
	}
};

mxShapeBasicRect2.prototype.lineNWInner = function(c, x, y, w, h, rectStyle, topLeftStyle, size, indent, top, left)
{
	if (!top && !left)
	{
		c.lineTo(0, 0);
	}
	else if (!top && left)
	{
		c.lineTo(indent, 0);
	}
	else if (top && !left)
	{
		c.lineTo(0, indent);
	}
	else if(topLeftStyle == 'square' || (topLeftStyle == 'default' && rectStyle == 'square' ))
	{
		c.lineTo(indent, indent);
	}
	else if((topLeftStyle == 'rounded' || (topLeftStyle == 'default' && rectStyle == 'rounded' )) ||
			(topLeftStyle == 'snip' || (topLeftStyle == 'default' && rectStyle == 'snip' )))
	{
		c.lineTo(indent, size + indent * 0.5);
	}
	else if((topLeftStyle == 'invRound' || (topLeftStyle == 'default' && rectStyle == 'invRound' )) ||
			(topLeftStyle == 'fold' || (topLeftStyle == 'default' && rectStyle == 'fold' )))
	{
		c.lineTo(indent, size + indent);
	}
};

mxShapeBasicRect2.prototype.paintFolds = function(c, x, y, w, h, rectStyle, topLeftStyle, topRightStyle, bottomRightStyle, bottomLeftStyle, size, top, right, bottom, left)
{
	if (rectStyle == 'fold' || topLeftStyle == 'fold' || topRightStyle == 'fold' || bottomRightStyle == 'fold' || bottomLeftStyle == 'fold')
	{
		if ((topLeftStyle == 'fold' || (topLeftStyle == 'default' && rectStyle == 'fold' )) && (top && left))
		{
			c.moveTo(0, size);
			c.lineTo(size, size);
			c.lineTo(size, 0);
		}
		
		if ((topRightStyle == 'fold' || (topRightStyle == 'default' && rectStyle == 'fold' )) && (top && right))
		{
			c.moveTo(w - size, 0);
			c.lineTo(w - size, size);
			c.lineTo(w, size);
		}
		
		if ((bottomRightStyle == 'fold' || (bottomRightStyle == 'default' && rectStyle == 'fold' )) && (bottom && right))
		{
			c.moveTo(w - size, h);
			c.lineTo(w - size, h - size);
			c.lineTo(w, h - size);
		}
		
		if ((bottomLeftStyle == 'fold' || (bottomLeftStyle == 'default' && rectStyle == 'fold' )) && (bottom && left))
		{
			c.moveTo(0, h - size);
			c.lineTo(size, h - size);
			c.lineTo(size, h);
		}
	}
};

mxCellRenderer.registerShape(mxShapeBasicRect2.prototype.cst.RECT2, mxShapeBasicRect2);

mxShapeBasicRect2.prototype.constraints = null;

Graph.handleFactory[mxShapeBasicRect2.prototype.cst.DIAG_ROUND_RECT] = function(state)
{
	var handles = [Graph.createHandle(state, ['size'], function(bounds)
	{
		var size = Math.max(0, Math.min(bounds.width / 2, bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'size', this.size))));

		return new mxPoint(bounds.x + size, bounds.y + size);
	}, function(bounds, pt)
	{
		this.state.style['size'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x))) / 100;
	})];
			
	var handle2 = Graph.createHandle(state, ['indent'], function(bounds)
	{
		var dx2 = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'indent', this.dx2))));

		return new mxPoint(bounds.x + bounds.width * 0.75, bounds.y + dx2 * bounds.height / 200);
	}, function(bounds, pt)
	{
		this.state.style['indent'] = Math.round(100 * Math.max(0, Math.min(100, 200 * (pt.y - bounds.y) / bounds.height))) / 100;
	});
	
	handles.push(handle2);
	
	return handles;
};

/**
 * $Id: mxBootstrap.js,v 1.0 2014/09/10 07:05:39 mate Exp $
 * Copyright (c) 2006-2014, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Rounded rectangle (adjustable rounding)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapRRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapRRect, mxShape);

mxShapeBootstrapRRect.prototype.cst = {
		PACKAGE : 'mxgraph.bootstrap.rrect',
		R_SIZE : 'rSize'
};

mxShapeBootstrapRRect.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapRRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeBootstrapRRect.prototype.cst.R_SIZE, '10'));
	c.roundrect(0, 0, w, h, rSize);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBootstrapRRect.prototype.cst.PACKAGE, mxShapeBootstrapRRect);

//**********************************************************************************************************************************************************
//Top Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapTopButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapTopButton, mxShape);

mxShapeBootstrapTopButton.prototype.cst = {
		TOP_BUTTON : 'mxgraph.bootstrap.topButton',
		R_SIZE : 'rSize'
};

mxShapeBootstrapTopButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapTopButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeBootstrapTopButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBootstrapTopButton.prototype.cst.TOP_BUTTON, mxShapeBootstrapTopButton);

//**********************************************************************************************************************************************************
//Bottom Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapBottomButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapBottomButton, mxShape);

mxShapeBootstrapBottomButton.prototype.cst = {
		BOTTOM_BUTTON : 'mxgraph.bootstrap.bottomButton',
		R_SIZE : 'rSize'
};

mxShapeBootstrapBottomButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapBottomButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeBootstrapBottomButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBootstrapBottomButton.prototype.cst.BOTTOM_BUTTON, mxShapeBootstrapBottomButton);

//**********************************************************************************************************************************************************
//Right Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapRightButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapRightButton, mxShape);

mxShapeBootstrapRightButton.prototype.cst = {
		RIGHT_BUTTON : 'mxgraph.bootstrap.rightButton',
		R_SIZE : 'rSize'
};

mxShapeBootstrapRightButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapRightButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeBootstrapRightButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBootstrapRightButton.prototype.cst.RIGHT_BUTTON, mxShapeBootstrapRightButton);

//**********************************************************************************************************************************************************
//Left Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapLeftButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapLeftButton, mxShape);

mxShapeBootstrapLeftButton.prototype.cst = {
		LEFT_BUTTON : 'mxgraph.bootstrap.leftButton',
		R_SIZE : 'rSize'
};

mxShapeBootstrapLeftButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapLeftButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeBootstrapLeftButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.lineTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeBootstrapLeftButton.prototype.cst.LEFT_BUTTON, mxShapeBootstrapLeftButton);

//**********************************************************************************************************************************************************
//Left Button (Striped)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapLeftButtonStriped(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapLeftButtonStriped, mxShape);

mxShapeBootstrapLeftButtonStriped.prototype.cst = {
		LEFT_BUTTON_STRIPED : 'mxgraph.bootstrap.leftButtonStriped'
};



/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapLeftButtonStriped.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	rSize = 5;
	c.begin();
	c.moveTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.lineTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.close();
	c.fill();

	
	var fillColor = '#ffffff';
	c.setAlpha('0.2');
	var stripeW = h * 0.5;

	c.setFillColor(fillColor);
	c.begin();
	c.moveTo(0, h * 0.75);
	c.lineTo(0, h * 0.25);
	c.lineTo(h * 0.75, h);
	c.lineTo(h * 0.25, h);
	c.close();
	c.fill();
	
	var end = false;
	var startX = stripeW * 0.5;
	
	while (!end)
	{
		c.begin();
		c.moveTo(startX, 0);
		
		if (startX + stripeW >= w)
		{
			c.lineTo(w, 0);
			c.lineTo(w, w - startX);
		}
		else
		{
			c.lineTo(startX + stripeW, 0);
			
			if (startX + stripeW + h > w)
			{
				c.lineTo(w, w - startX - stripeW);
				
				if (w - startX > h)
				{
					c.lineTo(w, h);
					c.lineTo(startX + h, h);
				}
				else
				{
					c.lineTo(w, w - startX);
				}
			}
			else
			{
				c.lineTo(startX + stripeW + h, h);
				c.lineTo(startX + h, h);
			}
		}

		c.close();
		c.fill();
		
		startX = startX + 2 * stripeW;
		
		if (startX > w)
		{
			end = true;
		}
	}
};

mxCellRenderer.registerShape(mxShapeBootstrapLeftButtonStriped.prototype.cst.LEFT_BUTTON_STRIPED, mxShapeBootstrapLeftButtonStriped);

//**********************************************************************************************************************************************************
//Rounded Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapRoundedButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapRoundedButton, mxShape);

mxShapeBootstrapRoundedButton.prototype.cst = {
		ROUNDED_BUTTON : 'mxgraph.bootstrap.roundedButton'
};



/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapRoundedButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	if (w > h)
	{
		var r = h * 0.5;
	
		c.begin();
		c.moveTo(w - r, 0);
		c.arcTo(r, r, 0, 0, 1, w - r, h);
		c.lineTo(r, h);
		c.arcTo(r, r, 0, 0, 1, r, 0);
		c.close();
		c.fillAndStroke();
	}
	else
	{
		var r = w * 0.5;
		
		c.begin();
		c.moveTo(0, h - r);
		c.arcTo(r, r, 0, 0, 0, w, h - r);
		c.lineTo(w, r);
		c.arcTo(r, r, 0, 0, 0, 0, r);
		c.close();
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeBootstrapRoundedButton.prototype.cst.ROUNDED_BUTTON, mxShapeBootstrapRoundedButton);

//**********************************************************************************************************************************************************
//Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapArrow, mxShape);

mxShapeBootstrapArrow.prototype.cst = {
		ARROW : 'mxgraph.bootstrap.arrow'
};



/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.moveTo(w * 0.9, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w * 0.9, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeBootstrapArrow.prototype.cst.ARROW, mxShapeBootstrapArrow);

//**********************************************************************************************************************************************************
//Tab Top
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapTabTop(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapTabTop, mxShape);

mxShapeBootstrapTabTop.prototype.cst = {
		TAB_TOP : 'mxgraph.bootstrap.tabTop',
		R_SIZE  : 'rSize'
};

mxShapeBootstrapTabTop.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:5}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapTabTop.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeBootstrapTopButton.prototype.cst.R_SIZE, '10'));
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');

	c.setStrokeColor(fillColor);
	c.begin();
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();

	c.setStrokeColor(strokeColor);
	c.begin();
	c.moveTo(0, h);
	c.lineTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeBootstrapTabTop.prototype.cst.TAB_TOP, mxShapeBootstrapTabTop);

//**********************************************************************************************************************************************************
//Image
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapImage(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapImage, mxShape);

mxShapeBootstrapImage.prototype.cst = {
		IMAGE : 'mxgraph.bootstrap.image',
		R_SIZE  : 'rSize'
};

mxShapeBootstrapImage.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:5}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapImage.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var rSize = Math.max(0, parseInt(mxUtils.getValue(this.style, mxShapeBootstrapTopButton.prototype.cst.R_SIZE, '10')));
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');

	c.begin();
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();
	c.stroke();

	var rsHalf = rSize * 0.5;
	c.translate(rsHalf, rsHalf);
	w = Math.max(0, w - rSize);
	h = Math.max(0, h - rSize);
	
	c.begin();
	c.moveTo(0, rsHalf);
	c.arcTo(rsHalf, rsHalf, 0, 0, 1, rsHalf, 0);
	c.lineTo(w - rsHalf, 0);
	c.arcTo(rsHalf, rsHalf, 0, 0, 1, w, rsHalf);
	c.lineTo(w, h - rsHalf);
	c.arcTo(rsHalf, rsHalf, 0, 0, 1, w - rsHalf, h);
	c.lineTo(rsHalf, h);
	c.arcTo(rsHalf, rsHalf, 0, 0, 1, 0, h - rsHalf);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeBootstrapImage.prototype.cst.IMAGE, mxShapeBootstrapImage);

//**********************************************************************************************************************************************************
//Checkbox
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapCheckbox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapCheckbox, mxShape);

mxShapeBootstrapCheckbox.prototype.cst = {
		CHECKBOX : 'mxgraph.bootstrap.checkbox'
};



/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapCheckbox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var rSize = 3;
	c.roundrect(0, 0, w, h, rSize, rSize);
	c.fillAndStroke();
	
	c.setStrokeWidth('3');
	c.begin();
	c.moveTo(w * 0.8, h * 0.2);
	c.lineTo(w * 0.4, h * 0.8);
	c.lineTo(w * 0.25, h * 0.6);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeBootstrapCheckbox.prototype.cst.CHECKBOX, mxShapeBootstrapCheckbox);

//**********************************************************************************************************************************************************
//Radio Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapRadioButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapRadioButton, mxShape);

mxShapeBootstrapRadioButton.prototype.cst = {
		RADIO_BUTTON : 'mxgraph.bootstrap.radioButton'
};



/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapRadioButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();
	
	c.setFillColor(strokeColor);
	c.ellipse(w * 0.25, h * 0.25, w * 0.5, h * 0.5);
	c.fill();
};

mxCellRenderer.registerShape(mxShapeBootstrapRadioButton.prototype.cst.RADIO_BUTTON, mxShapeBootstrapRadioButton);

//**********************************************************************************************************************************************************
//Horizontal Lines
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapHorLines(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapHorLines, mxShape);

mxShapeBootstrapHorLines.prototype.cst = {
		HOR_LINES : 'mxgraph.bootstrap.horLines'
};



/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapHorLines.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.rect(0, 0, w, h);
	c.fill();
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.moveTo(0, h);
	c.lineTo(w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeBootstrapHorLines.prototype.cst.HOR_LINES, mxShapeBootstrapHorLines);

//**********************************************************************************************************************************************************
//User 2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapUserTwo(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapUserTwo, mxShape);

mxShapeBootstrapUserTwo.prototype.cst = {
		USER2 : 'mxgraph.bootstrap.user2'
};



/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapUserTwo.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(0, h * 0.95);
	c.arcTo(w * 0.3, h * 0.3, 0, 0, 1, w * 0.02, h * 0.87);
	c.arcTo(w * 0.1, h * 0.1, 0, 0, 1, w * 0.08, h * 0.812);
	c.arcTo(w * 3, h * 3, 0, 0, 1, w * 0.29, h * 0.732);
	c.arcTo(w * 0.15, h * 0.15, 0, 0, 0, w * 0.385, h * 0.607);
	c.arcTo(w * 0.11, h * 0.11, 0, 0, 0, w * 0.355, h * 0.53);
	c.arcTo(w * 0.3, h * 0.3, 0, 0, 1, w * 0.305, h * 0.44);
	c.arcTo(w * 0.33, h * 0.38, 0, 0, 1, w * 0.312, h * 0.15);
	c.arcTo(w * 0.218, h * 0.218 , 0, 0, 1, w * 0.688, h * 0.15);
	c.arcTo(w * 0.33, h * 0.38, 0, 0, 1, w * 0.693, h * 0.44);
	c.arcTo(w * 0.25, h * 0.25, 0, 0, 1, w * 0.645, h * 0.53);
	c.arcTo(w * 0.1, h * 0.1, 0, 0, 0, w * 0.612, h * 0.6);
	c.arcTo(w * 0.15, h * 0.15, 0, 0, 0, w * 0.7, h * 0.726);
	c.arcTo(w * 3, h * 3, 0, 0, 1, w * 0.92, h * 0.812);
	c.arcTo(w * 0.1, h * 0.1, 0, 0, 1, w * 0.97, h * 0.865);
	c.arcTo(w * 0.2, h * 0.2, 0, 0, 1, w * 0.995, h * 0.952);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeBootstrapUserTwo.prototype.cst.USER2, mxShapeBootstrapUserTwo);

//**********************************************************************************************************************************************************
//Rating
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBootstrapRating(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBootstrapRating, mxShape);

mxShapeBootstrapRating.prototype.cst = {
		RATING : 'mxgraph.bootstrap.rating',
		RATING_STYLE : 'ratingStyle',
		RATING_SCALE : 'ratingScale',
		RATING_HEART : 'heart',
		RATING_STAR : 'star',
		EMPTY_FILL_COLOR : 'emptyFillColor',
		GRADE : 'grade'
};

mxShapeBootstrapRating.prototype.customProperties = [
	{name: 'ratingStyle', dispName: 'Rating Style', type: 'enum', 
		enumList: [{val: 'heart', dispName: 'Heart'}, 
		   {val: 'star', dispName: 'Star'}]
	},
	{name: 'ratingScale', dispName: 'Rating Scale', type: 'int', min:1, defVal:5}, 
	{name: 'emptyFillColor', dispName: 'Inactive Color', type: 'color', defVal:'none'},
	{name: 'grade', dispName: 'Grade', type: 'int', min:1, defVal:3} 
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBootstrapRating.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var ratingStyle = mxUtils.getValue(this.style, mxShapeBootstrapRating.prototype.cst.RATING_STYLE, mxShapeBootstrapRating.prototype.cst.RATING_STAR);
	var grade = mxUtils.getValue(this.style, mxShapeBootstrapRating.prototype.cst.GRADE, '5');
	var ratingScale = mxUtils.getValue(this.style, mxShapeBootstrapRating.prototype.cst.RATING_SCALE, '10');

	c.translate(x, y);

	if (ratingStyle === mxShapeBootstrapRating.prototype.cst.RATING_STAR)
	{
		for (var i = 0; i < grade; i++)
		{
			c.begin();
			c.moveTo(i * h * 1.2, 0.33 * h);
			c.lineTo(i * h * 1.2 + 0.364 * h, 0.33 * h);
			c.lineTo(i * h * 1.2 + 0.475 * h, 0);
			c.lineTo(i * h * 1.2 + 0.586 * h, 0.33 * h);
			c.lineTo(i * h * 1.2 + 0.95 * h, 0.33 * h);
			c.lineTo(i * h * 1.2 + 0.66 * h, 0.551 * h);
			c.lineTo(i * h * 1.2 + 0.775 * h, 0.9 * h);
			c.lineTo(i * h * 1.2 + 0.475 * h, 0.684 * h);
			c.lineTo(i * h * 1.2 + 0.175 * h, 0.9 * h);
			c.lineTo(i * h * 1.2 + 0.29 * h, 0.551 * h);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (ratingStyle === mxShapeBootstrapRating.prototype.cst.RATING_HEART)
	{
		for (var i = 0; i < grade; i++)
		{
			c.begin();
			c.moveTo(i * h * 1.2 + h * 0.519, h * 0.947);
			c.curveTo(i * h * 1.2 + h * 0.558, h * 0.908, 
					  i * h * 1.2 + h * 0.778, h * 0.682, 
					  i * h * 1.2 + h * 0.916, h * 0.54);
			c.curveTo(i * h * 1.2 + h * 1.039, h * 0.414, 
					  i * h * 1.2 + h * 1.036, h * 0.229, 
					  i * h * 1.2 + h * 0.924, h * 0.115);
			c.curveTo(i * h * 1.2 + h * 0.812, 0, 
					  i * h * 1.2 + h * 0.631, 0, 
					  i * h * 1.2 + h * 0.519, h * 0.115);
			c.curveTo(i * h * 1.2 + h * 0.408, 0, 
					  i * h * 1.2 + h * 0.227, 0, 
					  i * h * 1.2 + h * 0.115, h * 0.115);
			c.curveTo(i * h * 1.2 + h * 0.03, h * 0.229, 
					  i * h * 1.2, h * 0.414, 
					  i * h * 1.2 + h * 0.123, h * 0.54);
			c.close();
			c.fillAndStroke();
		}
	}

	var emptyFillColor = mxUtils.getValue(this.style, mxShapeBootstrapRating.prototype.cst.EMPTY_FILL_COLOR, '#ffffff');
	c.setFillColor(emptyFillColor);

	if (ratingStyle === mxShapeBootstrapRating.prototype.cst.RATING_STAR)
	{
		for (var i = grade; i < ratingScale; i++)
		{
			c.begin();
			c.moveTo(i * h * 1.2, 0.33 * h);
			c.lineTo(i * h * 1.2 + 0.364 * h, 0.33 * h);
			c.lineTo(i * h * 1.2 + 0.475 * h, 0);
			c.lineTo(i * h * 1.2 + 0.586 * h, 0.33 * h);
			c.lineTo(i * h * 1.2 + 0.95 * h, 0.33 * h);
			c.lineTo(i * h * 1.2 + 0.66 * h, 0.551 * h);
			c.lineTo(i * h * 1.2 + 0.775 * h, 0.9 * h);
			c.lineTo(i * h * 1.2 + 0.475 * h, 0.684 * h);
			c.lineTo(i * h * 1.2 + 0.175 * h, 0.9 * h);
			c.lineTo(i * h * 1.2 + 0.29 * h, 0.551 * h);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (ratingStyle === mxShapeBootstrapRating.prototype.cst.RATING_HEART)
	{
		for (var i = grade; i < ratingScale; i++)
		{
			c.begin();
			c.moveTo(i * h * 1.2 + h * 0.519, h * 0.947);
			c.curveTo(i * h * 1.2 + h * 0.558, h * 0.908, 
					  i * h * 1.2 + h * 0.778, h * 0.682, 
					  i * h * 1.2 + h * 0.916, h * 0.54);
			c.curveTo(i * h * 1.2 + h * 1.039, h * 0.414, 
					  i * h * 1.2 + h * 1.036, h * 0.229, 
					  i * h * 1.2 + h * 0.924, h * 0.115);
			c.curveTo(i * h * 1.2 + h * 0.812, 0, 
					  i * h * 1.2 + h * 0.631, 0, 
					  i * h * 1.2 + h * 0.519, h * 0.115);
			c.curveTo(i * h * 1.2 + h * 0.408, 0, 
					  i * h * 1.2 + h * 0.227, 0, 
					  i * h * 1.2 + h * 0.115, h * 0.115);
			c.curveTo(i * h * 1.2 + h * 0.03, h * 0.229, 
					  i * h * 1.2, h * 0.414, 
					  i * h * 1.2 + h * 0.123, h * 0.54);
			c.close();
			c.fillAndStroke();
		}
	}
};

mxCellRenderer.registerShape(mxShapeBootstrapRating.prototype.cst.RATING, mxShapeBootstrapRating);

//**********************************************************************************************************************************************************
//Anchor (a dummy shape without visuals used for anchoring)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeBoostrapAnchor(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeBoostrapAnchor, mxShape);

mxShapeBoostrapAnchor.prototype.cst = {
		ANCHOR : 'mxgraph.bootstrap.anchor'
};


/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeBoostrapAnchor.prototype.paintVertexShape = function(c, x, y, w, h)
{
};

mxCellRenderer.registerShape(mxShapeBoostrapAnchor.prototype.cst.ANCHOR, mxShapeBoostrapAnchor);


/**
 * $Id: mxC4.js,v 1.5 2018/26/11 12:32:06 mate Exp $
 * Copyright (c) 2006-2018, JGraph Ltd
 */
//**********************************************************************************************************************************************************
// Person
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeC4Person(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeC4Person, mxShape);

mxShapeC4Person.prototype.cst = {START : 'mxgraph.c4.person'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeC4Person.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var headSize = Math.min(w / 2, h / 3);
	var r = headSize / 2;
	
	c.ellipse(w * 0.5 - headSize * 0.5, 0, headSize, headSize);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(0, headSize * 0.8 + r);
	c.arcTo(r, r, 0, 0, 1, r, headSize * 0.8);
	c.lineTo(w - r, headSize * 0.8);
	c.arcTo(r, r, 0, 0, 1, w, headSize * 0.8 + r);
	c.lineTo(w, h - r);
	c.arcTo(r, r, 0, 0, 1, w - r, h);
	c.lineTo(r, h);
	c.arcTo(r, r, 0, 0, 1, 0, h -r);
	c.close();
	c.fillAndStroke();

	c.setShadow(false);
	
	c.ellipse(w * 0.5 - headSize * 0.5, 0, headSize, headSize);
	c.fillAndStroke();

};

var cylinderGetCylinderSize = mxCylinder.prototype.getCylinderSize;

mxShapeC4Person.prototype.getLabelMargins = function(rect)
{
	var headSize = Math.min(rect.width / 2, rect.height / 3);
		
	return new mxRectangle(0, headSize * 0.8, 0, 0);
};

mxCellRenderer.registerShape(mxShapeC4Person.prototype.cst.START, mxShapeC4Person);

/**
 * $Id: mxCabinets.js,v 1.0 2014/04/15 07:05:39 mate Exp $
 * Copyright (c) 2006-2014, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Cabinet
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxCabinetsCabinet(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxCabinetsCabinet, mxShape);

mxCabinetsCabinet.prototype.cst = {
		HAS_STAND : 'hasStand',
		CABINET : 'mxgraph.cabinets.cabinet'
};

mxCabinetsCabinet.prototype.customProperties = [
	{name: 'hasStand', dispName:'Has Stand', type:'bool', defVal:true}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxCabinetsCabinet.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h);
};

mxCabinetsCabinet.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxCabinetsCabinet.prototype.foreground = function(c, x, y, w, h)
{
	var wallTh = 15;
	c.rect(0, 0, w, wallTh);
	c.stroke();
	
	c.begin();
	c.moveTo(wallTh, wallTh);
	c.lineTo(wallTh, h);
	c.moveTo(w - wallTh, wallTh);
	c.lineTo(w - wallTh, h);
	c.stroke();
	
	var hasStand = mxUtils.getValue(this.style, mxCabinetsCabinet.prototype.cst.HAS_STAND, '1');
	
	if (hasStand === 1)
	{
		c.rect(0, h - 40, w, 40);
		c.fillAndStroke();
	}
	else
	{
		c.rect(0, h - wallTh, w, wallTh);
		c.fillAndStroke();
	};
};

mxCellRenderer.registerShape(mxCabinetsCabinet.prototype.cst.CABINET, mxCabinetsCabinet);

//**********************************************************************************************************************************************************
//Cover Plate
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxCabinetsCoverPlate(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxCabinetsCoverPlate, mxShape);

mxCabinetsCoverPlate.prototype.cst = {
		COVER_PLATE : 'mxgraph.cabinets.coverPlate'
};



/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxCabinetsCoverPlate.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, 0, 0, w, h);
	c.setShadow(false);
	this.foreground(c, 0, 0, w, h);
};

mxCabinetsCoverPlate.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.moveTo(10, h * 0.5 - 12.5);
	c.lineTo(10, h * 0.5 + 12.5);
	c.lineTo(w - 10, h * 0.5 + 12.5);
	c.lineTo(w - 10, h * 0.5 - 12.5);
	c.close();
	c.fillAndStroke();
};

mxCabinetsCoverPlate.prototype.foreground = function(c, x, y, w, h)
{
};

mxCellRenderer.registerShape(mxCabinetsCoverPlate.prototype.cst.COVER_PLATE, mxCabinetsCoverPlate);

//**********************************************************************************************************************************************************
//Dimension
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxCabinetsDimension(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxCabinetsDimension, mxShape);

mxCabinetsDimension.prototype.cst = {
		DIMENSION : 'mxgraph.cabinets.dimension'
};



/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxCabinetsDimension.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxCabinetsDimension.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 20);
	c.lineTo(w, 20);
	c.moveTo(10, 15);
	c.lineTo(0, 20);
	c.lineTo(10, 25);
	c.moveTo(w - 10, 15);
	c.lineTo(w, 20);
	c.lineTo(w - 10, 25);
	c.moveTo(0, 15);
	c.lineTo(0, h);
	c.moveTo(w, 15);
	c.lineTo(w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxCabinetsDimension.prototype.cst.DIMENSION, mxCabinetsDimension);

//**********************************************************************************************************************************************************
//Dimension Bottom
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxCabinetsDimensionBottom(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxCabinetsDimensionBottom, mxShape);

mxCabinetsDimensionBottom.prototype.cst = {
		DIMENSION : 'mxgraph.cabinets.dimensionBottom'
};



/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxCabinetsDimensionBottom.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxCabinetsDimensionBottom.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, h - 20);
	c.lineTo(w, h - 20);
	c.moveTo(10, h - 15);
	c.lineTo(0, h - 20);
	c.lineTo(10, h - 25);
	c.moveTo(w - 10, h - 15);
	c.lineTo(w, h - 20);
	c.lineTo(w - 10, h - 25);
	c.moveTo(0, h - 15);
	c.lineTo(0, 0);
	c.moveTo(w, h - 15);
	c.lineTo(w, 0);
	c.stroke();
};

mxCellRenderer.registerShape(mxCabinetsDimensionBottom.prototype.cst.DIMENSION, mxCabinetsDimensionBottom);


/**
 * $Id: mxCisco19.js,v 1.0 2019/12/10 13:05:39 mate Exp $
 * Copyright (c) 2006-2020, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//rect
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeCisco19Rect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeCisco19Rect, mxShape);

mxShapeCisco19Rect.prototype.cst = {
		SHAPE_RECT : 'mxgraph.cisco19.rect'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeCisco19Rect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var prIcon = mxUtils.getValue(this.state.style, 'prIcon', 'l2_switch');
	
	var fillColor = mxUtils.getValue(this.state.style, 'fillColor', '#ffffff');
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#000000');

	var bgIcon = 'mxgraph.cisco19.bg1';
	var circleBg = ['router', 'csr_1000v', 'wireless_router', 'l3_modular3', 'ucs_express', 'router_with_voice', 'router_with_firewall', 'netflow_router', 'secure_router', 'ip_telephone_router', 'asr_9000', 'clock', 'vbond', 'vmanage', 'vsmart'];
	
	c.translate(x, y);

	if (['l2_modular', 'l3_modular', '6500_vss', 'nexus_9500', 'nexus_7k'].includes(prIcon)) // square with 1 hor rect on top
	{
		bgIcon = 'mxgraph.cisco19.bg2';
	}
	else if (['l2_switch_with_dual_supervisor', 'l3_switch_with_dual_supervisor'].includes(prIcon)) //square with 2 hor rects on top
	{
		bgIcon = 'mxgraph.cisco19.bg3';
	}
	else if (['l2_modular2'].includes(prIcon)) // vert 2 rects
	{
		bgIcon = 'mxgraph.cisco19.bg4';
	}
	else if (['l3_modular2', '6500_vss2', 'hypervisor', 'collab1'].includes(prIcon)) // vert rect
	{
		bgIcon = 'mxgraph.cisco19.bg5';
	}
	else if (circleBg.includes(prIcon)) // circle
	{
		c.begin();

		if (prIcon == 'wireless_router')
		{
			c.ellipse(0, h * 0.17, w, h * 0.83);
		}
		else
		{
			c.ellipse(0, 0, w, h);
		}

		c.fill();
	}
	else if (['content_router', 'router_with_firewall2', 'netflow_router2', 'nam_virtual_service_blade', 'ucs_5108_blade_chassis', 'storage', 'nexus_1kv_vsm', 'nexus_1k', 'nexus_1010', 'dual mode access point', 'wireless_lan_controller', 'primary_codec', 'virtual_desktop_service', 'video_gateway', 'video_analytics', 'telepresence_exchange', 'meeting_scheduling_and_management_server', 'content_recording_streaming_server', 'communications_manager', 'cisco_unified_presence_service', 'cisco_unified_contact_center_enterprise_and_hosted', 'h323', 'monitor', 'telepresence_endpoint_twin_data_display', 'operations_manager', 'transcoder', 'contact_center_express', 'ip_ip_gateway', 'shield', 'set_top', 'da_encoder', 'ad_encoder', 'da_decoder', 'ad_decoder', 'acs', 'email_security', 'vpn_concentrator', 'ssl_terminator', 'cisco_security_manager', 'web_security', 'nac_appliance', 'ironport', 'ips_ids', 'firewall', 'asa_5500', 'flow_collector', 'load_balancer', 'web_application_firewall', 'analysis_correlation', 'flow_analytics', 'virtual_private_network2', 'web_security_services', 'web_security_services2', 'virtual_private_network_connector'].includes(prIcon)) //hor. rect
	{
		bgIcon = 'mxgraph.cisco19.bg6';
	}
	else if (['asr_1000'].includes(prIcon)) //hexagon
	{
		bgIcon = 'mxgraph.cisco19.bg7';
	}
	else if (['fibre_channel_director_mds_9000', 'fibre_channel_fabric_switch'].includes(prIcon)) // square with 1 hor rect at the bottom
	{
		bgIcon = 'mxgraph.cisco19.bg8';
	}
	else if (['ucs_c_series_server'].includes(prIcon)) // narrow hor rect
	{
		bgIcon = 'mxgraph.cisco19.bg9';
	}
	else if (['aci'].includes(prIcon)) // background specific for ACI
	{
		var frame = mxStencilRegistry.getStencil('mxgraph.cisco19.acibg');
		frame.drawShape(c, this, w * 0.195, h * 0.195, w * 0.61, h * 0.61);
	}
	else if (['immersive_telepresence_endpoint'].includes(prIcon)) // extra wide rect
	{
		bgIcon = 'mxgraph.cisco19.bg10';
	}


	if (!circleBg.includes(prIcon) && prIcon != 'aci')
	{
		var frame = mxStencilRegistry.getStencil(bgIcon);
		frame.drawShape(c, this, 0, 0, w, h);
	}

	c.setShadow(false);

	
	var prStencil = mxStencilRegistry.getStencil('mxgraph.cisco19.' + prIcon);

	c.setFillColor(strokeColor);
	
	if (prStencil != null)
	{
		prStencil.drawShape(c, this, 0, 0, w, h);
	}
};

mxCellRenderer.registerShape(mxShapeCisco19Rect.prototype.cst.SHAPE_RECT, mxShapeCisco19Rect);

mxShapeCisco19Rect.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.825, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.175, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.16), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.84), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.66, 0.17), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.66, 0.83), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.34, 0.17), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.34, 0.83), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0.33), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0.67), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0.33), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0.67), false));

	return (constr);
};


/**
 * $Id: mxDFD.js,v 1.5 2018/26/11 12:32:06 mate Exp $
 * Copyright (c) 2006-2018, JGraph Ltd
 */
//**********************************************************************************************************************************************************
// Start
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeDFDStart(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeDFDStart, mxShape);

mxShapeDFDStart.prototype.cst = {START : 'mxgraph.dfd.start'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeDFDStart.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var r = Math.min(h * 0.5, w * 0.5);
	
	c.begin();
	c.moveTo(w - r, h * 0.5 - r);
	c.arcTo(r, r, 0, 0, 1, w, h * 0.5);
	c.arcTo(r, r, 0, 0, 1, w - r, h * 0.5 + r);
	c.lineTo(r, h * 0.5 + r);
	c.arcTo(r, r, 0, 0, 1, 0, h * 0.5);
	c.arcTo(r, r, 0, 0, 1, r, h * 0.5 - r);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeDFDStart.prototype.cst.START, mxShapeDFDStart);

mxShapeDFDStart.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var r = Math.min(h * 0.5, w * 0.5);
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.5), false, null, 0, -r));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.5), false, null, 0, r));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, r * 0.293, h * 0.5 - r * 0.707));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - r * 0.293, h * 0.5 - r * 0.707));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - r * 0.293, h * 0.5 + r * 0.707));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, r * 0.293, h * 0.5 + r * 0.707));
	
	if (w >= 4 * h)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
		constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
		constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
		constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	}

	return (constr);
}

//**********************************************************************************************************************************************************
//Archive
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeDFDArchive(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeDFDArchive, mxShape);

mxShapeDFDArchive.prototype.cst = {ARCHIVE : 'mxgraph.dfd.archive'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeDFDArchive.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.begin();
	c.moveTo(0,0);
	c.lineTo(w, 0);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	
	c.begin();
	c.moveTo(w * 0.1, h * 0.2);
	c.lineTo(w * 0.9, h * 0.2);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeDFDArchive.prototype.cst.ARCHIVE, mxShapeDFDArchive);

mxShapeDFDArchive.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.875, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.625, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.375, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.125, 0.25), false));

	return (constr);
}

//**********************************************************************************************************************************************************
//Check2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeDFDCheck2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeDFDCheck2, mxShape);

mxShapeDFDCheck2.prototype.cst = {CHECK2 : 'mxgraph.dfd.check2'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeDFDCheck2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var size = Math.min(h * 0.5, w * 0.5);
	
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(size, 0);
	c.lineTo(w - size, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - size, h);
	c.lineTo(size, h);
	c.lineTo(0, h * 0.5);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	
	c.begin();
	c.moveTo(w - size, 0);
	c.lineTo(w - 2 * size, h * 0.5);
	c.lineTo(w - size, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeDFDCheck2.prototype.cst.CHECK2, mxShapeDFDCheck2);

mxShapeDFDCheck2.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var size = Math.min(h * 0.5, w * 0.5);
	
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, size * 0.5, h * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - size * 0.5, h * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, size * 0.5, h * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - size * 0.5, h * 0.75));

	if (w > h)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, size, 0));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - size, 0));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, size, h));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - size, h));
	}

	if(size * 4 <= w)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
		constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
		constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
		constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	}

	return (constr);
}

//**********************************************************************************************************************************************************
//Data Store with ID
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeDFDDataStoreID(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeDFDDataStoreID, mxShape);

mxShapeDFDDataStoreID.prototype.cst = {DATA_STORE_ID : 'mxgraph.dfd.dataStoreID'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeDFDDataStoreID.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var size = Math.min(h * 0.5, w * 0.5);
	
	c.begin();
	c.moveTo(w, h);
	c.lineTo(0, h);
	c.lineTo(0, 0);
	c.lineTo(w, 0);
	c.fillAndStroke();
	
	c.setShadow(false);
	
	var s = Math.min(30, w);
	
	c.begin();
	c.moveTo(s, 0);
	c.lineTo(s, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeDFDDataStoreID.prototype.cst.DATA_STORE_ID, mxShapeDFDDataStoreID);

mxShapeDFDDataStoreID.prototype.constraints = null;

//**********************************************************************************************************************************************************
//External Entity
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeDFDExternalEntity(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeDFDExternalEntity, mxShape);

mxShapeDFDExternalEntity.prototype.cst = {EXTERNAL_ENTITY : 'mxgraph.dfd.externalEntity'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeDFDExternalEntity.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var size = 10;
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w - size, 0);
	c.lineTo(w, size);
	c.lineTo(w, h);
	c.lineTo(size, h);
	c.lineTo(0, h - size);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);


	c.setFillColor('#000000');
	c.setAlpha(0.5);
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w - size, 0);
	c.lineTo(w, size);
	c.lineTo(size, size);
	c.lineTo(size, h);
	c.lineTo(0, h - size);
	c.close();
	c.fill();

	var opacity = parseFloat(mxUtils.getValue(this.style, 'opacity', '100'));

	c.setAlpha(opacity / 100);
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w - size, 0);
	c.lineTo(w, size);
	c.lineTo(w, h);
	c.lineTo(size, h);
	c.lineTo(0, h - size);
	c.close();
	c.moveTo(size, h);
	c.lineTo(size, size);
	c.lineTo(w, size);
	c.moveTo(0, 0);
	c.lineTo(size, size);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeDFDExternalEntity.prototype.cst.EXTERNAL_ENTITY, mxShapeDFDExternalEntity);

mxShapeDFDExternalEntity.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var size = 10;
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - size) * 0.25, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - size) * 0.5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - size) * 0.75, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - size, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, size, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - size) * 0.25 + size, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - size) * 0.5 + size, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - size) * 0.75 + size, h));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, size));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, size + (h - size) * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, size + (h - size) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, size + (h - size) * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - size) * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - size) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - size) * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - size));

	return (constr);
}

//**********************************************************************************************************************************************************
//Loop
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeDFDLoop(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeDFDLoop, mxShape);

mxShapeDFDLoop.prototype.cst = {LOOP : 'mxgraph.dfd.loop'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeDFDLoop.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var r = Math.min(h * 0.8, w * 0.8);
	
	c.begin();
	c.moveTo(w - r * 0.25, 0);
	c.arcTo(r, r, 0, 0, 1, w - r * 0.25, h);
	c.lineTo(r * 0.25, h);
	c.arcTo(r, r, 0, 0, 1, r * 0.25, 0);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeDFDLoop.prototype.cst.LOOP, mxShapeDFDLoop);

mxShapeDFDLoop.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var r = Math.min(h * 0.8, w * 0.8);
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - r * 0.25, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - r * 0.25, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, r * 0.25, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, r * 0.25, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));

	return (constr);
}


/**
 * $Id: mxEip.js,v 1.0 2014/11/27 06:09:21 mate Exp $
 * Copyright (c) 2006-2015, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Message Expiration
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeEipMessageExpiration(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeEipMessageExpiration, mxShape);

mxShapeEipMessageExpiration.prototype.cst = {
		SHAPE_MESS_EXP : 'mxgraph.eip.messExp'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeEipMessageExpiration.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxShapeEipMessageExpiration.prototype.background = function(c, x, y, w, h)
{
	c.ellipse(0, 0, w, h);
	c.stroke();
	
	c.setStrokeColor("#808080");
	c.begin();
	c.moveTo(w * 0.5, h * 0.1);
	c.lineTo(w * 0.5, h * 0.5);
	c.lineTo(w * 0.6, h * 0.8);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeEipMessageExpiration.prototype.cst.SHAPE_MESS_EXP, mxShapeEipMessageExpiration);

mxShapeEipMessageExpiration.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.145, 0.145), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.855, 0.145), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.855, 0.855), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.145, 0.855), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Return Address
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeEipReturnAddress(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeEipReturnAddress, mxShape);

mxShapeEipReturnAddress.prototype.cst = {
		SHAPE_RET_ADDR : 'mxgraph.eip.retAddr'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeEipReturnAddress.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeEipReturnAddress.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeEipReturnAddress.prototype.foreground = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(w * 0.05, h * 0.11);
	c.lineTo(w * 0.25, h * 0.11);
	c.moveTo(w * 0.05, h * 0.18);
	c.lineTo(w * 0.25, h * 0.18);
	c.moveTo(w * 0.05, h * 0.25);
	c.lineTo(w * 0.25, h * 0.25);

	c.setStrokeWidth(2);
	c.moveTo(w * 0.3, h * 0.63);
	c.lineTo(w * 0.8, h * 0.63);
	c.moveTo(w * 0.3, h * 0.72);
	c.lineTo(w * 0.8, h * 0.72);
	c.moveTo(w * 0.3, h * 0.80);
	c.lineTo(w * 0.8, h * 0.80);
	c.stroke();

	c.setFillColor("#EDEDED");
	c.rect(w * 0.8, h * 0.1, w * 0.12, h * 0.19);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeEipReturnAddress.prototype.cst.SHAPE_RET_ADDR, mxShapeEipReturnAddress);

mxShapeEipReturnAddress.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Anchor
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeEipAnchor(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeEipAnchor, mxShape);

mxShapeEipAnchor.prototype.cst = {
		SHAPE_ANCHOR : 'mxgraph.eip.anchor'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeEipAnchor.prototype.paintVertexShape = function(c, x, y, w, h)
{
};

mxCellRenderer.registerShape(mxShapeEipAnchor.prototype.cst.SHAPE_ANCHOR, mxShapeEipAnchor);

//**********************************************************************************************************************************************************
//Message Channel
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeEipMessageChannel(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeEipMessageChannel, mxShape);

mxShapeEipMessageChannel.prototype.cst = {
		SHAPE_MESSAGE_CHANNEL : 'mxgraph.eip.messageChannel'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeEipMessageChannel.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeEipMessageChannel.prototype.background = function(c, x, y, w, h)
{
	c.setGradient('#e6e6e6', '#808080', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.begin();
	c.moveTo(8, h * 0.5 + 10);
	c.arcTo(12, 12, 0, 0, 1, 8, h * 0.5 - 10);
	c.lineTo(w - 8, h * 0.5 - 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 + 10);
	c.close();
	c.fillAndStroke();
};

mxShapeEipMessageChannel.prototype.foreground = function(c, x, y, w, h)
{
	c.setFillColor('#e6e6e6');
	c.begin();
	c.moveTo(w - 8, h * 0.5 - 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 + 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 - 10);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeEipMessageChannel.prototype.cst.SHAPE_MESSAGE_CHANNEL, mxShapeEipMessageChannel);


mxShapeEipMessageChannel.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, 2.7, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false, null, -2.7, 0));

	var currW = 10;
	
	while (currW < w)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, currW, 0));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, currW, 0));
		
		currW = currW + 10;
	}
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Datatype Channel
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeEipDatatypeChannel(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeEipDatatypeChannel, mxShape);

mxShapeEipDatatypeChannel.prototype.cst = {
		SHAPE_DATATYPE_CHANNEL : 'mxgraph.eip.dataChannel'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeEipDatatypeChannel.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeEipDatatypeChannel.prototype.background = function(c, x, y, w, h)
{
	c.setGradient('#e6e6e6', '#808080', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.begin();
	c.moveTo(8, h * 0.5 + 10);
	c.arcTo(12, 12, 0, 0, 1, 8, h * 0.5 - 10);
	c.lineTo(w - 8, h * 0.5 - 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 + 10);
	c.close();
	c.fillAndStroke();
};

mxShapeEipDatatypeChannel.prototype.foreground = function(c, x, y, w, h)
{
	c.setFillColor('#e6e6e6');
	c.begin();
	c.moveTo(w - 8, h * 0.5 - 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 + 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 - 10);
	c.fillAndStroke();
	
	c.setFillColor("#fffbc0");
	c.setStrokeWidth("1");
	
	for(var i = 1; i * 20 + 10 < w - 14; i++)
	{
		c.rect(i * 20, h * 0.5 - 5, 10, 10);
		c.fillAndStroke();
	};
};

mxCellRenderer.registerShape(mxShapeEipDatatypeChannel.prototype.cst.SHAPE_DATATYPE_CHANNEL, mxShapeEipDatatypeChannel);

mxShapeEipDatatypeChannel.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, 2.7, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false, null, -2.7, 0));

	var currW = 10;
	
	while (currW < w)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, currW, 0));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, currW, 0));
		
		currW = currW + 10;
	}
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Dead Letter Channel
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeEipDeadLetterChannel(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeEipDeadLetterChannel, mxShape);

mxShapeEipDeadLetterChannel.prototype.cst = {
		SHAPE_DEAD_LETTER_CHANNEL : 'mxgraph.eip.deadLetterChannel'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeEipDeadLetterChannel.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeEipDeadLetterChannel.prototype.background = function(c, x, y, w, h)
{
	c.setGradient('#e6e6e6', '#808080', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.begin();
	c.moveTo(8, h * 0.5 + 10);
	c.arcTo(12, 12, 0, 0, 1, 8, h * 0.5 - 10);
	c.lineTo(w - 8, h * 0.5 - 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 + 10);
	c.close();
	c.fillAndStroke();
};

mxShapeEipDeadLetterChannel.prototype.foreground = function(c, x, y, w, h)
{
	c.setFillColor('#e6e6e6');
	c.begin();
	c.moveTo(w - 8, h * 0.5 - 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 + 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 - 10);
	c.fillAndStroke();
	
	c.setFillColor("#ff0000");
	c.setStrokeWidth("1");
	c.begin();
	c.moveTo(w * 0.5 - 6, h * 0.5 - 3);
	c.lineTo(w * 0.5 - 3, h * 0.5 - 6);
	c.lineTo(w * 0.5 + 3, h * 0.5 - 6);
	c.lineTo(w * 0.5 + 6, h * 0.5 - 3);
	c.lineTo(w * 0.5 + 6, h * 0.5 + 3);
	c.lineTo(w * 0.5 + 3, h * 0.5 + 6);
	c.lineTo(w * 0.5 - 3, h * 0.5 + 6);
	c.lineTo(w * 0.5 - 6, h * 0.5 + 3);
	c.close();
	c.fillAndStroke();
	
	c.setStrokeWidth("2");
	c.setStrokeColor("#ffffff");
	c.begin();
	c.moveTo(w * 0.5 - 4, h * 0.5);
	c.lineTo(w * 0.5 + 4, h * 0.5);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeEipDeadLetterChannel.prototype.cst.SHAPE_DEAD_LETTER_CHANNEL, mxShapeEipDeadLetterChannel);

mxShapeEipDeadLetterChannel.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, 2.7, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false, null, -2.7, 0));

	var currW = 10;
	
	while (currW < w)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, currW, 0));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, currW, 0));
		
		currW = currW + 10;
	}
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Invalid Message Channel
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeEipInvalidMessageChannel(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeEipInvalidMessageChannel, mxShape);

mxShapeEipInvalidMessageChannel.prototype.cst = {
		SHAPE_INVALID_MESSAGE_CHANNEL : 'mxgraph.eip.invalidMessageChannel'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeEipInvalidMessageChannel.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeEipInvalidMessageChannel.prototype.background = function(c, x, y, w, h)
{
	c.setGradient('#e6e6e6', '#808080', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.begin();
	c.moveTo(8, h * 0.5 + 10);
	c.arcTo(12, 12, 0, 0, 1, 8, h * 0.5 - 10);
	c.lineTo(w - 8, h * 0.5 - 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 + 10);
	c.close();
	c.fillAndStroke();
};

mxShapeEipInvalidMessageChannel.prototype.foreground = function(c, x, y, w, h)
{
	c.setFillColor('#e6e6e6');
	c.begin();
	c.moveTo(w - 8, h * 0.5 - 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 + 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 - 10);
	c.fillAndStroke();
	
	c.setFillColor("#ffe040");
	c.setStrokeWidth("1");
	c.begin();
	c.moveTo(w * 0.5 - 6, h * 0.5 + 5);
	c.lineTo(w * 0.5, h * 0.5 - 5);
	c.lineTo(w * 0.5 + 6, h * 0.5 + 5);
	c.close();
	c.fillAndStroke();
	
	c.setStrokeWidth("1");
	c.begin();
	c.moveTo(w * 0.5, h * 0.5 - 2);
	c.lineTo(w * 0.5, h * 0.5 + 2);
	c.moveTo(w * 0.5, h * 0.5 + 3);
	c.lineTo(w * 0.5, h * 0.5 + 4);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeEipInvalidMessageChannel.prototype.cst.SHAPE_INVALID_MESSAGE_CHANNEL, mxShapeEipInvalidMessageChannel);

mxShapeEipInvalidMessageChannel.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, 2.7, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false, null, -2.7, 0));

	var currW = 10;
	
	while (currW < w)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, currW, 0));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, currW, 0));
		
		currW = currW + 10;
	}
	
	return (constr);
};

/**
 * $Id: mxElectrical.js,v 1.0 2016/10/25 17:05:39 mate Exp $
 * Copyright (c) 2006-2016, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Test Point
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeElectricalTestPoint(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeElectricalTestPoint, mxShape);

mxShapeElectricalTestPoint.prototype.cst = {
		SHAPE_TEST_POINT : 'mxgraph.electrical.transmission.testPoint'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeElectricalTestPoint.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');

	var size = Math.min(w, h); 
	
	c.setFillColor(strokeColor);
	c.begin();
	c.ellipse(w * 0.5 - size / 2, 0, size, size);
	c.fillAndStroke();
	
	if (h > w)
	{
		c.begin();
		c.moveTo(w * 0.5, size);
		c.lineTo(w * 0.5, h);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapeElectricalTestPoint.prototype.cst.SHAPE_TEST_POINT, mxShapeElectricalTestPoint);

mxShapeElectricalTestPoint.prototype.constraints = [
                                                  new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                                  new mxConnectionConstraint(new mxPoint(0.5, 1), true)
                                                  ];

//**********************************************************************************************************************************************************
//Straight Bus
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeElectricalStraightBus(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeElectricalStraightBus, mxShape);

mxShapeElectricalStraightBus.prototype.cst = {
		SHAPE_STRAIGHT_BUS : 'mxgraph.electrical.transmission.straightBus'
};



/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeElectricalStraightBus.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var size = Math.min(w, h); 
	var x1 = w * 0.2;
	var y1 = 0;
	
	if (w > h)
	{
		y1 = h * 0.5;
	}
	else
	{
		y1 = w / 2;
	}
	
	c.begin();
	c.moveTo(w - x1, 0);
	c.lineTo(w - x1, h - y1);
	c.lineTo(w, h - y1);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h - y1);
	c.lineTo(x1, h - y1);
	c.lineTo(x1, 0);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeElectricalStraightBus.prototype.cst.SHAPE_STRAIGHT_BUS, mxShapeElectricalStraightBus);

mxShapeElectricalStraightBus.prototype.constraints = [
                                                    new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                                    new mxConnectionConstraint(new mxPoint(0.5, 1), true)
                                                    ];

//**********************************************************************************************************************************************************
//Two-Line Bus Elbow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeElectricalTwoLineBusElbow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.notch = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeElectricalTwoLineBusElbow, mxShape);

mxShapeElectricalTwoLineBusElbow.prototype.cst = {
		SHAPE_TWO_LINE_BUS_ELBOW : 'mxgraph.electrical.transmission.twoLineBusElbow'
};

mxShapeElectricalTwoLineBusElbow.prototype.customProperties = [
	{name:'notch', dispName:'Spacing', type:'float', min:0, defVal:25}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeElectricalTwoLineBusElbow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));

	c.translate(x, y);

	c.begin();
	c.moveTo(0, h);
	c.lineTo(w, h);
	c.lineTo(w, 0);
	c.stroke();
	
	var wn = Math.min(w, notch);
	var hn = Math.min(h, notch);
	
	c.begin();
	c.moveTo(0, h - hn);
	c.lineTo(w - wn, h - hn);
	c.lineTo(w - wn, 0);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeElectricalTwoLineBusElbow.prototype.cst.SHAPE_TWO_LINE_BUS_ELBOW, mxShapeElectricalTwoLineBusElbow);

mxShapeElectricalTwoLineBusElbow.prototype.constraints = null;

Graph.handleFactory[mxShapeElectricalTwoLineBusElbow.prototype.cst.SHAPE_TWO_LINE_BUS_ELBOW] = function(state)
{
	var handles = [Graph.createHandle(state, ['notch'], function(bounds)
	{
		var notch = Math.max(Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))), 0);

		return new mxPoint(bounds.x + bounds.width / 4, bounds.y + bounds.height - notch);
	}, function(bounds, pt)
	{
		this.state.style['notch'] = Math.round(0.2 * Math.max(0, bounds.width - pt.y + bounds.y)) / 0.2;
	})];
			
	return handles;

}

//**********************************************************************************************************************************************************
//Three-Line Bus Elbow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeElectricalThreeLineBusElbow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.notch = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeElectricalThreeLineBusElbow, mxShape);

mxShapeElectricalThreeLineBusElbow.prototype.cst = {
		SHAPE_THREE_LINE_BUS_ELBOW : 'mxgraph.electrical.transmission.threeLineBusElbow'
};

mxShapeElectricalThreeLineBusElbow.prototype.customProperties = [
	{name:'notch', dispName:'Spacing', type:'float', min:0, defVal:30}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeElectricalThreeLineBusElbow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));

	c.translate(x, y);

	c.begin();
	c.moveTo(0, h);
	c.lineTo(w, h);
	c.lineTo(w, 0);
	c.stroke();
	
	var wn = Math.min(w, notch);
	var hn = Math.min(h, notch);
	
	c.begin();
	c.moveTo(0, h - hn);
	c.lineTo(w - wn, h - hn);
	c.lineTo(w - wn, 0);
	c.stroke();
	
	c.begin();
	c.moveTo(0, h - hn / 2);
	c.lineTo(w - wn / 2, h - hn / 2);
	c.lineTo(w - wn / 2, 0);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeElectricalThreeLineBusElbow.prototype.cst.SHAPE_THREE_LINE_BUS_ELBOW, mxShapeElectricalThreeLineBusElbow);

mxShapeElectricalThreeLineBusElbow.prototype.constraints = null;

Graph.handleFactory[mxShapeElectricalThreeLineBusElbow.prototype.cst.SHAPE_THREE_LINE_BUS_ELBOW] = function(state)
{
	var handles = [Graph.createHandle(state, ['notch'], function(bounds)
	{
		var notch = Math.max(Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))), 0);

		return new mxPoint(bounds.x + bounds.width / 4, bounds.y + bounds.height - notch);
	}, function(bounds, pt)
	{
		this.state.style['notch'] = Math.round(0.2 * Math.max(0, bounds.width - pt.y + bounds.y)) / 0.2;
	})];
			
	return handles;

}

//**********************************************************************************************************************************************************
//Four-Line Bus Elbow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeElectricalFourLineBusElbow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.notch = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeElectricalFourLineBusElbow, mxShape);

mxShapeElectricalFourLineBusElbow.prototype.cst = {
		SHAPE_FOUR_LINE_BUS_ELBOW : 'mxgraph.electrical.transmission.fourLineBusElbow'
};

mxShapeElectricalFourLineBusElbow.prototype.customProperties = [
	{name:'notch', dispName:'Spacing', type:'float', min:0, defVal:75}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeElectricalFourLineBusElbow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));

	c.translate(x, y);

	c.begin();
	c.moveTo(0, h);
	c.lineTo(w, h);
	c.lineTo(w, 0);
	c.stroke();
	
	var wn = Math.min(w, notch);
	var hn = Math.min(h, notch);
	
	c.begin();
	c.moveTo(0, h - hn);
	c.lineTo(w - wn, h - hn);
	c.lineTo(w - wn, 0);
	c.stroke();
	
	c.begin();
	c.moveTo(0, h - hn / 3);
	c.lineTo(w - wn / 3, h - hn / 3);
	c.lineTo(w - wn / 3, 0);
	c.stroke();
	
	c.begin();
	c.moveTo(0, h - hn * 2 / 3);
	c.lineTo(w - wn * 2 / 3, h - hn * 2 / 3);
	c.lineTo(w - wn * 2 / 3, 0);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeElectricalFourLineBusElbow.prototype.cst.SHAPE_FOUR_LINE_BUS_ELBOW, mxShapeElectricalFourLineBusElbow);

mxShapeElectricalFourLineBusElbow.prototype.constraints = null;

Graph.handleFactory[mxShapeElectricalFourLineBusElbow.prototype.cst.SHAPE_FOUR_LINE_BUS_ELBOW] = function(state)
{
	var handles = [Graph.createHandle(state, ['notch'], function(bounds)
	{
		var notch = Math.max(Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))), 0);

		return new mxPoint(bounds.x + bounds.width / 4, bounds.y + bounds.height - notch);
	}, function(bounds, pt)
	{
		this.state.style['notch'] = Math.round(0.2 * Math.max(0, bounds.width - pt.y + bounds.y)) / 0.2;
	})];
			
	return handles;
}

//**********************************************************************************************************************************************************
//Four-Line Bus Elbow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeElectricalEightLineBusElbow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.notch = 0;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeElectricalEightLineBusElbow, mxShape);

mxShapeElectricalEightLineBusElbow.prototype.cst = {
		SHAPE_EIGHT_LINE_BUS_ELBOW : 'mxgraph.electrical.transmission.eightLineBusElbow'
};

mxShapeElectricalEightLineBusElbow.prototype.customProperties = [
	{name:'notch', dispName:'Spacing', type:'float', min:0, defVal:180}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeElectricalEightLineBusElbow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));

	c.translate(x, y);

	c.begin();
	c.moveTo(0, h);
	c.lineTo(w, h);
	c.lineTo(w, 0);
	c.stroke();
	
	var wn = Math.min(w, notch);
	var hn = Math.min(h, notch);
	
	c.begin();
	c.moveTo(0, h - hn);
	c.lineTo(w - wn, h - hn);
	c.lineTo(w - wn, 0);
	c.stroke();
	
	c.begin();
	c.moveTo(0, h - hn / 7);
	c.lineTo(w - wn / 7, h - hn / 7);
	c.lineTo(w - wn / 7, 0);
	c.stroke();
	
	c.begin();
	c.moveTo(0, h - hn * 2 / 7);
	c.lineTo(w - wn * 2 / 7, h - hn * 2 / 7);
	c.lineTo(w - wn * 2 / 7, 0);
	c.stroke();
	
	c.begin();
	c.moveTo(0, h - hn * 3 / 7);
	c.lineTo(w - wn * 3 / 7, h - hn * 3 / 7);
	c.lineTo(w - wn * 3 / 7, 0);
	c.stroke();
	
	c.begin();
	c.moveTo(0, h - hn * 4 / 7);
	c.lineTo(w - wn * 4 / 7, h - hn * 4 / 7);
	c.lineTo(w - wn * 4 / 7, 0);
	c.stroke();
	
	c.begin();
	c.moveTo(0, h - hn * 5 / 7);
	c.lineTo(w - wn * 5 / 7, h - hn * 5 / 7);
	c.lineTo(w - wn * 5 / 7, 0);
	c.stroke();
	
	c.begin();
	c.moveTo(0, h - hn * 6 / 7);
	c.lineTo(w - wn * 6 / 7, h - hn * 6 / 7);
	c.lineTo(w - wn * 6 / 7, 0);
	c.stroke();
	
};

mxCellRenderer.registerShape(mxShapeElectricalEightLineBusElbow.prototype.cst.SHAPE_EIGHT_LINE_BUS_ELBOW, mxShapeElectricalEightLineBusElbow);

mxShapeElectricalEightLineBusElbow.prototype.constraints = null;

Graph.handleFactory[mxShapeElectricalEightLineBusElbow.prototype.cst.SHAPE_EIGHT_LINE_BUS_ELBOW] = function(state)
{
	var handles = [Graph.createHandle(state, ['notch'], function(bounds)
	{
		var notch = Math.max(Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))), 0);

		return new mxPoint(bounds.x + bounds.width / 4, bounds.y + bounds.height - notch);
	}, function(bounds, pt)
	{
		this.state.style['notch'] = Math.round(0.2 * Math.max(0, bounds.width - pt.y + bounds.y)) / 0.2;
	})];
			
	return handles;
}

//**********************************************************************************************************************************************************
//Logic Gate
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeElectricalLogicGate(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeElectricalLogicGate, mxShape);

mxShapeElectricalLogicGate.prototype.cst = {
		SHAPE_LOGIC_GATE : 'mxgraph.electrical.logic_gates.logic_gate'
};

mxShapeElectricalLogicGate.prototype.customProperties = [
	{name: 'operation', dispName: 'Operation', type: 'enum', defVal:'and',
		enumList:[
			{val:'and', dispName:'And'},
			{val:'or', dispName:'Or'},
			{val:'xor', dispName:'Xor'}
		]},
	{name: 'numInputs', dispName: 'Inputs', type: 'int', min:2, defVal:2},
	{name: 'negating', dispName: 'Negating', type: 'bool', defVal:0}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeElectricalLogicGate.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var numInputs = parseInt(mxUtils.getValue(this.style, 'numInputs', '2'));
	var spacing = h / numInputs;
	var currH = spacing * 0.5;

	c.begin();
	c.moveTo(w * 0.8, h * 0.5);
	c.lineTo(w, h * 0.5);

	var operation = mxUtils.getValue(this.style, 'operation', 'and');

	for (var i = 0; i < numInputs; i++)
	{
		c.moveTo(0, currH);
		
		if (operation == 'and')
		{
			c.lineTo(w * 0.2, currH);
		}
		else
		{
			c.lineTo(w * 0.23, currH);
		}
		
		currH = currH + spacing;
	}

	c.stroke();


	switch(operation) {
	  case 'xor':
			c.begin();
			c.moveTo(w * 0.1, 0);
			c.arcTo(w * 0.6, h, 0, 0, 1, w * 0.1, h);
			c.stroke();
	  case 'or':
			c.begin();
			c.moveTo(w * 0.4, 0);
			c.arcTo(w * 0.45, h * 0.83, 0, 0, 1, w * 0.8, h * 0.5);
			c.arcTo(w * 0.45, h * 0.83, 0, 0, 1, w * 0.4, h);
			c.lineTo(w * 0.15, h);
			c.arcTo(w * 0.6, h, 0, 0, 0, w * 0.15, 0);
			c.close();
			c.fillAndStroke();
	    break;
	  default:
			c.begin();
			c.moveTo(w * 0.2, 0);
			c.lineTo(w * 0.5, 0);
			c.arcTo(w * 0.3, h * 0.5, 0, 0, 1, w * 0.5, h);
			c.lineTo(w * 0.2, h);
			c.close();
			c.fillAndStroke();
	};
	
	
	var negating = mxUtils.getValue(this.style, 'negating', '0');

	if (negating == '1')
	{
		var negSize = Math.min(w * 0.04, h * 0.07);
		c.begin();
		c.ellipse(w * 0.8, h * 0.5 - negSize * 0.5, negSize, negSize);
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeElectricalLogicGate.prototype.cst.SHAPE_LOGIC_GATE, mxShapeElectricalLogicGate);

mxShapeElectricalLogicGate.prototype.getConstraints = function(style)
{
	var constr = [new mxConnectionConstraint(new mxPoint(1, 0.5), false)];
	
	var numInputs = parseInt(mxUtils.getValue(style, 'numInputs', '2'));
	var spacing = 1 / numInputs;
	var currH = spacing * 0.5;

	for (var i = 0; i < numInputs; i++)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, currH), false));
		currH = currH + spacing;
	}

	return (constr);
}

//**********************************************************************************************************************************************************
//Buffer
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeElectricalBuffer(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeElectricalBuffer, mxShape);

mxShapeElectricalBuffer.prototype.cst = {
		SHAPE_BUFFER2 : 'mxgraph.electrical.logic_gates.buffer2'
};

mxShapeElectricalBuffer.prototype.customProperties = [
	{name: 'negating', dispName: 'Negating', type: 'bool', defVal:0}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeElectricalBuffer.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w * 0.2, h * 0.5);
	c.moveTo(w * 0.8, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.stroke();
	
	c.begin();
	c.moveTo(w * 0.2, 0);
	c.lineTo(w * 0.8, h * 0.5);
	c.lineTo(w * 0.2, h);
	c.close();
	c.fillAndStroke();
	
	var negating = mxUtils.getValue(this.style, 'negating', '0');

	if (negating == '1')
	{
		var negSize = Math.min(w * 0.04, h * 0.07);
		c.begin();
		c.ellipse(w * 0.8, h * 0.5 - negSize * 0.5, negSize, negSize);
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeElectricalBuffer.prototype.cst.SHAPE_BUFFER2, mxShapeElectricalBuffer);

mxShapeElectricalBuffer.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0, 0.5), true),
    new mxConnectionConstraint(new mxPoint(1, 0.5), true)
    ];

//**********************************************************************************************************************************************************
//Dual In-Line IC
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeElectricalDualInLineIC(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeElectricalDualInLineIC, mxShape);

mxShapeElectricalDualInLineIC.prototype.cst = {
		SHAPE_DUAL_INLINE_IC : 'mxgraph.electrical.logic_gates.dual_inline_ic'
};

mxShapeElectricalDualInLineIC.prototype.customProperties = [
	{name: 'pinStyle', dispName: 'Pin Style', type: 'enum', defVal:'line',
		enumList:[
			{val:'line', dispName:'Line'},
			{val:'square', dispName:'Square'}
		]},
	{name: 'startPin', dispName: 'Starting Pin', type: 'enum', defVal:'n',
		enumList:[
			{val:'n', dispName:'N'},
			{val:'e', dispName:'E'},
			{val:'s', dispName:'S'},
			{val:'w', dispName:'W'}
		]},
	{name: 'pinSpacing', dispName: 'Pin Spacing', type: 'float', min:1, defVal:20},
	{name: 'pinLabelType', dispName: 'Pin Label Type', type: 'enum', defVal:'gen',
		enumList:[
			{val:'gen', dispName:'Generated'},
			{val:'cust', dispName:'Custom'}
		]},
	{name: 'labelCount', dispName: 'Number of Labels', type: 'int', defVal: 20, dependentProps: ['labelNames']},
	{name: 'labelNames', dispName: 'Label Names', type: 'staticArr', subType: 'string', sizeProperty: 'labelCount', subDefVal: 'a'}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeElectricalDualInLineIC.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var fontColor = mxUtils.getValue(this.style, 'fontColor', '#000000');
	c.setFontColor(fontColor);
	var startPin = mxUtils.getValue(this.style, 'startPin', 'n');
	var pinLabelType = mxUtils.getValue(this.style, 'pinLabelType', 'gen');
	var labelNames = mxUtils.getValue(this.style, 'labelNames', '').toString().split(',');

	c.begin();
	
	if (startPin == 'n' || startPin == 's')
	{
		c.rect(10, 0, w - 20, h);
	}
	else
	{
		c.rect(0, 10, w, h - 20);
	}

	c.fillAndStroke();

	var pinSpacing = parseFloat(mxUtils.getValue(this.style, 'pinSpacing', '20'));
	var pinStyle = mxUtils.getValue(this.style, 'pinStyle', 'line');
	var fontSize = parseFloat(mxUtils.getValue(this.style, 'fontSize', '12'));
	
	if (startPin == 'n' || startPin == 's')
	{
		var pinsOne = parseInt(h / pinSpacing);
	}
	else
	{
		var pinsOne = parseInt(w / pinSpacing);
	}
	
	if (pinStyle == 'line')
	{
		c.setFontSize(fontSize * 0.8);
		var pinCount = 1;
		var currH = pinSpacing * 0.5;
		
		c.begin();
		
		if (startPin == 'n' || startPin == 's')
		{
			while (pinCount * pinSpacing <= h)
			{
				c.moveTo(0, currH);
				c.lineTo(10, currH);
				c.moveTo(w - 10, currH);
				c.lineTo(w, currH);
		
				if (startPin == 'n')
				{
					var currPinNum = pinCount;
				}
				else
				{
					var currPinNum = pinsOne + pinCount;
				}

				if (pinLabelType == 'gen')
				{
					c.text(20, currH, 0, 0, currPinNum.toString(), mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}
				else if (currPinNum - 1 < labelNames.length)
				{
					c.text(20, currH, 0, 0, labelNames[currPinNum - 1].toString(), mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}
				
				if (startPin == 'n')
				{
					var pc2 = 2 * pinsOne - pinCount + 1;
				}
				else
				{
					var pc2 = pinsOne - pinCount + 1;
				}
				
				if (pinLabelType == 'gen')
				{
					c.text(w - 20, currH, 0, 0, pc2.toString(), mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}
				else if (pc2 - 1 < labelNames.length)
				{
					c.text(w - 20, currH, 0, 0, labelNames[pc2 - 1].toString(), mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}
				
				currH = currH + pinSpacing;
				pinCount++;
			}
		}
		else
		{
			while (pinCount * pinSpacing <= w)
			{
				c.moveTo(currH, 0);
				c.lineTo(currH, 10);
				c.moveTo(currH, h - 10);
				c.lineTo(currH, h);
		
				if (startPin == 'e')
				{
					var currPinNum = pinsOne - pinCount + 1;
				}
				else
				{
					var currPinNum = 2 * pinsOne - pinCount + 1;
				}
				
				if (pinLabelType == 'gen')
				{
					c.text(currH, 20, 0, 0, currPinNum.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}
				else if (currPinNum - 1 < labelNames.length)
				{
					c.text(currH, 20, 0, 0, labelNames[currPinNum - 1].toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}
				
				if (startPin == 'e')
				{
					var pc2 = pinsOne + pinCount;
				}
				else
				{
					var pc2 = pinCount;
				}
				
				if (pinLabelType == 'gen')
				{
					c.text(currH, h - 20, 0, 0, pc2.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}
				else if (pc2 - 1 < labelNames.length)
				{
					c.text(currH, h - 20, 0, 0, labelNames[pc2 - 1].toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}
				
				currH = currH + pinSpacing;
				pinCount++;
			}
		}
		
		c.stroke();
	}
	else
	{
		c.setFontSize(fontSize * 0.5);
		var pinCount = 1;
		var currH = pinSpacing * 0.5;

		if (startPin == 'n' || startPin == 's')
		{
			while (pinCount * pinSpacing <= h)
			{
				c.begin();
				c.rect(0, currH - pinSpacing * 0.25, 10, pinSpacing * 0.5);
				c.fillAndStroke();

				c.begin();
				c.rect(w - 10, currH - pinSpacing * 0.25, 10, pinSpacing * 0.5);
				c.fillAndStroke();
				
				if (startPin == 'n')
				{
					var currPinNum = pinCount;
				}
				else
				{
					var currPinNum = pinsOne + pinCount;
				}

				if (pinLabelType == 'gen')
				{
					c.text(5, currH + 1, 0, 0, currPinNum.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}
				else if (currPinNum - 1 < labelNames.length)
				{
					c.text(5, currH + 1, 0, 0, labelNames[currPinNum - 1].toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}
				
				if (startPin == 'n')
				{
					var pc2 = 2 * pinsOne - pinCount + 1;
				}
				else
				{
					var pc2 = pinsOne - pinCount + 1;
				}
				
				if (pinLabelType == 'gen')
				{
					c.text(w - 5, currH + 1, 0, 0, pc2.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}
				else if (pc2 - 1 < labelNames.length)
				{
					c.text(w - 5, currH + 1, 0, 0, labelNames[pc2 - 1].toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}

				currH = currH + pinSpacing;
				pinCount++;
			}
		}
		else
		{
			while (pinCount * pinSpacing <= w)
			{
				c.begin();
				c.rect(currH - pinSpacing * 0.25, 0, pinSpacing * 0.5, 10);
				c.fillAndStroke();

				c.begin();
				c.rect(currH - pinSpacing * 0.25, h - 10, pinSpacing * 0.5, 10);
				c.fillAndStroke();
				
				if (startPin == 'e')
				{
					var currPinNum = pinsOne - pinCount + 1;
				}
				else
				{
					var currPinNum = 2 * pinsOne - pinCount + 1;
				}

				if (pinLabelType == 'gen')
				{
					c.text(currH, 5, 0, 0, currPinNum.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}
				else if (currPinNum - 1 < labelNames.length)
				{
					c.text(currH, 5, 0, 0, labelNames[currPinNum - 1].toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}
				
				if (startPin == 'e')
				{
					var pc2 = pinsOne + pinCount;
				}
				else
				{
					var pc2 = pinCount;
				}
				
				if (pinLabelType == 'gen')
				{
					c.text(currH, h - 5, 0, 0, pc2.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}
				else if (pc2 - 1 < labelNames.length)
				{
					c.text(currH, h - 5, 0, 0, labelNames[pc2 - 1].toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
				}

				currH = currH + pinSpacing;
				pinCount++;
			}
		}
		
	}
	
	c.setShadow(false);
	
	c.begin();
	
	switch(startPin) {
	  case 'e':
			if (h > 40)
			{
				c.moveTo(w, h * 0.5 - 10);
				c.arcTo(12, 12, 0, 0, 0, w, h * 0.5 + 10);
			}
	    break;
	  case 's':
			if (w > 40)
			{
				c.moveTo(w * 0.5 - 10, h);
				c.arcTo(12, 12, 0, 0, 1, w * 0.5 + 10, h);
			}
	    break;
	  case 'w':
			if (h > 40)
			{
				c.moveTo(0, h * 0.5 - 10);
				c.arcTo(12, 12, 0, 0, 1, 0, h * 0.5 + 10);
			}
	    break;
	  default:
			if (w > 40)
			{
				c.moveTo(w * 0.5 - 10, 0);
				c.arcTo(12, 12, 0, 0, 0, w * 0.5 + 10, 0);
			}
	}
	
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeElectricalDualInLineIC.prototype.cst.SHAPE_DUAL_INLINE_IC, mxShapeElectricalDualInLineIC);

mxShapeElectricalDualInLineIC.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	var pinSpacing = parseFloat(mxUtils.getValue(this.style, 'pinSpacing', '20'));
	var startPin = mxUtils.getValue(this.style, 'startPin', 'n');
	var pinCount = 1;
	var currH = pinSpacing * 0.5;
	var pinsOne = parseInt(h / pinSpacing);
	
	if (startPin == 'n' || startPin == 's')
	{
		while (pinCount * pinSpacing <= h)
		{
			constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, currH));
			constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, 0, currH));
			currH = currH + pinSpacing;
			pinCount++;
		}
	}
	else
	{
		while (pinCount * pinSpacing <= w)
		{
			constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, currH, 0));
			constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, currH, 0));
			currH = currH + pinSpacing;
			pinCount++;
		}
	}
	
	return (constr);
}

//**********************************************************************************************************************************************************
//Quad Flat Package IC
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeElectricalQFPIC(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeElectricalQFPIC, mxShape);

mxShapeElectricalQFPIC.prototype.cst = {
		SHAPE_QFP_IC : 'mxgraph.electrical.logic_gates.qfp_ic'
};

mxShapeElectricalQFPIC.prototype.customProperties = [
	{name: 'pinStyle', dispName: 'Pin Style', type: 'enum', defVal:'line',
		enumList:[
			{val:'line', dispName:'Line'},
			{val:'square', dispName:'Square'}
		]},
	{name: 'startPin', dispName: 'Starting Pin', type: 'enum', defVal:'sw',
		enumList:[
			{val:'sw', dispName:'SW'},
			{val:'nw', dispName:'NW'},
			{val:'ne', dispName:'NE'},
			{val:'se', dispName:'SE'}
		]},
	{name: 'pinSpacing', dispName: 'Pin Spacing', type: 'float', min:1, defVal:20},
	{name: 'pinLabelType', dispName: 'Pin Label Type', type: 'enum', defVal:'gen',
		enumList:[
			{val:'gen', dispName:'Generated'},
			{val:'cust', dispName:'Custom'}
		]},
	{name: 'labelCount', dispName: 'Number of Labels', type: 'int', defVal: 40, dependentProps: ['labelNames']},
	{name: 'labelNames', dispName: 'Label Names', type: 'staticArr', subType: 'string', sizeProperty: 'labelCount', subDefVal: 'a'}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeElectricalQFPIC.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.begin();
	c.moveTo(15, 10);
	c.lineTo(w - 15, 10);
	c.lineTo(w - 10, 15);
	c.lineTo(w - 10, h - 15);
	c.lineTo(w - 15, h - 10);
	c.lineTo(15, h - 10);
	c.lineTo(10, h - 15);
	c.lineTo(10, 15);
	c.close();
	c.fillAndStroke();

	var pinSpacing = parseFloat(mxUtils.getValue(this.style, 'pinSpacing', '20'));
	var pinStyle = mxUtils.getValue(this.style, 'pinStyle', 'line');
	var pinLabelType = mxUtils.getValue(this.style, 'pinLabelType', 'gen');
	var labelNames = mxUtils.getValue(this.style, 'labelNames', '').toString().split(',');
	var fontSize = parseFloat(mxUtils.getValue(this.style, 'fontSize', '12'));
	var fontColor = mxUtils.getValue(this.style, 'fontColor', '#000000');
	c.setFontColor(fontColor);
	var startPin = mxUtils.getValue(this.style, 'startPin', 'sw');
	
	if (pinStyle == 'line')
	{
		c.setFontSize(fontSize * 0.8);
		var pinCount = 1;
		var currH = pinSpacing * 0.5 + 20;
		
		c.begin();
		
		var pinsVOne = parseInt((h - pinSpacing - 40) / pinSpacing) + 1;
		var pinsHOne = parseInt((w - pinSpacing - 40) / pinSpacing) + 1;
		
		while (currH <= h - pinSpacing * 0.5 - 20)
		{
			c.moveTo(0, currH);
			c.lineTo(10, currH);
			c.moveTo(w - 10, currH);
			c.lineTo(w, currH);
			
			//west pins
			switch(startPin) {
			  case 'nw':
					var currPinNum = pinCount;
			    break;
			  case 'ne':
					var currPinNum = pinsHOne + pinCount;
			    break;
			  case 'se':
					var currPinNum = pinsVOne + pinsHOne + pinCount;
			    break;
			  default:
					var currPinNum = pinsVOne + 2 * pinsHOne + pinCount;
			}

			if (pinLabelType == 'gen')
			{
				c.text(20, currH, 0, 0, currPinNum.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}
			else if (currPinNum - 1 < labelNames.length)
			{
				c.text(20, currH, 0, 0, labelNames[currPinNum - 1].toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}
			
			//east pins
			switch(startPin) {
			  case 'nw':
					var pc2 = pinsHOne + 2 * pinsVOne - pinCount + 1;
			    break;
			  case 'ne':
					var pc2 = 2 * pinsHOne + 2 * pinsVOne - pinCount + 1;
			    break;
			  case 'se':
					var pc2 = pinsVOne - pinCount + 1;
			    break;
			  default:
					var pc2 = pinsHOne + pinsVOne - pinCount + 1;
			}

			if (pinLabelType == 'gen')
			{
				c.text(w - 20, currH, 0, 0, pc2.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}
			else if (pc2 - 1 < labelNames.length)
			{
				c.text(w - 20, currH, 0, 0, labelNames[pc2 - 1].toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}
			
			currH = currH + pinSpacing;
			pinCount++;
		}
		
		var pinCount = 1;
		var currH = pinSpacing * 0.5 + 20;
		
		while (currH <= w - pinSpacing * 0.5 - 20)
		{
			c.moveTo(currH, 0);
			c.lineTo(currH, 10);
			c.moveTo(currH, h - 10);
			c.lineTo(currH, h);
			
			//south pins
			switch(startPin) {
			  case 'nw':
					var currPinNum = pinsVOne + pinCount;
			    break;
			  case 'ne':
					var currPinNum = pinsVOne + pinsHOne + pinCount;
			    break;
			  case 'se':
					var currPinNum = 2 * pinsVOne + pinsHOne + pinCount;
			    break;
			  default:
					var currPinNum = pinCount;
			}
			
			if (pinLabelType == 'gen')
			{
				c.text(currH, h - 20, 0, 0, currPinNum.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}
			else if (currPinNum - 1 < labelNames.length)
			{
				c.text(currH, h - 20, 0, 0, labelNames[currPinNum - 1].toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}

			//north pins
			switch(startPin) {
			  case 'nw':
					var pc2 = 2 * pinsHOne + 2 * pinsVOne - pinCount + 1;
			    break;
			  case 'ne':
					var pc2 = pinsHOne - pinCount + 1;
			    break;
			  case 'se':
					var pc2 = pinsHOne + pinsVOne - pinCount + 1;
			    break;
			  default:
					var pc2 = 2 * pinsHOne + pinsVOne - pinCount + 1;
			}
			
			if (pinLabelType == 'gen')
			{
				c.text(currH, 20, 0, 0, pc2.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}
			else if (pc2 - 1 < labelNames.length)
			{
				c.text(currH, 20, 0, 0, labelNames[pc2 - 1].toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}
			
			currH = currH + pinSpacing;
			pinCount++;
		}
		
		c.stroke();
	}
	else
	{
		c.setFontSize(fontSize * 0.5);
		var pinCount = 1;
		var currH = pinSpacing * 0.5 + 20;
		var pinsVOne = parseInt((h - pinSpacing - 40) / pinSpacing) + 1;
		var pinsHOne = parseInt((w - pinSpacing - 40) / pinSpacing) + 1;
		
		while (currH <= h - pinSpacing * 0.5 - 20)
		{
			c.begin();
			c.rect(0, currH - pinSpacing * 0.25, 10, pinSpacing * 0.5);
			c.fillAndStroke();

			c.begin();
			c.rect(w - 10, currH - pinSpacing * 0.25, 10, pinSpacing * 0.5);
			c.fillAndStroke();
			
			//west pins
			switch(startPin) {
			  case 'nw':
					var currPinNum = pinCount;
			    break;
			  case 'ne':
					var currPinNum = pinsHOne + pinCount;
			    break;
			  case 'se':
					var currPinNum = pinsVOne + pinsHOne + pinCount;
			    break;
			  default:
					var currPinNum = pinsVOne + 2 * pinsHOne + pinCount;
			}

			if (pinLabelType == 'gen')
			{
				c.text(5, currH + 1, 0, 0, currPinNum.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}
			else if (currPinNum - 1 < labelNames.length)
			{
				c.text(5, currH + 1, 0, 0, labelNames[currPinNum - 1].toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}
			
			//east pins
			switch(startPin) {
			  case 'nw':
					var pc2 = pinsHOne + 2 * pinsVOne - pinCount + 1;
			    break;
			  case 'ne':
					var pc2 = 2 * pinsHOne + 2 * pinsVOne - pinCount + 1;
			    break;
			  case 'se':
					var pc2 = pinsVOne - pinCount + 1;
			    break;
			  default:
					var pc2 = pinsHOne + pinsVOne - pinCount + 1;
			}

			if (pinLabelType == 'gen')
			{
				c.text(w - 5, currH + 1, 0, 0, pc2.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}
			else if (pc2 - 1 < labelNames.length)
			{
				c.text(w - 5, currH + 1, 0, 0, labelNames[pc2 - 1].toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}

			currH = currH + pinSpacing;
			pinCount++;
		}
		
		var pinCount = 1;
		var currH = pinSpacing * 0.5 + 20;
		
		while (currH <= w - pinSpacing * 0.5 - 20)
		{
			c.begin();
			c.rect(currH - pinSpacing * 0.25, 0, pinSpacing * 0.5, 10);
			c.fillAndStroke();

			c.begin();
			c.rect(currH - pinSpacing * 0.25, h - 10, pinSpacing * 0.5, 10);
			c.fillAndStroke();
			
			//south pins
			switch(startPin) {
			  case 'nw':
					var currPinNum = pinsVOne + pinCount;
			    break;
			  case 'ne':
					var currPinNum = pinsVOne + pinsHOne + pinCount;
			    break;
			  case 'se':
					var currPinNum = 2 * pinsVOne + pinsHOne + pinCount;
			    break;
			  default:
					var currPinNum = pinCount;
			}
			
			if (pinLabelType == 'gen')
			{
				c.text(currH, h - 4, 0, 0, currPinNum.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}
			else if (currPinNum - 1 < labelNames.length)
			{
				c.text(currH, h - 4, 0, 0, labelNames[currPinNum - 1].toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}

			//north pins
			switch(startPin) {
			  case 'nw':
					var pc2 = 2 * pinsHOne + 2 * pinsVOne - pinCount + 1;
			    break;
			  case 'ne':
					var pc2 = pinsHOne - pinCount + 1;
			    break;
			  case 'se':
					var pc2 = pinsHOne + pinsVOne - pinCount + 1;
			    break;
			  default:
					var pc2 = 2 * pinsHOne + pinsVOne - pinCount + 1;
			}
			
			if (pinLabelType == 'gen')
			{
				c.text(currH, 6, 0, 0, pc2.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}
			else if (pc2 - 1 < labelNames.length)
			{
				c.text(currH, 6, 0, 0, labelNames[pc2 - 1].toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
			}

			currH = currH + pinSpacing;
			pinCount++;
		}
	}
	
	c.setShadow(false);
	
	if (w > 40)
	{
		c.setFillColor(mxUtils.getValue(this.style, 'strokeColor', '#000000'));

		c.begin();
		
		switch(startPin) {
		  case 'nw':
				c.ellipse(15, 15, 10, 10);
		    break;
		  case 'ne':
				c.ellipse(w - 25, 15, 10, 10);
		    break;
		  case 'se':
				c.ellipse(w - 25, h - 25, 10, 10);
		    break;
		  default:
				c.ellipse(15, h - 25, 10, 10);
		}
		
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeElectricalQFPIC.prototype.cst.SHAPE_QFP_IC, mxShapeElectricalQFPIC);

mxShapeElectricalQFPIC.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	var pinSpacing = parseFloat(mxUtils.getValue(this.style, 'pinSpacing', '20'));
	var pinCount = 1;
	var currH = pinSpacing * 0.5 + 20;
	
	var pinsOne = parseInt(h / pinSpacing);
	
	while (currH <= h - pinSpacing * 0.5 - 20)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, currH));
		constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, 0, currH));
		currH = currH + pinSpacing;
	}
	
	var pinCount = 1;
	var currH = pinSpacing * 0.5 + 20;
	
	while (currH <= w - pinSpacing * 0.5 - 20)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, currH, 0));
		constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, currH, 0));
		currH = currH + pinSpacing;
	}
	
	
	return (constr);
}

//**********************************************************************************************************************************************************
//Mux
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeElectricalMux(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeElectricalMux, mxShape);

mxShapeElectricalMux.prototype.cst = {
		SHAPE_MUX : 'mxgraph.electrical.abstract.mux2'
};

mxShapeElectricalMux.prototype.customProperties = [
	{name: 'operation', dispName: 'Operation', type: 'enum', defVal:'mux',
		enumList:[
			{val:'mux', dispName:'Mux'},
			{val:'demux', dispName:'Demux'}
		]},
	{name: 'selectorPins', dispName: 'Selector Pins', type: 'int', min:1, max:8, defVal:1},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeElectricalMux.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var selectorPins = parseInt(mxUtils.getValue(this.style, 'selectorPins', '1'));
	var operation = mxUtils.getValue(this.style, 'operation', 'mux');
	var fontSize = parseFloat(mxUtils.getValue(this.style, 'fontSize', '12'));
	c.setFontSize(fontSize * 0.5);
	var fontColor = mxUtils.getValue(this.style, 'fontColor', '#000000');
	c.setFontColor(fontColor);
	var dir = mxUtils.getValue(this.style, 'direction', 'east');
	var txtRot = 0;
	
	switch(dir)
	{
		case 'south' :
			txtRot = 270;
			break;
		case 'west' :
			txtRot = 180;
			break;
		case 'north' :
			txtRot = 90;
			break;
	}
		
	switch(operation) 
	{
	  case 'demux':
			c.begin();
			c.moveTo(w - 10, 0);
			c.lineTo(10, h * 0.1);
			c.lineTo(10, h * 0.9 - 10);
			c.lineTo(w - 10, h - 10);
			c.close();
			c.fillAndStroke();
	    break;
	  default:
			c.begin();
			c.moveTo(10, 0);
			c.lineTo(w - 10, h * 0.1);
			c.lineTo(w - 10, h * 0.9 - 10);
			c.lineTo(10, h - 10);
			c.close();
			c.fillAndStroke();
	};
	
	var numInputs = 1;
	var numOutputs = 1;
	
	if (operation == 'mux')
	{
		numInputs = Math.pow(2, selectorPins);
		var spacing = (h - 16) / numInputs;
	}
	else
	{
		numOutputs = Math.pow(2, selectorPins);
		var spacing = (h - 16) / numOutputs;
	}
	
	var currH = 3 + spacing * 0.5;
	
	c.begin();
	
	if (numInputs == 1)
	{
		c.moveTo(0, (h - 10) * 0.5);
		c.lineTo(10, (h - 10) * 0.5);
	}
	else
	{
		for (var i = 0; i < numInputs; i++)
		{
			c.moveTo(0, currH);
			c.lineTo(10, currH);
			c.text(14, currH + 1, 0, 0, '' + i.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, txtRot);
			currH = currH + spacing;
		}
	}

	if (numOutputs == 1)
	{
		c.moveTo(w - 10, (h - 10) * 0.5);
		c.lineTo(w, (h - 10) * 0.5);
	}
	else
	{
		for (var i = 0; i < numOutputs; i++)
		{
			c.moveTo(w - 10, currH);
			c.lineTo(w, currH);
			c.text(w - 14, currH + 1, 0, 0, '' + i.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, txtRot);
			currH = currH + spacing;
		}
	}

	var spacing = (w - 20) / selectorPins;
	var currW = 10 + spacing * 0.5;
	
	for (var i = 0; i < selectorPins; i++)
	{
		if (operation == 'mux')
		{
			c.moveTo(currW, h - 10 - (currW - 10) / (w - 20) * h * 0.1);
		}
		else
		{
			c.moveTo(currW, h - 10 - (w - currW - 10) / (w - 20) * h * 0.1);
		}

		c.lineTo(currW, h);

		c.text(currW + 5, h -4, 0, 0, 'S' + (selectorPins - i - 1).toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, txtRot);
		currW = currW + spacing;
	}

	c.stroke();
};

mxCellRenderer.registerShape(mxShapeElectricalMux.prototype.cst.SHAPE_MUX, mxShapeElectricalMux);

mxShapeElectricalMux.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var pinRange = (h - 16) / h;
	var selectorPins = parseInt(mxUtils.getValue(this.style, 'selectorPins', '1'));
	var operation = mxUtils.getValue(this.style, 'operation', 'mux');
	var dir = mxUtils.getValue(this.style, 'direction', 'east');
	
	var numInputs = 1;
	var numOutputs = 1;
	
	if (operation == 'mux')
	{
		numInputs = Math.pow(2, selectorPins);
		var spacing = pinRange / numInputs;
	}
	else
	{
		numOutputs = Math.pow(2, selectorPins);
		var spacing = pinRange / numOutputs;
	}
	
	var currH = spacing * 0.5;
	
	if (numInputs == 1)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5 * (h - 10) / h), false, 0, 0));
	}
	else
	{
		for (var i = 0; i < numInputs; i++)
		{
			constr.push(new mxConnectionConstraint(new mxPoint(0, currH), false, null, 0, 3));
			currH = currH + spacing;
		}
	}

	if (numOutputs == 1)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false, null, 0, -5));
	}
	else
	{
		for (var i = 0; i < numOutputs; i++)
		{
			constr.push(new mxConnectionConstraint(new mxPoint(1, currH), false, null, 0, 3));
			currH = currH + spacing;
		}
	}

	var spacing = (w - 20) / (w * selectorPins);
	var currW = spacing * 0.5;
	
	for (var i = 0; i < selectorPins; i++)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(currW, 1), false, null, 10, 0));
		currW = currW + spacing;
	}

	return (constr);
}

//**********************************************************************************************************************************************************
//Battery stack
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeElectricalBatteryStack(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeElectricalBatteryStack, mxShape);

mxShapeElectricalBatteryStack.prototype.cst = {
		SHAPE_BATTERY_STACK : 'mxgraph.electrical.miscellaneous.batteryStack'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeElectricalBatteryStack.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var bw = h * 0.3;
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	var dashed = mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, '0');
	
	var bNum = Math.floor((w - 20) / bw);
	var startX = (w - bNum * bw) * 0.5;

	if (bNum > 0)
	{
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(startX + bw * 0.2, h * 0.5);
		c.moveTo(w - startX - bw * 0.2, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
		
		var currX = startX;
		c.setFillColor(strokeColor);
		
		for (var i = 0; i < bNum; i++)
		{

			c.rect(currX + bw * 0.2, h * 0.25, bw * 0.2, h * 0.5);
			c.fillAndStroke();
			
			c.begin();
			c.moveTo(currX + bw * 0.8, 0);
			c.lineTo(currX + bw * 0.8, h);
			c.stroke();
			
			if (i > 0)
			{
				c.setDashed('1');
				c.begin();
				c.moveTo(currX - bw * 0.2, h * 0.5);
				c.lineTo(currX + bw * 0.2, h * 0.5);
				c.stroke();
				c.setDashed(dashed);
			}
			
			currX = currX + bw;
		}
	}
};

mxCellRenderer.registerShape(mxShapeElectricalBatteryStack.prototype.cst.SHAPE_BATTERY_STACK, mxShapeElectricalBatteryStack);

mxShapeElectricalBatteryStack.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0, 0.5), true),
    new mxConnectionConstraint(new mxPoint(1, 0.5), true)
    ];

/**
 * $Id: mxFloorplan.js,v 1.3 2014/02/17 17:05:39 mate Exp $
 * Copyright (c) 2006-2014, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Wall
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxFloorplanWall(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxFloorplanWall, mxShape);

mxFloorplanWall.prototype.cst = {
		WALL : 'mxgraph.floorplan.wall',
		WALL_THICKNESS : "wallThickness"
};

mxFloorplanWall.prototype.customProperties = [
	{name:'wallThickness', dispName:'Thickness', type:'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxFloorplanWall.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxFloorplanWall.prototype.background = function(c, x, y, w, h)
{
	var wallTh = parseFloat(mxUtils.getValue(this.style, mxFloorplanWall.prototype.cst.WALL_THICKNESS, '10'));
	c.rect(0, h * 0.5 - wallTh * 0.5, w, wallTh);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxFloorplanWall.prototype.cst.WALL, mxFloorplanWall);

//**********************************************************************************************************************************************************
//Wall Corner
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxFloorplanWallCorner(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxFloorplanWallCorner, mxShape);

mxFloorplanWallCorner.prototype.cst = {
		WALL_CORNER : 'mxgraph.floorplan.wallCorner',
		WALL_THICKNESS : "wallThickness"
};

mxFloorplanWallCorner.prototype.customProperties = [
	{name:'wallThickness', dispName:'Thickness', type:'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxFloorplanWallCorner.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxFloorplanWallCorner.prototype.background = function(c, x, y, w, h)
{
	var wallTh = parseFloat(mxUtils.getValue(this.style, mxFloorplanWallCorner.prototype.cst.WALL_THICKNESS, '10'));

	c.begin();
	c.moveTo(0, h);
	c.lineTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, wallTh);
	c.lineTo(wallTh, wallTh);
	c.lineTo(wallTh, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxFloorplanWallCorner.prototype.cst.WALL_CORNER, mxFloorplanWallCorner);

//**********************************************************************************************************************************************************
//Wall U
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxFloorplanWallU(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxFloorplanWallU, mxShape);

mxFloorplanWallU.prototype.cst = {
		WALL_U : 'mxgraph.floorplan.wallU',
		WALL_THICKNESS : "wallThickness"
};

mxFloorplanWallU.prototype.customProperties = [
	{name:'wallThickness', dispName:'Thickness', type:'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxFloorplanWallU.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxFloorplanWallU.prototype.background = function(c, x, y, w, h)
{
	var wallTh = parseFloat(mxUtils.getValue(this.style, mxFloorplanWallU.prototype.cst.WALL_THICKNESS, '10'));

	c.begin();
	c.moveTo(0, h);
	c.lineTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(w - wallTh, h);
	c.lineTo(w - wallTh, wallTh);
	c.lineTo(wallTh, wallTh);
	c.lineTo(wallTh, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxFloorplanWallU.prototype.cst.WALL_U, mxFloorplanWallU);

//**********************************************************************************************************************************************************
//Room
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxFloorplanRoom(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxFloorplanRoom, mxShape);

mxFloorplanRoom.prototype.cst = {
		ROOM : 'mxgraph.floorplan.room',
		WALL_THICKNESS : "wallThickness"
};

mxFloorplanRoom.prototype.customProperties = [
	{name:'wallThickness', dispName:'Thickness', type:'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxFloorplanRoom.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxFloorplanRoom.prototype.background = function(c, x, y, w, h)
{
	var wallTh = parseFloat(mxUtils.getValue(this.style, mxFloorplanRoom.prototype.cst.WALL_THICKNESS, '10'));

	c.begin();
	c.moveTo(0, h);
	c.lineTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.close();
	c.moveTo(wallTh, wallTh);
	c.lineTo(wallTh, h - wallTh);
	c.lineTo(w - wallTh, h - wallTh);
	c.lineTo(w - wallTh, wallTh);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxFloorplanRoom.prototype.cst.ROOM, mxFloorplanRoom);

//**********************************************************************************************************************************************************
//Window
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxFloorplanWindow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxFloorplanWindow, mxShape);

mxFloorplanWindow.prototype.cst = {
		WINDOW : 'mxgraph.floorplan.window',
		WALL_THICKNESS : "wallThickness"
};

mxFloorplanWindow.prototype.customProperties = [
	{name:'wallThickness', dispName:'Thickness', type:'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxFloorplanWindow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxFloorplanWindow.prototype.background = function(c, x, y, w, h)
{
	var wallTh = parseFloat(mxUtils.getValue(this.style, mxFloorplanWindow.prototype.cst.WALL_THICKNESS, '10'));
	c.rect(0, h * 0.5 - wallTh * 0.5, w, wallTh);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.stroke();
};

mxCellRenderer.registerShape(mxFloorplanWindow.prototype.cst.WINDOW, mxFloorplanWindow);

//**********************************************************************************************************************************************************
//Dimension
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxFloorplanDimension(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxFloorplanDimension, mxShape);

mxFloorplanDimension.prototype.cst = {
		DIMENSION : 'mxgraph.floorplan.dimension'
};

mxFloorplanDimension.prototype.customProperties = [
	{name:'wallThickness', dispName:'Thickness', type:'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxFloorplanDimension.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxFloorplanDimension.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 20);
	c.lineTo(w, 20);
	c.moveTo(10, 15);
	c.lineTo(0, 20);
	c.lineTo(10, 25);
	c.moveTo(w - 10, 15);
	c.lineTo(w, 20);
	c.lineTo(w - 10, 25);
	c.moveTo(0, 15);
	c.lineTo(0, h);
	c.moveTo(w, 15);
	c.lineTo(w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxFloorplanDimension.prototype.cst.DIMENSION, mxFloorplanDimension);

//**********************************************************************************************************************************************************
//Dimension Bottom
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxFloorplanDimensionBottom(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxFloorplanDimensionBottom, mxShape);

mxFloorplanDimensionBottom.prototype.cst = {
		DIMENSION : 'mxgraph.floorplan.dimensionBottom'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxFloorplanDimensionBottom.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxFloorplanDimensionBottom.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, h - 20);
	c.lineTo(w, h - 20);
	c.moveTo(10, h - 15);
	c.lineTo(0, h - 20);
	c.lineTo(10, h - 25);
	c.moveTo(w - 10, h - 15);
	c.lineTo(w, h - 20);
	c.lineTo(w - 10, h - 25);
	c.moveTo(0, h - 15);
	c.lineTo(0, 0);
	c.moveTo(w, h - 15);
	c.lineTo(w, 0);
	c.stroke();
};

mxCellRenderer.registerShape(mxFloorplanDimensionBottom.prototype.cst.DIMENSION, mxFloorplanDimensionBottom);

//**********************************************************************************************************************************************************
//Stairs
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxFloorplanStairs(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxFloorplanStairs, mxShape);

mxFloorplanStairs.prototype.cst = {
		STAIRS : 'mxgraph.floorplan.stairs'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxFloorplanStairs.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var minW = Math.max(w, 50);
	this.background(c, x, y, minW, h);
};

mxFloorplanStairs.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
	
	var step = 25;
	c.setShadow(false);
	
	c.begin();
	
	for (var i = 25; i < w; i = i + step)
	{
		c.moveTo(i, 0);
		c.lineTo(i, h);
	}
	
	c.stroke();
	
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.moveTo(w - step, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - step, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxFloorplanStairs.prototype.cst.STAIRS, mxFloorplanStairs);

////**********************************************************************************************************************************************************
////Stairs Double
////**********************************************************************************************************************************************************
///**
//* Extends mxShape.
//*/
//function mxFloorplanStairsRest(bounds, fill, stroke, strokewidth)
//{
//	mxShape.call(this);
//	this.bounds = bounds;
//	this.fill = fill;
//	this.stroke = stroke;
//	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
//};
//
///**
//* Extends mxShape.
//*/
//mxUtils.extend(mxFloorplanStairsRest, mxShape);
//
//mxFloorplanStairsRest.prototype.cst = {
//		STAIRS : 'mxgraph.floorplan.stairsRest'
//};
//
//
//
///**
//* Function: paintVertexShape
//* 
//* Paints the vertex shape.
//*/
//mxFloorplanStairsRest.prototype.paintVertexShape = function(c, x, y, w, h)
//{
//	c.translate(x, y);
//	var minW = Math.max(w, 50, h);
//	var minH = Math.min(w, h);
//	this.background(c, x, y, minW, h);
//};
//
//mxFloorplanStairsRest.prototype.background = function(c, x, y, w, h)
//{
//	c.rect(0, 0, w, h);
//	c.fillAndStroke();
//	
//	var step = 25;
//	c.setShadow(false);
//	
//	c.begin();
//	
//	for (var i = 25; i < w - h * 0.5; i = i + step)
//	{
//		c.moveTo(i, 0);
//		c.lineTo(i, h);
//	}
//	
//	c.stroke();
//	
//	c.begin();
//	c.moveTo(0, h * 0.5);
//	c.lineTo(w, h * 0.5);
//	
//	c.moveTo(w, 0);
//	c.lineTo(w - h * 0.5, h * 0.5);
//	c.lineTo(w, h);
//	
//	c.moveTo(w - h * 0.5, 0);
//	c.lineTo(w - h * 0.5, h);
//	
//	c.moveTo(0, h * 0.5);
//	c.lineTo(w, h * 0.5);
//	c.stroke();
//};
//
//mxCellRenderer.registerShape(mxFloorplanStairsRest.prototype.cst.STAIRS, mxFloorplanStairsRest);

//**********************************************************************************************************************************************************
//Stairs
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxFloorplanStairsRest(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxFloorplanStairsRest, mxShape);

mxFloorplanStairsRest.prototype.cst = {
		STAIRS : 'mxgraph.floorplan.stairsRest'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxFloorplanStairsRest.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var minW = Math.max(w, 50, h);
	var minH = Math.min(w, h);
	this.background(c, x, y, minW, h);
};

mxFloorplanStairsRest.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
	
	var step = 25;
	c.setShadow(false);
	
	c.begin();
	
	for (var i = 25; i < w - h * 0.5; i = i + step)
	{
		c.moveTo(i, 0);
		c.lineTo(i, h);
	}
	
	c.stroke();
	
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	
	c.moveTo(w, 0);
	c.lineTo(w - h * 0.5, h * 0.5);
	c.lineTo(w, h);
	
	c.moveTo(w - h * 0.5, 0);
	c.lineTo(w - h * 0.5, h);
	
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.stroke();
};

mxCellRenderer.registerShape(mxFloorplanStairsRest.prototype.cst.STAIRS, mxFloorplanStairsRest);

//**********************************************************************************************************************************************************
//Door, Left
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxFloorplanDoorLeft(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxFloorplanDoorLeft, mxShape);

mxFloorplanDoorLeft.prototype.cst = {
		DOOR_LEFT : 'mxgraph.floorplan.doorLeft'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxFloorplanDoorLeft.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxFloorplanDoorLeft.prototype.background = function(c, x, y, w, h)
{
		c.rect(0, 0, w, 5);
		c.fillAndStroke();
		
		c.begin();
		c.moveTo(w, 5);
		c.arcTo(w, w, 0, 0, 1, 0, 5 + w);
		c.lineTo(0, 5);
		c.stroke();
};

mxCellRenderer.registerShape(mxFloorplanDoorLeft.prototype.cst.DOOR_LEFT, mxFloorplanDoorLeft);

//**********************************************************************************************************************************************************
//Door, Right
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxFloorplanDoorRight(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxFloorplanDoorRight, mxShape);

mxFloorplanDoorRight.prototype.cst = {
		DOOR_RIGHT : 'mxgraph.floorplan.doorRight'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxFloorplanDoorRight.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxFloorplanDoorRight.prototype.background = function(c, x, y, w, h)
{
		c.rect(0, 0, w, 5);
		c.fillAndStroke();
		
		c.begin();
		c.moveTo(0, 5);
		c.arcTo(w, w, 0, 0, 0, w, 5 + w);
		c.lineTo(w, 5);
		c.stroke();
};

mxCellRenderer.registerShape(mxFloorplanDoorRight.prototype.cst.DOOR_RIGHT, mxFloorplanDoorRight);

//**********************************************************************************************************************************************************
//Door, Double
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxFloorplanDoorDouble(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxFloorplanDoorDouble, mxShape);

mxFloorplanDoorDouble.prototype.cst = {
		DOOR_DOUBLE : 'mxgraph.floorplan.doorDouble'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxFloorplanDoorDouble.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxFloorplanDoorDouble.prototype.background = function(c, x, y, w, h)
{
	var halfW = w * 0.5; 
	c.rect(0, 0, w, 5);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(halfW, 0);
	c.lineTo(halfW, 5);
	c.moveTo(halfW, 5);
	c.arcTo(halfW, halfW, 0, 0, 1, 0, 5 + halfW);
	c.lineTo(0, 5);
	c.moveTo(halfW, 5);
	c.arcTo(halfW, halfW, 0, 0, 0, w, 5 + halfW);
	c.lineTo(w, 5);
	c.stroke();
};

mxCellRenderer.registerShape(mxFloorplanDoorDouble.prototype.cst.DOOR_DOUBLE, mxFloorplanDoorDouble);

/**
 * $Id: mxFlowchart.js,v 1.5 2016/04/1 12:32:06 mate Exp $
 * Copyright (c) 2006-2018, JGraph Ltd
 */
//**********************************************************************************************************************************************************
// Document 2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeFlowchartDocument2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.size = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeFlowchartDocument2, mxActor);

mxShapeFlowchartDocument2.prototype.cst = {DOCUMENT2 : 'mxgraph.flowchart.document2'};

mxShapeFlowchartDocument2.prototype.customProperties = [
	{name: 'size', dispName: 'Wave Size', type: 'float', min:0, max:1, defVal:0.25},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeFlowchartDocument2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = h * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
	var fy = 1.4;
	var r = 5;
	
	c.begin();
	c.moveTo(w - r, 0);
	c.arcTo(r, r, 0, 0, 1, w, r);
	c.lineTo(w, h - dy / 2);
	c.quadTo(w * 3 / 4, h - dy * fy, w / 2, h - dy / 2);
	c.quadTo(w / 4, h - dy * (1 - fy), 0, h - dy / 2);
	c.lineTo(0, dy / 2);
	c.lineTo(0, r);
	c.arcTo(r, r, 0, 0, 1, r, 0);
	c.close();
	c.fillAndStroke();

};

mxCellRenderer.registerShape(mxShapeFlowchartDocument2.prototype.cst.DOCUMENT2, mxShapeFlowchartDocument2);

mxShapeFlowchartDocument2.prototype.constraints =
	[new mxConnectionConstraint(new mxPoint(0.25, 0), false),
    new mxConnectionConstraint(new mxPoint(0.5, 0), false),
    new mxConnectionConstraint(new mxPoint(0.75, 0), false),
	new mxConnectionConstraint(new mxPoint(0, 0.25), false),
	new mxConnectionConstraint(new mxPoint(0, 0.5), false),
	new mxConnectionConstraint(new mxPoint(0, 0.75), false),
	new mxConnectionConstraint(new mxPoint(1, 0.25), false),
	new mxConnectionConstraint(new mxPoint(1, 0.5), false),
	new mxConnectionConstraint(new mxPoint(1, 0.75), false)];

Graph.handleFactory[mxShapeFlowchartDocument2.prototype.cst.DOCUMENT2] = function(state)
{
	var handles = [Graph.createHandle(state, ['size'], function(bounds)
	{
		var size = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'size', this.size))));

		return new mxPoint(bounds.x + 3 * bounds.width / 4, bounds.y + (1 - size) * bounds.height);

	}, function(bounds, pt)
	{
		this.state.style['size'] = Math.max(0, Math.min(1, (bounds.y + bounds.height - pt.y) / bounds.height));
	})];
			
	return handles;
};

/**
 * $Id: mxGCP2.js,v 1.0 2018/08/21 13:05:39 mate Exp $
 * Copyright (c) 2006-2018, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//double rect
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeGCP2DoubleRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeGCP2DoubleRect, mxShape);

mxShapeGCP2DoubleRect.prototype.cst = {
		SHAPE_DOUBLE_RECT : 'mxgraph.gcp2.doubleRect'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeGCP2DoubleRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var dx = 8;
	var dy = 8;
	
	w = w - dx;
	h = h - dy;
	
	c.translate(x, y);
	c.begin();
	c.roundrect(dx, dy, w , h, 1, 1);
	c.fillAndStroke();
	c.roundrect(0, 0, w, h, 1, 1);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeGCP2DoubleRect.prototype.cst.SHAPE_DOUBLE_RECT, mxShapeGCP2DoubleRect);
mxShapeGCP2DoubleRect.prototype.constraints = mxRectangleShape.prototype.constraints;

//**********************************************************************************************************************************************************
//hexagonal icon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeGCP2HexIcon(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeGCP2HexIcon, mxShape);

mxShapeGCP2HexIcon.prototype.cst = {
		HEX_ICON : 'mxgraph.gcp2.hexIcon'
};

mxShapeGCP2HexIcon.prototype.customProperties = [
	{name: 'instNum', dispName: 'Number of instances', type: 'int', min: 0, defVal: 0},
	{name: 'prType', dispName: 'Instance Type', defVal: 'standard', type: 'enum', 
		enumList: [{val: 'standard', dispName: 'Standard'}, 
				   {val: 'dynamic', dispName: 'Dynamic'}, 
				   {val: 'multiple', dispName: 'Multiple'}, 
				   {val: 'shared', dispName: 'Shared'}, 
				   {val: 'replica', dispName: 'Replica'}, 
				   {val: 'dynamic2', dispName: 'Dynamic 2'}, 
				   {val: 'dynamic3', dispName: 'Dynamic 3'}, 
				   {val: 'highmem', dispName: 'High-Mem'}, 
				   {val: 'highcomp', dispName: 'High-Comp'},
				   {val: 'backend', dispName: 'Backend'},
				   {val: 'input', dispName: 'Input'}]},
	{name: 'prIcon', dispName: 'Instance Icon', defVal: 'compute_engine', type: 'enum', 
			enumList: [{val: 'compute_engine', dispName: 'Compute Engine'}, 
				       {val: 'gpu', dispName: 'GPU'},
				       {val: 'app_engine', dispName: 'App Engine'},
				       {val: 'cloud_functions', dispName: 'Cloud Functions'},
				       {val: 'container_engine', dispName: 'Kubernetes Engine'},
				       {val: 'container_optimized_os', dispName: 'Container-Optimized OS'},
				       {val: 'api_analytics', dispName: 'API Analytics'},
				       {val: 'apigee_sense', dispName: 'Apigee Sense'},
				       {val: 'api_monetization', dispName: 'API Monetization'},
				       {val: 'cloud_endpoints', dispName: 'Cloud Endpoints'},
				       {val: 'apigee_api_platform', dispName: 'Apigee API Platform'},
				       {val: 'developer_portal', dispName: 'Developer Portal'},
				       {val: 'cloud_iam', dispName: 'Cloud IAM'},
				       {val: 'beyondcorp', dispName: 'BeyondCorp'},
				       {val: 'cloud_iam', dispName: 'Cloud Resource Manager'},
				       {val: 'data_loss_prevention_api', dispName: 'Data Loss Prevention API'},
				       {val: 'cloud_security_scanner', dispName: 'Cloud Security Scanner'},
				       {val: 'key_management_service', dispName: 'Key Management Service'},
				       {val: 'identity_aware_proxy', dispName: 'Identity-Aware Proxy'},
				       {val: 'security_key_enforcement', dispName: 'Security Key Enforcement'},
				       {val: 'bigquery', dispName: 'BigQuery'},
				       {val: 'cloud_datalab', dispName: 'Cloud Datalab'},
				       {val: 'cloud_dataflow', dispName: 'Cloud Dataflow'},
				       {val: 'cloud_pubsub', dispName: 'Cloud Pub/Sub'},
				       {val: 'cloud_dataproc', dispName: 'Cloud Dataproc'},
				       {val: 'genomics', dispName: 'Genomics'},
				       {val: 'cloud_dataprep', dispName: 'Cloud Dataprep'},
				       {val: 'data_studio', dispName: 'Data Studio'},
				       {val: 'transfer_appliance', dispName: 'Transfer Appliance'},
				       {val: 'cloud_machine_learning', dispName: 'Cloud Machine Learning'},
				       {val: 'cloud_natural_language_api', dispName: 'Cloud Natural Language API'},
				       {val: 'cloud_vision_api', dispName: 'Vision API'},
				       {val: 'cloud_translation_api', dispName: 'Translation API'},
				       {val: 'cloud_speech_api', dispName: 'Speech API'},
				       {val: 'cloud_jobs_api', dispName: 'Jobs API'},
				       {val: 'cloud_video_intelligence_api', dispName: 'Cloud Video Intelligence API'},
				       {val: 'advanced_solutions_lab', dispName: 'Advanced Solutions Lab'},
				       {val: 'cloud_iot_core', dispName: 'Cloud IoT Core'},
				       {val: 'cloud_storage', dispName: 'Cloud Storage'},
				       {val: 'cloud_sql', dispName: 'Cloud SQL'},
				       {val: 'cloud_bigtable', dispName: 'Cloud Bigtable'},
				       {val: 'cloud_spanner', dispName: 'Cloud Spanner'},
				       {val: 'cloud_datastore', dispName: 'Cloud Datastore'},
				       {val: 'persistent_disk', dispName: 'Persistent Disk'},
				       {val: 'cloud_memorystore', dispName: 'Cloud Memorystore'},
				       {val: 'cloud_filestore', dispName: 'Cloud Filestore'},
				       {val: 'stackdriver', dispName: 'Stackdriver'},
				       {val: 'cloud_deployment_manager', dispName: 'Monitoring'},
				       {val: 'cloud_deployment_manager', dispName: 'Deployment Manager'},
				       {val: 'logging', dispName: 'Logging'},
				       {val: 'placeholder', dispName: 'Cloud Console'},
				       {val: 'error_reporting', dispName: 'Error Reporting'},
				       {val: 'placeholder', dispName: 'Cloud Shell'},
				       {val: 'trace', dispName: 'Trace'},
				       {val: 'placeholder', dispName: 'Cloud Mobile App'},
				       {val: 'profiler', dispName: 'Profiler'},
				       {val: 'placeholder', dispName: 'Billing API'},
				       {val: 'cloud_apis', dispName: 'Cloud APIs'},
				       {val: 'virtual_private_cloud', dispName: 'Virtual Private Cloud'},
				       {val: 'dedicated_interconnect', dispName: 'Dedicated Interconnect'},
				       {val: 'cloud_load_balancing', dispName: 'Cloud Load Balancing'},
				       {val: 'cloud_dns', dispName: 'Cloud DNS'},
				       {val: 'cloud_cdn', dispName: 'Cloud CDN'},
				       {val: 'cloud_network', dispName: 'Cloud Network'},
				       {val: 'cloud_external_ip_addresses', dispName: 'Cloud External IP Addresses'},
				       {val: 'cloud_routes', dispName: 'Cloud Routes'},
				       {val: 'cloud_firewall_rules', dispName: 'Cloud Firewall Rules'},
				       {val: 'cloud_vpn', dispName: 'Cloud VPN'},
				       {val: 'cloud_router', dispName: 'Cloud Router'},
				       {val: 'cloud_armor', dispName: 'Cloud Armor'},
				       {val: 'standard_network_tier', dispName: 'Standard Network Tier'},
				       {val: 'premium_network_tier', dispName: 'Premium Network Tier'},
				       {val: 'partner_interconnect', dispName: 'Partner Interconnect'},
				       {val: 'placeholder', dispName: 'Cloud SDK'},
				       {val: 'container_builder', dispName: 'Cloud Build'},
				       {val: 'cloud_tools_for_powershell', dispName: 'Cloud Tools for Visual Studio'},
				       {val: 'placeholder', dispName: 'Cloud Source Repositories'},
				       {val: 'placeholder', dispName: 'Maven App Engine Plugin'},
				       {val: 'placeholder', dispName: 'Cloud Tools for Eclipse'},
				       {val: 'placeholder', dispName: 'Cloud Tools for IntelliJ'},
				       {val: 'placeholder', dispName: 'Cloud Test Lab'},
				       {val: 'cloud_tools_for_powershell', dispName: 'Cloud Tools for PowerShell'},
				       {val: 'cloud_tools_for_powershell', dispName: 'IDE Plugins'},
				       {val: 'container_registry', dispName: 'Container Registry'},
				       {val: 'cloud_iot_edge', dispName: 'Cloud IoT Edge'},
				       {val: 'cloud_firestore', dispName: 'Cloud Firestore'},
				       {val: 'cloud_run', dispName: 'Cloud Run'},
				       {val: 'gke_on_prem', dispName: 'GKE-on-Prem'},
				       {val: 'cloud_data_catalog', dispName: 'Cloud Data Catalog'},
				       {val: 'cloud_data_fusion', dispName: 'Cloud Data Fusion'},
				       {val: 'ai_hub', dispName: 'AI Hub'},
				       {val: 'automl_video_intelligence', dispName: 'AutoML Video Intelligence'},
				       {val: 'automl_natural_language', dispName: 'AutoML Natural Language'},
				       {val: 'automl_tables', dispName: 'AutoML Tables'},
				       {val: 'automl_translation', dispName: 'AutoML Translation'},
				       {val: 'automl_vision', dispName: 'AutoML Vision'},
				       {val: 'recommendations_ai', dispName: 'Recommendations AI'},
				       {val: 'cloud_inference_api', dispName: 'Cloud Inference API'},
				       {val: 'cloud_service_mesh', dispName: 'Cloud Service Mesh'},
				       {val: 'cloud_nat', dispName: 'Cloud NAT'},
				       {val: 'traffic_director', dispName: 'Traffic Director'},
				       {val: 'cloud_test_lab', dispName: 'Cloud Test Lab'},
				       {val: 'cloud_code', dispName: 'Cloud Code'},
				       {val: 'cloud_tasks', dispName: 'Cloud Tasks'},
				       {val: 'placeholder', dispName: 'Gradle App Engine Plugin'}]}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeGCP2HexIcon.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var prIcon = mxUtils.getValue(this.state.style, 'prIcon', 'compute_engine');
	var prType = mxUtils.getValue(this.state.style, 'prType', '');
	var instNum = parseInt(mxUtils.getValue(this.state.style, 'instNum', 0));
	var fillColor = mxUtils.getValue(this.state.style, 'fillColor', '#ffffff');
	var opacity = mxUtils.getValue(this.state.style, 'opacity', '100');
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', 'none');
	var strokeWidth = mxUtils.getValue(this.state.style, 'strokeWidth', 1);
	var iconSize = Math.min(w, h);
	
	switch(prType)
	{
		case 'dynamic':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.gcp2.outline_blank_2');
			c.setAlpha(opacity * 0.5 / 100);
			c.setStrokeColor('none');
			bgSt1.drawShape(c, this, w * 0.21, h * 0.12, w * 0.58, h * 0.76);
			break;
		case 'multiple':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.gcp2.outline_blank_2');
			c.setAlpha(opacity * 0.5 / 100);
			c.setStrokeColor('none');
			bgSt1.drawShape(c, this, w * 0.21, h * 0.12, w * 0.58, h * 0.76);
			var bgSt2 = mxStencilRegistry.getStencil('mxgraph.gcp2.outline_blank_3');
			c.setAlpha(opacity * 0.7 / 100);
			c.setStrokeColor('none');
			bgSt2.drawShape(c, this, w * 0.17, h * 0.13, w * 0.66, h * 0.74);
			break;
		case 'shared':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.gcp2.outline_blank_1');
			this.style[mxConstants.STYLE_STROKEWIDTH] = iconSize * 0.038;
			c.setAlpha(opacity * 0.4 / 100);
			c.setStrokeColor(fillColor);
			c.setFillColor('none');
			bgSt1.drawShape(c, this, w * 0.02, h * 0, w * 0.96, h);
			var bgSt2 = mxStencilRegistry.getStencil('mxgraph.gcp2.outline_blank_2');
			c.setAlpha(opacity * 0.7 / 100);
			bgSt2.drawShape(c, this, w * 0.14, h * 0.01, w * 0.72, h * 0.98);
			c.setAlpha(opacity / 100);
			c.setFillColor('#ffffff');
			bgSt1.drawShape(c, this, w * 0.13, h * 0.12, w * 0.74, h * 0.76);
			this.style[mxConstants.STYLE_STROKEWIDTH] = strokeWidth;
			break;
		case 'replica':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.gcp2.outline_blank_1');
			this.style[mxConstants.STYLE_STROKEWIDTH] = iconSize * 0.038;
			c.setAlpha(opacity * 0.4 / 100);
			c.setStrokeColor(fillColor);
			c.setFillColor('none');
			bgSt1.drawShape(c, this, w * 0.02, h * 0, w * 0.96, h);
			c.setAlpha(opacity * 0.7 / 100);
			bgSt1.drawShape(c, this, w * 0.075, h * 0.06, w * 0.85, h * 0.88);
			c.setAlpha(opacity / 100);
			c.setFillColor('#ffffff');
			bgSt1.drawShape(c, this, w * 0.13, h * 0.12, w * 0.74, h * 0.76);
			this.style[mxConstants.STYLE_STROKEWIDTH] = strokeWidth;
			break;
		case 'dynamic2':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.gcp2.outline_blank_2');
			c.setAlpha(opacity * 0.5 / 100);
			c.setStrokeColor('none');
			bgSt1.drawShape(c, this, w * 0.14, h * 0.01, w * 0.72, h * 0.98);
			var bgSt2 = mxStencilRegistry.getStencil('mxgraph.gcp2.outline_blank_1');
			this.style[mxConstants.STYLE_STROKEWIDTH] = iconSize * 0.01;
			c.setStrokeColor(fillColor);
			c.setAlpha(opacity / 100);
			c.setFillColor('#ffffff');
			bgSt2.drawShape(c, this, w * 0.13, h * 0.12, w * 0.74, h * 0.76);
			this.style[mxConstants.STYLE_STROKEWIDTH] = strokeWidth;
			break;
		case 'dynamic3':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.gcp2.outline_blank_2');
			c.setStrokeColor('none');
			bgSt1.drawShape(c, this, w * 0.14, h * 0.01, w * 0.72, h * 0.98);
			var bgSt2 = mxStencilRegistry.getStencil('mxgraph.gcp2.outline_blank_1');
			this.style[mxConstants.STYLE_STROKEWIDTH] = iconSize * 0.01;
			c.setStrokeColor(fillColor);
			c.setAlpha(opacity / 100);
			c.setFillColor('#ffffff');
			bgSt2.drawShape(c, this, w * 0.13, h * 0.12, w * 0.74, h * 0.76);
			this.style[mxConstants.STYLE_STROKEWIDTH] = strokeWidth;
			break;
		case 'highmem':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.gcp2.outline_highmem');
			c.setAlpha(opacity * 0.5 / 100);
			c.setStrokeColor('none');
			bgSt1.drawShape(c, this, 0, h * 0.56, w, h * 0.28);
			break;
		case 'highcomp':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.gcp2.outline_highcomp');
			c.setAlpha(opacity * 0.5 / 100);
			c.setStrokeColor('none');
			bgSt1.drawShape(c, this, 0, h * 0.16, w, h * 0.28);
			break;
		case 'backend':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.gcp2.outline_blank_1');
			c.setFillColor('#FCC64D');
			bgSt1.drawShape(c, this, w * 0.12, h * 0.11, w * 0.76, h * 0.78);
			break;
		case 'input':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.gcp2.outline_blank_1');
			c.setFillColor('#A5DA40');
			bgSt1.drawShape(c, this, w * 0.12, h * 0.11, w * 0.76, h * 0.78);
			break;
		case 'standard':
		default:
			break;
	}
	
	c.setAlpha(opacity / 100);
	var stencil = mxStencilRegistry.getStencil('mxgraph.gcp2.' + prIcon);
	
	if (stencil != null)
	{
		c.setFillColor(fillColor);
		c.setStrokeColor('none');
		stencil.drawShape(c, this, w * 0.17, h * 0.16, w * 0.66, h * 0.68);
	}

	if (instNum > 0)
	{
		c.setFillColor('#ffffff');
		c.setStrokeColor('#ffffff');
		c.setStrokeWidth(iconSize * 0.038);
		c.ellipse(w * 0.2, 0, w * 0.18, h * 0.22);
		c.fillAndStroke();

		c.setAlpha(opacity * 0.5 / 100);
		c.setStrokeColor(fillColor);
		c.ellipse(w * 0.2, 0, w * 0.18, h * 0.22);
		c.stroke();

		c.setAlpha(opacity / 100);
		c.setFontColor('#4E6B89');
		c.setFontStyle(1);
		c.setFontSize(Math.min(w, h) * 0.1);
		
		c.text(w * 0.29, h * 0.11 + 1, 0, 0, instNum.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
};

mxCellRenderer.registerShape(mxShapeGCP2HexIcon.prototype.cst.HEX_ICON, mxShapeGCP2HexIcon);

mxShapeGCP2HexIcon.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.825, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.175, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.16), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.84), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.66, 0.17), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.66, 0.83), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.34, 0.17), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.34, 0.83), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0.33), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0.67), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0.33), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0.67), false));

	return (constr);
};


/**
 * $Id: mxGmdl.js,v 1.0 2015/09/09 17:05:39 mate Exp $
 * Copyright (c) 2006-2015, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//player
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeGmdlPlayer(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeGmdlPlayer, mxShape);

mxShapeGmdlPlayer.prototype.cst = {
		SHAPE_PLAYER : 'mxgraph.gmdl.player'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeGmdlPlayer.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.begin();
	c.rect(0, 0, w, h);
	c.fill();
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeGmdlPlayer.prototype.foreground = function(c, x, y, w, h)
{

	if ( h >= 4)
	{
		c.setFillColor('#FFED00');
		c.begin();
		c.rect(0, 0, w * 0.8, 4);
		c.fill();
	}
	
	if ( h >= 14 && w >= 33)
	{
		c.setFillColor('#717171');
		c.begin();
		c.rect(w - 33, h * 0.5 - 7, 4, 14);
		c.fill();
		c.begin();
		c.rect(w - 25, h * 0.5 - 7, 4, 14);
		c.fill();
	}

};

mxCellRenderer.registerShape(mxShapeGmdlPlayer.prototype.cst.SHAPE_PLAYER, mxShapeGmdlPlayer);

//**********************************************************************************************************************************************************
//switch
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeGmdlSwitch(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeGmdlSwitch, mxShape);

mxShapeGmdlSwitch.prototype.cst = {
		SHAPE_SWITCH : 'mxgraph.gmdl.switch',
		STATE : 'switchState',
		STATE_ON : 'on',
		STATE_OFF : 'off'
};

mxShapeGmdlSwitch.prototype.customProperties = [
	{name:'switchState', dispName:'State', type:'enum', defVal:'on',
		enumList:[{val:'on', dispName: 'On'}, {val:'off', dispName: 'Off'}]}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeGmdlSwitch.prototype.paintVertexShape = function(c, x, y, w, h)
{
	
	c.translate(x, y);
	var state = mxUtils.getValue(this.style, mxShapeGmdlSwitch.prototype.cst.STATE, mxShapeGmdlSwitch.prototype.cst.STATE_ON);
	this.background(c, x, y, w, h, state);
	c.setShadow(true);
	this.foreground(c, x, y, w, h, state);
};

mxShapeGmdlSwitch.prototype.background = function(c, x, y, w, h, state)
{
	c.begin();

	if (state === mxShapeGmdlSwitch.prototype.cst.STATE_ON)
	{
		c.save();
		c.setAlpha('0.5');
		c.moveTo(w * 0.135, h * 0.8);
		c.arcTo(w * 0.135, h * 0.3, 0, 0, 1, w * 0.135, h * 0.2);
		c.lineTo(w * 0.675, h * 0.2);
		c.arcTo(w * 0.135, h * 0.3, 0, 0, 1, w * 0.675, h * 0.8);
		c.close();
		c.fillAndStroke();
		c.restore();
	}
	else
	{
		c.setFillColor('#BCBBBB');
		c.moveTo(w * 0.225, h * 0.8);
		c.arcTo(w * 0.135, h * 0.3, 0, 0, 1, w * 0.225, h * 0.2);
		c.lineTo(w * 0.865, h * 0.2);
		c.arcTo(w * 0.135, h * 0.3, 0, 0, 1, w * 0.865, h * 0.8);
		c.close();
		c.fillAndStroke();
	}

};

mxShapeGmdlSwitch.prototype.foreground = function(c, x, y, w, h, state)
{
	c.begin();

	if (state === mxShapeGmdlSwitch.prototype.cst.STATE_ON)
	{
		c.ellipse(w * 0.36, 0, w * 0.64, h);
	}
	else
	{
		c.setFillColor('#F1F1F1');
		c.ellipse(0, 0, w * 0.64, h);
	}

	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeGmdlSwitch.prototype.cst.SHAPE_SWITCH, mxShapeGmdlSwitch);

//**********************************************************************************************************************************************************
//rect with margins
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeGmdlMarginRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeGmdlMarginRect, mxShape);

mxShapeGmdlMarginRect.prototype.cst = {
		SHAPE_MARGIN_RECT : 'mxgraph.gmdl.marginRect',
		MARGIN : 'rectMargin',
		MARGIN_TOP : 'rectMarginTop',
		MARGIN_LEFT : 'rectMarginLeft',
		MARGIN_BOTTOM : 'rectMarginBottom',
		MARGIN_RIGHT : 'rectMarginRight'
};

mxShapeGmdlMarginRect.prototype.customProperties = [
	{name:'rectMargin', dispName:'Margin', type:'float', min:0, defVal:0},
	{name:'rectMarginTop', dispName:'Margin Top', type:'float', defVal:0},
	{name:'rectMarginLeft', dispName:'Margin Left', type:'float', defVal:0},
	{name:'rectMarginBottom', dispName:'Margin Bottom', type:'float', defVal:0},
	{name:'rectMarginRight', dispName:'Margin Right', type:'float', defVal:0}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeGmdlMarginRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxShapeGmdlMarginRect.prototype.background = function(c, x, y, w, h, state)
{
	var margin = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlMarginRect.prototype.cst.MARGIN, '0'));
	var marginTop = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlMarginRect.prototype.cst.MARGIN_TOP, '0'));
	var marginLeft = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlMarginRect.prototype.cst.MARGIN_LEFT, '0'));
	var marginBottom = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlMarginRect.prototype.cst.MARGIN_BOTTOM, '0'));
	var marginRight = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlMarginRect.prototype.cst.MARGIN_RIGHT, '0'));

	var x1 = margin + marginLeft;
	var y1 = margin + marginTop;
	var w1 = w - marginRight - x1 - margin;
	var h1 = h - marginBottom - y1 - margin;

	if (w1 >0 && h1 > 0)
	{
		c.begin();
		c.rect(x1, y1, w1, h1);
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeGmdlMarginRect.prototype.cst.SHAPE_MARGIN_RECT, mxShapeGmdlMarginRect);

//**********************************************************************************************************************************************************
//slider normal
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeGmdlSliderNormal(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeGmdlSliderNormal, mxShape);

mxShapeGmdlSliderNormal.prototype.cst = {
		SHAPE_SLIDER_NORMAL : 'mxgraph.gmdl.sliderNormal',
		HANDLE_SIZE : 'handleSize'
};

mxShapeGmdlSliderNormal.prototype.customProperties = [
	{name:'handleSize', dispName:'Handle Size', type:'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeGmdlSliderNormal.prototype.paintVertexShape = function(c, x, y, w, h)
{
	
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(true);
};

mxShapeGmdlSliderNormal.prototype.background = function(c, x, y, w, h)
{
	var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderNormal.prototype.cst.HANDLE_SIZE, '10'));

	c.ellipse(0, h * 0.5 - hSize * 0.5, hSize, hSize);
	c.stroke();
	
	c.begin();
	c.moveTo(hSize, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeGmdlSliderNormal.prototype.cst.SHAPE_SLIDER_NORMAL, mxShapeGmdlSliderNormal);

//**********************************************************************************************************************************************************
//slider normal v2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeGmdlSlider2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeGmdlSlider2, mxShape);

mxShapeGmdlSlider2.prototype.cst = {
		SHAPE_SLIDER : 'mxgraph.gmdl.slider2',
		BAR_POS : 'barPos',
		HANDLE_SIZE : 'handleSize'
};

mxShapeGmdlSlider2.prototype.customProperties = [
	{name:'barPos', dispName:'Handle Position', type:'float', min:0, defVal:40},
	{name:'handleSize', dispName:'Handle Size', type:'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeGmdlSlider2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(true);
};

mxShapeGmdlSlider2.prototype.background = function(c, x, y, w, h)
{
	var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSlider2.prototype.cst.HANDLE_SIZE, '10'));
	var barPos = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSlider2.prototype.cst.BAR_POS, '40')) / 100;

	barPos = Math.max(0, Math.min(1, barPos));

	c.save();
	c.setStrokeColor('#bbbbbb');
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.fillAndStroke();
	
	c.restore();
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(barPos * w, h * 0.5);
	c.fillAndStroke();
	
	c.begin();
	c.ellipse(barPos * w - hSize * 0.5, h * 0.5 - hSize * 0.5, hSize, hSize);
	c.fillAndStroke();

};

mxCellRenderer.registerShape(mxShapeGmdlSlider2.prototype.cst.SHAPE_SLIDER, mxShapeGmdlSlider2);

mxShapeGmdlSlider2.prototype.constraints = null;

Graph.handleFactory[mxShapeGmdlSlider2.prototype.cst.SHAPE_SLIDER] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'barPos', 0.4))));

				return new mxPoint(bounds.x + barPos * bounds.width / 100, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100;
			})];
			
	return handles;
};

//**********************************************************************************************************************************************************
//slider focused v2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeGmdlSliderFocused(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeGmdlSliderFocused, mxShape);

mxShapeGmdlSliderFocused.prototype.cst = {
		SHAPE_SLIDER_FOCUSED : 'mxgraph.gmdl.sliderFocused',
		BAR_POS : 'barPos',
		HANDLE_SIZE : 'handleSize'
};

mxShapeGmdlSliderFocused.prototype.customProperties = [
	{name:'barPos', dispName:'Handle Position', type:'float', min:0, defVal:40},
	{name:'handleSize', dispName:'Handle Size', type:'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeGmdlSliderFocused.prototype.paintVertexShape = function(c, x, y, w, h)
{
	
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(true);
};

mxShapeGmdlSliderFocused.prototype.background = function(c, x, y, w, h)
{
	var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderFocused.prototype.cst.HANDLE_SIZE, '10'));
	var barPos = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderFocused.prototype.cst.BAR_POS, '40')) / 100;
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#ffffff');

	barPos = Math.max(0, Math.min(1, barPos));

	c.save();
	c.setStrokeColor('#bbbbbb');
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.fillAndStroke();

	c.restore();
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(barPos * w, h * 0.5);
	c.fillAndStroke();
	
	c.begin();
	c.ellipse(barPos * w - hSize * 0.167, h * 0.5 - hSize * 0.167, hSize * 0.33, hSize * 0.33);
	c.fillAndStroke();

	c.setFillColor(strokeColor);
	c.setAlpha(0.15);
	c.begin();
	c.ellipse(barPos * w - hSize * 0.5, h * 0.5 - hSize * 0.5, hSize, hSize);
	c.fill();

};

mxCellRenderer.registerShape(mxShapeGmdlSliderFocused.prototype.cst.SHAPE_SLIDER_FOCUSED, mxShapeGmdlSliderFocused);

mxShapeGmdlSliderFocused.prototype.constraints = null;

Graph.handleFactory[mxShapeGmdlSliderFocused.prototype.cst.SHAPE_SLIDER_FOCUSED] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'barPos', 0.4))));

				return new mxPoint(bounds.x + barPos * bounds.width / 100, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100;
			})];
			
	return handles;

};

//**********************************************************************************************************************************************************
//slider disabled
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeGmdlSliderDisabled(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeGmdlSliderDisabled, mxShape);

mxShapeGmdlSliderDisabled.prototype.cst = {
		SHAPE_SLIDER_DISABLED : 'mxgraph.gmdl.sliderDisabled',
		HANDLE_POSITION : 'hPos',
		HANDLE_SIZE : 'handleSize'
};

mxShapeGmdlSliderDisabled.prototype.customProperties = [
	{name:'hPos', dispName:'Handle Position', type:'float', min:0, defVal:40},
	{name:'handleSize', dispName:'Handle Size', type:'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeGmdlSliderDisabled.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(true);
};

mxShapeGmdlSliderDisabled.prototype.background = function(c, x, y, w, h)
{
	var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDisabled.prototype.cst.HANDLE_SIZE, '10'));
	var hPos = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDisabled.prototype.cst.HANDLE_POSITION, '50')) / 100;
	
	hPos = Math.max(hPos, 0);
	hPos = Math.min(hPos, 1);

	c.ellipse(w * hPos - hSize * 0.5, (h - hSize) * 0.5, hSize, hSize);
	c.fillAndStroke();
	
	var endL = w * hPos - 7;
	var startR = w * hPos + 7;
	
	if (endL > 0)
	{
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(endL, h * 0.5);
		c.stroke();
	}
	
	if (startR < w)
	{
		c.begin();
		c.moveTo(startR, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapeGmdlSliderDisabled.prototype.cst.SHAPE_SLIDER_DISABLED, mxShapeGmdlSliderDisabled);

//**********************************************************************************************************************************************************
//slider disabled v2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeGmdlSliderDisabled2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeGmdlSliderDisabled2, mxShape);

mxShapeGmdlSliderDisabled2.prototype.cst = {
		SHAPE_SLIDER_DISABLED : 'mxgraph.gmdl.sliderDisabled2',
		HANDLE_POSITION : 'hPos',
		HANDLE_SIZE : 'handleSize'
};

mxShapeGmdlSliderDisabled2.prototype.customProperties = [
	{name:'hPos', dispName:'Handle Position', type:'float', min:0, defVal:'40'},
	{name:'handleSize', dispName:'Handle Size', type:'float', min:0, defVal:'10'}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeGmdlSliderDisabled2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(true);
};

mxShapeGmdlSliderDisabled2.prototype.background = function(c, x, y, w, h)
{
	var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDisabled2.prototype.cst.HANDLE_SIZE, '10'));
	var hPos = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDisabled2.prototype.cst.HANDLE_POSITION, '50')) / 100;
	
	hPos = Math.min(Math.max(hPos, 0), 1);

	c.ellipse(w * hPos - hSize * 0.5, (h - hSize) * 0.5, hSize, hSize);
	c.fillAndStroke();
	
	var endL = w * hPos - 7;
	var startR = w * hPos + 7;
	
	if (endL > 0)
	{
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(endL, h * 0.5);
		c.stroke();
	}
	
	if (startR < w)
	{
		c.begin();
		c.moveTo(startR, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapeGmdlSliderDisabled2.prototype.cst.SHAPE_SLIDER_DISABLED, mxShapeGmdlSliderDisabled2);

mxShapeGmdlSlider2.prototype.constraints = null;

Graph.handleFactory[mxShapeGmdlSliderDisabled2.prototype.cst.SHAPE_SLIDER_DISABLED] = function(state)
{
	var handles = [Graph.createHandle(state, ['hPos'], function(bounds)
			{
				var hPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'hPos', 0.4))));

				return new mxPoint(bounds.x + hPos * bounds.width / 100, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['hPos'] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100;
			})];
			
	return handles;
};

//**********************************************************************************************************************************************************
//slider discrete
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeGmdlSliderDiscrete(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeGmdlSliderDiscrete, mxShape);

mxShapeGmdlSliderDiscrete.prototype.cst = {
		SHAPE_DISCRETE : 'mxgraph.gmdl.sliderDiscrete',
		BAR_POS : 'barPos',
		HANDLE_SIZE : 'handleSize'
};

mxShapeGmdlSliderDiscrete.prototype.customProperties = [
	{name:'barPos', dispName:'Handle Position', type:'int', min:0, defVal:'40'},
	{name:'handleSize', dispName:'Handle Size', type:'float', min:0, defVal:'10'}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeGmdlSliderDiscrete.prototype.paintVertexShape = function(c, x, y, w, h)
{
	
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(true);
};

mxShapeGmdlSliderDiscrete.prototype.background = function(c, x, y, w, h)
{
	var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDiscrete.prototype.cst.HANDLE_SIZE, '10'));
	var barPos = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDiscrete.prototype.cst.BAR_POS, '40')) / 100;
	var fontSize = parseFloat(mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '12'));
	var fontColor = mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, '#000000');

	barPos = Math.max(0, Math.min(1, barPos));

	c.save();
	c.setStrokeColor('#bbbbbb');
	c.begin();
	c.moveTo(0, h * 0.5 + 22.5);
	c.lineTo(w, h * 0.5 + 22.5);
	c.fillAndStroke();
	
	c.restore();
	c.begin();
	c.moveTo(0, h * 0.5 + 22.5);
	c.lineTo(barPos * w, h * 0.5 + 22.5);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(barPos * w, h * 0.5 + 15.5);
	c.lineTo(barPos * w - 10.5, h * 0.5 + 2.5);
	c.arcTo(15, 15, 0, 0, 1, barPos * w, h * 0.5 - 22.5);
	c.arcTo(15, 15, 0, 0, 1, barPos * w + 10.5, h * 0.5 + 2.5);
	c.close();
	c.fillAndStroke();

	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	var p = Math.round(barPos * 100);
	c.text(barPos * w, h * 0.5 - 9, 0, 0, p.toString() , mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeGmdlSliderDiscrete.prototype.cst.SHAPE_DISCRETE, mxShapeGmdlSliderDiscrete);

mxShapeGmdlSliderDiscrete.prototype.constraints = null;

Graph.handleFactory[mxShapeGmdlSliderDiscrete.prototype.cst.SHAPE_DISCRETE] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'barPos', 0.4))));

				return new mxPoint(bounds.x + barPos * bounds.width / 100, bounds.y + bounds.height / 2 + 22.5);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100;
			})];
			
	return handles;
};

//**********************************************************************************************************************************************************
//slider discrete with dots
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeGmdlSliderDiscreteDots(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeGmdlSliderDiscreteDots, mxShape);

mxShapeGmdlSliderDiscreteDots.prototype.cst = {
		SHAPE_DISCRETE_DOTS : 'mxgraph.gmdl.sliderDiscreteDots',
		BAR_POS : 'barPos',
		HANDLE_SIZE : 'handleSize'
};

mxShapeGmdlSliderDiscreteDots.prototype.customProperties = [
	{name:'barPos', dispName:'Handle Position', type:'int', min:0, defVal:'40'},
	{name:'handleSize', dispName:'Handle Size', type:'float', min:0, defVal:'10'}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeGmdlSliderDiscreteDots.prototype.paintVertexShape = function(c, x, y, w, h)
{
	
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(true);
};

mxShapeGmdlSliderDiscreteDots.prototype.background = function(c, x, y, w, h)
{
	var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDiscreteDots.prototype.cst.HANDLE_SIZE, '10'));
	var barPos = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDiscreteDots.prototype.cst.BAR_POS, '40')) / 100;
	var fontSize = parseFloat(mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '12'));
	var fontColor = mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, '#000000');
	var bright = mxUtils.getValue(this.style, 'bright', '1');

	barPos = Math.max(0, Math.min(1, barPos));

	c.save();
	c.setStrokeColor('#bebebe');
	c.begin();
	c.moveTo(0, h * 0.5 + 22.5);
	c.lineTo(w, h * 0.5 + 22.5);
	c.fillAndStroke();
	
	c.restore();

	if (barPos <= 0.1)
	{
		c.setFillColor('#bebebe');
	}
	
	c.begin();
	c.moveTo(0, h * 0.5 + 22.5);
	c.lineTo(barPos * w, h * 0.5 + 22.5);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(barPos * w, h * 0.5 + 15.5);
	c.lineTo(barPos * w - 10.5, h * 0.5 + 2.5);
	c.arcTo(15, 15, 0, 0, 1, barPos * w, h * 0.5 - 22.5);
	c.arcTo(15, 15, 0, 0, 1, barPos * w + 10.5, h * 0.5 + 2.5);
	c.close();
	c.fill();
	
	if (bright == '1')
	{
		c.setFillColor('#000000');
	}
	else
	{
		c.setFillColor('#ffffff');
	}
	
	c.ellipse(-1.5, h * 0.5 + 21, 3, 3);
	c.fill();
	
	c.ellipse(w * 0.2 - 1.5, h * 0.5 + 21, 3, 3);
	c.fill();
	
	c.ellipse(w * 0.4 - 1.5, h * 0.5 + 21, 3, 3);
	c.fill();
	
	c.ellipse(w * 0.6 - 1.5, h * 0.5 + 21, 3, 3);
	c.fill();
	
	c.ellipse(w * 0.8 - 1.5, h * 0.5 + 21, 3, 3);
	c.fill();
	
	c.ellipse(w - 1.5, h * 0.5 + 21, 3, 3);
	c.fill();
	
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	var p = Math.round(barPos * 100);
	c.text(barPos * w, h * 0.5 - 9, 0, 0, p.toString() , mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeGmdlSliderDiscreteDots.prototype.cst.SHAPE_DISCRETE_DOTS, mxShapeGmdlSliderDiscreteDots);

mxShapeGmdlSliderDiscreteDots.prototype.constraints = null;

Graph.handleFactory[mxShapeGmdlSliderDiscreteDots.prototype.cst.SHAPE_DISCRETE_DOTS] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'barPos', 0.4))));

				return new mxPoint(bounds.x + barPos * bounds.width / 100, bounds.y + bounds.height / 2 + 22.5);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(0.05 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 0.05;
			})];
			
	return handles;
};

//**********************************************************************************************************************************************************
//Progress Bar
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeGmdlProgressBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx1 = 0.8;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeGmdlProgressBar, mxShape);

mxShapeGmdlProgressBar.prototype.cst = {
		PROGRESS_BAR : 'mxgraph.gmdl.progressBar'
};

mxShapeGmdlProgressBar.prototype.customProperties = [
	{name:'dx1', dispName:'Handle Position', type:'int', min:0, defVal:0.8}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeGmdlProgressBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var dx1 = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx1', this.dx1))));

	c.translate(x, y);
	
	c.save();
	c.setStrokeColor('#aaaaaa');
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w , h * 0.5);
	c.stroke();
	
	c.restore();
	c.setShadow(false);
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(dx1, h * 0.5);
	c.stroke();
	
};

mxCellRenderer.registerShape(mxShapeGmdlProgressBar.prototype.cst.PROGRESS_BAR, mxShapeGmdlProgressBar);

mxShapeGmdlProgressBar.prototype.constraints = null;

Graph.handleFactory[mxShapeGmdlProgressBar.prototype.cst.PROGRESS_BAR] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx1'], function(bounds)
			{
				var dx1 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dx1', this.dx1))));

				return new mxPoint(bounds.x + dx1 * bounds.width, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx1'] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100;
			})];

	var handle2 = Graph.createHandle(state, ['dx2'], function(bounds)
			{
				var dx2 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx1))));

				return new mxPoint(bounds.x + dx2 * bounds.width, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx2'] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100;
			});
	
	handles.push(handle2);

	return handles;
};


/**
 * $Id: mxIBM.js,v 1.0 2018/08/21 13:05:39 mate Exp $
 * Copyright (c) 2006-2020, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Box
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIBMBox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIBMBox, mxShape);

mxShapeIBMBox.prototype.cst = {
		IBM_BOX : 'mxgraph.ibm.box'
};

mxShapeIBMBox.prototype.customProperties = [
	{name: 'prType', dispName: 'Box Type', defVal: 'cloud', type: 'enum', 
		enumList: [{val: 'cloud', dispName: 'IBM Cloud'}, 
				   {val: 'vpc', dispName: 'VPC'}, 
				   {val: 'region', dispName: 'Region'}, 
				   {val: 'zone', dispName: 'Zone'}, 
				   {val: 'subnet', dispName: 'Subnet ACL'}, 
				   {val: 'public', dispName: 'Public Network'}, 
				   {val: 'enterprise', dispName: 'Enterprise Network'}, 
				   {val: 'classic', dispName: 'Classic Infrastructure'}]}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIBMBox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.begin();
	c.rect(0,0, w, h);
	c.fillAndStroke();
	
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', 'none');
	c.setFillColor(strokeColor);
	c.setStrokeColor('none');
	
	var prType = mxUtils.getValue(this.state.style, 'prType', '');
	
	switch(prType)
	{
		case 'cloud':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.ibm.cloudtag');
			bgSt1.drawShape(c, this, 0, 0, 25, 25);
			break;
		case 'vpc':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.ibm.vpctag');
			bgSt1.drawShape(c, this, 0, 0, 25, 25);
			break;
		case 'region':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.ibm.regiontag');
			bgSt1.drawShape(c, this, 0, 0, 25, 25);
			break;
		case 'zone':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.ibm.zonetag');
			bgSt1.drawShape(c, this, 0, 0, 25, 25);
			break;
		case 'subnet':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.ibm.subnettag');
			bgSt1.drawShape(c, this, 0, 0, 25, 25);
			break;
		case 'public':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.ibm.publictag');
			bgSt1.drawShape(c, this, 0, 0, 25, 25);
			break;
		case 'enterprise':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.ibm.enterprisetag');
			bgSt1.drawShape(c, this, 0, 0, 25, 25);
			break;
		case 'classic':
			var bgSt1 = mxStencilRegistry.getStencil('mxgraph.ibm.classictag');
			bgSt1.drawShape(c, this, 0, 0, 25, 25);
			break;
		default:
			break;
	}
};

mxCellRenderer.registerShape(mxShapeIBMBox.prototype.cst.IBM_BOX, mxShapeIBMBox);

/**
 * $Id: mxInfographic.js,v 1.5 2016/04/1 12:32:06 mate Exp $
 * Copyright (c) 2006-2018, JGraph Ltd
 */
//**********************************************************************************************************************************************************
//Numbered entry (vertical)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicNumEntryVert(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicNumEntryVert, mxActor);

mxShapeInfographicNumEntryVert.prototype.cst = {NUM_ENTRY_VERT : 'mxgraph.infographic.numberedEntryVert'};

mxShapeInfographicNumEntryVert.prototype.customProperties = [
	{name:'dy', dispName:'Circle Size', min:0, defVal: 25}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicNumEntryVert.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));

	var inset = 5;

	var d = Math.min(dy, w - 2 * inset, h - inset);
	
	c.ellipse(w * 0.5 - d * 0.5, 0, d, d);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(0, d * 0.5);
	c.lineTo(w * 0.5 - d * 0.5 - inset, d * 0.5);
	c.arcTo(d * 0.5 + inset, d * 0.5 + inset, 0, 0, 0, w * 0.5 + d * 0.5 + inset, d * 0.5);
	c.lineTo(w, d * 0.5);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeInfographicNumEntryVert.prototype.cst.NUM_ENTRY_VERT, mxShapeInfographicNumEntryVert);

Graph.handleFactory[mxShapeInfographicNumEntryVert.prototype.cst.NUM_ENTRY_VERT] = function(state)
{
	var handles = [Graph.createHandle(state, ['dy'], function(bounds)
	{
		var dy = Math.max(0, Math.min(bounds.width, bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + bounds.width / 2, bounds.y + dy);
	}, function(bounds, pt)
	{
		this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height, bounds.width, pt.y - bounds.y))) / 100;
	})];
			
	return handles;
};

mxShapeInfographicNumEntryVert.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var inset = 5;
	var d = Math.min(dy, w - 2 * inset, h - inset);
	
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, d * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, 0, d * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, 0, d * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false, null, 0, d * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Bending Arch
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicBendingArch(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.startAngle = 0.25;
	this.endAngle = 0.75;
	this.arcWidth = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicBendingArch, mxActor);

mxShapeInfographicBendingArch.prototype.cst = {BENDING_ARCH : 'mxgraph.infographic.bendingArch'};

mxShapeInfographicBendingArch.prototype.customProperties = [
	{name:'startAngle', dispName:'Start Angle', min:0, max:1, defVal: 0.75},
	{name:'endAngle', dispName:'End Angle', min:0, max:1, defVal: 0.25},
	{name:'arcWidth', dispName:'Arc Width', min:0, max:1, defVal: 0.25}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicBendingArch.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'startAngle', this.startAngle))));
	var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'endAngle', this.endAngle))));
	var arcWidth = 1 - Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arcWidth', this.arcWidth))));
	var rx = w * 0.5;
	var ry = h * 0.5;
	var rx2 = rx * arcWidth;
	var ry2 = ry * arcWidth;
	
	var startX = rx + Math.sin(startAngle) * rx;
	var startY = ry - Math.cos(startAngle) * ry;
	var innerStartX = rx + Math.sin(startAngle) * rx2;
	var innerStartY = ry - Math.cos(startAngle) * ry2;
	var endX = rx + Math.sin(endAngle) * rx;
	var endY = ry - Math.cos(endAngle) * ry;
	var innerEndX = rx + Math.sin(endAngle) * rx2;
	var innerEndY = ry - Math.cos(endAngle) * ry2;
	
	var angDiff = endAngle - startAngle;
	
	if (angDiff < 0)
	{
		angDiff = angDiff + Math.PI * 2;
	}
		
	var bigArc = 0;
	
	if (angDiff > Math.PI)
	{
		bigArc = 1;
	}

	var rx3 = rx2 - 5;
	var ry3 = ry2 - 5;

	c.ellipse(w * 0.5 - rx3, h * 0.5 - ry3, 2 * rx3, 2 * ry3);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(startX, startY);
	c.arcTo(rx, ry, 0, bigArc, 1, endX, endY);
	c.lineTo(innerEndX, innerEndY);
	c.arcTo(rx2, ry2, 0, bigArc, 0, innerStartX, innerStartY);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeInfographicBendingArch.prototype.cst.BENDING_ARCH, mxShapeInfographicBendingArch);

mxShapeInfographicBendingArch.prototype.constraints = null;

Graph.handleFactory[mxShapeInfographicBendingArch.prototype.cst.BENDING_ARCH] = function(state)
{
	var handles = [Graph.createHandle(state, ['startAngle'], function(bounds)
	{
		var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'startAngle', this.startAngle))));

		return new mxPoint(bounds.x + bounds.width * 0.5 + Math.sin(startAngle) * bounds.width * 0.5, bounds.y + bounds.height * 0.5 - Math.cos(startAngle) * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * 0.5) / (bounds.width * 0.5)))) / 100;
		var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * 0.5) / (bounds.height * 0.5)))) / 100;
		
		var res =  0.5 * Math.atan2(handleX, handleY) / Math.PI;
		
		if (res < 0)
		{
			res = 1 + res;
		}

		this.state.style['startAngle'] = res;
		
	})];

	var handle2 = Graph.createHandle(state, ['endAngle'], function(bounds)
	{
		var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'endAngle', this.endAngle))));

		return new mxPoint(bounds.x + bounds.width * 0.5 + Math.sin(endAngle) * bounds.width * 0.5, bounds.y + bounds.height * 0.5 - Math.cos(endAngle) * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * 0.5) / (bounds.width * 0.5)))) / 100;
		var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * 0.5) / (bounds.height * 0.5)))) / 100;
		
		var res =  0.5 * Math.atan2(handleX, handleY) / Math.PI;
		
		if (res < 0)
		{
			res = 1 + res;
		}
		
		this.state.style['endAngle'] = res;
	});
	
	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['arcWidth'], function(bounds)
	{
		var arcWidth = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'arcWidth', this.arcWidth))));

		return new mxPoint(bounds.x + bounds.width / 2, bounds.y + arcWidth * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		this.state.style['arcWidth'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, (pt.y - bounds.y) / (bounds.height * 0.5)))) / 100;
	});
			
	handles.push(handle3);
	
	return handles;
};

//**********************************************************************************************************************************************************
//Parallelogram
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicParallelogram(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 10;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicParallelogram, mxActor);

mxShapeInfographicParallelogram.prototype.cst = {PARALLELOGRAM : 'mxgraph.infographic.parallelogram'};

mxShapeInfographicParallelogram.prototype.customProperties = [
	{name:'dx', dispName:'Angle', min:0, defVal: 15}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicParallelogram.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w * 0.5, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));

	c.begin();
	c.moveTo(0, h);
	c.lineTo(2 * dx, 0);
	c.lineTo(w, 0);
	c.lineTo(w - 2 * dx, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeInfographicParallelogram.prototype.cst.PARALLELOGRAM, mxShapeInfographicParallelogram);

Graph.handleFactory[mxShapeInfographicParallelogram.prototype.cst.PARALLELOGRAM] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + dx, bounds.y + bounds.height / 2);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width / 2, pt.x - bounds.x))) / 100;
	})];
			
	return handles;
};

mxShapeInfographicParallelogram.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w * 0.5, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var w2 = w - 2 * dx;

	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2 * dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2 * dx + w2 * 0.5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - 2 * dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, w - dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w2 * 0.5, h));

	return (constr);
};

//**********************************************************************************************************************************************************
//Ribbon Rolled
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicRibbonRolled(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 185;
	this.dy = 15;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicRibbonRolled, mxActor);

mxShapeInfographicRibbonRolled.prototype.cst = {RIBBON_ROLLED : 'mxgraph.infographic.ribbonRolled'};

mxShapeInfographicRibbonRolled.prototype.customProperties = [
	{name:'dx', dispName:'Roll Length', min:0, defVal: 185},
	{name:'dy', dispName:'Ribbon Width', min:0, defVal: 15}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicRibbonRolled.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));

	c.begin();
	c.moveTo(0, dy);
	c.lineTo(dx, 0);
	c.lineTo(dx, dy);
	c.lineTo(w, dy);
	c.lineTo(w, h - dy);
	c.lineTo(w - dx, h);
	c.lineTo(w - dx, h - dy);
	c.lineTo(0, h - dy);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	c.setFillAlpha('0.2');
	c.setFillColor('#000000');
	c.begin();
	c.moveTo(0, dy);
	c.lineTo(dx, 0);
	c.lineTo(dx, dy);
	c.close();
	c.moveTo(w, h - dy);
	c.lineTo(w - dx, h);
	c.lineTo(w - dx, h - dy);
	c.close();
	c.fill();
	
	c.begin();
	c.moveTo(0, dy);
	c.lineTo(dx, 0);
	c.lineTo(dx, dy);
	c.lineTo(w, dy);
	c.lineTo(w, h - dy);
	c.lineTo(w - dx, h);
	c.lineTo(w - dx, h - dy);
	c.lineTo(0, h - dy);
	c.close();
	c.stroke();
	
};

mxCellRenderer.registerShape(mxShapeInfographicRibbonRolled.prototype.cst.RIBBON_ROLLED, mxShapeInfographicRibbonRolled);

Graph.handleFactory[mxShapeInfographicRibbonRolled.prototype.cst.RIBBON_ROLLED] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + dx, bounds.y + dy);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
		this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, pt.y - bounds.y))) / 100;
	})];
			
	return handles;
};

mxShapeInfographicRibbonRolled.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var h2 = h - dy;
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h2));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false, null, 0, h2));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, 0, h2));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false, null, 0, h2));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, 0, -dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Ribbon Double Folded
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicRibbonDoubleFolded(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 25;
	this.dy = 15;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicRibbonDoubleFolded, mxActor);

mxShapeInfographicRibbonDoubleFolded.prototype.cst = {RIBBON_DOUBLE_FOLDED : 'mxgraph.infographic.ribbonDoubleFolded'};

mxShapeInfographicRibbonDoubleFolded.prototype.customProperties = [
	{name:'dx', dispName:'Fold Length', min:0, defVal: 25},
	{name:'dy', dispName:'Ribbon Width', min:0, defVal: 15}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicRibbonDoubleFolded.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));

	c.begin();
	c.moveTo(0, dy);
	c.lineTo(dx, 0);
	c.lineTo(dx, dy);
	c.lineTo(w, dy);
	c.lineTo(w, h - dy);
	c.lineTo(w - dx, h);
	c.lineTo(w - dx, h - dy);
	c.lineTo(0, h - dy);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	c.setFillAlpha('0.2');
	c.setFillColor('#000000');
	c.begin();
	c.moveTo(0, dy);
	c.lineTo(dx, 0);
	c.lineTo(dx, h - 2 * dy);
	c.lineTo(0, h - dy);
	c.close();
	c.moveTo(w, h - dy);
	c.lineTo(w - dx, h);
	c.lineTo(w - dx, h - dy);
	c.close();
	c.fill();
	
	c.begin();
	c.moveTo(0, dy);
	c.lineTo(dx, 0);
	c.lineTo(dx, dy);
	c.lineTo(w, dy);
	c.lineTo(w, h - dy);
	c.lineTo(w - dx, h);
	c.lineTo(w - dx, h - dy);
	c.lineTo(0, h - dy);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeInfographicRibbonDoubleFolded.prototype.cst.RIBBON_DOUBLE_FOLDED, mxShapeInfographicRibbonDoubleFolded);

Graph.handleFactory[mxShapeInfographicRibbonDoubleFolded.prototype.cst.RIBBON_DOUBLE_FOLDED] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + dx, bounds.y + dy);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
		this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, pt.y - bounds.y))) / 100;
	})];
			
	return handles;
};

mxShapeInfographicRibbonDoubleFolded.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, 0, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false, null, 0, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, 0, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false, null, 0, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Ribbon Front Folded
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicRibbonFrontFolded(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
	this.dy = 0.5;
	this.notch = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicRibbonFrontFolded, mxActor);

mxShapeInfographicRibbonFrontFolded.prototype.cst = {RIBBON_FRONT_FOLDED : 'mxgraph.infographic.ribbonFrontFolded'};

mxShapeInfographicRibbonFrontFolded.prototype.customProperties = [
	{name:'dx', dispName:'Fold Length', min:0, defVal: 25},
	{name:'dy', dispName:'Ribbon Width', min:0, defVal: 15},
	{name:'notch', dispName:'Notch', min:0, defVal: 15}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicRibbonFrontFolded.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var notch = Math.max(0, Math.min(w - dx, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));

	c.begin();
	c.moveTo(0, dy);
	c.lineTo(dx, 0);
	c.lineTo(dx, dy);
	c.lineTo(w, dy);
	c.lineTo(w - notch, (h - dy) / 2 + dy);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	c.setFillAlpha('0.2');
	c.setFillColor('#000000');
	c.begin();
	c.moveTo(0, dy);
	c.lineTo(dx, 0);
	c.lineTo(dx, h - dy);
	c.lineTo(0, h);
	c.close();
	c.fill();
	
	c.begin();
	c.moveTo(0, dy);
	c.lineTo(dx, 0);
	c.lineTo(dx, dy);
	c.lineTo(w, dy);
	c.lineTo(w - notch, (h - dy) / 2 + dy);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeInfographicRibbonFrontFolded.prototype.cst.RIBBON_FRONT_FOLDED, mxShapeInfographicRibbonFrontFolded);

Graph.handleFactory[mxShapeInfographicRibbonFrontFolded.prototype.cst.RIBBON_FRONT_FOLDED] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + dx, bounds.y + dy);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
		this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, pt.y - bounds.y))) / 100;
	})];

	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
	{
		var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
		var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

		return new mxPoint(bounds.x + bounds.width - notch, bounds.y + dy + (bounds.height - dy) * 0.5);
	}, function(bounds, pt)
	{
		this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.width, (bounds.width + bounds.x - pt.x)))) / 100;
	});
			
	handles.push(handle2);

	return handles;
};

mxShapeInfographicRibbonFrontFolded.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var notch = Math.max(0, Math.min(w - dx, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - notch, (h + dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h + dy) * 0.5));

	return (constr);
};

//**********************************************************************************************************************************************************
//Ribbon Back Folded
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicRibbonBackFolded(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
	this.dy = 0.5;
	this.notch = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicRibbonBackFolded, mxActor);

mxShapeInfographicRibbonBackFolded.prototype.cst = {RIBBON_BACK_FOLDED : 'mxgraph.infographic.ribbonBackFolded'};

mxShapeInfographicRibbonBackFolded.prototype.customProperties = [
	{name:'dx', dispName:'Fold Length', min:0, defVal: 25},
	{name:'dy', dispName:'Ribbon Width', min:0, defVal: 15},
	{name:'notch', dispName:'Notch', min:0, defVal: 15}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicRibbonBackFolded.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var notch = Math.max(0, Math.min(w - dx, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));

	c.begin();
	c.moveTo(0, dy);
	c.lineTo(dx, 0);
	c.lineTo(dx, dy);
	c.lineTo(w, dy);
	c.lineTo(w - notch, (h - dy) / 2 + dy);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	c.setFillAlpha('0.2');
	c.setFillColor('#000000');
	c.begin();
	c.moveTo(0, dy);
	c.lineTo(dx, 0);
	c.lineTo(dx, dy);
	c.close();
	c.fill();
	
	c.begin();
	c.moveTo(0, dy);
	c.lineTo(dx, 0);
	c.lineTo(dx, dy);
	c.lineTo(w, dy);
	c.lineTo(w - notch, (h - dy) / 2 + dy);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeInfographicRibbonBackFolded.prototype.cst.RIBBON_BACK_FOLDED, mxShapeInfographicRibbonBackFolded);

Graph.handleFactory[mxShapeInfographicRibbonBackFolded.prototype.cst.RIBBON_BACK_FOLDED] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + dx, bounds.y + dy);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
		this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, pt.y - bounds.y))) / 100;
	})];

	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
	{
		var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
		var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

		return new mxPoint(bounds.x + bounds.width - notch, bounds.y + dy + (bounds.height - dy) * 0.5);
	}, function(bounds, pt)
	{
		this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.width, (bounds.width + bounds.x - pt.x)))) / 100;
	});
			
	handles.push(handle2);
	
	return handles;
};

mxShapeInfographicRibbonBackFolded.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var notch = Math.max(0, Math.min(w - dx, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, 0, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - notch, (h + dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h + dy) * 0.5));

	return (constr);
};

//**********************************************************************************************************************************************************
//Banner
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicBanner(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
	this.dy = 0.5;
	this.notch = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicBanner, mxActor);

mxShapeInfographicBanner.prototype.cst = {BANNER : 'mxgraph.infographic.banner'};

mxShapeInfographicBanner.prototype.customProperties = [
	{name:'dx', dispName:'Fold Length', min:0, defVal: 25},
	{name:'dy', dispName:'Ribbon Width', min:0, defVal: 15},
	{name:'notch', dispName:'Notch', min:0, defVal: 15}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicBanner.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w / 2, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));

	dx = Math.min(w / 2 - 2 * dy, dx);
	
	notch = Math.min(dx, notch);
	
	c.begin();
	c.moveTo(0, dy);
	c.lineTo(dx, dy);
	c.lineTo(dx, 0);
	c.lineTo(w - dx, 0);
	c.lineTo(w - dx, dy);
	c.lineTo(w, dy);
	c.lineTo(w - notch, (h - dy) * 0.5 + dy);
	c.lineTo(w, h);
	c.lineTo(w - dx - 2 * dy, h);
	c.lineTo(w - dx - 2 * dy, h - dy);
	c.lineTo(dx + 2 * dy, h - dy);
	c.lineTo(dx + 2 * dy, h);
	c.lineTo(0, h);
	c.lineTo(notch, (h - dy) * 0.5 + dy);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	c.setFillAlpha('0.2');
	c.setFillColor('#000000');
	c.begin();
	c.moveTo(0,dy);
	c.lineTo(dx, dy);
	c.lineTo(dx, h - dy);
	c.lineTo(dx + 2 * dy, h);
	c.lineTo(0, h);
	c.lineTo(notch, (h - dy) * 0.5 + dy);
	c.close();
	c.moveTo(w,dy);
	c.lineTo(w - dx, dy);
	c.lineTo(w - dx, h - dy);
	c.lineTo(w - dx - 2 * dy, h);
	c.lineTo(w, h);
	c.lineTo(w - notch, (h - dy) * 0.5 + dy);
	c.close();
	c.fill();
	
	c.setFillAlpha('0.4');
	c.begin();
	c.moveTo(dx, h - dy);
	c.lineTo(dx + 2 * dy, h - dy);
	c.lineTo(dx + 2 * dy, h);
	c.close();
	c.moveTo(w - dx, h - dy);
	c.lineTo(w - dx - 2 * dy, h - dy);
	c.lineTo(w - dx - 2 * dy, h);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeInfographicBanner.prototype.cst.BANNER, mxShapeInfographicBanner);

Graph.handleFactory[mxShapeInfographicBanner.prototype.cst.BANNER] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + bounds.width - dx, bounds.y + dy);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width / 2, bounds.x + bounds.width - pt.x))) / 100;
		this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, pt.y - bounds.y))) / 100;
	})];
			
	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
	{
		var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
		var dx = Math.max(0, Math.min(bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var notch = Math.max(0, Math.min(dx, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

		return new mxPoint(bounds.x + bounds.width - notch, bounds.y + dy + (bounds.height - dy) * 0.5);
	}, function(bounds, pt)
	{
		this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.width, (bounds.width + bounds.x - pt.x)))) / 100;
	});
			
	handles.push(handle2);
	
	return handles;
};

mxShapeInfographicBanner.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w / 2, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	dx = Math.min(w / 2 - 2 * dy, dx);
	notch = Math.min(dx, notch);
	var w2 = w - 2 * dx;

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx + w2 * 0.25, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx + w2 * 0.5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx + w2 * 0.75, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx + w2, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx + w2, (h - dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx + w2, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx + w2 * 0.75, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx + w2 * 0.5, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx + w2 * 0.25, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, (h - dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, notch, (h + dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - notch, (h + dy) * 0.5));

	return (constr);
};

//**********************************************************************************************************************************************************
//Circular Callout
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicCircularCallout(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicCircularCallout, mxActor);

mxShapeInfographicCircularCallout.prototype.cst = {CIRCULAR_CALLOUT : 'mxgraph.infographic.circularCallout'};

mxShapeInfographicCircularCallout.prototype.customProperties = [
	{name:'dy', dispName:'Ribbon Width', min:0, defVal: 15}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicCircularCallout.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = Math.max(0, Math.min(h * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	
	var rx = Math.max(0, Math.min(w * 0.5, w * 0.5 - dy));
	var ry = Math.max(0, Math.min(h * 0.5, h * 0.5 - dy));
	
	c.begin();
	c.moveTo(w, h * 0.5);
	c.arcTo(w * 0.5, h * 0.5, 0, 0, 1, w * 0.5, h);
	c.arcTo(w * 0.5, h * 0.5, 0, 0, 1, 0, h * 0.5);
	c.arcTo(w * 0.5, h * 0.5, 0, 0, 1, w * 0.5, 0);
	c.lineTo(w, 0);
	c.close();
	c.moveTo(w * 0.5, dy);
	c.arcTo(rx, ry, 0, 0, 0, w * 0.5 - rx, h * 0.5);
	c.arcTo(rx, ry, 0, 0, 0, w * 0.5, h * 0.5 + ry);
	c.arcTo(rx, ry, 0, 0, 0, w * 0.5 + rx, h * 0.5);
	c.arcTo(rx, ry, 0, 0, 0, w * 0.5, h * 0.5 - ry);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeInfographicCircularCallout.prototype.cst.CIRCULAR_CALLOUT, mxShapeInfographicCircularCallout);

Graph.handleFactory[mxShapeInfographicCircularCallout.prototype.cst.CIRCULAR_CALLOUT] = function(state)
{
	var handles = [Graph.createHandle(state, ['dy'], function(bounds)
	{
		var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + bounds.width * 0.5, bounds.y + dy);
	}, function(bounds, pt)
	{
		this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, pt.y - bounds.y))) / 100;
	})];
			
	return handles;
};

mxShapeInfographicCircularCallout.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = Math.max(0, Math.min(h * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var rx = Math.max(0, Math.min(w * 0.5, w * 0.5 - dy));
	var ry = Math.max(0, Math.min(h * 0.5, h * 0.5 - dy));
	
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.855, 0.855), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.145, 0.855), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.145, 0.145), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Shaded triangle
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicShadedTriangle(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicShadedTriangle, mxActor);

mxShapeInfographicShadedTriangle.prototype.cst = {SHADED_TRIANGLE : 'mxgraph.infographic.shadedTriangle'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicShadedTriangle.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(0, h);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	
	c.setFillColor('#ffffff');
	c.setFillAlpha('0.2');
	
	c.begin();
	c.moveTo(0, h);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w * 0.5, h * 0.67);
	c.close();
	c.fill();
	
	c.setFillColor('#000000');

	c.begin();
	c.moveTo(w, h);
	c.lineTo(w * 0.5, h * 0.67);
	c.lineTo(w * 0.5, 0);
	c.close();
	c.fill();
	
	c.begin();
	c.moveTo(0, h);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeInfographicShadedTriangle.prototype.cst.SHADED_TRIANGLE, mxShapeInfographicShadedTriangle);

mxShapeInfographicShadedTriangle.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Shaded pyramid
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicShadedPyramid(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicShadedPyramid, mxActor);

mxShapeInfographicShadedPyramid.prototype.cst = {SHADED_PYRAMID : 'mxgraph.infographic.shadedPyramid'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicShadedPyramid.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var h1 = Math.max(h - w * 0.3, 0);
	c.begin();
	c.moveTo(0, h1);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h1);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	
	c.setFillColor('#ffffff');
	c.setFillAlpha('0.2');
	
	c.begin();
	c.moveTo(0, h1);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();
	
	c.setFillColor('#000000');

	c.begin();
	c.moveTo(w, h1);
	c.lineTo(w * 0.5, h);
	c.lineTo(w * 0.5, 0);
	c.close();
	c.fill();
	
	c.begin();
	c.moveTo(0, h1);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h1);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeInfographicShadedPyramid.prototype.cst.SHADED_PYRAMID, mxShapeInfographicShadedPyramid);

mxShapeInfographicShadedPyramid.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var h1 = Math.max(h - w * 0.3, 0);
	
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.75, h1 * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.75, (h + h1) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.25, (h + h1) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.25, h1 * 0.5));

	return (constr);
};

//**********************************************************************************************************************************************************
//Pyramid step
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicPyramidStep(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicPyramidStep, mxActor);

mxShapeInfographicPyramidStep.prototype.cst = {PYRAMID_STEP : 'mxgraph.infographic.pyramidStep'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicPyramidStep.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var h1 = Math.max(w * 0.1, 0);
	c.begin();
	c.moveTo(0, h1);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h1);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	
	c.setFillColor('#ffffff');
	c.setFillAlpha('0.2');
	
	c.begin();
	c.moveTo(0, h1);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h);
	c.close();
	c.fill();
	
	c.setFillColor('#000000');

	c.begin();
	c.moveTo(w, h1);
	c.lineTo(w, h);
	c.lineTo(w * 0.5, h);
	c.lineTo(w * 0.5, 0);
	c.close();
	c.fill();
	
	c.begin();
	c.moveTo(0, h1);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h1);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeInfographicPyramidStep.prototype.cst.PYRAMID_STEP, mxShapeInfographicPyramidStep);

mxShapeInfographicPyramidStep.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var h1 = Math.max(w * 0.1, 0);
	
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.75, h1 * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h1));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h1 + (h - h1) * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h1 + (h - h1) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h1 + (h - h1) * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.75, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.25, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h1 + (h - h1) * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h1 + (h - h1) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h1 + (h - h1) * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.25, h1 * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h1));
	return (constr);
};

//**********************************************************************************************************************************************************
//Cylinder
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicCylinder(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicCylinder, mxActor);

mxShapeInfographicCylinder.prototype.cst = {CYLINDER : 'mxgraph.infographic.cylinder'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicCylinder.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var dy = 20;
	var rx = w * 0.5;
	var ry = dy * 0.5;
	
	c.begin();
	c.moveTo(0, dy * 0.5);
	c.arcTo(rx, ry, 0, 0, 1, w, ry);
	c.lineTo(w, h - ry);
	c.arcTo(rx, ry, 0, 0, 1, 0, h - ry);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	c.setGradient('#000000', '#ffffff', 0, 0, w, h, mxConstants.DIRECTION_EAST, 0.4, 0.4);
	
	c.begin();
	c.moveTo(0, dy * 0.5);
	c.arcTo(rx, ry, 0, 0, 0, w, ry);
	c.lineTo(w, h - ry);
	c.arcTo(rx, ry, 0, 0, 1, 0, h - ry);
	c.close();
	c.fill();

	c.begin();
	c.moveTo(0, dy * 0.5);
	c.arcTo(rx, ry, 0, 0, 1, w, ry);
	c.lineTo(w, h - ry);
	c.arcTo(rx, ry, 0, 0, 1, 0, h - ry);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeInfographicCylinder.prototype.cst.CYLINDER, mxShapeInfographicCylinder);

mxShapeInfographicCylinder.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = 20;
	var rx = w * 0.5;
	var ry = dy * 0.5;
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, dy * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, dy * 0.5 + (h - dy) * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, dy * 0.5 + (h - dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, dy * 0.5 + (h - dy) * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h - dy * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - dy * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy * 0.5 + (h - dy) * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy * 0.5 + (h - dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dy * 0.5 + (h - dy) * 0.25));

	return (constr);
};

//**********************************************************************************************************************************************************
//Circular Callout 2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicCircularCallout2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicCircularCallout2, mxActor);

mxShapeInfographicCircularCallout2.prototype.cst = {CIRCULAR_CALLOUT_2 : 'mxgraph.infographic.circularCallout2'};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicCircularCallout2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, 'none');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, 'none');
	c.setFillColor(strokeColor);

	var rx = Math.max(0, Math.min(w * 0.5, h * 0.4, h * 0.5 - 7));

	c.begin();
	c.moveTo(w * 0.5 - 2, 2.15 * rx);
	c.arcTo(rx * 0.23, rx * 0.23, 0, 0, 0, w * 0.5 - rx * 0.2, rx * 1.97);
	c.arcTo(rx, rx, 0, 0, 1, w * 0.5 - rx, rx);
	c.arcTo(rx, rx, 0, 0, 1, w * 0.5, 0);
	c.arcTo(rx, rx, 0, 0, 1, w * 0.5 + rx, rx);
	c.arcTo(rx, rx, 0, 0, 1, w * 0.5 + rx * 0.2, rx * 1.97);
	c.arcTo(rx * 0.23, rx * 0.23, 0, 0, 0, w * 0.5 + 2, 2.15 * rx);

	var rxMin = Math.max(rx * 0.1, 6);
	
	if (rx * 0.04 > 4)
	{
		c.lineTo(w * 0.5 + 2, h - rx * 0.22);
		c.arcTo(rx * 0.05, rx * 0.05, 0, 0, 0, w * 0.5 + rx * 0.04, h - rx * 0.19);
	}
	else
	{
		c.lineTo(w * 0.5 + 2, h - 2 * rxMin);
	}
	
	c.arcTo(rxMin, rxMin, 0, 0, 1, w * 0.5 + rxMin, h - rxMin);
	c.arcTo(rxMin, rxMin, 0, 0, 1, w * 0.5, h);
	c.arcTo(rxMin, rxMin, 0, 0, 1, w * 0.5 - rxMin, h - rxMin);

	if (rx * 0.04 > 4)
	{
		c.arcTo(rxMin, rxMin, 0, 0, 1, w * 0.5 - rx * 0.04, h - rx * 0.19);
		c.arcTo(rxMin * 0.5, rxMin * 0.5, 0, 0, 0, w * 0.5 - 2, h - rx * 0.22);
	}
	else
	{
		c.arcTo(rxMin, rxMin, 0, 0, 1, w * 0.5 - 2, h - 2 * rxMin);
	}
	
	c.close();
	c.moveTo(w * 0.5, rx * 0.2);
	c.arcTo(rx * 0.8, rx * 0.8, 0, 0, 0, w * 0.5 - rx * 0.8, rx * 0.8);
	c.arcTo(rx * 0.8, rx * 0.8, 0, 0, 0, w * 0.5, rx * 1.8);
	c.arcTo(rx * 0.8, rx * 0.8, 0, 0, 0, w * 0.5 + rx * 0.8, rx * 0.8);
	c.arcTo(rx * 0.8, rx * 0.8, 0, 0, 0, w * 0.5, rx * 0.2);
	c.close();
	c.moveTo(w * 0.5, h - rxMin * 1.75);
	c.arcTo(rxMin * 0.75, rxMin * 0.75, 0, 0, 0, w * 0.5 - rxMin * 0.75, h - rxMin );
	c.arcTo(rxMin * 0.75, rxMin * 0.75, 0, 0, 0, w * 0.5, h - rxMin * 0.25);
	c.arcTo(rxMin * 0.75, rxMin * 0.75, 0, 0, 0, w * 0.5 + rxMin * 0.75, h - rxMin);
	c.arcTo(rxMin * 0.75, rxMin * 0.75, 0, 0, 0, w * 0.5, h - rxMin * 1.75);
	c.close();
	c.fill();
	
	c.setFillColor(fillColor);
	c.setShadow(false);
	
	c.begin();
	c.moveTo(w * 0.5, rx * 0.2);
	c.arcTo(rx * 0.8, rx * 0.8, 0, 0, 0, w * 0.5 - rx * 0.8, rx * 0.8);
	c.arcTo(rx * 0.8, rx * 0.8, 0, 0, 0, w * 0.5, rx * 1.8);
	c.arcTo(rx * 0.8, rx * 0.8, 0, 0, 0, w * 0.5 + rx * 0.8, rx * 0.8);
	c.arcTo(rx * 0.8, rx * 0.8, 0, 0, 0, w * 0.5, rx * 0.2);
	c.close();
	c.moveTo(w * 0.5, h - rxMin * 1.75);
	c.arcTo(rxMin * 0.75, rxMin * 0.75, 0, 0, 0, w * 0.5 - rxMin * 0.75, h - rxMin );
	c.arcTo(rxMin * 0.75, rxMin * 0.75, 0, 0, 0, w * 0.5, h - rxMin * 0.25);
	c.arcTo(rxMin * 0.75, rxMin * 0.75, 0, 0, 0, w * 0.5 + rxMin * 0.75, h - rxMin);
	c.arcTo(rxMin * 0.75, rxMin * 0.75, 0, 0, 0, w * 0.5, h - rxMin * 1.75);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeInfographicCircularCallout2.prototype.cst.CIRCULAR_CALLOUT_2, mxShapeInfographicCircularCallout2);

mxShapeInfographicCircularCallout2.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var rx = Math.max(0, Math.min(w * 0.5, h * 0.4, h * 0.5 - 7));

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - rx, rx));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + rx, rx));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Banner Single Fold
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicBannerSingleFold(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
	this.dy = 0.5;
	this.dx2 = 0.5;
	this.notch = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicBannerSingleFold, mxActor);

mxShapeInfographicBannerSingleFold.prototype.cst = {BANNER_SINGLE_FOLD : 'mxgraph.infographic.bannerSingleFold'};

mxShapeInfographicBannerSingleFold.prototype.customProperties = [
	{name:'dx', dispName: 'Fold Length', type:'float', defVal:32, min:0},
	{name:'dy', dispName: 'Banner Width', type:'float', defVal:17, min:0},
	{name:'notch', dispName: 'Notch', type:'float', defVal:15, min:0}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicBannerSingleFold.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));

	dx = Math.min(w - 2 * dy, dx);

	var dx2 = Math.max(0, Math.min(w - dx - 2 * dy, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));

	notch = Math.min(dx, notch);
	
	c.begin();
	c.moveTo(dx2, 0);
	c.lineTo(w - dx, 0);
	c.lineTo(w - dx, dy);
	c.lineTo(w, dy);
	c.lineTo(w - notch, (h - dy) * 0.5 + dy);
	c.lineTo(w, h);
	c.lineTo(w - dx - 2 * dy, h);
	c.lineTo(w - dx - 2 * dy, h - dy);
	c.lineTo(dx2, h - dy);
	c.lineTo(0, (h - dy) * 0.5);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	c.setFillAlpha('0.05');
	c.setFillColor('#000000');
	c.begin();
	c.moveTo(w,dy);
	c.lineTo(w - dx, dy);
	c.lineTo(w - dx, h - dy);
	c.lineTo(w - dx - 2 * dy, h);
	c.lineTo(w, h);
	c.lineTo(w - notch, (h - dy) * 0.5 + dy);
	c.close();
	c.fill();
	
	c.setFillAlpha('0.4');
	c.begin();
	c.moveTo(w - dx, h - dy);
	c.lineTo(w - dx - 2 * dy, h - dy);
	c.lineTo(w - dx - 2 * dy, h);
	c.close();
	c.fill();
	
	c.begin();
	c.moveTo(dx2, 0);
	c.lineTo(w - dx, 0);
	c.lineTo(w - dx, dy);
	c.lineTo(w, dy);
	c.lineTo(w - notch, (h - dy) * 0.5 + dy);
	c.lineTo(w, h);
	c.lineTo(w - dx - 2 * dy, h);
	c.lineTo(w - dx - 2 * dy, h - dy);
	c.lineTo(dx2, h - dy);
	c.lineTo(0, (h - dy) * 0.5);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeInfographicBannerSingleFold.prototype.cst.BANNER_SINGLE_FOLD, mxShapeInfographicBannerSingleFold);

Graph.handleFactory[mxShapeInfographicBannerSingleFold.prototype.cst.BANNER_SINGLE_FOLD] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + bounds.width - dx, bounds.y + dy);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width, bounds.x + bounds.width - pt.x))) / 100;
		this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, pt.y - bounds.y))) / 100;
	})];
			
	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
	{
		var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var notch = Math.max(0, Math.min(dx, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

		return new mxPoint(bounds.x + bounds.width - notch, bounds.y + dy + (bounds.height - dy) * 0.5);
	}, function(bounds, pt)
	{
		this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.width, (bounds.width + bounds.x - pt.x)))) / 100;
	});
			
	handles.push(handle2);

	var handle3 = Graph.createHandle(state, ['dx2'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
		var dx2 = Math.max(0, Math.min(bounds.width - dx, parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2))));

		return new mxPoint(bounds.x + dx2, bounds.y + (bounds.height - dy) * 0.5);
	}, function(bounds, pt)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));
		
		this.state.style['dx2'] = Math.round(100 * Math.max(0, Math.min(bounds.width - dx - 2 * dy, pt.x - bounds.x))) / 100;
	});
			
	handles.push(handle3);
	

	return handles;
};

mxShapeInfographicBannerSingleFold.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	dx = Math.min(w - 2 * dy, dx);
	var dx2 = Math.max(0, Math.min(w - dx - 2 * dy, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	notch = Math.min(dx, notch);
	var w2 = w - dx - dx2;
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 + w2 * 0.25, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 + w2 * 0.5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 + w2 * 0.75, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 + w2, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx * 0.25, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx * 0.5, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx * 0.75, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - notch, (h + dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx - 2 * dy, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - (dx + 2 * dy) * 0.75, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - (dx + 2 * dy) * 0.5, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - (dx + 2 * dy) * 0.25, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 + w2 * 0.25, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 + w2 * 0.5, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 + w2 * 0.75, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 + w2, h - dy));
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Shaded Cube
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicShadedCube(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.isoAngle = 15;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicShadedCube, mxActor);

mxShapeInfographicShadedCube.prototype.cst = {SHADED_CUBE : 'mxgraph.infographic.shadedCube'};

mxShapeInfographicShadedCube.prototype.customProperties = [
	{name:'isoAngle', dispName: 'Perspective', type:'float', defVal:15, min:0}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicShadedCube.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var isoAngle = Math.max(0.01, Math.min(94, parseFloat(mxUtils.getValue(this.style, 'isoAngle', this.isoAngle)))) * Math.PI / 200 ;
	var isoH = Math.min(w * Math.tan(isoAngle), h * 0.5);
	
	c.begin();
	c.moveTo(w * 0.5, 0);
	c.lineTo(w, isoH);
	c.lineTo(w, h - isoH);
	c.lineTo(w * 0.5, h);
	c.lineTo(0, h - isoH);
	c.lineTo(0, isoH);
	c.close();
	c.fillAndStroke();

	c.setShadow(false);
	c.setFillAlpha('0.2');
	c.setFillColor('#000000');
	
	c.begin();
	c.moveTo(w * 0.5, 2 * isoH);
	c.lineTo(w, isoH);
	c.lineTo(w, h - isoH);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();

	c.setFillColor('#ffffff');
	c.begin();
	c.moveTo(w * 0.5, 2 * isoH);
	c.lineTo(0, isoH);
	c.lineTo(0, h - isoH);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeInfographicShadedCube.prototype.cst.SHADED_CUBE, mxShapeInfographicShadedCube);

Graph.handleFactory[mxShapeInfographicShadedCube.prototype.cst.SHADED_CUBE] = function(state)
{
	var handles = [Graph.createHandle(state, ['isoAngle'], function(bounds)
	{
		var isoAngle = Math.max(0.01, Math.min(94, parseFloat(mxUtils.getValue(this.state.style, 'isoAngle', this.isoAngle)))) * Math.PI / 200 ;
		var isoH = Math.min(bounds.width * Math.tan(isoAngle), bounds.height * 0.5);

		return new mxPoint(bounds.x, bounds.y + isoH);
	}, function(bounds, pt)
	{
		this.state.style['isoAngle'] = Math.round(100 * Math.max(0, Math.min(100, pt.y - bounds.y))) / 100;
	})];
			
	return handles;
};

mxShapeInfographicShadedCube.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var isoAngle = Math.max(0.01, Math.min(94, parseFloat(mxUtils.getValue(this.style, 'isoAngle', this.isoAngle)))) * Math.PI / 200 ;
	var isoH = Math.min(w * Math.tan(isoAngle), h * 0.5);
	
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.75, isoH * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, isoH));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, isoH + (h - 2 * isoH) * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, isoH + (h - 2 * isoH) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, isoH + (h - 2 * isoH) * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h - isoH));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.75, h - isoH * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.25, h - isoH * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - isoH));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - isoH));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, isoH + (h - 2 * isoH) * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, isoH + (h - 2 * isoH) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, isoH + (h - 2 * isoH) * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, isoH));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.25, isoH * 0.5));

	return (constr);
};

//**********************************************************************************************************************************************************
//Partial Concentric Ellipse
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicPartConcEllipse(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.startAngle = 0.25;
	this.endAngle = 0.75;
	this.arcWidth = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicPartConcEllipse, mxActor);

mxShapeInfographicPartConcEllipse.prototype.cst = {PART_CONC_ELLIPSE : 'mxgraph.infographic.partConcEllipse'};

mxShapeInfographicPartConcEllipse.prototype.customProperties = [
	{name:'startAngle', dispName:'Start Angle', min:0, max:1, defVal: 0.25},
	{name:'endAngle', dispName:'End Angle', min:0, max:1, defVal: 0.1},
	{name:'arcWidth', dispName:'Arc Width', min:0, max:1, defVal: 0.5}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicPartConcEllipse.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'startAngle', this.startAngle))));
	var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'endAngle', this.endAngle))));
	var arcWidth = 1 - Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arcWidth', this.arcWidth))));
	var rx = w * 0.5;
	var ry = h * 0.5;
	var rx2 = rx * arcWidth;
	var ry2 = ry * arcWidth;
	
	var angDiff = endAngle - startAngle;
	
	if (angDiff < 0)
	{
		angDiff = angDiff + Math.PI * 2;
	}
	else if (angDiff == Math.PI)
	{
		endAngle = endAngle + 0.00001;
	}
		
	var startX = rx + Math.sin(startAngle) * rx;
	var startY = ry - Math.cos(startAngle) * ry;
	var innerStartX = rx + Math.sin(startAngle) * rx2;
	var innerStartY = ry - Math.cos(startAngle) * ry2;
	var endX = rx + Math.sin(endAngle) * rx;
	var endY = ry - Math.cos(endAngle) * ry;
	var innerEndX = rx + Math.sin(endAngle) * rx2;
	var innerEndY = ry - Math.cos(endAngle) * ry2;
	
	var bigArc = 0;
	
	if (angDiff <= Math.PI)
	{
		bigArc = 1;
	}
		
	c.begin();
	c.moveTo(rx, 0);
	c.arcTo(rx, ry, 0, 0, 1, w, ry);
	c.arcTo(rx, ry, 0, 0, 1, rx, h);
	c.arcTo(rx, ry, 0, 0, 1, 0, ry);
	c.arcTo(rx, ry, 0, 0, 1, rx, 0);
	c.close();
	c.moveTo(rx, h * 0.5 - ry2);
	c.arcTo(rx2, ry2, 0, 0, 0, w * 0.5 - rx2, ry);
	c.arcTo(rx2, ry2, 0, 0, 0, rx, h * 0.5 + ry2);
	c.arcTo(rx2, ry2, 0, 0, 0, w * 0.5 + rx2, ry);
	c.arcTo(rx2, ry2, 0, 0, 0, rx, h * 0.5 - ry2);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	c.setFillAlpha('0.2');
	c.setFillColor('#ffffff');
	
	c.begin();
	c.moveTo(startX, startY);
	c.arcTo(rx, ry, 0, bigArc, 0, endX, endY);
	c.lineTo(innerEndX, innerEndY);
	c.arcTo(rx2, ry2, 0, bigArc, 1, innerStartX, innerStartY);
	c.close();
	c.fill();
	
	var rx = w * 0.5;
	var ry = h * 0.5;
	var rx2 = rx * arcWidth;
	var ry2 = ry * arcWidth;

	var rx3 = rx2 + (rx - rx2) * 0.25;
	var ry3 = ry2 + (ry - ry2) * 0.25;

	c.setFillColor('#000000');
	
	c.begin();
	c.moveTo(rx, h * 0.5 - ry2);
	c.arcTo(rx2, ry2, 0, 0, 1, w * 0.5 + rx2, ry);
	c.arcTo(rx2, ry2, 0, 0, 1, rx, h * 0.5 + ry2);
	c.arcTo(rx2, ry2, 0, 0, 1, w * 0.5 - rx2, ry);
	c.arcTo(rx2, ry2, 0, 0, 1, rx, h * 0.5 - ry2);
	c.close();
	c.moveTo(rx, h * 0.5 - ry3);
	c.arcTo(rx3, ry3, 0, 0, 0, w * 0.5 - rx3, ry);
	c.arcTo(rx3, ry3, 0, 0, 0, rx, h * 0.5 + ry3);
	c.arcTo(rx3, ry3, 0, 0, 0, w * 0.5 + rx3, ry);
	c.arcTo(rx3, ry3, 0, 0, 0, rx, h * 0.5 - ry3);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeInfographicPartConcEllipse.prototype.cst.PART_CONC_ELLIPSE, mxShapeInfographicPartConcEllipse);

Graph.handleFactory[mxShapeInfographicPartConcEllipse.prototype.cst.PART_CONC_ELLIPSE] = function(state)
{
	var handles = [Graph.createHandle(state, ['startAngle'], function(bounds)
	{
		var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'startAngle', this.startAngle))));

		return new mxPoint(bounds.x + bounds.width * 0.5 + Math.sin(startAngle) * bounds.width * 0.5, bounds.y + bounds.height * 0.5 - Math.cos(startAngle) * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * 0.5) / (bounds.width * 0.5)))) / 100;
		var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * 0.5) / (bounds.height * 0.5)))) / 100;
		
		var res =  0.5 * Math.atan2(handleX, handleY) / Math.PI;
		
		if (res < 0)
		{
			res = 1 + res;
		}

		this.state.style['startAngle'] = res;
		
	})];

	var handle2 = Graph.createHandle(state, ['endAngle'], function(bounds)
	{
		var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'endAngle', this.endAngle))));

		return new mxPoint(bounds.x + bounds.width * 0.5 + Math.sin(endAngle) * bounds.width * 0.5, bounds.y + bounds.height * 0.5 - Math.cos(endAngle) * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * 0.5) / (bounds.width * 0.5)))) / 100;
		var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * 0.5) / (bounds.height * 0.5)))) / 100;
		
		var res =  0.5 * Math.atan2(handleX, handleY) / Math.PI;
		
		if (res < 0)
		{
			res = 1 + res;
		}
		
		this.state.style['endAngle'] = res;
	});
	
	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['arcWidth'], function(bounds)
	{
		var arcWidth = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'arcWidth', this.arcWidth))));

		return new mxPoint(bounds.x + bounds.width / 2, bounds.y + arcWidth * bounds.height * 0.5);
	}, function(bounds, pt)
	{
		this.state.style['arcWidth'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, (pt.y - bounds.y) / (bounds.height * 0.5)))) / 100;
	});
			
	handles.push(handle3);
	
	return handles;
};

mxShapeInfographicPartConcEllipse.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	
	constr.push(new mxConnectionConstraint(new mxPoint(0.145, 0.145), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.855, 0.145), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.855, 0.855), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.145, 0.855), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Banner Half Fold
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicBannerHalfFold(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
	this.dx2 = 0.5;
	this.notch = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicBannerHalfFold, mxActor);

mxShapeInfographicBannerHalfFold.prototype.cst = {BANNER_HALF_FOLD : 'mxgraph.infographic.bannerHalfFold'};

mxShapeInfographicBannerHalfFold.prototype.customProperties = [
	{name:'dx', dispName:'Banner Width', min:0, defVal: 40},
	{name:'dx2', dispName:'Spike Size', min:0, defVal: 20},
	{name:'notch', dispName:'Notch Size', min:0, defVal: 15}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicBannerHalfFold.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dx2 = Math.max(0, Math.min(w - dx, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var notch = Math.max(0, Math.min(h - dx, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));

	c.begin();
	c.moveTo(dx2, 0);
	c.lineTo(w - dx, 0);
	c.lineTo(w, dx);
	c.lineTo(w, h);
	c.lineTo(w - dx * 0.5, h - notch);
	c.lineTo(w - dx, h);
	c.lineTo(w - dx, dx);
	c.lineTo(dx2, dx);
	c.lineTo(0, dx * 0.5);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	c.setFillAlpha('0.2');
	c.setFillColor('#000000');
	c.begin();
	c.moveTo(w - dx, dx);
	c.lineTo(w, dx);
	c.lineTo(w, h);
	c.lineTo(w - dx * 0.5, h - notch);
	c.lineTo(w - dx, h);
	c.lineTo(w - dx, dx);
	c.lineTo(0, dx);
	c.close();
	c.fill();
	
	c.begin();
	c.moveTo(dx2, 0);
	c.lineTo(w - dx, 0);
	c.lineTo(w, dx);
	c.lineTo(w, h);
	c.lineTo(w - dx * 0.5, h - notch);
	c.lineTo(w - dx, h);
	c.lineTo(w - dx, dx);
	c.lineTo(dx2, dx);
	c.lineTo(0, dx * 0.5);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeInfographicBannerHalfFold.prototype.cst.BANNER_HALF_FOLD, mxShapeInfographicBannerHalfFold);

Graph.handleFactory[mxShapeInfographicBannerHalfFold.prototype.cst.BANNER_HALF_FOLD] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

		return new mxPoint(bounds.x + bounds.width - dx, bounds.y + dx);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width, bounds.x + bounds.width - pt.x))) / 100;
	})];
			
	var handle2 = Graph.createHandle(state, ['notch'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var notch = Math.max(0, Math.min(bounds.height - dx, parseFloat(mxUtils.getValue(this.state.style, 'notch', this.notch))));

		return new mxPoint(bounds.x + bounds.width - dx * 0.5, bounds.y + bounds.height - notch);
	}, function(bounds, pt)
	{
		this.state.style['notch'] = Math.round(100 * Math.max(0, Math.min(bounds.height, (bounds.height + bounds.y - pt.y)))) / 100;
	});
			
	handles.push(handle2);
	
	var handle3 = Graph.createHandle(state, ['dx2'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var dx2 = Math.max(0, Math.min(bounds.width - dx, parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2))));

		return new mxPoint(bounds.x + dx2, bounds.y + dx);
	}, function(bounds, pt)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		
		this.state.style['dx2'] = Math.round(100 * Math.max(0, Math.min(bounds.width - dx, pt.x - bounds.x))) / 100;
	});
			
	handles.push(handle3);
	
	return handles;
};

mxShapeInfographicBannerHalfFold.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dx2 = Math.max(0, Math.min(w - dx, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var notch = Math.max(0, Math.min(h - dx, parseFloat(mxUtils.getValue(this.style, 'notch', this.notch))));
	var w2 = w - dx - dx2;
	var h2 = h - dx;

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, dx * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 + w2 * 0.25, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 + w2 * 0.5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 + w2 * 0.75, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx * 0.5, dx * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, dx + h2 * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, dx + h2 * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, dx + h2 * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx * 0.5, h - notch));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, dx + h2 * 0.75));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, dx + h2 * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, dx + h2 * 0.25));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - dx, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 + w2 * 0.25, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 + w2 * 0.5, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2 + w2 * 0.75, dx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx2, dx));

	return (constr);
};

//**********************************************************************************************************************************************************
//Circular Dial
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicCircularDial(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicCircularDial, mxActor);

mxShapeInfographicCircularDial.prototype.cst = {CIRCULAR_DIAL : 'mxgraph.infographic.circularDial'};

mxShapeInfographicCircularDial.prototype.customProperties = [
	{name:'dy', dispName:'Hole Size', min:0, defVal: 15}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicCircularDial.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy = Math.max(0, Math.min(h * 0.5 - 10, w * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	
	var rx = Math.max(0, Math.min(w * 0.5, h * 0.5 - 10));
	var rx2 = rx - dy;
	
	c.begin();
	c.moveTo(w * 0.5 - rx, h);
	c.lineTo(w * 0.5 - rx, rx);
	c.arcTo(rx, rx, 0, 0, 1, w * 0.5, 0);
	c.arcTo(rx, rx, 0, 0, 1, w * 0.5 + rx, rx);
	c.lineTo(w * 0.5 + rx, h);
	c.close();
	c.moveTo(w * 0.5, dy);
	c.arcTo(rx2, rx2, 0, 0, 0, w * 0.5 - rx2, rx);
	c.arcTo(rx2, rx2, 0, 0, 0, w * 0.5, rx + rx2);
	c.arcTo(rx2, rx2, 0, 0, 0, w * 0.5 + rx2, rx);
	c.arcTo(rx2, rx2, 0, 0, 0, w * 0.5, dy);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	c.setFillAlpha('0.2');
	c.setFillColor('#000000');

	c.begin();
	c.moveTo(w * 0.5 - rx, 2 * rx);
	c.lineTo(w * 0.5 + rx, 2 * rx);
	c.lineTo(w * 0.5 + rx, h);
	c.lineTo(w * 0.5 - rx, h);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeInfographicCircularDial.prototype.cst.CIRCULAR_DIAL, mxShapeInfographicCircularDial);

Graph.handleFactory[mxShapeInfographicCircularDial.prototype.cst.CIRCULAR_DIAL] = function(state)
{
	var handles = [Graph.createHandle(state, ['dy'], function(bounds)
	{
		var dy = Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + bounds.width * 0.5, bounds.y + dy);
	}, function(bounds, pt)
	{
		this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.y - bounds.y))) / 100;
	})];
			
	return handles;
};

mxShapeInfographicCircularDial.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dy = Math.max(0, Math.min(h * 0.5 - 10, w * 0.5, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var rx = Math.max(0, Math.min(w * 0.5, h * 0.5 - 10));
	var rx2 = rx - dy;
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - rx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - rx, (rx + h) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - rx, rx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - rx * 0.71, rx * 0.29));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + rx * 0.71, rx * 0.29));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + rx, rx));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + rx, (rx + h) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + rx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 + rx * 0.5, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5 - rx * 0.5, h));

	return (constr);
};

//**********************************************************************************************************************************************************
//Simple ribbon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicRibbonSimple(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.notch1 = 0.5;
	this.notch2 = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicRibbonSimple, mxActor);

mxShapeInfographicRibbonSimple.prototype.cst = {RIBBON_SIMPLE : 'mxgraph.infographic.ribbonSimple'};

mxShapeInfographicRibbonSimple.prototype.customProperties = [
	{name:'notch1', dispName:'Notch Size', min:0, defVal: 20},
	{name:'notch2', dispName:'Spike Size', min:0, defVal: 20}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicRibbonSimple.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var notch1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch1', this.notch2))));
	var notch2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch2', this.notch2))));

	c.begin();
	c.moveTo(0, h);
	c.lineTo(notch1, h * 0.5);
	c.lineTo(0, 0);
	c.lineTo(w - notch2, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - notch2, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeInfographicRibbonSimple.prototype.cst.RIBBON_SIMPLE, mxShapeInfographicRibbonSimple);

Graph.handleFactory[mxShapeInfographicRibbonSimple.prototype.cst.RIBBON_SIMPLE] = function(state)
{
	var handles = [Graph.createHandle(state, ['notch1'], function(bounds)
	{
		var notch1 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'notch1', this.notch1))));

		return new mxPoint(bounds.x + notch1, bounds.y + bounds.height * 0.5);
	}, function(bounds, pt)
	{
		this.state.style['notch1'] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
	})];

	var handle2 = Graph.createHandle(state, ['notch2'], function(bounds)
	{
		var notch2 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'notch2', this.notch2))));

		return new mxPoint(bounds.x + bounds.width - notch2, bounds.y);
	}, function(bounds, pt)
	{
		this.state.style['notch2'] = Math.round(100 * Math.max(0, Math.min(bounds.width, (bounds.width + bounds.x - pt.x)))) / 100;
	});
			
	handles.push(handle2);

	return handles;
};

mxShapeInfographicRibbonSimple.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var notch1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch1', this.notch2))));
	var notch2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'notch2', this.notch2))));
	var w2 = w - notch2;
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w2 * 0.25, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w2 * 0.5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w2 * 0.75, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w2, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w2, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w2 * 0.75, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w2 * 0.5, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w2 * 0.25, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, notch1, h * 0.5));

	return (constr);
};

//**********************************************************************************************************************************************************
//Bar with callout
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicBarCallout(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
	this.dy = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicBarCallout, mxActor);

mxShapeInfographicBarCallout.prototype.cst = {BAR_CALLOUT : 'mxgraph.infographic.barCallout'};

mxShapeInfographicBarCallout.prototype.customProperties = [
	{name:'dx', dispName:'Callout Position', min:0, defVal: 100},
	{name:'dy', dispName:'Callout Size', min:0, defVal: 30}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicBarCallout.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));

	var x1 = Math.max(dx - dy * 0.35, 0);
	var x2 = Math.min(dx + dy * 0.35, w);
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h - dy);
	c.lineTo(x2, h - dy);
	c.lineTo(dx, h);
	c.lineTo(x1, h - dy);
	c.lineTo(0, h - dy);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeInfographicBarCallout.prototype.cst.BAR_CALLOUT, mxShapeInfographicBarCallout);

mxShapeInfographicBarCallout.prototype.constraints = null;

Graph.handleFactory[mxShapeInfographicBarCallout.prototype.cst.BAR_CALLOUT] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + dx, bounds.y + bounds.height -  dy);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
		this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height, bounds.y + bounds.height - pt.y))) / 100;
	})];
			
	return handles;
};

mxShapeInfographicBarCallout.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
	var x1 = Math.max(dx - dy * 0.35, 0);
	var x2 = Math.min(dx + dy * 0.35, w);

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, (h - dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false, null, 0, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false, null, 0, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - dy));

	return (constr);
};

//**********************************************************************************************************************************************************
//Flag
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeInfographicFlag(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dx = 0.5;
	this.dy = 0.5;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeInfographicFlag, mxActor);

mxShapeInfographicFlag.prototype.cst = {FLAG : 'mxgraph.infographic.flag'};

mxShapeInfographicFlag.prototype.customProperties = [
	{name:'dx', dispName:'Pole Width', min:0, defVal: 30},
	{name:'dy', dispName:'Spike Size', min:0, defVal: 20}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeInfographicFlag.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h - dy);
	c.lineTo(dx, h - dy);
	c.lineTo(dx * 0.5, h);
	c.lineTo(0, h - dy);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	c.setFillAlpha('0.2');
	c.setFillColor('#ffffff');
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(dx, 0);
	c.lineTo(dx, h - dy);
	c.lineTo(dx * 0.5, h);
	c.lineTo(0, h - dy);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeInfographicFlag.prototype.cst.FLAG, mxShapeInfographicFlag);

Graph.handleFactory[mxShapeInfographicFlag.prototype.cst.FLAG] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'dy'], function(bounds)
	{
		var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));
		var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

		return new mxPoint(bounds.x + dx, bounds.y + bounds.height - dy);
	}, function(bounds, pt)
	{
		this.state.style['dx'] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
		this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height, bounds.y + bounds.height - pt.y))) / 100;
	})];
			
	return handles;
};

mxShapeInfographicFlag.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, (h - dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - dy) * 0.5));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.75, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.25, h - dy));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx * 0.5, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, dx * 0.5, 0));

	return (constr);
};


/**
 * $Id: mxKubernetes.js,v 1.5 2019/14/11 12:32:06 mate Exp $
 * Copyright (c) 2006-2020, JGraph Ltd
 */
//**********************************************************************************************************************************************************
// Kubernetes icon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeKubernetesIcon(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeKubernetesIcon, mxShape);

mxShapeKubernetesIcon.prototype.cst = {
		ICON : 'mxgraph.kubernetes.icon'
};

mxShapeKubernetesIcon.prototype.customProperties = [
	{name: 'prIcon', dispName: '', defVal: 'api', type: 'API', 
			enumList: [{val: 'c_c_m', dispName: 'C-C-M'},
					   {val: 'c_m', dispName: 'C-M'},
					   {val: 'c_role', dispName: 'C-Role'},
					   {val: 'cm', dispName: 'CM'},
					   {val: 'crb', dispName: 'CRB'},
					   {val: 'crd', dispName: 'CRD'},
					   {val: 'cronjob', dispName: 'Cronjob'},
					   {val: 'deploy', dispName: 'Deploy'},
					   {val: 'ds', dispName: 'DS'},
					   {val: 'ep', dispName: 'EP'},
					   {val: 'etcd', dispName: 'ETCD'},
					   {val: 'group', dispName: 'Group'},
					   {val: 'hpa', dispName: 'HPA'},
					   {val: 'ing', dispName: 'ING'},
					   {val: 'job', dispName: 'Job'},
					   {val: 'k_proxy', dispName: 'K-Proxy'},
					   {val: 'kubelet', dispName: 'Kubelet'},
					   {val: 'limits', dispName: 'Limits'},
					   {val: 'master', dispName: 'Master'},
					   {val: 'netpol', dispName: 'Netpol'},
					   {val: 'node', dispName: 'Node'},
					   {val: 'ns', dispName: 'NS'},
					   {val: 'pod', dispName: 'Pod'},
					   {val: 'psp', dispName: 'PSP'},
					   {val: 'pv', dispName: 'PV'},
					   {val: 'pvc', dispName: 'PVC'},
					   {val: 'quota', dispName: 'Quota'},
					   {val: 'rb', dispName: 'RB'},
					   {val: 'role', dispName: 'Role'},
					   {val: 'rs', dispName: 'RS'},
					   {val: 'sa', dispName: 'SA'},
					   {val: 'sc', dispName: 'SC'},
					   {val: 'sched', dispName: 'Sched'},
					   {val: 'secret', dispName: 'Secret'},
					   {val: 'sts', dispName: 'STS'},
					   {val: 'svc', dispName: 'SVC'},
					   {val: 'user', dispName: 'User'},
				       {val: 'vol', dispName: 'Vol'}]}
];


/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeKubernetesIcon.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var prIcon = mxUtils.getValue(this.state.style, 'prIcon', '');
	
	var fillColor = mxUtils.getValue(this.state.style, 'fillColor', '#ffffff');
	var strokeColor = mxUtils.getValue(this.state.style, 'strokeColor', '#ffffff');

	c.translate(x, y);
	
	var frame = mxStencilRegistry.getStencil('mxgraph.kubernetes.frame');
	
	c.setFillColor(strokeColor);
	frame.drawShape(c, this, 0, 0, w, h);

	c.setFillColor(fillColor);
	frame.drawShape(c, this, w * 0.03, h * 0.03, w * 0.94, h * 0.94);
	
	var prStencil = mxStencilRegistry.getStencil('mxgraph.kubernetes.' + prIcon);
	
	if (prStencil != null)
	{
		c.setFillColor(strokeColor);
		prStencil.drawShape(c, this, w * 0.2, h * 0.2, w * 0.6, h * 0.6);
	}
};

mxCellRenderer.registerShape(mxShapeKubernetesIcon.prototype.cst.ICON, mxShapeKubernetesIcon);

mxShapeKubernetesIcon.prototype.getConstraints = function(style, w, h)
{
	var constr = [];
	var r = Math.min(h * 0.5, w * 0.5);
	
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
}


/**
 * $Id: mxLeanMap.js,v 1.3 2013/05/30 14:19:14 mate Exp $
 * Copyright (c) 2006-2013, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Boat Shipment
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxLeanBoatShipment(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxLeanBoatShipment, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxLeanBoatShipment.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.begin();
	c.moveTo(w * 0.15, h * 0.77);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w * 0.85, h * 0.77);
	c.close();
	c.moveTo(w * 0.2, h);
	c.lineTo(0, h * 0.8);
	c.lineTo(w, h * 0.8);
	c.lineTo(w * 0.8, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.boat_shipment', mxLeanBoatShipment);

mxLeanBoatShipment.prototype.constraints = [
                                            new mxConnectionConstraint(new mxPoint(0.5, 0), false),
                                            new mxConnectionConstraint(new mxPoint(0.5, 1), false),
                                            new mxConnectionConstraint(new mxPoint(0, 0.8), false),
                                            new mxConnectionConstraint(new mxPoint(1, 0.8), false),
                                            new mxConnectionConstraint(new mxPoint(0.2, 1), false),
                                            new mxConnectionConstraint(new mxPoint(0.8, 1), false),
                                            new mxConnectionConstraint(new mxPoint(0.26, 0.5), false),
                                            new mxConnectionConstraint(new mxPoint(0.74, 0.5), false)
                                            ];

//**********************************************************************************************************************************************************
//Safety Stock
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxLeanSafetyStock(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxLeanSafetyStock, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxLeanSafetyStock.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxLeanSafetyStock.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxLeanSafetyStock.prototype.foreground = function(c, w, h)
{
	c.begin();
	c.moveTo(0, h * 0.34);
	c.lineTo(w, h * 0.34);
	c.moveTo(0, h * 0.66);
	c.lineTo(w, h * 0.66);
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.buffer_or_safety_stock', mxLeanSafetyStock);

mxLeanSafetyStock.prototype.constraints = [
                                           new mxConnectionConstraint(new mxPoint(0, 0), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 1), true),
                                           new mxConnectionConstraint(new mxPoint(1, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                           ];

//**********************************************************************************************************************************************************
//Data Box
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxLeanDataBox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxLeanDataBox, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxLeanDataBox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxLeanDataBox.prototype.background = function(c, w, h)
{
	c.begin();
	c.moveTo(0, h);
	c.lineTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.fillAndStroke();
};

mxLeanDataBox.prototype.foreground = function(c, w, h)
{
	c.begin();
	c.moveTo(0, h * 0.2);
	c.lineTo(w, h * 0.2);
	c.moveTo(0, h * 0.4);
	c.lineTo(w, h * 0.4);
	c.moveTo(0, h * 0.6);
	c.lineTo(w, h * 0.6);
	c.moveTo(0, h * 0.8);
	c.lineTo(w, h * 0.8);
	c.stroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.data_box', mxLeanDataBox);

mxLeanDataBox.prototype.constraints = [
                                           new mxConnectionConstraint(new mxPoint(0, 0), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 1), true),
                                           new mxConnectionConstraint(new mxPoint(1, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                           ];

//**********************************************************************************************************************************************************
//Customer / Supplier
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxLeanCustomerSupplier(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxLeanCustomerSupplier, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxLeanCustomerSupplier.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.background(c, w, h);
	c.setShadow(false);
};

mxLeanCustomerSupplier.prototype.background = function(c, w, h)
{
	c.begin();
	c.moveTo(0, h);
	c.lineTo(0, h * 0.3);
	c.lineTo(w * 0.33, h * 0.02);
	c.lineTo(w * 0.33, h * 0.3);
	c.lineTo(w * 0.67, h * 0.02);
	c.lineTo(w * 0.67, h * 0.3);
	c.lineTo(w, h * 0.02);
	c.lineTo(w, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.outside_sources', mxLeanCustomerSupplier);

mxLeanCustomerSupplier.prototype.constraints = [
                                       new mxConnectionConstraint(new mxPoint(1, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0, 1), true),
                                       new mxConnectionConstraint(new mxPoint(1, 1), true),
                                       new mxConnectionConstraint(new mxPoint(0.33, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0.67, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0, 0.3), true),
                                       new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                       new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                       new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                       new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                       new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                       ];

//**********************************************************************************************************************************************************
//Dedicated Process
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxLeanDedicatedProcess(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxLeanDedicatedProcess, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxLeanDedicatedProcess.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var fontSize = parseFloat(mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '8'));

	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h, fontSize);
};

mxLeanDedicatedProcess.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxLeanDedicatedProcess.prototype.foreground = function(c, w, h, fontSize)
{
	var lineH = Math.min(fontSize * 1.5, h);
	c.begin();
	c.moveTo(0, lineH);
	c.lineTo(w, lineH);
	c.stroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.manufacturing_process', mxLeanDedicatedProcess);

mxLeanDedicatedProcess.prototype.constraints = [
                                       new mxConnectionConstraint(new mxPoint(0, 0), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0, 1), true),
                                       new mxConnectionConstraint(new mxPoint(1, 1), true),
                                       new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                       new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                       new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                       new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                       new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                       new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                       ];

//**********************************************************************************************************************************************************
//Shared Process
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxLeanSharedProcess(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxLeanSharedProcess, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxLeanSharedProcess.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var fontSize = parseFloat(mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '8'));

	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h, fontSize);
};

mxLeanSharedProcess.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxLeanSharedProcess.prototype.foreground = function(c, w, h, fontSize)
{
	var lineH = Math.min(fontSize * 1.5, h);
	c.begin();
	c.moveTo(0, lineH);
	c.lineTo(w, lineH);
	c.stroke();

	var start = 0;
	var i = 0;
	var s = 10;
	var offset = 0;
	c.begin();
	var strokeWidth = parseFloat(mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '2'));
	c.setStrokeWidth(strokeWidth * 0.5);

	while (start < h + w)
	{
		start = start + s;
		if (start > lineH)
		{
			var startX = Math.max(0, start - h); 
			var startY = Math.min(start, h); 

			var endX = Math.min(start - lineH, w);

			var endY = lineH;
			var endY = Math.max(start - w, lineH);
			
			if (startX < w)
			{
				c.moveTo(startX, startY);
				c.lineTo(endX, endY);
			}
		}
	};

	c.stroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.manufacturing_process_shared', mxLeanSharedProcess);

mxLeanSharedProcess.prototype.constraints = [
                                                new mxConnectionConstraint(new mxPoint(0, 0), true),
                                                new mxConnectionConstraint(new mxPoint(1, 0), true),
                                                new mxConnectionConstraint(new mxPoint(0, 1), true),
                                                new mxConnectionConstraint(new mxPoint(1, 1), true),
                                                new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                                new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                                new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                                new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                                new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                                new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                                new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                                new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                                new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                                new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                                new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                                new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                                ];

//**********************************************************************************************************************************************************
// Workcell
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanWorkcell(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanWorkcell, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanWorkcell.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(w * 0.65, h);
	c.lineTo(w * 0.65, h * 0.4);
	c.lineTo(w * 0.35, h * 0.4);
	c.lineTo(w * 0.35, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.work_cell', mxLeanWorkcell);

mxLeanWorkcell.prototype.constraints = [
                                             new mxConnectionConstraint(new mxPoint(0, 0), true),
                                             new mxConnectionConstraint(new mxPoint(1, 0), true),
                                             new mxConnectionConstraint(new mxPoint(0, 1), true),
                                             new mxConnectionConstraint(new mxPoint(1, 1), true),
                                             new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                             new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                             new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                             new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                             new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                             new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                             new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                             new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                             new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                             new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                             new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                             ];

//**********************************************************************************************************************************************************
//Inventory Box
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanInventoryBox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanInventoryBox, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanInventoryBox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(0, h);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h);
	c.close();
	c.fillAndStroke();
	c.setShadow(false);
	c.begin();
	c.moveTo(w * 0.4, h * 0.45);
	c.lineTo(w * 0.6, h * 0.45);
	c.moveTo(w * 0.5, h * 0.45);
	c.lineTo(w * 0.5, h * 0.85);
	c.moveTo(w * 0.4, h * 0.85);
	c.lineTo(w * 0.6, h * 0.85);
	c.stroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.inventory_box', mxLeanInventoryBox);

mxLeanInventoryBox.prototype.constraints = [
                                             new mxConnectionConstraint(new mxPoint(0, 1), true),
                                             new mxConnectionConstraint(new mxPoint(1, 1), true),
                                             new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                             new mxConnectionConstraint(new mxPoint(0.375, 0.25), false),
                                             new mxConnectionConstraint(new mxPoint(0.25, 0.5), false),
                                             new mxConnectionConstraint(new mxPoint(0.125, 0.75), false),
                                             new mxConnectionConstraint(new mxPoint(0.625, 0.25), false),
                                             new mxConnectionConstraint(new mxPoint(0.75, 0.5), false),
                                             new mxConnectionConstraint(new mxPoint(0.875, 0.75), false),
                                             new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                             new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                             new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                             ];

//**********************************************************************************************************************************************************
//Push Arrow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanPushArrow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanPushArrow, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanPushArrow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxLeanPushArrow.prototype.background = function(c, w, h)
{
	c.begin();
	c.moveTo(0, h * 0.17);
	c.lineTo(w * 0.75, h * 0.17);
	c.lineTo(w * 0.75, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w * 0.75, h);
	c.lineTo(w * 0.75, h * 0.83);
	c.lineTo(0, h * 0.83);
	c.close();
	c.fillAndStroke();
};

mxLeanPushArrow.prototype.foreground = function(c, w, h, fontSize)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setFillColor(strokeColor);
	c.rect(0, h * 0.17, w * 0.12, h * 0.66);
	c.fill();
	c.rect(w * 0.24, h * 0.17, w * 0.12, h * 0.66);
	c.fill();
	c.rect(w * 0.48, h * 0.17, w * 0.12, h * 0.66);
	c.fill();
	
	c.begin();
	c.moveTo(w * 0.72, h * 0.17);
	c.lineTo(w * 0.75, h * 0.17);
	c.lineTo(w * 0.75, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w * 0.75, h);
	c.lineTo(w * 0.75, h * 0.83);
	c.lineTo(w * 0.72, h * 0.83);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.push_arrow', mxLeanPushArrow);

mxLeanPushArrow.prototype.constraints = [
                                           new mxConnectionConstraint(new mxPoint(0.25, 0.17), false),
                                           new mxConnectionConstraint(new mxPoint(0.5, 0.17), false),
                                           new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.17), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.83), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 0.83), false),
                                           new mxConnectionConstraint(new mxPoint(0.5, 0.83), false),
                                           new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                           ];

//**********************************************************************************************************************************************************
//Supermarket
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanSupermarket(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanSupermarket, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanSupermarket.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.moveTo(0, h * 0.33);
	c.lineTo(w, h * 0.33);
	c.moveTo(0, h * 0.67);
	c.lineTo(w, h * 0.67);
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.supermarket', mxLeanSupermarket);

mxLeanSupermarket.prototype.constraints = [
                                           new mxConnectionConstraint(new mxPoint(0, 0), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 1), true),
                                           new mxConnectionConstraint(new mxPoint(1, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                           ];

//**********************************************************************************************************************************************************
//Material Pull
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanMaterialPull(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanMaterialPull, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanMaterialPull.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.begin();
	c.moveTo(w * 0.732, h * 0.0736);
	c.arcTo(w * 0.4827, h * 0.4959, 0, 1, 0, w * 0.9553, h * 0.6191);
	c.stroke();
	
	c.begin();
	c.moveTo(w * 0.9071, h * 0.6191);
	c.lineTo(w * 0.9794, h * 0.4951);
	c.lineTo(w, h * 0.6438);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.physical_pull', mxLeanMaterialPull);

mxLeanMaterialPull.prototype.constraints = [
                                           new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(0.98, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(0.144, 0.144), false),
                                           new mxConnectionConstraint(new mxPoint(0.144, 0.845), false),
                                           new mxConnectionConstraint(new mxPoint(0.845, 0.845), false)
                                           ];

//**********************************************************************************************************************************************************
//FIFO Lane
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanFifoLane(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanFifoLane, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanFifoLane.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var fontSize = parseFloat(mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '8'));

	this.background(c, w, h, fontSize);
	c.setShadow(false);
};

mxLeanFifoLane.prototype.background = function(c, w, h, fontSize)
{
	var lineH = Math.min(fontSize * 1.5, h);
	c.begin();
	c.moveTo(0, lineH);
	c.lineTo(w, lineH);
	c.moveTo(0, h);
	c.lineTo(w, h);
	c.stroke();

	c.rect(w * 0.02, lineH + 4, w * 0.26, h - lineH - 8);
	c.fillAndStroke();
	
	c.ellipse(w * 0.35, lineH + 4, w * 0.26, h - lineH - 8);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w * 0.69, lineH + 4);
	c.lineTo(w * 0.98, lineH + 4);
	c.lineTo(w * 0.835, h - 4);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.fifo_lane', mxLeanFifoLane);

mxLeanFifoLane.prototype.constraints = [
                                           new mxConnectionConstraint(new mxPoint(0, 1), true),
                                           new mxConnectionConstraint(new mxPoint(1, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                           ];

//**********************************************************************************************************************************************************
//Truck Shipment
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanTruckShipment(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanTruckShipment, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanTruckShipment.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.background(c, w, h);
	c.setShadow(false);
};

mxLeanTruckShipment.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w * 0.6, h * 0.8);
	c.fillAndStroke();
	
	c.rect(w * 0.6, h * 0.35, w * 0.4, h * 0.45);
	c.fillAndStroke();
	
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setFillColor(strokeColor);
	c.ellipse(w * 0.15, h * 0.8, w * 0.2, h * 0.2);
	c.fillAndStroke();
	
	c.ellipse(w * 0.65, h * 0.8, w * 0.2, h * 0.2);
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.truck_shipment', mxLeanTruckShipment);

mxLeanTruckShipment.prototype.constraints = [
                                           new mxConnectionConstraint(new mxPoint(0, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(0.6, 0.35), false),
                                           new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 0.8), false),
                                           new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                           ];

//**********************************************************************************************************************************************************
//Production Control
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanProductionControl(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanProductionControl, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanProductionControl.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.schedule', mxLeanProductionControl);

mxLeanProductionControl.prototype.constraints = [
                                           new mxConnectionConstraint(new mxPoint(0, 0), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 1), true),
                                           new mxConnectionConstraint(new mxPoint(1, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                           ];


//**********************************************************************************************************************************************************
//FIFO Sequence
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanFifoSequence(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanFifoSequence, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanFifoSequence.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.moveTo(0, h);
	c.lineTo(w, h);
	c.moveTo(w * 0.05, h * 0.5);
	c.lineTo(w * 0.15, h * 0.5);
	c.moveTo(w * 0.75, h * 0.5);
	c.lineTo(w * 0.88, h * 0.5);
	c.stroke();
	
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.88, h * 0.39);
	c.lineTo(w * 0.98, h * 0.5);
	c.lineTo(w * 0.88, h * 0.61);
	c.fillAndStroke();
	
//	c.setFontSize(Math.min(h * 0.5, w * 0.2));
//	c.setFontColor(strokeColor);
//	c.text(w * 0.5, h * 0.5, 0, 0, 'FIFO', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.fifo_sequence_flow', mxLeanFifoSequence);

mxLeanFifoSequence.prototype.constraints = [
                                                 new mxConnectionConstraint(new mxPoint(0, 0), true),
                                                 new mxConnectionConstraint(new mxPoint(1, 0), true),
                                                 new mxConnectionConstraint(new mxPoint(0, 1), true),
                                                 new mxConnectionConstraint(new mxPoint(1, 1), true),
                                                 new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                                 new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                                 new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                                 new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                                 new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                                 new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                                 new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                                 new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                                 ];

//**********************************************************************************************************************************************************
//Production Kanban
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanProductionKanban(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanProductionKanban, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanProductionKanban.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.setDashed(true);
	c.begin();
	c.moveTo(4, h - 10);
	c.lineTo(4, 25);
	c.lineTo(w, 25);
	c.stroke();

	c.setDashed(false);
	c.begin();
	c.moveTo(w - 75, 0);
	c.lineTo(w - 30, 0);
	c.lineTo(w - 15, 15);
	c.lineTo(w - 15, 50);
	c.lineTo(w - 75, 50);
	c.close();
	c.fillAndStroke();
	
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(0, h - 10);
	c.lineTo(4, h);
	c.lineTo(8, h - 10);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.production_kanban', mxLeanProductionKanban);

mxLeanProductionKanban.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 4, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, 25));

	return (constr);
};

//**********************************************************************************************************************************************************
//Withdrawal Kanban
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanWithdrawalKanban(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanWithdrawalKanban, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanWithdrawalKanban.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.setDashed(true);
	c.begin();
	c.moveTo(4, h - 10);
	c.lineTo(4, 25);
	c.lineTo(w, 25);
	c.stroke();

	c.setDashed(false);
	c.begin();
	c.moveTo(w - 75, 0);
	c.lineTo(w - 30, 0);
	c.lineTo(w - 15, 15);
	c.lineTo(w - 15, 50);
	c.lineTo(w - 75, 50);
	c.close();
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w - 75, 45);
	c.lineTo(w - 70, 50);
	c.moveTo(w - 75, 35);
	c.lineTo(w - 60, 50);
	c.moveTo(w - 75, 25);
	c.lineTo(w - 50, 50);
	c.moveTo(w - 75, 15);
	c.lineTo(w - 40, 50);
	c.moveTo(w - 75, 5);
	c.lineTo(w - 30, 50);
	c.moveTo(w - 70, 0);
	c.lineTo(w - 20, 50);
	c.moveTo(w - 60, 0);
	c.lineTo(w - 15, 45);
	c.moveTo(w - 50, 0);
	c.lineTo(w - 15, 35);
	c.moveTo(w - 40, 0);
	c.lineTo(w - 15, 25);
	c.stroke();
	
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(0, h - 10);
	c.lineTo(4, h);
	c.lineTo(8, h - 10);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.withdrawal_kanban', mxLeanWithdrawalKanban);

mxLeanWithdrawalKanban.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 4, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, 25));

	return (constr);
};

//**********************************************************************************************************************************************************
//Signal Kanban
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanSignalKanban(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanSignalKanban, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanSignalKanban.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.setDashed(true);
	c.begin();
	c.moveTo(4, h - 10);
	c.lineTo(4, 15);
	c.lineTo(w, 15);
	c.stroke();

	c.setDashed(false);
	c.begin();
	c.moveTo(w - 65, 0);
	c.lineTo(w - 25, 0);
	c.lineTo(w - 45, 45);
	c.close();
	c.fillAndStroke();
	
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(0, h - 10);
	c.lineTo(4, h);
	c.lineTo(8, h - 10);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.signal_kanban', mxLeanSignalKanban);

mxLeanSignalKanban.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 4, h));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, 15));

	return (constr);
};

//**********************************************************************************************************************************************************
//Sequenced Pull Ball
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanSequencedPullBall(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanSequencedPullBall, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanSequencedPullBall.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();
	
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setFillColor(strokeColor);
	c.setShadow(false);
	
	c.ellipse(w * 0.15, h * 0.15, w * 0.7, h * 0.7);
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.sequenced_pull_ball', mxLeanSequencedPullBall);

mxLeanSequencedPullBall.prototype.constraints = [
                                            new mxConnectionConstraint(new mxPoint(0.144, 0.144), false),
                                            new mxConnectionConstraint(new mxPoint(0.856, 0.144), false),
                                            new mxConnectionConstraint(new mxPoint(0.856, 0.856), false),
                                            new mxConnectionConstraint(new mxPoint(0.144, 0.856), false),
                                            new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                            new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                            new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                            new mxConnectionConstraint(new mxPoint(0.5, 1), true)
                                            ];

//**********************************************************************************************************************************************************
//Rail Shipment
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanRailShipment(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanRailShipment, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanRailShipment.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.rect(w * 0.1, 0, w * 0.35, h * 0.8);
	c.fillAndStroke();
	c.rect(w * 0.55, 0, w * 0.35, h * 0.8);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(0, h);
	c.lineTo(w, h);
	c.moveTo(w * 0.45, h * 0.7);
	c.lineTo(w * 0.55, h * 0.7);
	c.stroke();
	
	c.ellipse(w * 0.15, h * 0.8, w * 0.06, h * 0.2);
	c.fillAndStroke();
	c.ellipse(w * 0.34, h * 0.8, w * 0.06, h * 0.2);
	c.fillAndStroke();
	c.ellipse(w * 0.6, h * 0.8, w * 0.06, h * 0.2);
	c.fillAndStroke();
	c.ellipse(w * 0.79, h * 0.8, w * 0.06, h * 0.2);
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.rail_shipment', mxLeanRailShipment);

mxLeanRailShipment.prototype.constraints = [
                                           new mxConnectionConstraint(new mxPoint(0, 1), true),
                                           new mxConnectionConstraint(new mxPoint(1, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.1, 0.25), false),
                                           new mxConnectionConstraint(new mxPoint(0.1, 0.5), false),
                                           new mxConnectionConstraint(new mxPoint(0.1, 0.75), false),
                                           new mxConnectionConstraint(new mxPoint(0.9, 0.25), false),
                                           new mxConnectionConstraint(new mxPoint(0.9, 0.5), false),
                                           new mxConnectionConstraint(new mxPoint(0.9, 0.75), false),
                                           new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                           ];

//**********************************************************************************************************************************************************
//Warehouse
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanWarehouse(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanWarehouse, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanWarehouse.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.rect(0, 0, w, h);
	c.fillAndStroke();
	
	c.setShadow(false);
	
	c.begin();
	c.moveTo(0, h * 0.4);
	c.lineTo(w, h * 0.4);
	c.moveTo(w * 0.15, h);
	c.lineTo(w * 0.15, h * 0.55);
	c.lineTo(w * 0.3, h * 0.55);
	c.lineTo(w * 0.3, h);
	c.stroke();

	c.ellipse(w * 0.27, h * 0.75, w * 0.02, w * 0.02);
	c.stroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.warehouse', mxLeanWarehouse);

mxLeanWarehouse.prototype.constraints = [
                                           new mxConnectionConstraint(new mxPoint(0, 0), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 1), true),
                                           new mxConnectionConstraint(new mxPoint(1, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                           ];

//**********************************************************************************************************************************************************
//Timeline
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanTimeline(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanTimeline, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanTimeline.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	var shapeInfo = mxUtils.getValue(this.style, 'mainText', '20,Time 1,50,Time 2,30,Time 3,40,Time 4,30,Time 5,50,Time 6,20,Time 7').toString().split(',');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '12');
	var times = new Array();
	var totalTime = 0;
	
	for (var i = 0; i < shapeInfo.length; i = i + 2)
	{
		var currTime = parseFloat(shapeInfo[i]); 
		times.push(currTime);
		totalTime = totalTime + currTime;
	};
	
	var scaleX = w / totalTime;
	var names = new Array();
	
	for (var i = 1; i < shapeInfo.length; i = i + 2)
	{
		names.push(shapeInfo[i]);
	};
	
	c.begin();
	var currX = 0;
	c.moveTo(0, h);
	
	for (var i = 0; i < names.length; i++)
	{
		var currTime = times[i] * scaleX;
		currX = currX + currTime;
		
		if (i % 2 === 0)
		{
			c.lineTo(currX, h);
			c.lineTo(currX, fontSize * 1.5);
			c.text(currX - currTime * 0.5, h - fontSize * 0.75, 0, 0, names[i], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		}
		else
		{
			c.lineTo(currX, fontSize * 1.5);
			c.lineTo(currX, h);
			c.text(currX - currTime * 0.5, fontSize * 0.75, 0, 0, names[i], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		}
	};
	
	c.stroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.timeline', mxLeanTimeline);

//**********************************************************************************************************************************************************
//Cross Dock
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanCrossDock(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanCrossDock, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanCrossDock.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.rect(0, 0, w, h);
	c.fillAndStroke();
	
	c.setShadow(false);
	
	c.begin();
	c.moveTo(0, h * 0.25);
	c.lineTo(w, h * 0.25);
	
	c.moveTo(w * 0.1, h * 0.4);
	c.lineTo(w * 0.35, h * 0.4);
	c.arcTo(w * 0.15, h * 0.15, 0, 0, 1, w * 0.5, h * 0.5);
	c.arcTo(w * 0.15, h * 0.15, 0, 0, 0, w * 0.65, h * 0.6);
	c.lineTo(w * 0.9, h * 0.6);
	c.stroke();

	c.moveTo(w * 0.1, h * 0.4);
	c.lineTo(w * 0.35, h * 0.4);
	c.arcTo(w * 0.15, h * 0.25, 0, 0, 1, w * 0.5, h * 0.55);
	c.arcTo(w * 0.15, h * 0.25, 0, 0, 0, w * 0.65, h * 0.7);
	c.lineTo(w * 0.9, h * 0.7);
	c.stroke();

	c.moveTo(w * 0.1, h * 0.4);
	c.lineTo(w * 0.35, h * 0.4);
	c.arcTo(w * 0.15, h * 0.3, 0, 0, 1, w * 0.5, h * 0.6);
	c.arcTo(w * 0.15, h * 0.3, 0, 0, 0, w * 0.65, h * 0.8);
	c.lineTo(w * 0.9, h * 0.8);
	c.stroke();

	c.moveTo(w * 0.1, h * 0.8);
	c.lineTo(w * 0.35, h * 0.8);
	c.arcTo(w * 0.15, h * 0.3, 0, 0, 0, w * 0.5, h * 0.6);
	c.arcTo(w * 0.15, h * 0.3, 0, 0, 1, w * 0.65, h * 0.4);
	c.lineTo(w * 0.9, h * 0.4);
	c.stroke();

	c.moveTo(w * 0.1, h * 0.8);
	c.lineTo(w * 0.35, h * 0.8);
	c.arcTo(w * 0.15, h * 0.1, 0, 0, 0, w * 0.5, h * 0.75);
	c.arcTo(w * 0.15, h * 0.1, 0, 0, 1, w * 0.65, h * 0.7);
	c.lineTo(w * 0.9, h * 0.7);
	c.stroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.crossDock', mxLeanCrossDock);

mxLeanCrossDock.prototype.constraints = [
                                         new mxConnectionConstraint(new mxPoint(0, 0), true),
                                         new mxConnectionConstraint(new mxPoint(1, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0, 1), true),
                                         new mxConnectionConstraint(new mxPoint(1, 1), true),
                                         new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                         new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                         new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                         new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                         new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                         new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                         new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                         new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                         new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                         ];

//**********************************************************************************************************************************************************
//Orders
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanOrders(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanOrders, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanOrders.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.rect(0, h * 0.56, w, h * 0.44);
	c.fillAndStroke();
	
	var strokeWidth = parseFloat(mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '2'));
	c.setStrokeWidth(strokeWidth * 0.5);
	
	c.begin();
	c.moveTo(w * 0.04, h * 0.5418);
	c.lineTo(w * 0.94, h * 0.5418);
	c.moveTo(w * 0.0522, h * 0.5088);
	c.lineTo(w * 0.9522, h * 0.5088);
	c.moveTo(w * 0.05, h * 0.4738);
	c.lineTo(w * 0.95, h * 0.4738);
	c.moveTo(w * 0.0456, h * 0.4427);
	c.lineTo(w * 0.9456, h * 0.4427);
	c.moveTo(w * 0.0422, h * 0.4135);
	c.lineTo(w * 0.9422, h * 0.4135);
	c.moveTo(w * 0.0533, h * 0.3804);
	c.lineTo(w * 0.9533, h * 0.3804);
	c.moveTo(w * 0.0556, h * 0.3454);
	c.lineTo(w * 0.9556, h * 0.3454);
	c.moveTo(w * 0.05, h * 0.3143);
	c.lineTo(w * 0.95, h * 0.3143);
	c.moveTo(w * 0.0489, h * 0.2832);
	c.lineTo(w * 0.0489, h * 0.2832);
	c.moveTo(w * 0.0544, h * 0.254);
	c.lineTo(w * 0.9544, h * 0.254);
	c.moveTo(w * 0.0489, h * 0.221);
	c.lineTo(w * 0.9489, h * 0.221);
	c.moveTo(w * 0.0556, h * 0.1918);
	c.lineTo(w * 0.9556, h * 0.1918);
	c.moveTo(w * 0.0522, h * 0.1587);
	c.lineTo(w * 0.9522, h * 0.1587);
	c.moveTo(w * 0.0544, h * 0.1276);
	c.lineTo(w * 0.9544, h * 0.1276);
	c.moveTo(w * 0.0544, h * 0.0965);
	c.lineTo(w * 0.9544, h * 0.0965);
	c.moveTo(w * 0.0556, h * 0.0654);
	c.lineTo(w * 0.9556, h * 0.0654);
	c.moveTo(w * 0.0533, h * 0.0304);
	c.lineTo(w * 0.9533, h * 0.0304);
	c.moveTo(w * 0.0556, 0);
	c.lineTo(w * 0.9556, 0);
	c.stroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.orders', mxLeanOrders);

mxLeanOrders.prototype.constraints = [
                                         new mxConnectionConstraint(new mxPoint(0.05, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0.95, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0, 1), true),
                                         new mxConnectionConstraint(new mxPoint(1, 1), true),
                                         new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0.05, 0.25), false),
                                         new mxConnectionConstraint(new mxPoint(0.05, 0.5), false),
                                         new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                         new mxConnectionConstraint(new mxPoint(0.95, 0.25), false),
                                         new mxConnectionConstraint(new mxPoint(0.95, 0.5), false),
                                         new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                         new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                         new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                         new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                         ];

//**********************************************************************************************************************************************************
//Batched Kanban
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanBatchedKanban(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanBatchedKanban, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanBatchedKanban.prototype.paintVertexShape = function(c, x, y, w, h)
{
	w = Math.max(110, w);
	
	c.translate(x, y);
	
	c.begin();
	c.moveTo(4, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.5 - 20, h * 0.5 - 35);
	c.lineTo(w * 0.5 + 25, h * 0.5 - 35);
	c.lineTo(w * 0.5 + 40, h * 0.5 - 20);
	c.lineTo(w * 0.5 + 40, h * 0.5 + 15);
	c.lineTo(w * 0.5 - 20, h * 0.5 + 15);
	c.close();
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w * 0.5 - 30, h * 0.5 - 25);
	c.lineTo(w * 0.5 + 15, h * 0.5 - 25);
	c.lineTo(w * 0.5 + 30, h * 0.5 - 10);
	c.lineTo(w * 0.5 + 30, h * 0.5 + 25);
	c.lineTo(w * 0.5 - 30, h * 0.5 + 25);
	c.close();
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w * 0.5 - 40, h * 0.5 - 15);
	c.lineTo(w * 0.5 + 5, h * 0.5 - 15);
	c.lineTo(w * 0.5 + 20, h * 0.5);
	c.lineTo(w * 0.5 + 20, h * 0.5 + 35);
	c.lineTo(w * 0.5 - 40, h * 0.5 + 35);
	c.close();
	c.fillAndStroke();
	
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w - 10, h * 0.5 - 4);
	c.lineTo(w, h * 0.5);
	c.lineTo(w - 10, h * 0.5 + 4);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.batched_kanban', mxLeanBatchedKanban);

mxLeanBatchedKanban.prototype.constraints = [
                                      new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                      new mxConnectionConstraint(new mxPoint(1, 0.5), true)
                                      ];

//**********************************************************************************************************************************************************
//Control Center
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxLeanControlCenter(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxLeanControlCenter, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxLeanControlCenter.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.rect(w * 0.15, 0, w * 0.7, h * 0.8);
	c.fillAndStroke();
	c.rect(0, h * 0.8, w, h * 0.2);
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.lean_mapping.control_center', mxLeanControlCenter);

mxLeanControlCenter.prototype.constraints = [
                                      new mxConnectionConstraint(new mxPoint(0.15, 0), true),
                                      new mxConnectionConstraint(new mxPoint(0.85, 0), true),
                                      new mxConnectionConstraint(new mxPoint(0, 1), true),
                                      new mxConnectionConstraint(new mxPoint(1, 1), true),
                                      new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                      new mxConnectionConstraint(new mxPoint(0.15, 0.25), false),
                                      new mxConnectionConstraint(new mxPoint(0.15, 0.5), false),
                                      new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                      new mxConnectionConstraint(new mxPoint(0.85, 0.25), false),
                                      new mxConnectionConstraint(new mxPoint(0.85, 0.5), false),
                                      new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                      new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                      new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                      new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                      ];

//**********************************************************************************************************************************************************
//Electronical Info
//**********************************************************************************************************************************************************
function mxLeanElectronicInfoShape()
{
	mxArrow.call(this);
};

mxUtils.extend(mxLeanElectronicInfoShape, mxArrow);

mxLeanElectronicInfoShape.prototype.paintEdgeShape = function(c, pts)
{
	// Base vector (between end points)
	var p0 = pts[0];
	var pe = pts[pts.length - 1];
	
	var dx = pe.x - p0.x;
	var dy = pe.y - p0.y;
	
	p0.x = p0.x + dx * 0.05;
	p0.y = p0.y + dy * 0.05;
	pe.x = pe.x - dx * 0.05;
	pe.y = pe.y - dy * 0.05;
	dx = pe.x - p0.x;
	dy = pe.y - p0.y;
	
	var dist = Math.sqrt(dx * dx + dy * dy);
	var nx = dx / dist;
	var ny = dy / dist;
	var midX = p0.x + dx * 0.5; 
	var midY = p0.y + dy * 0.5;
	
	var p1x = midX - nx * dist * 0.1 - ny / 3 * dist * 0.1;
	var p1y = midY - ny * dist * 0.1 + nx / 3 * dist * 0.1;
	var p4x = midX + nx * dist * 0.1 + ny / 3 * dist * 0.1;
	var p4y = midY + ny * dist * 0.1 - nx / 3 * dist * 0.1;

	c.begin();
	c.moveTo(p0.x, p0.y);
	c.lineTo(p4x, p4y);
	c.lineTo(p1x, p1y);
	c.lineTo(pe.x, pe.y);
	c.stroke();

	var dx = pe.x - p1x;
	var dy = pe.y - p1y;
	var dist = Math.sqrt(dx * dx + dy * dy);
	var nx = dx / dist;
	var ny = dy / dist;
	
	c.setFillColor(mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000'));
	c.begin();
	c.moveTo(pe.x - nx * 10 - ny * 5, pe.y - ny * 10 + nx * 5);
	c.lineTo(pe.x, pe.y);
	c.lineTo(pe.x - nx * 10 + ny * 5, pe.y - ny * 10 - nx * 5);
	c.fillAndStroke();
};

// Registers the electronic info shape
mxCellRenderer.registerShape('mxgraph.lean_mapping.electronic_info_flow_edge', mxLeanElectronicInfoShape);

//**********************************************************************************************************************************************************
//Manual Info
//**********************************************************************************************************************************************************
function mxLeanManualInfoShape()
{
	mxArrow.call(this);
};

mxUtils.extend(mxLeanManualInfoShape, mxArrow);

mxLeanManualInfoShape.prototype.paintEdgeShape = function(c, pts)
{
	// Base vector (between end points)
	var p0 = pts[0];
	var pe = pts[pts.length - 1];
	
	var dx = pe.x - p0.x;
	var dy = pe.y - p0.y;
	
	p0.x = p0.x + dx * 0.05;
	p0.y = p0.y + dy * 0.05;
	pe.x = pe.x - dx * 0.05;
	pe.y = pe.y - dy * 0.05;
	dx = pe.x - p0.x;
	dy = pe.y - p0.y;
	
	var dist = Math.sqrt(dx * dx + dy * dy);
	var nx = dx / dist;
	var ny = dy / dist;
	
	c.begin();
	c.moveTo(p0.x, p0.y);
	c.lineTo(pe.x, pe.y);
	c.stroke();

	c.setFillColor(mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000'));
	c.begin();
	c.moveTo(pe.x - nx * 10 - ny * 5, pe.y - ny * 10 + nx * 5);
	c.lineTo(pe.x, pe.y);
	c.lineTo(pe.x - nx * 10 + ny * 5, pe.y - ny * 10 - nx * 5);
	c.fillAndStroke();
};

//Registers the electronic info shape
mxCellRenderer.registerShape('mxgraph.lean_mapping.manual_info_flow_edge', mxLeanManualInfoShape);

//**********************************************************************************************************************************************************
//Timeline
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeLeanTimeline(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeLeanTimeline, mxShape);

mxShapeLeanTimeline.prototype.cst = {
		SHAPE_TIMELINE : 'mxgraph.lean_mapping.timeline2'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeLeanTimeline.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dy1 = mxUtils.getValue(this.style, 'dy1', '0');
	var dx2 = mxUtils.getValue(this.style, 'dx2', '0');
	var dy2 = mxUtils.getValue(this.style, 'dy2', '0');
	var dx3 = mxUtils.getValue(this.style, 'dx3', '0');
	var dy3 = mxUtils.getValue(this.style, 'dy3', '0');
	var dx4 = mxUtils.getValue(this.style, 'dx4', '0');
	var dy4 = mxUtils.getValue(this.style, 'dy4', '0');
	var dx5 = mxUtils.getValue(this.style, 'dx5', '0');
	var dy5 = mxUtils.getValue(this.style, 'dy5', '0');
	var dy6 = mxUtils.getValue(this.style, 'dy6', '0');
	
	var lastUp = true;

	c.begin();

	if (dy1 <= 0.5)
	{
		c.moveTo(0, 0);
		lastUp = true;
	}
	else
	{
		c.moveTo(0, h);
		lastUp = false;
	}

	//2
	if (dy2 <= 0.5 && lastUp)
	{
		c.lineTo(dx2, 0);
		lastUp = true;
	}
	else if (dy2 > 0.5 && !lastUp)
	{
		c.lineTo(dx2, h);
		lastUp = false;
	}
	else if (dy2 <= 0.5 && !lastUp)
	{
		c.lineTo(dx2, h);
		c.lineTo(dx2, 0);
		lastUp = true;
	}
	else
	{
		c.lineTo(dx2, 0);
		c.lineTo(dx2, h);
		lastUp = false;
	}
		
	//3
	if (dy3 <= 0.5 && lastUp)
	{
		c.lineTo(dx3, 0);
		lastUp = true;
	}
	else if (dy3 > 0.5 && !lastUp)
	{
		c.lineTo(dx3, h);
		lastUp = false;
	}
	else if (dy3 <= 0.5 && !lastUp)
	{
		c.lineTo(dx3, h);
		c.lineTo(dx3, 0);
		lastUp = true;
	}
	else
	{
		c.lineTo(dx3, 0);
		c.lineTo(dx3, h);
		lastUp = false;
	}
		
	//4
	if (dy4 <= 0.5 && lastUp)
	{
		c.lineTo(dx4, 0);
		lastUp = true;
	}
	else if (dy4 > 0.5 && !lastUp)
	{
		c.lineTo(dx4, h);
		lastUp = false;
	}
	else if (dy4 <= 0.5 && !lastUp)
	{
		c.lineTo(dx4, h);
		c.lineTo(dx4, 0);
		lastUp = true;
	}
	else
	{
		c.lineTo(dx4, 0);
		c.lineTo(dx4, h);
		lastUp = false;
	}
		
	//5
	if (dy5 <= 0.5 && lastUp)
	{
		c.lineTo(dx5, 0);
		lastUp = true;
	}
	else if (dy5 > 0.5 && !lastUp)
	{
		c.lineTo(dx5, h);
		lastUp = false;
	}
	else if (dy5 <= 0.5 && !lastUp)
	{
		c.lineTo(dx5, h);
		c.lineTo(dx5, 0);
		lastUp = true;
	}
	else
	{
		c.lineTo(dx5, 0);
		c.lineTo(dx5, h);
		lastUp = false;
	}
		
	//6
	if (dy6 <= 0.5 && lastUp)
	{
		c.lineTo(w, 0);
		lastUp = true;
	}
	else if (dy6 > 0.5 && !lastUp)
	{
		c.lineTo(w, h);
		lastUp = false;
	}
	else if (dy6 <= 0.5 && !lastUp)
	{
		c.lineTo(w, h);
		c.lineTo(w, 0);
		lastUp = true;
	}
	else
	{
		c.lineTo(w, 0);
		c.lineTo(w, h);
		lastUp = false;
	}
		
	//end
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeLeanTimeline.prototype.cst.SHAPE_TIMELINE, mxShapeLeanTimeline);

Graph.handleFactory[mxShapeLeanTimeline.prototype.cst.SHAPE_TIMELINE] = function(state)
{
	var handles = [Graph.createHandle(state, ['dy1'], function(bounds)
			{
				var dy1 = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'dy1', 0))));

				return new mxPoint(bounds.x, bounds.y + dy1 * bounds.height);
			}, function(bounds, pt)
			{
				this.state.style['dy1'] = Math.round(1000 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1000;
			})];

	var handle2 = Graph.createHandle(state, ['dx2', 'dy2'], function(bounds)
			{

				var dx2 = Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'dx3', 0)), parseFloat(mxUtils.getValue(this.state.style, 'dx2', 0))));
				var dy2 = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'dy2', 0))));

				return new mxPoint(bounds.x + dx2, bounds.y + dy2 * bounds.height);
			}, function(bounds, pt)
			{
				this.state.style['dx2'] = Math.round(1000 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, 'dx3', 0)), (pt.x - bounds.x)))) / 1000;
				this.state.style['dy2'] = Math.round(1000 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1000;
			});
	
	handles.push(handle2);

	var handle3 = Graph.createHandle(state, ['dx3', 'dy3'], function(bounds)
			{
				var dx3 = Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dx2', 0)), Math.min(parseFloat(mxUtils.getValue(this.state.style, 'dx4', 0)), parseFloat(mxUtils.getValue(this.state.style, 'dx3', 0))));
				var dy3 = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'dy3', 0))));

				return new mxPoint(bounds.x + dx3, bounds.y + dy3 * bounds.height);
			}, function(bounds, pt)
			{
				this.state.style['dx3'] = Math.round(1000 * Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dx2', 0)), Math.min(parseFloat(mxUtils.getValue(this.state.style, 'dx4', 0)), (pt.x - bounds.x)))) / 1000;
				this.state.style['dy3'] = Math.round(1000 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1000;
			});
	
	handles.push(handle3);

	var handle4 = Graph.createHandle(state, ['dx4', 'dy4'], function(bounds)
			{
				var dx4 = Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dx3', 0)), Math.min(parseFloat(mxUtils.getValue(this.state.style, 'dx5', 0)), parseFloat(mxUtils.getValue(this.state.style, 'dx4', 0))));
				var dy4 = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'dy4', 0))));

				return new mxPoint(bounds.x + dx4, bounds.y + dy4 * bounds.height);
			}, function(bounds, pt)
			{
				this.state.style['dx4'] = Math.round(1000 * Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dx3', 0)), Math.min(parseFloat(mxUtils.getValue(this.state.style, 'dx5', 0)), (pt.x - bounds.x)))) / 1000;
				this.state.style['dy4'] = Math.round(1000 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1000;
			});
	
	handles.push(handle4);

	var handle5 = Graph.createHandle(state, ['dx5', 'dy5'], function(bounds)
			{
				var dx5 = Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dx4', 0)), Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx5', 0))));
				var dy5 = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'dy5', 0))));

				return new mxPoint(bounds.x + dx5, bounds.y + dy5 * bounds.height);
			}, function(bounds, pt)
			{
				this.state.style['dx5'] = Math.round(1000 * Math.max(parseFloat(mxUtils.getValue(this.state.style, 'dx4', 0)), Math.min(bounds.width, (pt.x - bounds.x)))) / 1000;
				this.state.style['dy5'] = Math.round(1000 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1000;
			});
	
	handles.push(handle5);

	var handle6 = Graph.createHandle(state, ['dy6'], function(bounds)
			{
				var dy6 = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'dy6', 0))));

				return new mxPoint(bounds.x + bounds.width, bounds.y + dy6 * bounds.height);
			}, function(bounds, pt)
			{
				this.state.style['dy6'] = Math.round(1000 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1000;
			});

	handles.push(handle6);

	return handles;
};

/**
 * $Id: mxNetworks.js,v 1.0 2015/06/15 17:05:39 mate Exp $
 * Copyright (c) 2006-2015, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Bus
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeNetworksBus(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeNetworksBus, mxShape);

mxShapeNetworksBus.prototype.cst = {
		SHAPE_BUS : 'mxgraph.networks.bus'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeNetworksBus.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeNetworksBus.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(8, h * 0.5 + 10);
	c.arcTo(12, 12, 0, 0, 1, 8, h * 0.5 - 10);
	c.lineTo(w - 8, h * 0.5 - 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 + 10);
	c.close();
	c.fillAndStroke();
};

mxShapeNetworksBus.prototype.foreground = function(c, x, y, w, h)
{
	c.setFillColor('#ffffff');
	c.begin();
	c.moveTo(w - 8, h * 0.5 - 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 + 10);
	c.arcTo(12, 12, 0, 0, 1, w - 8, h * 0.5 - 10);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeNetworksBus.prototype.cst.SHAPE_BUS, mxShapeNetworksBus);

//**********************************************************************************************************************************************************
//Comm Link
//**********************************************************************************************************************************************************
function mxShapeNetworksCommLinkEdge()
{
	mxArrow.call(this);
};

mxUtils.extend(mxShapeNetworksCommLinkEdge, mxArrow);

mxShapeNetworksCommLinkEdge.prototype.paintEdgeShape = function(c, pts)
{
	// Base vector (between end points)
	var p0 = pts[0];
	var pe = pts[pts.length - 1];
	
	var dx = pe.x - p0.x;
	var dy = pe.y - p0.y;
	
	p0.x = p0.x + dx * 0.05;
	p0.y = p0.y + dy * 0.05;
	pe.x = pe.x - dx * 0.05;
	pe.y = pe.y - dy * 0.05;
	dx = pe.x - p0.x;
	dy = pe.y - p0.y;
	
	var dist = Math.sqrt(dx * dx + dy * dy);
	var nx = dx / dist;
	var ny = dy / dist;
	var midX = p0.x + dx * 0.5; 
	var midY = p0.y + dy * 0.5;
	
	var p1x = midX + nx * dist / 3 * 0.1 - ny / 3 * dist * 0.1;
	var p1y = midY + ny * dist / 3 * 0.1 + nx / 3 * dist * 0.1;
	var p2x = midX + nx * dist * 0.1 + ny * dist * 0.1;
	var p2y = midY + ny * dist * 0.1 - nx * dist * 0.1;

	var p3x = midX - nx * dist / 3 * 0.1 + ny / 3 * dist * 0.1;
	var p3y = midY - ny * dist / 3 * 0.1 - nx / 3 * dist * 0.1;
	var p4x = midX - nx * dist * 0.1 - ny * dist * 0.1;
	var p4y = midY - ny * dist * 0.1 + nx * dist * 0.1;

	c.begin();
	c.moveTo(p0.x, p0.y);
	c.lineTo(p2x, p2y);
	c.lineTo(p1x, p1y);
	c.lineTo(pe.x, pe.y);
	c.lineTo(p4x, p4y);
	c.lineTo(p3x, p3y);
	c.close();
	c.fillAndStroke();
};

//Registers the comm link edge
mxCellRenderer.registerShape('mxgraph.networks.comm_link_edge', mxShapeNetworksCommLinkEdge);

/**
 * $Id: mxSysML.js,v 1.0 2014/07/23 07:05:39 mate Exp $
 * Copyright (c) 2006-2014, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Composite
//**********************************************************************************************************************************************************
function mxShapeSysMLComposite()
{
	mxCylinder.call(this);
};
	
mxUtils.extend(mxShapeSysMLComposite, mxShape);

mxShapeSysMLComposite.prototype.isHtmlAllowed = function()
{
	return false;
};

mxShapeSysMLComposite.prototype.paintForeground = function(c, x, y, w, h)
{
	if (this.style != null)
	{
		var shape = mxCellRenderer.defaultShapes[this.style['symbol0']];

		c.save();
			
		var tmp = new shape();
		tmp.style = this.style;
		shape.prototype.paintVertexShape.call(tmp, c, x, y, w, h);
		c.restore();

		c.setDashed(false);
			
		// Draws the symbols defined in the style. The symbols are
		// numbered from 1...n. Possible postfixes are align,
		// verticalAlign, spacing, arcSpacing, width, height
		var counter = 1;
			
		do
		{
			shape = mxCellRenderer.defaultShapes[this.style['symbol' + counter]];
				
			if (shape != null)
			{
				var align = this.style['symbol' + counter + 'Align'];
				var valign = this.style['symbol' + counter + 'VerticalAlign'];
				var width = this.style['symbol' + counter + 'Width'];
				var height = this.style['symbol' + counter + 'Height'];
				var spacing = this.style['symbol' + counter + 'Spacing'] || 0;
				var vspacing = this.style['symbol' + counter + 'VSpacing'] || 0;
				var arcspacing = this.style['symbol' + counter + 'ArcSpacing'];
				var direction = this.style['symbol' + counter + 'Direction'];
					
				if (arcspacing != null)
				{
					spacing += this.getArcSize(w + this.strokewidth, h + this.strokewidth) * arcspacing;
					vspacing += this.getArcSize(w + this.strokewidth, h + this.strokewidth) * arcspacing;
				}
					
				var x2 = x;
				var y2 = y;
					
				if (align == mxConstants.ALIGN_CENTER)
				{
					x2 += (w - width) / 2;
				}
				else if (align == mxConstants.ALIGN_RIGHT)
				{
					x2 += w - width - spacing;
				}
				else
				{
					x2 += spacing;
				}
					
				if (valign == mxConstants.ALIGN_MIDDLE)
				{
					y2 += (h - height) / 2;
				}
				else if (valign == mxConstants.ALIGN_BOTTOM)
				{
					y2 += h - height - vspacing;
				}
				else
				{
					y2 += vspacing;
				}
					
				c.save();
			
				var tmp = new shape();

				tmp.style = mxUtils.clone(this.style);
				tmp.direction = direction;
				tmp.updateTransform(c, x2, y2, width, height);
				shape.prototype.paintVertexShape.call(tmp, c, x2, y2, width, height);
				c.restore();
			}
				
			counter++;
		}
		while (shape != null);
	}
};

mxCellRenderer.registerShape('mxgraph.sysml.composite', mxShapeSysMLComposite);

//**********************************************************************************************************************************************************
//Package
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLPackage(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLPackage, mxShape);

mxShapeSysMLPackage.prototype.cst = {
		PACKAGE : 'mxgraph.sysml.package',
		LABEL_X : 'labelX'
};

mxShapeSysMLPackage.prototype.customProperties = [
	{name: 'labelX', dispName: 'Header Width', type: 'float', min:0, defVal:90} 
];

mxShapeSysMLPackage.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLPackage.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeSysMLPackage.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeSysMLPackage.prototype.foreground = function(c, x, y, w, h)
{
	var xSize = parseInt(mxUtils.getValue(this.style, mxShapeSysMLPackage.prototype.cst.LABEL_X, '90'));
	var ySize = 20;
	
	xSize = Math.min(xSize, w);
	
	if (xSize > ySize)
	{
		c.begin();
		c.moveTo(0, ySize);
		c.lineTo(xSize - ySize * 0.5, ySize);
		c.lineTo(xSize, ySize * 0.5);
		c.lineTo(xSize, 0);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapeSysMLPackage.prototype.cst.PACKAGE, mxShapeSysMLPackage);

Graph.handleFactory[mxShapeSysMLPackage.prototype.cst.PACKAGE] = function(state)
{
	var handles = [Graph.createHandle(state, ['labelX'], function(bounds)
			{
				var labelX = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'labelX', 90))));

				return new mxPoint(bounds.x + labelX, bounds.y + 10);
			}, function(bounds, pt)
			{
				this.state.style['labelX'] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
			})];
	
	return handles;

}

//**********************************************************************************************************************************************************
//Package2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLPackage2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLPackage2, mxShape);

mxShapeSysMLPackage2.prototype.cst = {
		PACKAGE2 : 'mxgraph.sysml.package2',
		LABEL_X : 'labelX'
};

mxShapeSysMLPackage2.prototype.customProperties = [
	{name: 'labelX', dispName: 'Header Width', type: 'float', min:0, defVal:90} 
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLPackage2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeSysMLPackage2.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.stroke();
};

mxShapeSysMLPackage2.prototype.foreground = function(c, x, y, w, h)
{
	var xSize = parseInt(mxUtils.getValue(this.style, mxShapeSysMLPackage2.prototype.cst.LABEL_X, '90'));
	var ySize = 20;
	
	xSize = Math.min(xSize, w);
	
	if (xSize > ySize)
	{
		c.begin();
		c.moveTo(0, ySize);
		c.lineTo(xSize - ySize * 0.5, ySize);
		c.lineTo(xSize, ySize * 0.5);
		c.lineTo(xSize, 0);
		c.lineTo(0, 0);
		c.close();
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeSysMLPackage2.prototype.cst.PACKAGE2, mxShapeSysMLPackage2);

Graph.handleFactory[mxShapeSysMLPackage2.prototype.cst.PACKAGE2] = function(state)
{
	var handles = [Graph.createHandle(state, ['labelX'], function(bounds)
			{
				var labelX = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'labelX', 90))));

				return new mxPoint(bounds.x + labelX, bounds.y + 10);
			}, function(bounds, pt)
			{
				this.state.style['labelX'] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
			})];
	
	return handles;

}

//**********************************************************************************************************************************************************
//None
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLNone(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLNone, mxShape);

mxShapeSysMLNone.prototype.cst = {
		NONE : 'mxgraph.sysml.none'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLNone.prototype.paintVertexShape = function(c, x, y, w, h)
{
};

mxCellRenderer.registerShape(mxShapeSysMLNone.prototype.cst.NONE, mxShapeSysMLNone);

//**********************************************************************************************************************************************************
//Rectangle
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLRect, mxShape);

mxShapeSysMLRect.prototype.cst = {
		RECT : 'mxgraph.sysml.rect'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.rect(x, y, w, h);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLRect.prototype.cst.RECT, mxShapeSysMLRect);

//**********************************************************************************************************************************************************
//Port
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLPortOne(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLPortOne, mxShape);

mxShapeSysMLPortOne.prototype.cst = {
		PORT1 : 'mxgraph.sysml.port1'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLPortOne.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.rect(x + w * 0.05, y, w - w * 0.1, h);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLPortOne.prototype.cst.PORT1, mxShapeSysMLPortOne);

mxShapeSysMLPortOne.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.05, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.95, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.95, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.95, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.95, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.05, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.05, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.05, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Port2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLPortTwo(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLPortTwo, mxShape);

mxShapeSysMLPortTwo.prototype.cst = {
		PORT2 : 'mxgraph.sysml.port2'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLPortTwo.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.rect(x + w * 0.05, y, w * 0.8, h);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLPortTwo.prototype.cst.PORT2, mxShapeSysMLPortTwo);

mxShapeSysMLPortTwo.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.05, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.95, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.95, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.95, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.95, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.05, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.05, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.05, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Port3
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLPortThree(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLPortThree, mxShape);

mxShapeSysMLPortThree.prototype.cst = {
		PORT3 : 'mxgraph.sysml.port3'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLPortThree.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.rect(x + w * 0.07, y, w * 0.86, h);
	c.fillAndStroke();
	c.rect(x, y + h * 0.125, w * 0.14, h * 0.25);
	c.fillAndStroke();
	c.rect(x, y + h * 0.625, w * 0.14, h * 0.25);
	c.fillAndStroke();
	c.rect(x + w * 0.86, y + h * 0.375, w * 0.14, h * 0.25);
	c.fillAndStroke();
	this.drawIn(c, x + w * 0.01, y + h * 0.2, w * 0.11, h * 0.10);
	this.drawOut(c, x + w * 0.02, y + h * 0.7, w * 0.11, h * 0.10);
	this.drawInOut(c, x + w * 0.88, y + h * 0.45, w * 0.1, h * 0.10);
};

mxShapeSysMLPortThree.prototype.drawIn = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(x, y + h * 0.5);
	c.lineTo(x + w, y + h * 0.5);
	c.moveTo(x + w * 0.75, y);
	c.lineTo(x + w, y + h * 0.5);
	c.lineTo(x + w * 0.75, y + h);
	c.stroke();
}

mxShapeSysMLPortThree.prototype.drawOut = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(x, y + h * 0.5);
	c.lineTo(x + w, y + h * 0.5);
	c.moveTo(x + w * 0.25, y);
	c.lineTo(x, y + h * 0.5);
	c.lineTo(x + w * 0.25, y + h);
	c.stroke();
}

mxShapeSysMLPortThree.prototype.drawInOut = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(x + w * 0.75, y);
	c.lineTo(x + w, y + h * 0.5);
	c.lineTo(x + w * 0.75, y + h);
	c.moveTo(x + w * 0.25, y);
	c.lineTo(x, y + h * 0.5);
	c.lineTo(x + w * 0.25, y + h);
	c.stroke();
}

mxCellRenderer.registerShape(mxShapeSysMLPortThree.prototype.cst.PORT3, mxShapeSysMLPortThree);

//**********************************************************************************************************************************************************
//Port
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLPortFour(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLPortFour, mxShape);

mxShapeSysMLPortFour.prototype.cst = {
		PORT4 : 'mxgraph.sysml.port4'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLPortFour.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.rect(x + w * 0.05, y, w - w * 0.05, h);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLPortFour.prototype.cst.PORT4, mxShapeSysMLPortFour);

mxShapeSysMLPortFour.prototype.constraints = [
                                                   new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                                   new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                                   new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                                   new mxConnectionConstraint(new mxPoint(1, 0.5), true)
                                                   ];

//**********************************************************************************************************************************************************
//Item Flow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLItemFlow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLItemFlow, mxShape);

mxShapeSysMLItemFlow.prototype.cst = {
		ITEM_FLOW : 'mxgraph.sysml.itemFlow',
		FLOW_DIR : 'flowDir',
		FLOW_TYPE : 'flowType'
};

mxShapeSysMLItemFlow.prototype.customProperties = [
	{name: 'flowDir', dispName: 'Flow Direction', type: 'enum',
		enumList:[
			{val:'n', dispName:'North'},
			{val:'s', dispName:'South'},
			{val:'e', dispName:'East'},
			{val:'w', dispName:'West'}
		]},
		{name: 'flowType', dispName: 'Flow Type', type: 'enum',
			enumList:[
				{val:'in', dispName:'In'},
				{val:'out', dispName:'Out'}
]}];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLItemFlow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var flowDir = mxUtils.getValue(this.style, mxShapeSysMLItemFlow.prototype.cst.FLOW_DIR, 'none').toLowerCase();
	var flowType = mxUtils.getValue(this.style, mxShapeSysMLItemFlow.prototype.cst.FLOW_TYPE, 'none');
	
	if (flowDir === 'n')
	{
		c.rect(x, y + 10, w, h - 10);
		c.fillAndStroke();

		c.setShadow(false);
		
		c.rect(x + w * 0.5 - 10, y, 20, 20);
		c.fillAndStroke();
		
		if (flowType === 'in')
		{
			this.drawDown(c, x + w * 0.5 - 5, y + 2, 10, 16);
		}
		else if (flowType === 'out')
		{
			this.drawUp(c, x + w * 0.5 - 5, y + 2, 10, 16);
		}
	}
	else if (flowDir === 's')
	{
		c.rect(x, y, w, h - 10);
		c.fillAndStroke();

		c.setShadow(false);
		
		c.rect(x + w * 0.5 - 10, y + h - 20, 20, 20);
		c.fillAndStroke();

		if (flowType === 'in')
		{
			this.drawUp(c, x + w * 0.5 - 5, y + h - 18, 10, 16);
		}
		else if (flowType === 'out')
		{
			this.drawDown(c, x + w * 0.5 - 5, y + h - 18, 10, 16);
		}
	}
	else if (flowDir === 'w')
	{
		c.rect(x + 10, y, w - 10, h);
		c.fillAndStroke();

		c.setShadow(false);
		
		c.rect(x, y + h * 0.5 - 10, 20, 20);
		c.fillAndStroke();
		
		if (flowType === 'in')
		{
			this.drawRight(c, x + 2, y + h * 0.5 - 5, 16, 10);
		}
		else if (flowType === 'out')
		{
			this.drawLeft(c, x + 2, y + h * 0.5 - 5, 16, 10);
		}
	}
	else if (flowDir === 'e')
	{
		c.rect(x, y, w - 10, h);
		c.fillAndStroke();

		c.setShadow(false);
		
		c.rect(x + w - 20, y + h * 0.5 - 10, 20, 20);
		c.fillAndStroke();
		
		if (flowType === 'in')
		{
			this.drawLeft(c, x + w - 18, y + h * 0.5 - 5, 16, 10);
		}
		else if (flowType === 'out')
		{
			this.drawRight(c, x + w - 18, y + h * 0.5 - 5, 16, 10);
		}
	}
};

mxShapeSysMLItemFlow.prototype.drawRight = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(x, y + h * 0.5);
	c.lineTo(x + w, y + h * 0.5);
	c.moveTo(x + w * 0.75, y);
	c.lineTo(x + w, y + h * 0.5);
	c.lineTo(x + w * 0.75, y + h);
	c.stroke();
}

mxShapeSysMLItemFlow.prototype.drawDown = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(x + w * 0.5, y);
	c.lineTo(x + w * 0.5, y + h);
	c.moveTo(x, y + h * 0.75);
	c.lineTo(x + w * 0.5, y + h);
	c.lineTo(x + w, y + h * 0.75);
	c.stroke();
}

mxShapeSysMLItemFlow.prototype.drawLeft = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(x, y + h * 0.5);
	c.lineTo(x + w, y + h * 0.5);
	c.moveTo(x + w * 0.25, y);
	c.lineTo(x, y + h * 0.5);
	c.lineTo(x + w * 0.25, y + h);
	c.stroke();
}

mxShapeSysMLItemFlow.prototype.drawUp = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(x + w * 0.5, y + h);
	c.lineTo(x + w * 0.5, y);
	c.moveTo(x, y + h * 0.25);
	c.lineTo(x + w * 0.5, y);
	c.lineTo(x + w, y + h * 0.25);
	c.stroke();
}

mxCellRenderer.registerShape(mxShapeSysMLItemFlow.prototype.cst.ITEM_FLOW, mxShapeSysMLItemFlow);

mxShapeSysMLItemFlow.prototype.constraints = [
                                         new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                         new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                         new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                         new mxConnectionConstraint(new mxPoint(0, 0.5), true)
                                         ];

//**********************************************************************************************************************************************************
//Item Flow Left
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLItemFlowLeft(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLItemFlowLeft, mxShape);

mxShapeSysMLItemFlowLeft.prototype.cst = {
		ITEM_FLOW_LEFT : 'mxgraph.sysml.itemFlowLeft'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLItemFlowLeft.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.rect(x + 10, y, w - 10, h);
	c.fillAndStroke();
	c.rect(x, y + h * 0.25 - 10, 20, 20);
	c.fillAndStroke();
	c.rect(x, y + h * 0.5 - 10, 20, 20);
	c.fillAndStroke();
	c.rect(x, y + h * 0.75 - 10, 20, 20);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLItemFlowLeft.prototype.cst.ITEM_FLOW_LEFT, mxShapeSysMLItemFlowLeft);

mxShapeSysMLItemFlowLeft.prototype.constraints = [
                                              new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                              new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                              new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                              new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                              new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                              new mxConnectionConstraint(new mxPoint(0, 0.75), true)
                                              ];

//**********************************************************************************************************************************************************
//Item Flow Right
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLItemFlowRight(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLItemFlowRight, mxShape);

mxShapeSysMLItemFlowRight.prototype.cst = {
		ITEM_FLOW_RIGHT : 'mxgraph.sysml.itemFlowRight'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLItemFlowRight.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.rect(x, y, w - 10, h);
	c.fillAndStroke();
	c.rect(x + w - 20, y + h * 0.25 - 10, 20, 20);
	c.fillAndStroke();
	c.rect(x + w - 20, y + h * 0.5 - 10, 20, 20);
	c.fillAndStroke();
	c.rect(x + w - 20, y + h * 0.75 - 10, 20, 20);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLItemFlowRight.prototype.cst.ITEM_FLOW_RIGHT, mxShapeSysMLItemFlowRight);

mxShapeSysMLItemFlowRight.prototype.constraints = [
                                                  new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                                  new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                                  new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                                  new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                                  new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                                  new mxConnectionConstraint(new mxPoint(1, 0.75), true)
                                                  ];

//**********************************************************************************************************************************************************
//Nested Port
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLNestedPort(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLNestedPort, mxShape);

mxShapeSysMLNestedPort.prototype.cst = {
		NESTED_PORT : 'mxgraph.sysml.nestedPort'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLNestedPort.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.rect(x + w * 0.08, y, w * 0.92, h);
	c.fillAndStroke();
	c.rect(x + w * 0.03, y + h * 0.1, w * 0.1, h * 0.8);
	c.fillAndStroke();
	c.rect(x, y + h * 0.15, w * 0.06, h * 0.16);
	c.fillAndStroke();
	c.rect(x, y + h * 0.42, w * 0.06, h * 0.16);
	c.fillAndStroke();
	c.rect(x, y + h * 0.69, w * 0.06, h * 0.16);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLNestedPort.prototype.cst.NESTED_PORT, mxShapeSysMLNestedPort);

//**********************************************************************************************************************************************************
//Package Containment
//**********************************************************************************************************************************************************
mxMarker.addMarker('sysMLPackCont', function(c, shape, type, pe, unitX, unitY, size, source, sw, filled)
{
	var nx = unitX * (size + sw + 1);
	var ny = unitY * (size + sw + 1);
	var a = size / 2;

	return function()
	{
		c.begin();
		c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
		c.lineTo(pe.x - nx / 2 + ny / 2, pe.y - ny / 2 - nx / 2);
		c.stroke();
		c.ellipse(pe.x - 0.5 * nx - a, pe.y - 0.5 * ny - a, 2 * a, 2 * a);
		c.stroke();
	};
});

//**********************************************************************************************************************************************************
//Required Interface
//**********************************************************************************************************************************************************
mxMarker.addMarker('sysMLReqInt', function(c, shape, type, pe, unitX, unitY, size, source, sw, filled)
{
	var nx = unitX * (size + sw + 1);
	var ny = unitY * (size + sw + 1);
	var a = size / 2;
	
	return function()
	{
		var fillColor = mxUtils.getValue(shape.style, mxConstants.STYLE_FILLCOLOR, 'none');
		c.setFillColor(fillColor);
		c.ellipse(pe.x - 0.5 * nx - a, pe.y - 0.5 * ny - a, 2 * a, 2 * a);
		c.fillAndStroke();
	};
});

//**********************************************************************************************************************************************************
//Provided Interface
//**********************************************************************************************************************************************************
mxMarker.addMarker('sysMLProvInt', function(c, shape, type, pe, unitX, unitY, size, source, sw, filled)
{
	var nx = unitX * (size + sw + 1);
	var ny = unitY * (size + sw + 1);
	var a = size / 2;
	
	return function()
	{
		var fillColor = mxUtils.getValue(shape.style, mxConstants.STYLE_FILLCOLOR, 'none');
		c.setFillColor(fillColor);
		c.begin();
		c.moveTo(pe.x - ny / 2, pe.y + nx / 2);
		c.arcTo(a, a, 0, 0, 1, pe.x + ny / 2, pe.y - nx / 2);
		c.fillAndStroke();
	};
});

//**********************************************************************************************************************************************************
//Parametric Diagram
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLParametricDiagram(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLParametricDiagram, mxShape);

mxShapeSysMLParametricDiagram.prototype.cst = {
		PARAM_DGM : 'mxgraph.sysml.paramDgm'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLParametricDiagram.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.roundrect(x, y, w, h, 10, 10);
	c.fillAndStroke();
	
	c.setShadow(false);
	
	if (h > 60)
	{
		c.rect(x, y + h * 0.25 - 10, 20, 20);
		c.stroke();
		c.rect(x, y + h * 0.75 - 10, 20, 20);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapeSysMLParametricDiagram.prototype.cst.PARAM_DGM, mxShapeSysMLParametricDiagram);

//**********************************************************************************************************************************************************
//Constraint Property
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLConstraintProperty(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLConstraintProperty, mxShape);

mxShapeSysMLConstraintProperty.prototype.cst = {
		CONS_PROP : 'mxgraph.sysml.consProp'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLConstraintProperty.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.rect(x, y, w, h);
	c.fillAndStroke();
	
	c.setShadow(false);
	
	if (h > 60)
	{
		c.rect(x, y + 50, 20, 20);
		c.stroke();
		c.rect(x, y + 80, 20, 20);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapeSysMLConstraintProperty.prototype.cst.CONS_PROP, mxShapeSysMLConstraintProperty);

//**********************************************************************************************************************************************************
//Call Behavior Action
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLCallBehaviorAction(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLCallBehaviorAction, mxShape);

mxShapeSysMLCallBehaviorAction.prototype.cst = {
		CALL_BEH_ACT : 'mxgraph.sysml.callBehAct'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLCallBehaviorAction.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.roundrect(x, y, w, h, 10, 10);
	c.fillAndStroke();
	
	if ((h > 30) && (w > 40))
	{
		c.setShadow(false);
		
		this.drawSymb(c, x + w - 30, y + h - 30, 20, 20);
	}
};

mxShapeSysMLCallBehaviorAction.prototype.drawSymb = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(x + w * 0.5, y);
	c.lineTo(x + w * 0.5, y + h);
	c.moveTo(x, y + h);
	c.lineTo(x, y + h * 0.5);
	c.lineTo(x + w, y + h * 0.5);
	c.lineTo(x + w, y + h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeSysMLCallBehaviorAction.prototype.cst.CALL_BEH_ACT, mxShapeSysMLCallBehaviorAction);

mxShapeSysMLCallBehaviorAction.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2.9, 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, -2.9, 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false, null, -2.9, -2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false, null, 2.9, -2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Accept Event Action
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLAcceptEventAction(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLAcceptEventAction, mxShape);

mxShapeSysMLAcceptEventAction.prototype.cst = {
		ACC_EVENT : 'mxgraph.sysml.accEvent'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLAcceptEventAction.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(x, y);
	c.lineTo(x + w, y);
	c.lineTo(x + w, y + h);
	c.lineTo(x, y + h);
	c.lineTo(x + h * 0.3, y + h * 0.5);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLAcceptEventAction.prototype.cst.ACC_EVENT, mxShapeSysMLAcceptEventAction);

mxShapeSysMLAcceptEventAction.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null,  h * 0.3, 0));

	return (constr);
};

//**********************************************************************************************************************************************************
//Time Event
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLTimeEvent(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLTimeEvent, mxShape);

mxShapeSysMLTimeEvent.prototype.cst = {
		TIME_EVENT : 'mxgraph.sysml.timeEvent'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLTimeEvent.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(x, y);
	c.lineTo(x + w, y);
	c.lineTo(x, y + h);
	c.lineTo(x + w, y + h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLTimeEvent.prototype.cst.TIME_EVENT, mxShapeSysMLTimeEvent);

mxShapeSysMLTimeEvent.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Send Signal Action
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLSendSignalAction(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLSendSignalAction, mxShape);

mxShapeSysMLSendSignalAction.prototype.cst = {
		SEND_SIG_ACT : 'mxgraph.sysml.sendSigAct'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLSendSignalAction.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(x, y);
	c.lineTo(x + w - h * 0.3, y);
	c.lineTo(x + w, y + h * 0.5);
	c.lineTo(x + w - h * 0.3, y + h);
	c.lineTo(x, y + h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLSendSignalAction.prototype.cst.SEND_SIG_ACT, mxShapeSysMLSendSignalAction);

mxShapeSysMLSendSignalAction.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, -h * 0.3, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false, null, -h * 0.3, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Activity Final
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLActivityFinal(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLActivityFinal, mxShape);

mxShapeSysMLActivityFinal.prototype.cst = {
		ACT_FINAL : 'mxgraph.sysml.actFinal'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLActivityFinal.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.ellipse(x, y, w, h);
	c.fillAndStroke();
	
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setFillColor(strokeColor);
	
	c.ellipse(x + 5, y + 5, w - 10, h - 10);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLActivityFinal.prototype.cst.ACT_FINAL, mxShapeSysMLActivityFinal);

mxShapeSysMLActivityFinal.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.145, 0.145), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.855, 0.145), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.855, 0.855), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.145, 0.855), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Activity Parameter Node
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLActivityParameterNode(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLActivityParameterNode, mxShape);

mxShapeSysMLActivityParameterNode.prototype.cst = {
		ACT_PARAM_NODE : 'mxgraph.sysml.actParamNode'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLActivityParameterNode.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	var minX = Math.max(w * 0.35, 70);
	var maxX = Math.min(w * 0.65, w - 10);
	c.begin();
	c.moveTo(minX, h);
	c.lineTo(10, h);
	c.lineTo(10, 0);
	c.lineTo(minX, 0);
	c.moveTo(maxX, h);
	c.lineTo(w - 10, h);
	c.lineTo(w - 10, 0);
	c.lineTo(maxX, 0);
	c.stroke();

	var xSize = 50;
	var ySize = 20;
	
	xSize = Math.min(xSize, w);
	
	if (xSize > ySize)
	{
		c.begin();
		c.moveTo(10, ySize);
		c.lineTo(xSize - ySize * 0.5, ySize);
		c.lineTo(xSize, ySize * 0.5);
		c.lineTo(xSize, 0);
		c.lineTo(10, 0);
		c.close();
		c.fillAndStroke();
	}
	
	c.rect(0, h * 0.35 - 10, 20, 20);
	c.fillAndStroke();
	c.rect(0, h * 0.65 - 10, 20, 20);
	c.fillAndStroke();
	c.rect(w - 20, h * 0.5 - 10, 20, 20);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLActivityParameterNode.prototype.cst.ACT_PARAM_NODE, mxShapeSysMLActivityParameterNode);

mxShapeSysMLActivityParameterNode.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.35), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.65), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Control Operator
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLControlOperator(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLControlOperator, mxShape);

mxShapeSysMLControlOperator.prototype.cst = {
		CONT_OPER : 'mxgraph.sysml.contOper'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLControlOperator.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeSysMLControlOperator.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeSysMLControlOperator.prototype.foreground = function(c, x, y, w, h)
{
	var xSize = 130;
	var ySize = 20;
	
	xSize = Math.min(xSize, w);
	
	if (xSize > ySize)
	{
		c.begin();
		c.moveTo(0, ySize);
		c.lineTo(xSize - ySize * 0.5, ySize);
		c.lineTo(xSize, ySize * 0.5);
		c.lineTo(xSize, 0);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapeSysMLControlOperator.prototype.cst.CONT_OPER, mxShapeSysMLControlOperator);

//**********************************************************************************************************************************************************
//Flow Final
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLFlowFinal(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLFlowFinal, mxShape);

mxShapeSysMLFlowFinal.prototype.cst = {
		FLOW_FINAL : 'mxgraph.sysml.flowFinal'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLFlowFinal.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();

	c.setShadow(false);
	
	c.begin();
	c.moveTo(w * 0.145, h * 0.145);
	c.lineTo(w * 0.855, h * 0.855);
	c.moveTo(w * 0.855, h * 0.145);
	c.lineTo(w * 0.145, h * 0.855);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeSysMLFlowFinal.prototype.cst.FLOW_FINAL, mxShapeSysMLFlowFinal);

mxShapeSysMLFlowFinal.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0.145, 0.145), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.855, 0.145), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.855, 0.855), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.145, 0.855), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Is Control
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLIsControl(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLIsControl, mxShape);

mxShapeSysMLIsControl.prototype.cst = {
		IS_CONTROL : 'mxgraph.sysml.isControl'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLIsControl.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.rect(0, h * 0.5 - 10, 10, 20);
	c.fillAndStroke();
	c.roundrect(10, 0, w - 20, h, 10, 10);
	c.fillAndStroke();
	c.rect(w - 10, h * 0.5 - 10, 10, 20);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLIsControl.prototype.cst.IS_CONTROL, mxShapeSysMLIsControl);

mxShapeSysMLIsControl.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Is Stream
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLIsStream(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLIsStream, mxShape);

mxShapeSysMLIsStream.prototype.cst = {
		IS_STREAM : 'mxgraph.sysml.isStream'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLIsStream.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');

	c.setFillColor(strokeColor);
	c.rect(0, h * 0.5 - 10, 10, 20);
	c.fillAndStroke();
	
	c.setFillColor(fillColor);
	c.roundrect(10, 0, w - 20, h, 10, 10);
	c.fillAndStroke();

	c.setFillColor(strokeColor);
	c.rect(w - 10, h * 0.5 - 10, 10, 20);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLIsStream.prototype.cst.IS_STREAM, mxShapeSysMLIsStream);

mxShapeSysMLIsStream.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Is Activity Stream
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLIsActStream(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLIsActStream, mxShape);

mxShapeSysMLIsActStream.prototype.cst = {
		IS_ACT_STREAM : 'mxgraph.sysml.isActStream'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLIsActStream.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.rect(0, 0, w - 10, h);
	c.fillAndStroke();

	var xSize = 40;
	var ySize = 20;
	
	xSize = Math.min(xSize, w);
	
	if (xSize > ySize)
	{
		c.begin();
		c.moveTo(0, ySize);
		c.lineTo(xSize - ySize * 0.5, ySize);
		c.lineTo(xSize, ySize * 0.5);
		c.lineTo(xSize, 0);
		c.lineTo(0, 0);
		c.close();
		c.fillAndStroke();
	}
	
	c.rect(w - 20, h * 0.5 - 10, 20, 20);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLIsActStream.prototype.cst.IS_ACT_STREAM, mxShapeSysMLIsActStream);

mxShapeSysMLIsActStream.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Parameter Set
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLParameterSet(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLParameterSet, mxShape);

mxShapeSysMLParameterSet.prototype.cst = {
		PARAM_SET : 'mxgraph.sysml.paramSet'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLParameterSet.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.rect(0, h * 0.5 - 28, 10, 56);
	c.fillAndStroke();
	c.roundrect(10, 0, w - 20, h, 10, 10);
	c.fillAndStroke();
	c.rect(w - 10, h * 0.5 - 28, 10, 56);
	c.fillAndStroke();

	c.setShadow(false);

	c.rect(4, h * 0.5 - 24, 6, 20);
	c.fillAndStroke();
	c.rect(4, h * 0.5 + 4, 6, 20);
	c.fillAndStroke();
	c.rect(w - 10, h * 0.5 - 24, 6, 20);
	c.fillAndStroke();
	c.rect(w - 10, h * 0.5 + 4, 6, 20);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLParameterSet.prototype.cst.PARAM_SET, mxShapeSysMLParameterSet);

mxShapeSysMLParameterSet.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, 0, -14));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, 0, 14));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false, null, 0, -14));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false, null, 0, 14));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Is Parameter Activity Set
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLParameterActivitySet(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLParameterActivitySet, mxShape);

mxShapeSysMLParameterActivitySet.prototype.cst = {
		PARAM_ACT_SET : 'mxgraph.sysml.paramActSet'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLParameterActivitySet.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.rect(10, 0, w - 20, h);
	c.fillAndStroke();

	var xSize = 50;
	var ySize = 20;
	
	xSize = Math.min(xSize, w);
	
	if (xSize > ySize)
	{
		c.begin();
		c.moveTo(10, ySize);
		c.lineTo(xSize - ySize * 0.5, ySize);
		c.lineTo(xSize, ySize * 0.5);
		c.lineTo(xSize, 0);
		c.lineTo(10, 0);
		c.close();
		c.fillAndStroke();
	}
	
	c.setShadow(false);
	
	if (h > 70)
	{
		c.rect(0, h * 0.5 - 28, 15, 56);
		c.fillAndStroke();
		c.rect(4, h * 0.5 - 24, 15, 20);
		c.fillAndStroke();
		c.rect(4, h * 0.5 + 4, 15, 20);
		c.fillAndStroke();
	
		c.rect(w - 15, h * 0.5 - 28, 15, 56);
		c.fillAndStroke();
		c.rect(w - 19, h * 0.5 - 24, 15, 20);
		c.fillAndStroke();
		c.rect(w - 19, h * 0.5 + 4, 15, 20);
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeSysMLParameterActivitySet.prototype.cst.PARAM_ACT_SET, mxShapeSysMLParameterActivitySet);

mxShapeSysMLParameterActivitySet.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, 0, -14));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, null, 0, 14));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false, null, 0, -14));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false, null, 0, 14));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));

	return (constr);
};

//**********************************************************************************************************************************************************
//Probability
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLProbability(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLProbability, mxShape);

mxShapeSysMLProbability.prototype.cst = {
		PROBABILITY : 'mxgraph.sysml.probability'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLProbability.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.roundrect(0, 0, w - 10, h, 10, 10);
	c.fillAndStroke();
	c.rect(w - 10, h * 0.25 - 28, 10, 56);
	c.fillAndStroke();
	c.rect(w - 10, h * 0.75 - 28, 10, 56);
	c.fillAndStroke();

	c.setShadow(false);

	c.rect(w - 10, h * 0.25 - 24, 6, 20);
	c.fillAndStroke();
	c.rect(w - 10, h * 0.25 + 4, 6, 20);
	c.fillAndStroke();
	c.rect(w - 10, h * 0.75 - 24, 6, 20);
	c.fillAndStroke();
	c.rect(w - 10, h * 0.75 + 4, 6, 20);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLProbability.prototype.cst.PROBABILITY, mxShapeSysMLProbability);

mxShapeSysMLProbability.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false, null, 0, -14));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false, null, 0, 14));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false, null, 0, -14));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false, null, 0, 14));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false, null, -5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, -5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false, null, -5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false, null, -5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false, null, -5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false, null, -5, 0));

	return (constr);
};

//**********************************************************************************************************************************************************
//Is Activity Stream
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLActivityProbability(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLActivityProbability, mxShape);

mxShapeSysMLActivityProbability.prototype.cst = {
		ACT_PROB : 'mxgraph.sysml.actProb'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLActivityProbability.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.rect(0, 0, w - 10, h);
	c.fillAndStroke();

	var xSize = 40;
	var ySize = 20;
	
	xSize = Math.min(xSize, w);
	
	if (xSize > ySize)
	{
		c.begin();
		c.moveTo(0, ySize);
		c.lineTo(xSize - ySize * 0.5, ySize);
		c.lineTo(xSize, ySize * 0.5);
		c.lineTo(xSize, 0);
		c.lineTo(0, 0);
		c.close();
		c.fillAndStroke();
	}
	
	c.setShadow(false);
	
	if (h > 70)
	{
		c.rect(w - 15, h * 0.25 - 28, 15, 56);
		c.fillAndStroke();
		c.rect(w - 19, h * 0.25 - 24, 15, 20);
		c.fillAndStroke();
		c.rect(w - 19, h * 0.25 + 4, 15, 20);
		c.fillAndStroke();

		c.rect(w - 15, h * 0.75 - 28, 15, 56);
		c.fillAndStroke();
		c.rect(w - 19, h * 0.75 - 24, 15, 20);
		c.fillAndStroke();
		c.rect(w - 19, h * 0.75 + 4, 15, 20);
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeSysMLActivityProbability.prototype.cst.ACT_PROB, mxShapeSysMLActivityProbability);

mxShapeSysMLActivityProbability.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false, null, 0, -14));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false, null, 0, 14));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false, null, 0, -14));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false, null, 0, 14));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false, null, -5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, -5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false, null, -5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false, null, -5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false, null, -5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false, null, -5, 0));

	return (constr);
};

//**********************************************************************************************************************************************************
//Object Flow Right
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLObjectFlowRight(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLObjectFlowRight, mxShape);

mxShapeSysMLObjectFlowRight.prototype.cst = {
		OBJ_FLOW_R : 'mxgraph.sysml.objFlowR'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLObjectFlowRight.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.roundrect(0, 0, w - 10, h, 10, 10);
	c.fillAndStroke();
	c.rect(w - 10, h * 0.5 - 10, 10, 20);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLObjectFlowRight.prototype.cst.OBJ_FLOW_R, mxShapeSysMLObjectFlowRight);

mxShapeSysMLObjectFlowRight.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, -5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false, null, -5, 0));

	return (constr);
};

//**********************************************************************************************************************************************************
//Object Flow Left
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLObjectFlowLeft(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLObjectFlowLeft, mxShape);

mxShapeSysMLObjectFlowLeft.prototype.cst = {
		OBJ_FLOW_L : 'mxgraph.sysml.objFlowL'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLObjectFlowLeft.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.rect(0, h * 0.5 - 10, 10, 20);
	c.fillAndStroke();
	c.roundrect(10, 0, w - 10, h, 10, 10);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLObjectFlowLeft.prototype.cst.OBJ_FLOW_L, mxShapeSysMLObjectFlowLeft);

mxShapeSysMLObjectFlowLeft.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, 5, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false, null, 5, 0));

	return (constr);
};

//**********************************************************************************************************************************************************
//Activity Partition
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLActivityPartition(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLActivityPartition, mxShape);

mxShapeSysMLActivityPartition.prototype.cst = {
		ACT_PART : 'mxgraph.sysml.actPart'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLActivityPartition.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(0, h);
	c.moveTo(w, 0);
	c.lineTo(w, h);
	c.stroke();
	
};

mxCellRenderer.registerShape(mxShapeSysMLActivityPartition.prototype.cst.ACT_PART, mxShapeSysMLActivityPartition);

//**********************************************************************************************************************************************************
//Continuation
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLContinuation(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLContinuation, mxShape);

mxShapeSysMLContinuation.prototype.cst = {
		CONT : 'mxgraph.sysml.cont'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLContinuation.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	if (w > h)
	{
		var r = h * 0.5;
	
		c.begin();
		c.moveTo(w - r, 0);
		c.arcTo(r, r, 0, 0, 1, w - r, h);
		c.lineTo(r, h);
		c.arcTo(r, r, 0, 0, 1, r, 0);
		c.close();
		c.fillAndStroke();
	}
	else
	{
		var r = w * 0.5;
		
		c.begin();
		c.moveTo(0, h - r);
		c.arcTo(r, r, 0, 0, 0, w, h - r);
		c.lineTo(w, r);
		c.arcTo(r, r, 0, 0, 0, 0, r);
		c.close();
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeSysMLContinuation.prototype.cst.CONT, mxShapeSysMLContinuation);

mxShapeSysMLContinuation.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	
	if (w > h)
	{
		var r = h * 0.5;

		if (w > 2 * h)
		{
			constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
			constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
			constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
			constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
		}
	}
	else
	{
		var r = w * 0.5;
		
		if (h > 2 * w)
		{
			constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));
			constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
			constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
			constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
		}
	}

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, r * 0.29, r * 0.29));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - r * 0.29, r * 0.29));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, r * 0.29, h - r * 0.29));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - r * 0.29, h - r * 0.29));

	return (constr);
};

//**********************************************************************************************************************************************************
//Coregion
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLCoregion(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLCoregion, mxShape);

mxShapeSysMLCoregion.prototype.cst = {
		COREGION : 'mxgraph.sysml.coregion'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLCoregion.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var brack = 10;
	
	brack = Math.min(brack, h);
	
	c.begin();
	c.moveTo(0, brack);
	c.lineTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, brack);
	c.moveTo(0, h - brack);
	c.lineTo(0, h);
	c.lineTo(w, h);
	c.lineTo(w, h - brack);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeSysMLCoregion.prototype.cst.COREGION, mxShapeSysMLCoregion);

//**********************************************************************************************************************************************************
//X marker
//**********************************************************************************************************************************************************
mxMarker.addMarker('sysMLx', function(c, shape, type, pe, unitX, unitY, size, source, sw, filled)
{
	var nx = unitX * (size + sw + 1);
	var ny = unitY * (size + sw + 1);

	return function()
	{
		c.begin();
		c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
		c.lineTo(pe.x + nx / 2 + ny / 2, pe.y + ny / 2 - nx / 2);

		c.moveTo(pe.x + nx / 2 - ny / 2, pe.y + ny / 2 + nx / 2);
		c.lineTo(pe.x - nx / 2 + ny / 2, pe.y - ny / 2 - nx / 2);
		c.stroke();
	};
});

//**********************************************************************************************************************************************************
//Dimension
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLDimension(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLDimension, mxShape);

mxShapeSysMLDimension.prototype.cst = {
		DIMENSION : 'mxgraph.sysml.dimension'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLDimension.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxShapeSysMLDimension.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 20);
	c.lineTo(w, 20);
	c.moveTo(10, 15);
	c.lineTo(0, 20);
	c.lineTo(10, 25);
	c.moveTo(w - 10, 15);
	c.lineTo(w, 20);
	c.lineTo(w - 10, 25);
	c.moveTo(0, 15);
	c.lineTo(0, h);
	c.moveTo(w, 15);
	c.lineTo(w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeSysMLDimension.prototype.cst.DIMENSION, mxShapeSysMLDimension);

//**********************************************************************************************************************************************************
//Lost marker
//**********************************************************************************************************************************************************
mxMarker.addMarker('sysMLLost', function(c, shape, type, pe, unitX, unitY, size, source, sw, filled)
{
	var nx = unitX * (size + sw + 1);
	var ny = unitY * (size + sw + 1);
	var a = size / 2;

	return function()
	{
		c.begin();
		c.moveTo(pe.x - 1.5 * nx - ny / 2, pe.y - 1.5 * ny + nx / 2);
		c.lineTo(pe.x - nx / 2, pe.y - ny / 2);
		c.lineTo(pe.x - 1.5 * nx + ny / 2, pe.y - 1.5 * ny - nx / 2);
		c.stroke();

		c.ellipse(pe.x - 0.5 * nx - a, pe.y - 0.5 * ny - a, 2 * a, 2 * a);

		var strokeColor = mxUtils.getValue(shape.style, mxConstants.STYLE_STROKECOLOR, '#000000');
		c.setFillColor(strokeColor);
		c.fillAndStroke();
	};
});

//**********************************************************************************************************************************************************
//Found marker
//**********************************************************************************************************************************************************
mxMarker.addMarker('sysMLFound', function(c, shape, type, pe, unitX, unitY, size, source, sw, filled)
{
	var nx = unitX * (size + sw + 1);
	var ny = unitY * (size + sw + 1);
	var a = size / 2;

	return function()
	{
		c.ellipse(pe.x - 0.5 * nx - a, pe.y - 0.5 * ny - a, 2 * a, 2 * a);

		var strokeColor = mxUtils.getValue(shape.style, mxConstants.STYLE_STROKECOLOR, '#000000');
		c.setFillColor(strokeColor);
		c.fillAndStroke();
	};
});

//**********************************************************************************************************************************************************
//Composite State
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLCompositeState(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLCompositeState, mxShape);

mxShapeSysMLCompositeState.prototype.cst = {
		COMP_STATE : 'mxgraph.sysml.compState'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLCompositeState.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxShapeSysMLCompositeState.prototype.background = function(c, x, y, w, h)
{
	var tabH = 20;
	var tabW = 110;
	c.roundrect(0, tabH, w, h - tabH, 10, 10);
	c.fillAndStroke();
	c.rect(15, 0, tabW, tabH);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLCompositeState.prototype.cst.COMP_STATE, mxShapeSysMLCompositeState);

mxShapeSysMLCompositeState.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2.9, 22.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - 2.9, 22.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2.9, h - 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - 2.9, h - 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - 20) * 0.25 + 20));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - 20) * 0.5 + 20));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - 20) * 0.75 + 20));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, 0, (h - 20) * 0.25 + 20));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, 0, (h - 20) * 0.5 + 20));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, 0, (h - 20) * 0.75 + 20));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 15, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 70, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 125, 0));

	if (w * 0.75 > 125)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false, null, 0, 20));
		
		if (w * 0.5 > 125)
		{
			constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, 0, 20));

			if (w * 0.25 > 125)
			{
				constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false, null, 0, 20));
			}
		}
	}
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Region
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLRegion(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLRegion, mxShape);

mxShapeSysMLRegion.prototype.cst = {
		REGION : 'mxgraph.sysml.region'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLRegion.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var tabH = 20;
	var tabW = 50;

	c.translate(x, y);
	this.background(c, x, y, w, h, tabH, tabW);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, tabH, tabW);
};

mxShapeSysMLRegion.prototype.background = function(c, x, y, w, h, tabH, tabW)
{
	var strokeW = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '1'));
	c.roundrect(0, tabH, w, h - tabH, 10, 10);
	c.fillAndStroke();
	
	c.setStrokeWidth(strokeW * 2);
	c.rect(15, 0, tabW, tabH);
	c.fillAndStroke();
	c.setStrokeWidth(strokeW);
};

mxShapeSysMLRegion.prototype.foreground = function(c, x, y, w, h, tabH, tabW)
{
	c.setDashed(true);
	c.begin();
	c.moveTo(w * 0.5, tabH);
	c.lineTo(w * 0.5, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeSysMLRegion.prototype.cst.REGION, mxShapeSysMLRegion);

mxShapeSysMLRegion.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2.9, 22.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - 2.9, 22.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2.9, h - 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - 2.9, h - 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - 20) * 0.25 + 20));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - 20) * 0.5 + 20));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - 20) * 0.75 + 20));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, 0, (h - 20) * 0.25 + 20));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, 0, (h - 20) * 0.5 + 20));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false, null, 0, (h - 20) * 0.75 + 20));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 15, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 40, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 65, 0));

	if (w * 0.75 > 65)
	{
		constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false, null, 0, 20));
		
		if (w * 0.5 > 65)
		{
			constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false, null, 0, 20));

			if (w * 0.25 > 65)
			{
				constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false, null, 0, 20));
			}
		}
	}
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Simple State
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLSimpleState(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLSimpleState, mxShape);

mxShapeSysMLSimpleState.prototype.cst = {
		SIMPLE_STATE : 'mxgraph.sysml.simpleState'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLSimpleState.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
//	this.foreground(c, x, y, w, h);
};

mxShapeSysMLSimpleState.prototype.background = function(c, x, y, w, h)
{
	var strokeW = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '1'));
	c.roundrect(0, 0, w, h, 10, 10);
	c.fillAndStroke();
};

mxShapeSysMLSimpleState.prototype.foreground = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 20);
	c.lineTo(w, 20);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeSysMLSimpleState.prototype.cst.SIMPLE_STATE, mxShapeSysMLSimpleState);

mxShapeSysMLSimpleState.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2.9, 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - 2.9, 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2.9, h - 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - 2.9, h - 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	
	return (constr);
};

//**********************************************************************************************************************************************************
//State Machine
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLStateMachine(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLStateMachine, mxShape);

mxShapeSysMLStateMachine.prototype.cst = {
		STATE_MACHINE : 'mxgraph.sysml.stateMachine'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLStateMachine.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeSysMLStateMachine.prototype.background = function(c, x, y, w, h)
{
	c.roundrect(0, 0, w - 10, h, 10, 10);
	c.fillAndStroke();
};

mxShapeSysMLStateMachine.prototype.foreground = function(c, x, y, w, h)
{
	var strokeC = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setFillColor(strokeC);

	c.ellipse(w - 20, h * 0.5 - 10, 20, 20);
	c.stroke();
	
	c.ellipse(w - 17, h * 0.5 - 7, 14, 14);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLStateMachine.prototype.cst.STATE_MACHINE, mxShapeSysMLStateMachine);

mxShapeSysMLStateMachine.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2.9, 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - 12.9, 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2.9, h - 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - 12.9, h - 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false, null, -10, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false, null, -10, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	
	return (constr);
};

//**********************************************************************************************************************************************************
// X
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLX(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLX, mxShape);

mxShapeSysMLX.prototype.cst = {
		X : 'mxgraph.sysml.x'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLX.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, h);
	c.moveTo(0, h);
	c.lineTo(w, 0);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLX.prototype.cst.X, mxShapeSysMLX);

mxShapeSysMLX.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Submachine State
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLSubmachineState(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLSubmachineState, mxShape);

mxShapeSysMLSubmachineState.prototype.cst = {
		SUBMACHINE_STATE : 'mxgraph.sysml.submState'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLSubmachineState.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeSysMLSubmachineState.prototype.background = function(c, x, y, w, h)
{
	c.roundrect(0, 0, w - 10, h, 10, 10);
	c.fillAndStroke();
};

mxShapeSysMLSubmachineState.prototype.foreground = function(c, x, y, w, h)
{
	var strokeC = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setFillColor(strokeC);

	c.ellipse(w - 20, h * 0.5 - 10, 20, 20);
	c.stroke();
	
	c.ellipse(w - 17, h * 0.5 - 7, 14, 14);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeSysMLSubmachineState.prototype.cst.SUBMACHINE_STATE, mxShapeSysMLSubmachineState);

mxShapeSysMLSubmachineState.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2.9, 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - 12.9, 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 2.9, h - 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - 12.9, h - 2.9));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.25, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.75, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.25), false, null, -10, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.75), false, null, -10, 0));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.25), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.75), false));
	
	return (constr);
};

//**********************************************************************************************************************************************************
//Use Case with Extension Points
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeSysMLUseCaseExtensionPoints(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeSysMLUseCaseExtensionPoints, mxShape);

mxShapeSysMLUseCaseExtensionPoints.prototype.cst = {
		USE_CASE_EXT_PT : 'mxgraph.sysml.useCaseExtPt'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeSysMLUseCaseExtensionPoints.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeSysMLUseCaseExtensionPoints.prototype.background = function(c, x, y, w, h)
{
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeSysMLUseCaseExtensionPoints.prototype.foreground = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(w * 0.02, h * 0.35);
	c.lineTo(w * 0.98, h * 0.35);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeSysMLUseCaseExtensionPoints.prototype.cst.USE_CASE_EXT_PT, mxShapeSysMLUseCaseExtensionPoints);

mxShapeSysMLUseCaseExtensionPoints.prototype.getConstraints = function(style, w, h)
{
	var constr = [];

	constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 0), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.5, 1), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.145, 0.145), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.145, 0.855), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.855, 0.855), false));
	constr.push(new mxConnectionConstraint(new mxPoint(0.855, 0.145), false));
	
	return (constr);
};

/**
 * $Id: mxBpmnShape2.js,v 1.6 2013/12/20 09:54:28 mate Exp $
 * Copyright (c) 2006-2010, JGraph Ltd
 */
/**
 * Class: mxBpmnShape
 *
 * Extends <mxShape> to implement an cylinder shape. If a
 * custom shape with one filled area and an overlay path is
 * needed, then this shape's <redrawPath> should be overridden.
 * This shape is registered under <mxConstants.SHAPE_CYLINDER>
 * in <mxCellRenderer>.
 * 
 * Constructor: mxBpmnShape
 *
 * Constructs a new cylinder shape.
 * 
 * Parameters:
 * 
 * bounds - <mxRectangle> that defines the bounds. This is stored in
 * <mxShape.bounds>.
 * fill - String that defines the fill color. This is stored in <fill>.
 * stroke - String that defines the stroke color. This is stored in <stroke>.
 * strokewidth - Optional integer that defines the stroke width. Default is
 * 1. This is stored in <strokewidth>.
 */
function mxBpmnShape(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxBpmnShape, mxShape);

mxBpmnShape.prototype.customProperties = [
	{name: 'symbol', dispName: 'Event', type: 'enum', defVal:'general', 
		enumList: [{val: 'general', dispName: 'General'}, 
				   {val: 'message', dispName: 'Message'}, 
				   {val: 'timer', dispName: 'Timer'}, 
				   {val: 'escalation', dispName: 'Escalation'}, 
				   {val: 'conditional', dispName: 'Conditional'}, 
				   {val: 'link', dispName: 'Link'}, 
				   {val: 'error', dispName: 'Error'}, 
				   {val: 'cancel', dispName: 'Cancel'}, 
				   {val: 'compensation', dispName: 'Compensation'}, 
				   {val: 'signal', dispName: 'Signal'}, 
				   {val: 'multiple', dispName: 'Multiple'}, 
				   {val: 'parallelMultiple', dispName: 'Parallel Multiple'}, 
				   {val: 'terminate', dispName: 'Terminate'}, 
				   {val: 'exclusiveGw', dispName: 'Exclusive Gw'}, 
				   {val: 'parallelGw', dispName: 'Parallel Gw'}, 
				   {val: 'complexGw', dispName: 'Complex Gw'}]
	},
	{name: 'outline', dispName: 'Event Type', type: 'enum', defVal:'standard', 
		enumList: [{val: 'standard', dispName: 'Standard'}, 
				   {val: 'eventInt', dispName: 'Interrupting'}, 
				   {val: 'eventNonint', dispName: 'Non-Interrupting'}, 
				   {val: 'catching', dispName: 'Catching'}, 
				   {val: 'boundInt', dispName: 'Bound Interrupting'}, 
				   {val: 'boundNonint', dispName: 'Bound Non-Interrupting'}, 
				   {val: 'throwing', dispName: 'Throwing'}, 
				   {val: 'end', dispName: 'End'}, 
				   {val: 'none', dispName: 'None'}]
	},
	{name: 'background', dispName: 'Background', type: 'enum', defVal:'none',
		enumList: [{val: 'gateway', dispName: 'Gateway'}, 
				   {val: 'none', dispName: 'None'}]
}];

mxBpmnShape.prototype.eventTypeEnum = { 
		START_STANDARD : 'standard', 
		EVENT_SP_INT : 'eventInt', 
		EVENT_SP_NONINT : 'eventNonint',
		CATCHING : 'catching',
		BOUND_INT : 'boundInt',
		BOUND_NONINT : 'boundNonint',
		THROWING : 'throwing',
		END : 'end',
		NONE : 'none',
		GATEWAY : 'gateway'};

mxBpmnShape.prototype.eventEnum = { 
		GENERAL 		: 'general', 
		MESSAGE 		: 'message', 
		TIMER 			: 'timer', 
		ESCALATION 		: 'escalation', 
		CONDITIONAL 	: 'conditional', 
		LINK 			: 'link', 
		ERROR			: 'error', 
		CANCEL			: 'cancel', 
		COMPENSATION 	: 'compensation', 
		SIGNAL 			: 'signal', 
		MULTIPLE		: 'multiple', 
		PAR_MULTI		: 'parallelMultiple', 
		TERMINATE		: 'terminate',
		GW_EXCLUSIVE 	: 'exclusiveGw',
		GW_PARALLEL		: 'parallelGw',
		GW_COMPLEX		: 'complexGw'};

mxBpmnShape.prototype.miscEnum = {
		OUTLINE			: 'outline',
		BACKGROUND		: 'background',
		SYMBOL			: 'symbol',
		GATEWAY			: 'gateway'};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxBpmnShape.prototype.paintVertexShape = function(c, x, y, w, h)
{
	this.redrawPath(c, x, y, w, h, mxBpmnShape.prototype.miscEnum.BACKGROUND);
	var bg = mxUtils.getValue(this.style, mxBpmnShape.prototype.miscEnum.BACKGROUND, mxBpmnShape.prototype.eventTypeEnum.NONE);

	if (bg === mxBpmnShape.prototype.eventTypeEnum.GATEWAY)
	{
		c.setShadow(false);
	}

	this.redrawPath(c, x, y, w, h, mxBpmnShape.prototype.miscEnum.OUTLINE);
	this.redrawPath(c, x, y, w, h, mxBpmnShape.prototype.miscEnum.SYMBOL);
};

/**
 * Function: redrawPath
 *
 * Draws the path for this shape.
 */
mxBpmnShape.prototype.redrawPath = function(c, x, y, w, h, layer)
{
	var bg = mxUtils.getValue(this.style, mxBpmnShape.prototype.miscEnum.BACKGROUND, mxBpmnShape.prototype.eventTypeEnum.NONE);

	if (layer == mxBpmnShape.prototype.miscEnum.BACKGROUND)
	{
		if (bg != null)
		{
			var f = this.backgrounds[bg];

			if (f != null)
			{
				c.translate(x, y);
				f.call(this, c, x, y, w, h, layer);
			}
		}
	}
	else if (layer == mxBpmnShape.prototype.miscEnum.OUTLINE)
	{
		if (bg === mxBpmnShape.prototype.eventTypeEnum.GATEWAY)
		{
			c.translate(w / 4, h / 4);
			h /= 2;
			w /= 2;
			
			//add rhombus connections here
			this.constraints = [
			                                      new mxConnectionConstraint(new mxPoint(0.5, 0), true),
			                                      new mxConnectionConstraint(new mxPoint(0.5, 1), true),
			                                      new mxConnectionConstraint(new mxPoint(0, 0.5), true),
			                                      new mxConnectionConstraint(new mxPoint(1, 0.5), true),
			                                      new mxConnectionConstraint(new mxPoint(0.25, 0.25), false),
			                                      new mxConnectionConstraint(new mxPoint(0.25, 0.75), false),
			                                      new mxConnectionConstraint(new mxPoint(0.75, 0.25), false),
			                                      new mxConnectionConstraint(new mxPoint(0.75, 0.75), false)
			                                      ];
		}
		else
		{
			//add ellipse connections here
			this.constraints = [
			                                      new mxConnectionConstraint(new mxPoint(0.5, 0), true),
			                                      new mxConnectionConstraint(new mxPoint(0.5, 1), true),
			                                      new mxConnectionConstraint(new mxPoint(0, 0.5), true),
			                                      new mxConnectionConstraint(new mxPoint(1, 0.5), true),
			                                      new mxConnectionConstraint(new mxPoint(0.145, 0.145), false),
			                                      new mxConnectionConstraint(new mxPoint(0.145, 0.855), false),
			                                      new mxConnectionConstraint(new mxPoint(0.855, 0.145), false),
			                                      new mxConnectionConstraint(new mxPoint(0.855, 0.855), false)
			                                      ];
		}

		var o = mxUtils.getValue(this.style, mxBpmnShape.prototype.miscEnum.OUTLINE, mxBpmnShape.prototype.eventTypeEnum.NONE);

		if (o != null)
		{
			var f = this.outlines[o];

			if (f != null)
			{
				f.call(this, c, x, y, w, h, bg === mxBpmnShape.prototype.eventTypeEnum.GATEWAY);
			}
		}
	}
	else if (layer == mxBpmnShape.prototype.miscEnum.SYMBOL)
	{
		if (bg === mxBpmnShape.prototype.eventTypeEnum.GATEWAY)
		{
			h /= 2;
			w /= 2;
		}

		var s = mxUtils.getValue(this.style, mxBpmnShape.prototype.miscEnum.SYMBOL, null);

		if (s != null)
		{
			var f = this.symbols[s];

			if (f != null)
			{
				var strokeColor = c.state.strokeColor;
				var fillColor = c.state.fillColor;
				var o = mxUtils.getValue(this.style, mxBpmnShape.prototype.miscEnum.OUTLINE, mxBpmnShape.prototype.eventTypeEnum.NONE);

				if (s === mxBpmnShape.prototype.eventEnum.MESSAGE)
				{
					c.translate(w * 0.15, h * 0.3);
					w = w * 0.7;
					h = h * 0.4;
				}
				else if (s === mxBpmnShape.prototype.eventEnum.TIMER)
				{
					c.translate(w * 0.11, h * 0.11);
					w = w * 0.78;
					h = h * 0.78;
				}
				else if (s === mxBpmnShape.prototype.eventEnum.ESCALATION)
				{
					c.translate(w * 0.19, h * 0.15);
					w = w * 0.62;
					h = h * 0.57;
				}
				else if (s === mxBpmnShape.prototype.eventEnum.CONDITIONAL)
				{
					c.translate(w * 0.3, h * 0.16);
					w = w * 0.4;
					h = h * 0.68;
				}
				else if (s === mxBpmnShape.prototype.eventEnum.LINK)
				{
					c.translate(w * 0.27, h * 0.33);
					w = w * 0.46;
					h = h * 0.34;
				}
				else if (s === mxBpmnShape.prototype.eventEnum.ERROR)
				{
					c.translate(w * 0.212, h * 0.243);
					w = w * 0.58;
					h = h * 0.507;
				}
				else if (s === mxBpmnShape.prototype.eventEnum.CANCEL)
				{
					c.translate(w * 0.22, h * 0.22);
					w = w * 0.56;
					h = h * 0.56;
				}
				else if (s === mxBpmnShape.prototype.eventEnum.COMPENSATION)
				{
					c.translate(w * 0.28, h * 0.35);
					w = w * 0.44;
					h = h * 0.3;
				}
				else if (s === mxBpmnShape.prototype.eventEnum.SIGNAL)
				{
					c.translate(w * 0.19, h * 0.15);
					w = w * 0.62;
					h = h * 0.57;
				}
				else if (s === mxBpmnShape.prototype.eventEnum.MULTIPLE)
				{
					c.translate(w * 0.2, h * 0.19);
					w = w * 0.6;
					h = h * 0.565;
				}
				else if (s === mxBpmnShape.prototype.eventEnum.PAR_MULTI)
				{
					c.translate(w * 0.2, h * 0.2);
					w = w * 0.6;
					h = h * 0.6;
				}
				else if (s === mxBpmnShape.prototype.eventEnum.TERMINATE)
				{
					c.translate(w * 0.05, h * 0.05);
					w = w * 0.9;
					h = h * 0.9;
				}
				else if (s === mxBpmnShape.prototype.eventEnum.GW_EXCLUSIVE)
				{
					c.translate(w * 0.12, 0);
					w = w * 0.76;
				}
				
				var isInverse = false;
				
				if (s === 'star')
				{
					c.setFillColor(strokeColor);
				}
				else if (o === mxBpmnShape.prototype.eventTypeEnum.THROWING || o === mxBpmnShape.prototype.eventTypeEnum.END)
				{
					c.setStrokeColor(fillColor);
					c.setFillColor(strokeColor);
					isInverse = true;
				}

				f.call(this, c, x, y, w, h, layer, isInverse);
				
				if (s === 'star')
				{
					c.setFillColor(fillColor);
				}
				else if (o === mxBpmnShape.prototype.eventTypeEnum.THROWING || o === mxBpmnShape.prototype.eventTypeEnum.END)
				{
					c.setStrokeColor(strokeColor);
					c.setFillColor(fillColor);
				}
			}
		}
	}
};

//Contains all possible backgrounds
mxBpmnShape.prototype.backgrounds = {
		'none': function(c, x, y, w, h)
		{
		},
		'gateway': function(c, x, y, w, h)
		{
			c.begin();
			c.moveTo(w / 2, 0);
			c.lineTo(w, h / 2);
			c.lineTo(w / 2, h);
			c.lineTo(0, h / 2);
			c.close();
			c.fillAndStroke();
		}
};

//Contains all possible outlines
mxBpmnShape.prototype.outlines = {
		'none' : function(c, x, y, w, h, isGateway)
		{
			if (!isGateway)
			{
				c.setShadow(false);
			}
		},
		'standard': function(c, x, y, w, h, isGateway)
		{
			c.ellipse(0, 0, w, h);
			c.fillAndStroke();

			if (!isGateway)
			{
				c.setShadow(false);
			}
		},
		'eventInt': function(c, x, y, w, h, isGateway)
		{
			c.ellipse(0, 0, w, h);
			c.fillAndStroke();

			if (!isGateway)
			{
				c.setShadow(false);
			}
		},
		'eventNonint': function(c, x, y, w, h, isGateway)
		{
			var dashed = c.state.dashed;
			c.setDashed(true);
			c.ellipse(0, 0, w, h);
			c.fillAndStroke();
			c.setDashed(dashed);

			if (!isGateway)
			{
				c.setShadow(false);
			}

		},
		'catching': function(c, x, y, w, h, isGateway)
		{
			c.ellipse(0, 0, w, h);
			c.fillAndStroke();

			if (!isGateway)
			{
				c.setShadow(false);
			}

			var inset = 2;
			c.ellipse(inset, inset, w - 2 *inset, h - 2 * inset);
			c.stroke();
		},
		'boundInt': function(c, x, y, w, h, isGateway)
		{
			c.ellipse(0, 0, w, h);
			c.fillAndStroke();

			if (!isGateway)
			{
				c.setShadow(false);
			}
			var inset = 2;
			c.ellipse(inset, inset, w - 2 *inset, h - 2 * inset);
			c.stroke();
		},
		'boundNonint': function(c, x, y, w, h, isGateway)
		{
			var dashed = c.state.dashed;
			c.setDashed(true);
			c.ellipse(0, 0, w, h);
			c.fillAndStroke();

			if (!isGateway)
			{
				c.setShadow(false);
			}

			var inset = 2;
			c.ellipse(inset, inset, w - 2 *inset, h - 2 * inset);
			c.stroke();
			c.setDashed(dashed);
		},
		'throwing': function(c, x, y, w, h, isGateway)
		{
			c.ellipse(0, 0, w, h);
			c.fillAndStroke();

			if (!isGateway)
			{
				c.setShadow(false);
			}

			var inset = 2;
			c.ellipse(w * 0.02 + inset, h * 0.02 + inset, w * 0.96 - 2 *inset, h * 0.96 - 2 * inset);
			c.stroke();
		},
		'end': function(c, x, y, w, h, isGateway)
		{
			var sw = c.state.strokeWidth;
			c.setStrokeWidth(sw * 3);
			c.ellipse(0, 0, w, h);
			c.fillAndStroke();
			c.setStrokeWidth(sw);

			if (!isGateway)
			{
				c.setShadow(false);
			}
		}
};

//Contains all possible symbols
mxBpmnShape.prototype.symbols = {
		'general' : function(c, x, y, w, h)
		{
		},
		'message': function(c, x, y, w, h, layer, isInverse)
		{
			c.rect(0, 0, w, h);
			c.fillAndStroke();

			var fc = mxUtils.getValue(this.style, "fillColor", "none");

			if (fc === 'none')
			{
				if (isInverse)
				{
					c.setStrokeColor('#ffffff');
				}
			}
			
			c.begin();
			c.moveTo(0, 0);
			c.lineTo(w * 0.5, h * 0.5);
			c.lineTo(w, 0);
			c.stroke();
		},
		'timer' : function(c, x, y, w, h)
		{
			c.ellipse(0, 0, w, h);
			c.fillAndStroke();

			c.begin();
			c.moveTo(w * 0.5, 0);
			c.lineTo(w * 0.5, h * 0.0642);
			c.moveTo(w * 0.7484, h * 0.0654);
			c.lineTo(w * 0.7126, h * 0.1281);
			c.moveTo(w * 0.93, h * 0.2471);
			c.lineTo(w * 0.8673, h * 0.2854);
			c.moveTo(w, h * 0.5);
			c.lineTo(w * 0.9338, h * 0.5);
			c.moveTo(w * 0.93, h * 0.7509);
			c.lineTo(w * 0.8673, h * 0.7126);
			c.moveTo(w * 0.7484, h * 0.9326);
			c.lineTo(w * 0.7126, h * 0.8699);
			c.moveTo(w * 0.5, h * 0.9338);
			c.lineTo(w * 0.5, h);
			c.moveTo(w * 0.2496, h * 0.9325);
			c.lineTo(w * 0.2854, h * 0.8699);
			c.moveTo(w * 0.068, h * 0.7509);
			c.lineTo(w * 0.1307, h * 0.7126);
			c.moveTo(0, h * 0.5);
			c.lineTo(w * 0.0642, h * 0.5);
			c.moveTo(w * 0.068, h * 0.2471);
			c.lineTo(w * 0.1307, h * 0.2854);
			c.moveTo(w * 0.2496, h * 0.0654);
			c.lineTo(w * 0.2854, h * 0.1281);
			c.moveTo(w * 0.5246, h * 0.0706);
			c.lineTo(w * 0.5, h * 0.5);
			c.lineTo(w * 0.7804, h * 0.5118);	
			c.stroke();
		},
		'escalation' : function(c, x, y, w, h)
		{
			c.begin();
			c.moveTo(0, h);
			c.lineTo(w * 0.5, 0);
			c.lineTo(w, h);
			c.lineTo(w * 0.5, h * 0.5);
			c.close();
			c.fillAndStroke();
		},
		'conditional' : function(c, x, y, w, h)
		{
			c.rect(0, 0, w, h);
			c.fillAndStroke();
			c.begin();
			c.moveTo(0, h * 0.1027);
			c.lineTo(w * 0.798, h * 0.1027);
			c.moveTo(0, h * 0.3669);
			c.lineTo(w * 0.798, h * 0.3669);
			c.moveTo(0, h * 0.6311);
			c.lineTo(w * 0.798, h * 0.6311);
			c.moveTo(0, h * 0.8953);
			c.lineTo(w * 0.798, h * 0.8953);
			c.stroke();
		},
		'link' : function(c, x, y, w, h)
		{
			c.begin();
			c.moveTo(0, h * 0.76);
			c.lineTo(0, h * 0.24);
			c.lineTo(w * 0.63, h * 0.24);
			c.lineTo(w * 0.63, 0);
			c.lineTo(w, h * 0.5);
			c.lineTo(w * 0.63, h);
			c.lineTo(w * 0.63, h * 0.76);
			c.close();
			c.fillAndStroke();
		},
		'error' : function(c, x, y, w, h)
		{
			c.begin();
			c.moveTo(0, h);
			c.lineTo(w * 0.3287, h * 0.123);
			c.lineTo(w * 0.6194, h * 0.6342);
			c.lineTo(w, 0);
			c.lineTo(w * 0.6625, h * 0.939);
			c.lineTo(w * 0.3717, h * 0.5064);
			c.close();
			c.fillAndStroke();
		},
		'cancel' : function(c, x, y, w, h)
		{
			c.begin();
			c.moveTo(w * 0.1051, 0);
			c.lineTo(w * 0.5, h * 0.3738);
			c.lineTo(w * 0.8909, 0);
			c.lineTo(w, h * 0.1054);
			c.lineTo(w * 0.623, h * 0.5);
			c.lineTo(w, h * 0.8926);
			c.lineTo(w * 0.8909, h);
			c.lineTo(w * 0.5, h * 0.6242);
			c.lineTo(w * 0.1051, h);
			c.lineTo(0, h * 0.8926);
			c.lineTo(w * 0.373, h * 0.5);
			c.lineTo(0, h * 0.1054);
			c.close();
			c.fillAndStroke();
		},
		'compensation' : function(c, x, y, w, h)
		{
			c.begin();
			c.moveTo(0, h * 0.5);
			c.lineTo(w * 0.5, 0);
			c.lineTo(w * 0.5, h);
			c.close();
			c.moveTo(w * 0.5, h * 0.5);
			c.lineTo(w, 0);
			c.lineTo(w, h);
			c.close();
			c.fillAndStroke();
		},
		'signal' : function(c, x, y, w, h)
		{
			c.begin();
			c.moveTo(0, h);
			c.lineTo(w * 0.5, 0);
			c.lineTo(w, h);
			c.close();
			c.fillAndStroke();
		},
		'multiple' : function(c, x, y, w, h)
		{
			c.begin();
			c.moveTo(0, h * 0.39);
			c.lineTo(w * 0.5, 0);
			c.lineTo(w, h * 0.39);
			c.lineTo(w * 0.815, h);
			c.lineTo(w * 0.185, h);
			c.close();
			c.fillAndStroke();
		},
		'parallelMultiple' : function(c, x, y, w, h)
		{
			c.begin();
			c.moveTo(w * 0.38, 0);
			c.lineTo(w * 0.62, 0);
			c.lineTo(w * 0.62, h * 0.38);
			c.lineTo(w, h * 0.38);
			c.lineTo(w, h * 0.62);
			c.lineTo(w * 0.62, h * 0.62);
			c.lineTo(w * 0.62, h);
			c.lineTo(w * 0.38, h);
			c.lineTo(w * 0.38, h * 0.62);
			c.lineTo(0, h * 0.62);
			c.lineTo(0, h * 0.38);
			c.lineTo(w * 0.38, h * 0.38);
			c.close();
			c.fillAndStroke();
		},
		'terminate' : function(c, x, y, w, h)
		{
			c.ellipse(0, 0, w, h);
			c.fillAndStroke();
		},
		'exclusiveGw' : function(c, x, y, w, h)
		{
			var strokeColor = c.state.strokeColor;
			var fillColor = c.state.fillColor;
			c.setStrokeColor(fillColor);
			c.setFillColor(strokeColor);

			c.begin();
			c.moveTo(w * 0.105, 0);
			c.lineTo(w * 0.5, h * 0.38);
			c.lineTo(w * 0.895, h * 0);
			c.lineTo(w, h * 0.11);
			c.lineTo(w * 0.6172, h * 0.5);
			c.lineTo(w, h * 0.89);
			c.lineTo(w * 0.895, h);
			c.lineTo(w * 0.5, h * 0.62);
			c.lineTo(w * 0.105, h);
			c.lineTo(0, h * 0.89);
			c.lineTo(w * 0.3808, h * 0.5);
			c.lineTo(0, h * 0.11);
			c.close();
			c.fillAndStroke();

			c.setStrokeColor(strokeColor);
			c.setFillColor(fillColor);

		},
		'parallelGw' : function(c, x, y, w, h)
		{
			var strokeColor = c.state.strokeColor;
			var fillColor = c.state.fillColor;
			c.setStrokeColor(fillColor);
			c.setFillColor(strokeColor);

			c.begin();
			c.moveTo(w * 0.38, 0);
			c.lineTo(w * 0.62, 0);
			c.lineTo(w * 0.62, h * 0.38);
			c.lineTo(w, h * 0.38);
			c.lineTo(w, h * 0.62);
			c.lineTo(w * 0.62, h * 0.62);
			c.lineTo(w * 0.62, h);
			c.lineTo(w * 0.38, h);
			c.lineTo(w * 0.38, h * 0.62);
			c.lineTo(0, h * 0.62);
			c.lineTo(0, h * 0.38);
			c.lineTo(w * 0.38, h * 0.38);
			c.close();
			c.fillAndStroke();

			c.setStrokeColor(strokeColor);
			c.setFillColor(fillColor);
		},
		'complexGw' : function(c, x, y, w, h)
		{
			var strokeColor = c.state.strokeColor;
			var fillColor = c.state.fillColor;
			c.setStrokeColor(fillColor);
			c.setFillColor(strokeColor);

			c.begin();
			c.moveTo(0, h * 0.44);
			c.lineTo(w * 0.36, h * 0.44);
			c.lineTo(w * 0.1, h * 0.18);
			c.lineTo(w * 0.18, h * 0.1);
			c.lineTo(w * 0.44, h * 0.36);
			c.lineTo(w * 0.44, 0);
			c.lineTo(w * 0.56, 0);
			c.lineTo(w * 0.56, h * 0.36);
			c.lineTo(w * 0.82, h * 0.1);
			c.lineTo(w * 0.90, h * 0.18);
			c.lineTo(w * 0.64, h * 0.44);
			c.lineTo(w, h * 0.44);
			c.lineTo(w, h * 0.56);
			c.lineTo(w * 0.64, h * 0.56);
			c.lineTo(w * 0.9, h * 0.82);
			c.lineTo(w * 0.82, h * 0.9);
			c.lineTo(w * 0.56, h * 0.64);
			c.lineTo(w * 0.56, h);
			c.lineTo(w * 0.44, h);
			c.lineTo(w * 0.44, h * 0.64);
			c.lineTo(w * 0.18, h * 0.9);
			c.lineTo(w * 0.1, h * 0.82);
			c.lineTo(w * 0.36, h * 0.56);
			c.lineTo(0, h * 0.56);
			c.close();
			c.fillAndStroke();

			c.setStrokeColor(strokeColor);
			c.setFillColor(fillColor);
		},
		'star': function(c, x, y, w, h)
		{
			c.translate(w / 5, h / 6);
			h *= 2 / 3;
			w *= 3 / 5;
			
			c.begin();
			c.moveTo(0, h / 4);
			c.lineTo(w / 3, h / 4);
			c.lineTo(w / 2, 0);
			c.lineTo(2 * w / 3, h / 4);
			c.lineTo(w, h / 4);
			c.lineTo(5 * w / 6, h / 2);
			c.lineTo(w, 3 * h / 4);
			c.lineTo(2 * w / 3, 3 * h / 4);
			c.lineTo(w / 2, h);
			c.lineTo(w / 3, 3 * h / 4);
			c.lineTo(0, 3 * h / 4);
			c.lineTo(w / 6, h / 2);
			c.close();
			c.fillAndStroke();
		}
};

mxCellRenderer.registerShape('mxgraph.bpmn.shape', mxBpmnShape);

/**
 * $Id: mxER.js,v 1.6 2013/05/17 13:46:41 mate Exp $
 * Copyright (c) 2006-2010, JGraph Ltd
 */

//TODO markers.html probably isn't needed, because it was used for testing during development before the new canvas was introduced

//**********************************************************************************************************************************************************
//Entity
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeEREntity(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeEREntity, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeEREntity.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, 'buttonText', 'Entity');
	var fontColor = mxUtils.getValue(this.style, 'textColor', '#666666');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '17');
	c.translate(x, y);
	var rSize = 10;
	w = Math.max(w, 2 * rSize);
	h = Math.max(h, 2 * rSize);
	this.background(c, x, y, w, h, rSize, fontColor);
	c.setShadow(false);
	this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
};

mxShapeEREntity.prototype.background = function(c, x, y, w, h, rSize, fontColor)
{
	var buttonStyle = mxUtils.getValue(this.style, 'buttonStyle', 'round').toString();

	if (buttonStyle === 'round')
	{
		c.begin();
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(w - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
		c.lineTo(w, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
		c.close();	
		c.fillAndStroke();
	}
	else if (buttonStyle === 'rect')
	{
		c.begin();
		c.moveTo(0, 0);
		c.lineTo(w, 0);
		c.lineTo(w, h);
		c.lineTo(0, h);
		c.close();	
		c.fillAndStroke();
	}
	else if (buttonStyle === 'dblFrame')
	{
		var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
		c.setFillColor(fillColor);
		c.begin();
		c.moveTo(0, 0);
		c.lineTo(w, 0);
		c.lineTo(w, h);
		c.lineTo(0, h);
		c.close();	
		c.fillAndStroke();
		rSize = Math.min(w, h);
		c.begin();
		c.moveTo(rSize * 0.1, rSize * 0.1);
		c.lineTo(w - rSize * 0.1, rSize * 0.1);
		c.lineTo(w - rSize * 0.1, h - rSize * 0.1);
		c.lineTo(rSize * 0.1, h - rSize * 0.1);
		c.close();	
		c.stroke();
	}

};

mxShapeEREntity.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w * 0.5, h * 0.5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape('mxgraph.er.entity', mxShapeEREntity);

mxShapeEREntity.prototype.constraints = [
                                           new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                           ];

//**********************************************************************************************************************************************************
//Entity Extended
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeEREntityExt(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeEREntityExt, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeEREntityExt.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, 'buttonText', 'Entity');
	var attributes = mxUtils.getValue(this.style, 'subText', '+ attribute 1,+ attribute 2,+ attribute 3').toString().split(',');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '17');
	var mainColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#008cff');
	var attrColor = mxUtils.getValue(this.style, 'fillColor2', '#ffffff');
	var maxTextWidth = 0;
	c.translate(x, y);
	var rSize = 10;
	var barY = fontSize * 1.25;

	for (var i = 0; i < attributes.length; i++)
	{
		var currWidth = mxUtils.getSizeForString(attributes[i], fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currWidth > maxTextWidth)
		{
			maxTextWidth = currWidth;
		}
	}

	w = Math.max(w, 2 * rSize, maxTextWidth + rSize);
	h = Math.max(h, 2 * rSize, (attributes.length + 1) * barY);
	this.background(c, x, y, w, h, rSize);
	c.setShadow(false);
	this.shapes(c, x, y, w, h, fontSize, mainColor, attrColor, rSize, barY);
	this.mainText(c, x, y, w, h, mainText, fontSize, attrColor);
	this.attrText(c, x, y, w, h, attributes, fontSize, strokeColor, barY, rSize);
};

mxShapeEREntityExt.prototype.background = function(c, x, y, w, h, rSize)
{
	var buttonStyle = mxUtils.getValue(this.style, 'buttonStyle', 'round').toString();
	c.begin();

	if (buttonStyle === 'round')
	{
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(w - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
		c.lineTo(w, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	}
	else if (buttonStyle === 'rect')
	{
		c.moveTo(0, 0);
		c.lineTo(w, 0);
		c.lineTo(w, h);
		c.lineTo(0, h);
	}

	c.close();	
	c.fillAndStroke();
};

mxShapeEREntityExt.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w * 0.5, fontSize * 0.5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxShapeEREntityExt.prototype.shapes = function(c, x, y, w, h, fontSize, mainColor, attrColor, rSize, barY)
{
	var buttonStyle = mxUtils.getValue(this.style, 'buttonStyle', 'round').toString();

	if (buttonStyle === 'round')
	{
		c.begin();
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(w - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
		c.lineTo(w, barY);
		c.lineTo(0, barY);
		c.close();
		c.fill();

		c.setFillColor(attrColor);
		c.begin();
		c.moveTo(w, barY);
		c.lineTo(w, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
		c.lineTo(0, barY);
		c.close();
		c.fill();
	}
	else if (buttonStyle === 'rect')
	{
		c.begin();
		c.moveTo(0, 0);
		c.lineTo(w, 0);
		c.lineTo(w, barY);
		c.lineTo(0, barY);
		c.close();
		c.fill();

		c.setFillColor(attrColor);
		c.begin();
		c.moveTo(0, barY);
		c.lineTo(w, barY);
		c.lineTo(w, h);
		c.lineTo(0, h);
		c.close();
		c.fill();
	}

	c.begin();

	if (buttonStyle === 'round')
	{
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(w - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
		c.lineTo(w, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	}
	else if (buttonStyle === 'rect')
	{
		c.moveTo(0, 0);
		c.lineTo(w, 0);
		c.lineTo(w, h);
		c.lineTo(0, h);
	}

	c.close();	
	c.stroke();
};

mxShapeEREntityExt.prototype.attrText = function(c, x, y, w, h, attributes, fontSize, fontColor, barY, rSize)
{
	for (var i = 0; i < attributes.length; i++)
	{
		c.begin();
		c.setFontSize(fontSize);
		c.setFontColor(fontColor);
		c.text(rSize * 0.5, (i + 1.5) * barY, 0, 0, attributes[i], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
};

mxCellRenderer.registerShape('mxgraph.er.entityExt', mxShapeEREntityExt);

mxShapeEREntityExt.prototype.constraints = [
                                         new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                         new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                         new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                         new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                         new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                         new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                         new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                         new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                         new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                         ];

//**********************************************************************************************************************************************************
//Attribute
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeERAttribute(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeERAttribute, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeERAttribute.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, 'buttonText', 'Entity');
	var fontColor = mxUtils.getValue(this.style, 'textColor', '#666666');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '17');
	c.translate(x, y);
	var rSize = 10;
	w = Math.max(w, 2 * rSize);
	h = Math.max(h, 2 * rSize);
	this.background(c, x, y, w, h, rSize, fontColor);
	c.setShadow(false);
	this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
};

mxShapeERAttribute.prototype.background = function(c, x, y, w, h, rSize, fontColor)
{
	var buttonStyle = mxUtils.getValue(this.style, 'buttonStyle', 'simple').toString();

	if (buttonStyle === 'simple')
	{
		c.begin();
		c.ellipse(0, 0, w, h);
		c.fillAndStroke();
	}
	else if (buttonStyle === 'dblFrame')
	{
		var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#666666');
		c.setFillColor(fillColor);
		c.begin();
		c.ellipse(0, 0, w, h);
		c.fillAndStroke();
		rSize = Math.min(w, h);
		c.begin();
		c.ellipse(rSize * 0.1, rSize * 0.1, w - rSize * 0.2, h - rSize * 0.2);
		c.stroke();
	}
};

mxShapeERAttribute.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w * 0.5, h * 0.5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape('mxgraph.er.attribute', mxShapeERAttribute);

mxShapeERAttribute.prototype.constraints = [
                                                 new mxConnectionConstraint(new mxPoint(0.144, 0.144), false),
                                                 new mxConnectionConstraint(new mxPoint(0.856, 0.144), false),
                                                 new mxConnectionConstraint(new mxPoint(0.856, 0.856), false),
                                                 new mxConnectionConstraint(new mxPoint(0.144, 0.856), false),
                                                 new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                                 new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                                 new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                                 new mxConnectionConstraint(new mxPoint(0.5, 1), true)
                                                 ];

//**********************************************************************************************************************************************************
//Has
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeERHas(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeERHas, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeERHas.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, 'buttonText', 'Entity');
	var fontColor = mxUtils.getValue(this.style, 'textColor', '#666666');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '17');
	c.translate(x, y);
	var rSize = 10;
	w = Math.max(w, 2 * rSize);
	h = Math.max(h, 2 * rSize);
	this.background(c, x, y, w, h, rSize, fontColor);
	c.setShadow(false);
	this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
};

mxShapeERHas.prototype.background = function(c, x, y, w, h, rSize, fontColor)
{
	var buttonStyle = mxUtils.getValue(this.style, 'buttonStyle', 'rhombus').toString();

	if (buttonStyle === 'rhombus')
	{
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w * 0.5, 0);
		c.lineTo(w, h * 0.5);
		c.lineTo(w * 0.5, h);
		c.close();	
		c.fillAndStroke();
	}
	else if (buttonStyle === 'dblFrame')
	{
		var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#666666');
		c.setFillColor(fillColor);
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w * 0.5, 0);
		c.lineTo(w, h * 0.5);
		c.lineTo(w * 0.5, h);
		c.close();	
		c.fillAndStroke();
		c.begin();
		c.moveTo(w * 0.1, h * 0.5);
		c.lineTo(w * 0.5, h * 0.1);
		c.lineTo(w * 0.9, h * 0.5);
		c.lineTo(w * 0.5, h * 0.9);
		c.close();	
		c.stroke();
	}
};

mxShapeERHas.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w * 0.5, h * 0.5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape('mxgraph.er.has', mxShapeERHas);

mxShapeERHas.prototype.constraints = [
                                      new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                      new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                      new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                      new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                      new mxConnectionConstraint(new mxPoint(0.25, 0.25), false),
                                      new mxConnectionConstraint(new mxPoint(0.25, 0.75), false),
                                      new mxConnectionConstraint(new mxPoint(0.75, 0.25), false),
                                      new mxConnectionConstraint(new mxPoint(0.75, 0.75), false)
                                      ];

//**********************************************************************************************************************************************************
//Cloud
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeERCloud(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeERCloud, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeERCloud.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, 'buttonText', 'Entity');
	var fontColor = mxUtils.getValue(this.style, 'textColor', '#666666');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '17');
	c.translate(x, y);
	var rSize = 10;
	w = Math.max(w, 2 * rSize);
	h = Math.max(h, 2 * rSize);
	this.background(c, x, y, w, h, rSize, fontColor);
	c.setShadow(false);
	this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
};

mxShapeERCloud.prototype.background = function(c, x, y, w, h, rSize, fontColor)
{
	c.begin();
	c.moveTo(0.25 * w, 0.25 * h);
	c.curveTo(0.05 * w, 0.25 * h, 0, 0.5 * h, 0.16 * w, 0.55 * h);
	c.curveTo(0, 0.66 * h, 0.18 * w, 0.9 * h, 0.31 * w, 0.8 * h);
	c.curveTo(0.4 * w, h, 0.7 * w, h, 0.8 * w, 0.8 * h);
	c.curveTo(w, 0.8 * h, w, 0.6 * h, 0.875 * w, 0.5 * h); 
	c.curveTo(w, 0.3 * h, 0.8 * w, 0.1 * h, 0.625 * w, 0.2 * h);
	c.curveTo(0.5 * w, 0.05 * h, 0.3 * w, 0.05 * h, 0.25 * w, 0.25 * h);
	c.fillAndStroke();
};

mxShapeERCloud.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w * 0.5, h * 0.5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape('mxgraph.er.cloud', mxShapeERCloud);

mxShapeERCloud.prototype.constraints = [
                                        new mxConnectionConstraint(new mxPoint(0.08, 0.5), false),
                                        new mxConnectionConstraint(new mxPoint(0.9, 0.5), false),
                                        new mxConnectionConstraint(new mxPoint(0.5, 0.1), false),
                                        new mxConnectionConstraint(new mxPoint(0.5, 0.92), false),
                                        new mxConnectionConstraint(new mxPoint(0.24, 0.24), false),
                                        new mxConnectionConstraint(new mxPoint(0.22, 0.8), false),
                                        new mxConnectionConstraint(new mxPoint(0.81, 0.2), false),
                                        new mxConnectionConstraint(new mxPoint(0.78, 0.78), false)
                                      ];

//**********************************************************************************************************************************************************
//Hierarchy (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeERHierarchy(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeERHierarchy, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeERHierarchy.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, 'buttonText', 'main').toString().split(',');
	var subText = mxUtils.getValue(this.style, 'subText', 'sub').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, 'textColor', '#666666');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '17');
	c.translate(x, y);
	var rSize = 10;
	w = Math.max(w, 2 * rSize);
	h = Math.max(h, 2 * rSize);
	this.background(c, x, y, w, h, rSize, fontColor);
	c.setShadow(false);
	this.shapeText(c, x, y, w, h, mainText, subText, fontSize, fontColor);
};

mxShapeERHierarchy.prototype.background = function(c, x, y, w, h, rSize, fontColor)
{
	var buttonStyle = mxUtils.getValue(this.style, 'buttonStyle', 'round').toString();

	if (buttonStyle === 'round')
	{
		c.begin();
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(w - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
		c.lineTo(w, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
		c.close();	
		c.fillAndStroke();
	}
	else if (buttonStyle === 'rect')
	{
		c.begin();
		c.moveTo(0, 0);
		c.lineTo(w, 0);
		c.lineTo(w, h);
		c.lineTo(0, h);
		c.close();	
		c.fillAndStroke();
	}
	else if (buttonStyle === 'dblFrame')
	{
		var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#666666');
		c.setFillColor(fillColor);
		c.begin();
		c.moveTo(0, 0);
		c.lineTo(w, 0);
		c.lineTo(w, h);
		c.lineTo(0, h);
		c.close();	
		c.fillAndStroke();
		rSize = Math.min(w, h);
		c.begin();
		c.moveTo(rSize * 0.1, rSize * 0.1);
		c.lineTo(w - rSize * 0.1, rSize * 0.1);
		c.lineTo(w - rSize * 0.1, h - rSize * 0.1);
		c.lineTo(rSize * 0.1, h - rSize * 0.1);
		c.close();	
		c.stroke();
	}

	var trX = 0;
	var trY = 0;

	if (buttonStyle === 'round')
	{
		trX = w * 0.5;
		trY = rSize;
		c.translate(trX, trY);
		w = w * 0.5 - rSize;
		h = h - 2 * rSize;
		c.begin();
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(w - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
		c.lineTo(w, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
		c.close();	
		c.fillAndStroke();
	}
	else if (buttonStyle === 'rect')
	{
		trX = w * 0.5;
		trY = rSize;
		c.translate(trX, trY);
		w = w * 0.5 - rSize;
		h = h - 2 * rSize;
		c.begin();
		c.moveTo(0, 0);
		c.lineTo(w, 0);
		c.lineTo(w, h);
		c.lineTo(0, h);
		c.close();	
		c.fillAndStroke();
	}
	else if (buttonStyle === 'dblFrame')
	{
		trX = w * 0.5;
		trY = rSize * 0.15;
		c.translate(trX, trY);
		w = w * 0.5 - rSize * 0.15;
		h = h - rSize * 0.3;
		var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#666666');
		c.setFillColor(fillColor);
		c.begin();
		c.moveTo(0, 0);
		c.lineTo(w, 0);
		c.lineTo(w, h);
		c.lineTo(0, h);
		c.close();	
		c.fillAndStroke();
		rSize = Math.min(w, h);
		c.begin();
		c.moveTo(rSize * 0.1, rSize * 0.1);
		c.lineTo(w - rSize * 0.1, rSize * 0.1);
		c.lineTo(w - rSize * 0.1, h - rSize * 0.1);
		c.lineTo(rSize * 0.1, h - rSize * 0.1);
		c.close();	
		c.stroke();
	}

	c.translate(- trX, - trY);

};

mxShapeERHierarchy.prototype.shapeText = function(c, x, y, w, h, text, subText, fontSize, fontColor, rSize)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w * 0.25, (h - fontSize) * 0.5, 0, 0, text[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.25, (h + fontSize) * 0.5, 0, 0, text[1], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.7, (h - fontSize) * 0.5, 0, 0, subText[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.7, (h + fontSize) * 0.5, 0, 0, subText[1], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape('mxgraph.er.hierarchy', mxShapeERHierarchy);

mxShapeERHierarchy.prototype.constraints = [
                                         new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                         new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                         new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                         new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                         new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                         new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                         new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                         new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                         new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                         new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                         ];

//**********************************************************************************************************************************************************
//Note
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeERNote(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeERNote, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeERNote.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, 'buttonText', 'Entity');
	var fontColor = mxUtils.getValue(this.style, 'textColor', '#666666');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '17');
	var backColor = mxUtils.getValue(this.style, 'fillColor2', '#ffffff');
	c.translate(x, y);
	var flipSize = 20;
	w = Math.max(w, flipSize * 2);
	h = Math.max(h, flipSize * 2);
	this.background(c, x, y, w, h, flipSize);
	c.setShadow(false);
	this.flipShape(c, x, y, w, h, flipSize, backColor);
	this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
};

mxShapeERNote.prototype.background = function(c, x, y, w, h, flipSize)
{
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w - flipSize, 0);
	c.lineTo(w, flipSize);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();	
	c.fillAndStroke();
};

mxShapeERNote.prototype.flipShape = function(c, x, y, w, h, flipSize, backColor)
{
	c.setLineJoin('round');
	c.setFillColor(backColor);
	c.begin();
	c.moveTo(w - flipSize, 0);
	c.lineTo(w, flipSize);
	c.lineTo(w - flipSize, flipSize);
	c.close();	
	c.fillAndStroke();
};

mxShapeERNote.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w * 0.5, h * 0.5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape('mxgraph.er.note', mxShapeERNote);

mxShapeERNote.prototype.constraints = [
                                           new mxConnectionConstraint(new mxPoint(0, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 1), true),
                                           new mxConnectionConstraint(new mxPoint(1, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                           new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                           new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                           new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                           ];

//**********************************************************************************************************************************************************
//Chen's Notation Legend (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeERChen(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeERChen, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeERChen.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var fontColor = mxUtils.getValue(this.style, 'textColor', '#666666');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '17');
	c.translate(x, y);
	var flipSize = 20;
	w = Math.max(w, flipSize * 2);
	h = Math.max(h, flipSize * 2);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, fontSize, fontColor);
};

mxShapeERChen.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();	
	c.fillAndStroke();
};

mxShapeERChen.prototype.foreground = function(c, x, y, w, h, fontSize, fontColor)
{
	c.begin();
	c.moveTo(0, h * 0.25);
	c.lineTo(w, h * 0.25);
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.moveTo(0, h * 0.75);
	c.lineTo(w, h * 0.75);

	c.moveTo(w * 0.25, h * 0.5);
	c.lineTo(w * 0.25, h);

	c.moveTo(w * 0.5, h * 0.25);
	c.lineTo(w * 0.5, h);

	c.moveTo(w * 0.75, h * 0.5);
	c.lineTo(w * 0.75, h);
	c.stroke();

	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w * 0.5, h * 0.125, 0, 0, 'ERD Peter Chen\'s Notation', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setFontSize(fontSize * 0.85);
	c.text(w * 0.25, h * 0.375, 0, 0, 'Cardinality', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.75, h * 0.375, 0, 0, 'Optionality', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setFontSize(fontSize * 0.7);
	c.text(w * 0.125, h * 0.625, 0, 0, '1', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.375, h * 0.625, 0, 0, 'One', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.625, h * 0.625, 0, 0, '0', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.875, h * 0.625, 0, 0, 'Optional', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.text(w * 0.125, h * 0.875, 0, 0, 'N', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.375, h * 0.875, 0, 0, 'Many', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.625, h * 0.875, 0, 0, '1', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.875, h * 0.875, 0, 0, 'Mandatory', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape('mxgraph.er.chens', mxShapeERChen);

mxShapeERChen.prototype.constraints = [
                                       new mxConnectionConstraint(new mxPoint(0, 0), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0, 1), true),
                                       new mxConnectionConstraint(new mxPoint(1, 1), true),
                                       new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                       new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                       new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                       new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                       new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                       new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                       ];

//**********************************************************************************************************************************************************
//Bachman's Notation Legend (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeERBachman(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeERBachman, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeERBachman.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var fontColor = mxUtils.getValue(this.style, 'textColor', '#666666');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '17');
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, fontSize, fontColor);
};

mxShapeERBachman.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();	
	c.fillAndStroke();
};

mxShapeERBachman.prototype.foreground = function(c, x, y, w, h, fontSize, fontColor)
{
	c.begin();
	c.moveTo(0, h * 0.125);
	c.lineTo(w, h * 0.125);
	c.moveTo(0, h * 0.25);
	c.lineTo(w, h * 0.25);
	c.moveTo(0, h * 0.375);
	c.lineTo(w, h * 0.375);
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.moveTo(0, h * 0.625);
	c.lineTo(w, h * 0.625);
	c.moveTo(0, h * 0.75);
	c.lineTo(w, h * 0.75);
	c.moveTo(0, h * 0.875);
	c.lineTo(w, h * 0.875);

	c.moveTo(w * 0.5, h * 0.125);
	c.lineTo(w * 0.5, h);
	c.stroke();

	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w * 0.5, h * 0.0625, 0, 0, 'ERD Bachman\'s Notation', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setFontSize(fontSize * 0.85);
	c.text(w * 0.52, h * 0.1875, 0, 0, 'Relationship', mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.52, h * 0.3125, 0, 0, 'Cardinality (One)', mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.52, h * 0.4375, 0, 0, 'Cardinality (Many)', mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.52, h * 0.5625, 0, 0, 'Mandatory, One', mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.52, h * 0.6875, 0, 0, 'Mandatory, Many', mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.52, h * 0.8125, 0, 0, 'Optional, One', mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.52, h * 0.9375, 0, 0, 'Optional, Many', mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	var textWidth = mxUtils.getSizeForString('has/forms', fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
	c.begin();
	c.moveTo(w * 0.04, h * 0.1875);
	c.lineTo(w * 0.25  - textWidth * 0.5, h * 0.1875);
	c.moveTo(w * 0.25  + textWidth * 0.5, h * 0.1875);
	c.lineTo(w * 0.46, h * 0.1875);

	c.text(w * 0.25, h * 0.1875, 0, 0, 'has/forms', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, true, 0, 0);

	c.moveTo(w * 0.04, h * 0.3125);
	c.lineTo(w * 0.46, h * 0.3125);

	c.moveTo(w * 0.04, h * 0.4375);
	c.lineTo(w * 0.46, h * 0.4375);
	c.moveTo(w * 0.46, h * 0.4050);
	c.lineTo(w * 0.4, h * 0.4375);
	c.lineTo(w * 0.46, h * 0.47);

	c.moveTo(w * 0.04, h * 0.5625);
	c.lineTo(w * 0.46, h * 0.5625);
	c.moveTo(w * 0.38, h * 0.53);
	c.lineTo(w * 0.38, h * 0.595);

	c.moveTo(w * 0.04, h * 0.6875);
	c.lineTo(w * 0.46, h * 0.6875);
	c.moveTo(w * 0.46, h * 0.655);
	c.lineTo(w * 0.4, h * 0.6875);
	c.lineTo(w * 0.46, h * 0.72);
	c.moveTo(w * 0.38, h * 0.655);
	c.lineTo(w * 0.38, h * 0.72);

	c.moveTo(w * 0.04, h * 0.8125);
	c.lineTo(w * 0.46, h * 0.8125);

	c.moveTo(w * 0.04, h * 0.9375);
	c.lineTo(w * 0.46, h * 0.9375);
	c.moveTo(w * 0.46, h * 0.9050);
	c.lineTo(w * 0.4, h * 0.9375);
	c.lineTo(w * 0.46, h * 0.97);

	c.stroke();

	var ellSize = h / 15;
	c.begin();
	c.ellipse(w * 0.46 - ellSize, h * 0.8125 - ellSize * 0.5, ellSize, ellSize);
	c.fillAndStroke();

	c.begin();
	c.ellipse(w * 0.4 - ellSize, h * 0.9375 - ellSize * 0.5, ellSize, ellSize);
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.er.bachmans', mxShapeERBachman);

mxShapeERBachman.prototype.constraints = [
                                       new mxConnectionConstraint(new mxPoint(0, 0), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0, 1), true),
                                       new mxConnectionConstraint(new mxPoint(1, 1), true),
                                       new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                       new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                       new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                       new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                       new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                       new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                       new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                       new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                       ];

//**********************************************************************************************************************************************************
//Information Engineering Notation Legend (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeERInfEng(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeERInfEng, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeERInfEng.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var fontColor = mxUtils.getValue(this.style, 'textColor', '#666666');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '17');
	c.translate(x, y);
	w = Math.max(w, h / 1.5);
	h = Math.max(h, fontSize * 5);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, fontSize, fontColor);
};

mxShapeERInfEng.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();	
	c.fillAndStroke();
};

mxShapeERInfEng.prototype.foreground = function(c, x, y, w, h, fontSize, fontColor)
{
	c.begin();
	c.moveTo(0, h * 0.2);
	c.lineTo(w, h * 0.2);
	c.moveTo(0, h * 0.4);
	c.lineTo(w, h * 0.4);
	c.moveTo(0, h * 0.6);
	c.lineTo(w, h * 0.6);
	c.moveTo(0, h * 0.8);
	c.lineTo(w, h * 0.8);

	c.moveTo(w * 0.5, h * 0.2);
	c.lineTo(w * 0.5, h);
	c.stroke();

	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w * 0.5, h * 0.1, 0, 0, 'ERD Information Engineering Notation', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setFontSize(fontSize * 0.85);
	c.text(w * 0.52, h * 0.3, 0, 0, 'Zero or one', mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.52, h * 0.5, 0, 0, 'One only', mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.52, h * 0.7, 0, 0, 'Zero or more', mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.52, h * 0.9, 0, 0, 'One or more', mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	var ellSize = h / 12;

	c.begin();
	c.moveTo(w * 0.04, h * 0.3);
	c.lineTo(w * 0.46, h * 0.3);
	c.moveTo(w * 0.46 - ellSize, h * 0.25);
	c.lineTo(w * 0.46 - ellSize, h * 0.35);

	c.moveTo(w * 0.04, h * 0.5);
	c.lineTo(w * 0.46, h * 0.5);
	c.moveTo(w * 0.46 - ellSize * 2, h * 0.45);
	c.lineTo(w * 0.46 - ellSize * 2, h * 0.55);
	c.moveTo(w * 0.46 - ellSize * 2.5, h * 0.45);
	c.lineTo(w * 0.46 - ellSize * 2.5, h * 0.55);

	c.moveTo(w * 0.04, h * 0.7);
	c.lineTo(w * 0.46, h * 0.7);
	c.moveTo(w * 0.46, h * 0.65);
	c.lineTo(w * 0.46 - ellSize * 2, h * 0.7);
	c.lineTo(w * 0.46, h * 0.75);
	c.stroke();

	c.moveTo(w * 0.04, h * 0.9);
	c.lineTo(w * 0.46, h * 0.9);
	c.moveTo(w * 0.46, h * 0.85);
	c.lineTo(w * 0.46 - ellSize * 2, h * 0.9);
	c.lineTo(w * 0.46, h * 0.95);
	c.moveTo(w * 0.46 - ellSize * 2.5, h * 0.85);
	c.lineTo(w * 0.46 - ellSize * 2.5, h * 0.95);
	c.stroke();

	c.begin();
	c.ellipse(w * 0.46 - ellSize * 3, h * 0.3 - ellSize * 0.5, ellSize, ellSize);
	c.fillAndStroke();

	c.begin();
	c.ellipse(w * 0.46 - ellSize * 3, h * 0.7 - ellSize * 0.5, ellSize, ellSize);
	c.fillAndStroke();
};

mxCellRenderer.registerShape('mxgraph.er.ie', mxShapeERInfEng);

mxShapeERInfEng.prototype.constraints = [
                                          new mxConnectionConstraint(new mxPoint(0, 0), true),
                                          new mxConnectionConstraint(new mxPoint(1, 0), true),
                                          new mxConnectionConstraint(new mxPoint(0, 1), true),
                                          new mxConnectionConstraint(new mxPoint(1, 1), true),
                                          new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                          new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                          new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                          new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                          new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                          new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                          new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                          new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                          new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                          new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                          new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                          new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                          ];

// ER markers
mxMarker.addMarker('ERone', function(c, shape, type, pe, unitX, unitY, size, source, sw, filled)
{
	var nx = unitX * (size + sw + 1);
	var ny = unitY * (size + sw + 1);

	return function()
	{
		c.begin();
		c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
		c.lineTo(pe.x - nx / 2 + ny / 2, pe.y - ny / 2 - nx / 2);
		c.stroke();
	};
});

mxMarker.addMarker('ERmandOne', function(c, shape, type, pe, unitX, unitY, size, source, sw, filled)
{
	var nx = unitX * (size + sw + 1);
	var ny = unitY * (size + sw + 1);

	return function()
	{
		c.begin();
		c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
		c.lineTo(pe.x - nx / 2 + ny / 2, pe.y - ny / 2 - nx / 2);
		c.moveTo(pe.x - nx - ny / 2, pe.y - ny + nx / 2);
		c.lineTo(pe.x - nx + ny / 2, pe.y - ny - nx / 2);
		c.stroke();
	};
});

mxMarker.addMarker('ERmany', function(c, shape, type, pe, unitX, unitY, size, source, sw, filled)
{
	var nx = unitX * (size + sw + 1);
	var ny = unitY * (size + sw + 1);

	return function()
	{
		c.begin();
		c.moveTo(pe.x + ny / 2, pe.y - nx / 2);
		c.lineTo(pe.x - nx, pe.y - ny);
		c.lineTo(pe.x - ny / 2, pe.y + nx / 2);
		c.stroke();
	};
});

mxMarker.addMarker('ERoneToMany', function(c, shape, type, pe, unitX, unitY, size, source, sw, filled)
{
	var nx = unitX * (size + sw + 1);
	var ny = unitY * (size + sw + 1);

	return function()
	{
		c.begin();
		c.moveTo(pe.x - nx - ny / 2, pe.y - ny + nx / 2);
		c.lineTo(pe.x - nx + ny / 2, pe.y - ny - nx / 2);
		c.moveTo(pe.x + ny / 2, pe.y - nx / 2);
		c.lineTo(pe.x - nx, pe.y - ny);
		c.lineTo(pe.x - ny / 2, pe.y + nx / 2);
		c.stroke();
	};
});

mxMarker.addMarker('ERzeroToMany', function(c, shape, type, pe, unitX, unitY, size, source, sw, filled)
{
	var nx = unitX * (size + sw + 1);
	var ny = unitY * (size + sw + 1);
	var a = size / 2;

	return function()
	{
		c.begin();
		c.ellipse(pe.x - 1.5 * nx - a, pe.y - 1.5 * ny - a, 2 * a, 2 * a);

		if (filled)
		{
			// TODO not sure if this is ok, because by default, markers use strokeColor for filling 
			var oldColor = mxUtils.getValue(shape.style, mxConstants.STYLE_STROKECOLOR, '#666666');
			
			c.setFillColor('#ffffff');
			c.fillAndStroke();
			c.setFillColor(oldColor);
		}
		else
		{
			c.stroke();
		}

		c.begin();
		c.moveTo(pe.x + ny / 2, pe.y - nx / 2);
		c.lineTo(pe.x - nx, pe.y - ny);
		c.lineTo(pe.x - ny / 2, pe.y + nx / 2);
		c.stroke();
	};
});

mxMarker.addMarker('ERzeroToOne', function(c, shape, type, pe, unitX, unitY, size, source, sw, filled)
{
	var nx = unitX * (size + sw + 1);
	var ny = unitY * (size + sw + 1);
	var a = size / 2;

	return function()
	{
		c.begin();
		c.ellipse(pe.x - 1.5 * nx - a, pe.y - 1.5 * ny - a, 2 * a, 2 * a);

		if (filled)
		{
			// TODO not sure if this is ok, because by default, markers use strokeColor for filling 
			var oldColor = mxUtils.getValue(shape.style, mxConstants.STYLE_STROKECOLOR, '#666666');
			
			c.setFillColor('#ffffff');
			c.fillAndStroke();
			c.setFillColor(oldColor);
		}
		else
		{
			c.stroke();
		}

		c.begin();
		c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
		c.lineTo(pe.x - nx / 2 + ny / 2, pe.y - ny / 2 - nx / 2);
		c.stroke();
	};
});

//**********************************************************************************************************************************************************
//Rounded rectangle (adjustable rounding)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeERRRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeERRRect, mxShape);

mxShapeERRRect.prototype.cst = {
		RRECT : 'mxgraph.er.rrect',
		R_SIZE : 'rSize'
};

mxShapeERRRect.prototype.customProperties = [
	{name: 'rSize', dispName: 'Rounding Size', type: 'float'},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeERRRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeERRRect.prototype.cst.R_SIZE, '10'));
	c.roundrect(0, 0, w, h, rSize);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeERRRect.prototype.cst.RRECT, mxShapeERRRect);

mxShapeERRRect.prototype.constraints = [
                                            new mxConnectionConstraint(new mxPoint(0.25, 0), true),
                                            new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                            new mxConnectionConstraint(new mxPoint(0.75, 0), true),
                                            new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                            new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                            new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                            new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                            new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                            new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                            new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                            new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                            new mxConnectionConstraint(new mxPoint(0.75, 1), true)
                                            ];

//**********************************************************************************************************************************************************
//Anchor (a dummy shape without visuals used for anchoring)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeERAnchor(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeERAnchor, mxShape);

mxShapeERAnchor.prototype.cst = {
		ANCHOR : 'mxgraph.er.anchor'
};



/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeERAnchor.prototype.paintVertexShape = function(c, x, y, w, h)
{
};

mxCellRenderer.registerShape(mxShapeERAnchor.prototype.cst.ANCHOR, mxShapeERAnchor);


/**
 * $Id: mxIOS7Ui.js,v 1.6 2013/12/04 16:48:54 mate Exp $
 * Copyright (c) 2006-2013, JGraph Ltd
 */

var mxIOS7C =
{
		MAIN_TEXT : 'mainText',
		SUB_TEXT : 'subText',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize',
		BAR_POS : 'barPos',
		BUTTON_TEXT : 'buttonText',
		BUTTON_STATE : 'buttonState',
		SELECTED : '+', 		//has to be one character long
		STATE_ON : 'on',
		STATE_OFF : 'off',
		GRID_SIZE : 'gridSize',
		
		SHAPE_IOS7_APP_BAR : 'mxgraph.ios7ui.appBar',
		SHAPE_IOS7_ON_OFF_BUTTON : 'mxgraph.ios7ui.onOffButton',
		SHAPE_IOS7_SLIDER : 'mxgraph.ios7ui.slider',
		SHAPE_IOS7_DOWNLOAD_BAR : 'mxgraph.ios7ui.downloadBar',
		SHAPE_IOS7_ICON : 'mxgraph.ios7ui.icon',
		SHAPE_IOS7_HOR_BUTTON_BAR : 'mxgraph.ios7ui.horButtonBar',
		SHAPE_IOS7_PAGE_CONTROL : 'mxgraph.ios7ui.pageControl',
		SHAPE_IOS7_EXPAND :  'mxgraph.ios7ui.expand',
		SHAPE_IOS7_ICON_GRID : 'mxgraph.ios7ui.iconGrid',
		SHAPE_IOS7_PHONE : 'mxgraph.ios7ui.phone',
		SHAPE_IOS7_SEARCH_BOX : 'mxgraph.ios7ui.searchBox',
		SHAPE_IOS7_URL : 'mxgraph.ios7ui.url',
		SHAPE_IOS7_ACTION_DIALOG : 'mxgraph.ios7ui.actionDialog',
		
		STYLE_FILLCOLOR2 : 'fillColor2',
		STYLE_FILLCOLOR3 : 'fillColor3',
		STYLE_TEXTCOLOR : 'textColor',
		STYLE_TEXTCOLOR2 : 'textColor2',
		STYLE_STROKECOLOR2 : 'strokeColor2',
		STYLE_STROKECOLOR3 : 'strokeColor3',
		STYLE_TEXTSIZE : 'textSize'
};

//**********************************************************************************************************************************************************
//iOS7 Application Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeIOS7AppBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeIOS7AppBar, mxShape);

mxShapeIOS7AppBar.prototype.customProperties = [
	{name: 'fillColor2', dispName: 'Fill Color 2', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeIOS7AppBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeIOS7AppBar.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fill();
};

mxShapeIOS7AppBar.prototype.foreground = function(c, x, y, w, h)
{
	c.setFillColor(mxUtils.getValue(this.style, mxIOS7C.STYLE_FILLCOLOR2, '#222222'));

	c.ellipse(5, h * 0.5 - 1.5, 3, 3);
	c.fill();
	c.ellipse(9, h * 0.5 - 1.5, 3, 3);
	c.fill();
	c.ellipse(13, h * 0.5 - 1.5, 3, 3);
	c.fill();
	c.ellipse(17, h * 0.5 - 1.5, 3, 3);
	c.fill();
	c.ellipse(21, h * 0.5 - 1.5, 3, 3);
	c.fill();
	
	c.ellipse(54, h * 0.5 + 2, 2, 2);
	c.fillAndStroke();
	
	c.setStrokeWidth(2);
	c.begin();
	c.moveTo(52, h * 0.5 + 1);
	c.arcTo(3.5, 3.5, 0, 0, 1, 58, h * 0.5 + 1);
	c.stroke();
	
	c.begin();
	c.moveTo(50, h * 0.5 - 1);
	c.arcTo(6, 6, 0, 0, 1, 60, h * 0.5 - 1);
	c.stroke();
	
	c.begin();
	c.moveTo(w - 19, h * 0.5 - 2);
	c.lineTo(w - 6, h * 0.5 - 2);
	c.lineTo(w - 6, h * 0.5 + 2);
	c.lineTo(w - 19, h * 0.5 + 2);
	c.close();
	c.fill();

	c.setStrokeWidth(1);
	c.begin();
	c.moveTo(w - 44, h * 0.5  - 2.5);
	c.lineTo(w - 36, h * 0.5  + 2.5);
	c.lineTo(w - 40, h * 0.5 + 5);
	c.lineTo(w - 40, h * 0.5 - 5);
	c.lineTo(w - 36, h * 0.5 - 2.5);
	c.lineTo(w - 44, h * 0.5 + 2.5);
	c.stroke();
	
	c.begin();
	c.moveTo(w - 20, h * 0.5 - 3);
	c.lineTo(w - 5, h * 0.5 - 3);
	c.lineTo(w - 5, h * 0.5 - 1);
	c.lineTo(w - 3.5, h * 0.5 - 1);
	c.lineTo(w - 3.5, h * 0.5 + 1);
	c.lineTo(w - 5, h * 0.5 + 1);
	c.lineTo(w - 5, h * 0.5 + 3);
	c.lineTo(w - 20, h * 0.5 + 3);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_APP_BAR, mxShapeIOS7AppBar);

//**********************************************************************************************************************************************************
//On-Off Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7OnOffButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7OnOffButton, mxShape);

mxShapeIOS7OnOffButton.prototype.customProperties = [
	{name: 'buttonState', dispName: 'Button State', type: 'enum',
		enumList: [{val: 'on', dispName: 'On'},
				   {val: 'off', dispName: 'Off'}]
	},
	{name: 'strokeColor2', dispName: 'Stroke Color 2', type: 'color'},
	{name: 'fillColor2', dispName: 'Fill Color 2', type: 'color'},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7OnOffButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	w = Math.max(w, 2 * h);
	var state = mxUtils.getValue(this.style, mxIOS7C.BUTTON_STATE, mxIOS7C.STATE_ON);
	this.background(c, x, y, w, h, state);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, state);
};

mxShapeIOS7OnOffButton.prototype.background = function(c, x, y, w, h, state)
{
	if (state === mxIOS7C.STATE_ON)
	{
		c.roundrect(0, 0, w, h, h * 0.5, h * 0.5);
		c.fillAndStroke();
	}
	else if (state === mxIOS7C.STATE_OFF)
	{
		c.setStrokeColor(mxUtils.getValue(this.style, mxIOS7C.STYLE_STROKECOLOR2, '#aaaaaa'));
		c.setFillColor(mxUtils.getValue(this.style, mxIOS7C.STYLE_FILLCOLOR2, '#ffffff'));
		c.roundrect(0, 0, w, h, h * 0.5, h * 0.5);
		c.fillAndStroke();
	}

};

mxShapeIOS7OnOffButton.prototype.foreground = function(c, x, y, w, h, state)
{
	c.setFillColor('#ffffff');

	if (state === mxIOS7C.STATE_ON)
	{
		c.ellipse(w - h + 1, 1, h - 2, h - 2);
		c.fill();
	}
	else
	{
		c.ellipse(0, 0, h, h);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_ON_OFF_BUTTON, mxShapeIOS7OnOffButton);

//**********************************************************************************************************************************************************
//Slider
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7Slider(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.barPos = 80;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7Slider, mxShape);



/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7Slider.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.setShadow(false);

	this.foreground(c, w, h);
};

mxShapeIOS7Slider.prototype.foreground = function(c, w, h)
{
	c.setStrokeWidth(2);
	
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.stroke();

	var barPos = mxUtils.getValue(this.style, mxIOS7C.BAR_POS, '80');
	barPos = Math.min(barPos, 100);
	barPos = Math.max(barPos, 0);
	var deadzone = 0; 
	var virRange = w - 2 * deadzone;
	var truePos = deadzone + virRange * barPos / 100;

	c.setStrokeColor(mxUtils.getValue(this.style, mxIOS7C.STYLE_STROKECOLOR2, '#a0a0a0'));
	c.ellipse(truePos - 5, h * 0.5 - 5, 10, 10);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_SLIDER, mxShapeIOS7Slider);

Graph.handleFactory[mxIOS7C.SHAPE_IOS7_SLIDER] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'barPos', this.barPos))));

				return new mxPoint(bounds.x + barPos / 100 * bounds.width, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(1000 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 1000;
			})];

	return handles;
}

//**********************************************************************************************************************************************************
//Download Bar
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7DownloadBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.barPos = 80;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7DownloadBar, mxShape);

mxShapeIOS7DownloadBar.prototype.customProperties = [
	{name: 'barPos', dispName: 'Handle Position', type: 'float', min:0, max:1, defVal:30},
	{name: 'strokeColor2', dispName: 'Stroke Color 2', type: 'color'}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7DownloadBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.foreground(c, w, h);
};

mxShapeIOS7DownloadBar.prototype.foreground = function(c, w, h)
{
	var fieldText = mxUtils.getValue(this.style, mxIOS7C.BUTTON_TEXT, '');
	c.setFontStyle(mxConstants.FONT_BOLD);
	c.text(w * 0.5, h * 0.2, 0, 0, fieldText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	var barPos = mxUtils.getValue(this.style, mxIOS7C.BAR_POS, '80');
	barPos = Math.min(barPos, 100);
	barPos = Math.max(barPos, 0);
	var truePos = w * barPos / 100;

	c.setStrokeWidth(2);
	c.setStrokeColor(mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, ''));
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.stroke();

	c.setStrokeColor(mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, ''));
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(truePos, h * 0.5);
	c.stroke();
};

mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_DOWNLOAD_BAR, mxShapeIOS7DownloadBar);

Graph.handleFactory[mxIOS7C.SHAPE_IOS7_DOWNLOAD_BAR] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'barPos', this.barPos))));

				return new mxPoint(bounds.x + barPos / 100 * bounds.width, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(1000 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 1000;
			})];

	return handles;
}

//**********************************************************************************************************************************************************
//Icon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7Icon(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7Icon, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7Icon.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.foreground(c, w, h);
};

mxShapeIOS7Icon.prototype.foreground = function(c, w, h)
{
	c.setGradient('#00D0F0', '#0080F0', w * 0.325, 0, w * 0.675, h * 0.5, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.roundrect(0, 0, w, h, w * 0.1, h * 0.1);
	c.fill();
	
	var fieldText = mxUtils.getValue(this.style, mxIOS7C.BUTTON_TEXT, '');
	c.setFontColor('#ffffff');
	c.setFontStyle(mxConstants.FONT_BOLD);
	c.setFontSize(8);
	c.text(w * 0.5, h * 0.5, 0, 0, fieldText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_ICON, mxShapeIOS7Icon);

//**********************************************************************************************************************************************************
//Horizontal Button Bar
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7horButtonBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7horButtonBar, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7horButtonBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var textStrings = mxUtils.getValue(this.style, mxIOS7C.BUTTON_TEXT, '+Button 1, Button 2, Button 3').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTCOLOR, '#666666');
	var selectedFontColor = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTCOLOR2, '#ffffff');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '8.5').toString();
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var selectedFillColor = mxUtils.getValue(this.style, mxIOS7C.STYLE_FILLCOLOR2, '#008cff');
	var buttonNum = textStrings.length;
	var buttonWidths = new Array(buttonNum);
	var buttonTotalWidth = 0;
	var selectedButton = -1;
	var rSize = 2.5; //rounding size
	var labelOffset = 2.5;

	for (var i = 0; i < buttonNum; i++)
	{
		var buttonText = textStrings[i];

		if(buttonText.charAt(0) === mxIOS7C.SELECTED)
		{
			buttonText = textStrings[i].substring(1);
			selectedButton = i;
		}

		buttonWidths[i] = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
		buttonTotalWidth += buttonWidths[i];
	}

	var trueH = Math.max(h, fontSize * 1.5, 10);
	var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
	var trueW = Math.max(w, minW);

	c.translate(x, y);
	this.background(c, trueW, trueH, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, bgColor, selectedFillColor, selectedButton);
	c.setShadow(false);

	var currWidth = 0;

	for (var i = 0; i < buttonNum; i++)
	{
		if (i === selectedButton)
		{
			c.setFontColor(selectedFontColor);
		}
		else
		{
			c.setFontColor(fontColor);
		}

		currWidth = currWidth + labelOffset;
		this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
		currWidth = currWidth + buttonWidths[i] + labelOffset;
	}
};

mxShapeIOS7horButtonBar.prototype.background = function(c, w, h, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, bgColor, selectedFillColor, selectedButton)
{
	c.begin();

	//draw the frame
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();
	c.fillAndStroke();

	//draw the button separators
	c.setStrokeColor(frameColor);
	c.begin();
	for (var i = 1; i < buttonNum; i++)
	{
		if (i !== selectedButton && i !== (selectedButton + 1))
		{
			var currWidth = 0;

			for (var j = 0; j < i; j++)
			{
				currWidth += buttonWidths[j] + 2 * labelOffset;
			}

			currWidth = currWidth * w / minW;
			c.moveTo(currWidth, 0);
			c.lineTo(currWidth, h);
		}
	}

	c.stroke();

	//draw the selected button
	var buttonLeft = 0;
	c.setStrokeColor(mxConstants.NONE);

	for (var i = 0; i < selectedButton; i++)
	{
		buttonLeft += buttonWidths[i] + 2 * labelOffset;
	}

	buttonLeft = buttonLeft * w / minW;
	var buttonRight = (buttonWidths[selectedButton] + 2 * labelOffset) * w / minW;
	buttonRight += buttonLeft;
	c.setFillColor('#0080F0');

	if (selectedButton === 0)
	{
		c.begin();
		// we draw a path for the first button
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(buttonRight, 0);
		c.lineTo(buttonRight, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
		c.close();
		c.fill();
	}
	else if (selectedButton === buttonNum - 1)
	{
		c.begin();
		// we draw a path for the last button
		c.moveTo(buttonLeft, 0);
		c.lineTo(buttonRight - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, buttonRight, rSize);
		c.lineTo(buttonRight, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, buttonRight - rSize, h);
		c.lineTo(buttonLeft, h);
		c.close();
		c.fill();
	}
	else if (selectedButton !== -1)
	{
		c.begin();
		// we draw a path rectangle for one of the buttons in the middle
		c.moveTo(buttonLeft, 0);
		c.lineTo(buttonRight, 0);
		c.lineTo(buttonRight, h);
		c.lineTo(buttonLeft, h);
		c.close();
		c.fill();
	}

	//draw the frame again, to achieve a nicer effect
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.begin();
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();
	c.stroke();
};

mxShapeIOS7horButtonBar.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW)
{
	if(textString.charAt(0) === mxIOS7C.SELECTED)
	{
		textString = textString.substring(1);
	}

	c.begin();
	c.setFontSize(fontSize);
	c.text((w + buttonWidth * 0.5) * trueW / minW, h * 0.5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_HOR_BUTTON_BAR, mxShapeIOS7horButtonBar);

//**********************************************************************************************************************************************************
//Page Control
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7pageControl(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7pageControl, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7pageControl.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#000000');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');

	var rSize = Math.min(h * 0.5, w * 0.05);
	c.setFillColor(strokeColor);
	c.ellipse(0, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
	c.ellipse(w * 0.25 - rSize * 0.5, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
	c.ellipse(w * 0.5 - rSize, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
	c.ellipse(w * 0.75 - rSize * 1.5, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
	c.setFillColor(fillColor);
	c.ellipse(w - 2 * rSize, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
};

mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_PAGE_CONTROL, mxShapeIOS7pageControl);

//**********************************************************************************************************************************************************
//Icon Grid
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7iconGrid(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7iconGrid, mxShape);

mxShapeIOS7iconGrid.prototype.customProperties = [
	{name: 'gridSize', dispName: 'Grid Size', type: 'String'},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7iconGrid.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var gridSize = mxUtils.getValue(this.style, mxIOS7C.GRID_SIZE, '4,7').toString().split(',');

	var boxSizeX = w / (parseInt(gridSize[0],10) + (gridSize[0]-1) * 0.1);
	var boxSizeY = h / (parseInt(gridSize[1],10) + (gridSize[1]-1) * 0.1);
	
	for (var i = 0; i < gridSize[0]; i++)
	{
		for (var j = 0; j < gridSize[1]; j++)
		{
			c.rect(boxSizeX * 1.1 * i, boxSizeY * 1.1 * j, boxSizeX, boxSizeY);
			c.fill();
		}
	}
};

mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_ICON_GRID, mxShapeIOS7iconGrid);

//**********************************************************************************************************************************************************
//iPhone Vertical
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7phone(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7phone, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7phone.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var rSize = 25;

	c.roundrect(0, 0, w, h, rSize, rSize);
	c.fillAndStroke();
	
	c.setShadow(false);
	
	this.foreground(c, x, y, w, h, rSize);
};

mxShapeIOS7phone.prototype.foreground = function(c, x, y, w, h, rSize)
{
	c.rect(w * 0.0625, h * 0.15, w * 0.875, h * 0.7);
	c.stroke();

	c.ellipse(w * 0.4875, h * 0.04125, w * 0.025, h * 0.0125);
	c.stroke();

	c.roundrect(w * 0.375, h * 0.075, w * 0.25, h * 0.01875, w * 0.02, h * 0.01);
	c.stroke();
	c.ellipse(w * 0.4, h * 0.875, w * 0.2, h * 0.1);
	c.stroke();
	c.roundrect(w * 0.4575, h * 0.905, w * 0.085, h * 0.04375, h * 0.00625, h * 0.00625);
	c.stroke();
};

mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_PHONE, mxShapeIOS7phone);

//**********************************************************************************************************************************************************
//Search Box
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7searchBox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7searchBox, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7searchBox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeIOS7searchBox.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fill();
};

mxShapeIOS7searchBox.prototype.foreground = function(c, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxIOS7C.BUTTON_TEXT, 'Search');
	var fontColor = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTCOLOR, '#666666');
	var strokeColor2 = mxUtils.getValue(this.style, mxIOS7C.STYLE_STROKECOLOR2, '#008cff');
	var fontSize = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTSIZE, '17');
	var rSize = Math.min(w, h) * 0.1;

	c.setFillColor('#ffffff');
	c.roundrect(w * 0.05, h * 0.15, w * 0.5, h * 0.7, rSize, rSize);
	c.fillAndStroke();
	
	c.setFontColor(fontColor);
	c.setFontSize(Math.min(h * 0.7, w * 0.1));

	c.text(5, h * 0.5, 0, 0, mainText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setStrokeColor(strokeColor2);
	c.ellipse(w * 0.05 + 3, h * 0.5 - 3, 4, 4);
	c.stroke();
	c.begin();
	c.moveTo(w * 0.05 + 8, h * 0.5 + 3.5);
	c.lineTo(w * 0.05 + 6, h * 0.5 + 0.5);
	c.stroke();
};

mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_SEARCH_BOX, mxShapeIOS7searchBox);

//**********************************************************************************************************************************************************
//URL
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7URL(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7URL, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7URL.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeIOS7URL.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fill();
};

mxShapeIOS7URL.prototype.foreground = function(c, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxIOS7C.BUTTON_TEXT, 'draw.io');
	var fontColor = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTCOLOR, '#666666');
	var strokeColor2 = mxUtils.getValue(this.style, mxIOS7C.STYLE_STROKECOLOR2, '#008cff');
	var fontSize = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTSIZE, '17');
	var rSize = Math.min(w, h) * 0.1;

	c.setFillColor('#d8d8d8');
	c.roundrect(w * 0.05, h * 0.15, w * 0.9, h * 0.7, rSize, rSize);
	c.fill();
	
	c.setFontColor(fontColor);
	c.setFontSize(Math.min(h * 0.7, w * 0.1));

	c.text(w * 0.5, h * 0.5, 0, 0, mainText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setStrokeColor(strokeColor2);
	c.begin();
	c.moveTo(w * 0.95 - 5, h * 0.5);
	c.arcTo(3, 3, 0, 1, 1, w * 0.95 - 8, h * 0.5 - 3);
	c.stroke();

	c.setFillColor(strokeColor2);
	c.begin();
	c.moveTo(w * 0.95 - 8, h * 0.5 - 4);
	c.lineTo(w * 0.95 - 6, h * 0.5 - 3);
	c.lineTo(w * 0.95 - 8, h * 0.5 - 2);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_URL, mxShapeIOS7URL);

//**********************************************************************************************************************************************************
//Action Dialog
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7Actiondialog(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7Actiondialog, mxShape);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7Actiondialog.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxIOS7C.MAIN_TEXT, 'Main Text');
	var subText = mxUtils.getValue(this.style, mxIOS7C.SUB_TEXT, 'Sub Text');
	var fontColor = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTCOLOR, '#666666');
	var fontSize = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTSIZE, '17');
	c.translate(x, y);
	this.background(c, x, y, w, h);
	
	c.setShadow(false);
	
	c.setFillColor('#e0e0e0');
	c.roundrect(w * 0.05, h * 0.1, w * 0.9, h * 0.35, w * 0.025, h * 0.05);
	c.fill();
	c.roundrect(w * 0.05, h * 0.55, w * 0.9, h * 0.35, w * 0.025, h * 0.05);
	c.fill();
	
	c.setFontStyle(mxConstants.FONT_BOLD);
	this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
	this.subText(c, x, y, w, h, subText, fontSize / 1.4, fontColor);
};

mxShapeIOS7Actiondialog.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fill();
};

mxShapeIOS7Actiondialog.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w * 0.5, h * 0.4, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxShapeIOS7Actiondialog.prototype.subText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.text(w * 0.5, h * 0.7, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_ACTION_DIALOG, mxShapeIOS7Actiondialog);

//**********************************************************************************************************************************************************
//Anchor (a dummy shape without visuals used for anchoring)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7Anchor(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7Anchor, mxShape);

mxShapeIOS7Anchor.prototype.cst = {
		ANCHOR : 'mxgraph.ios7ui.anchor'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7Anchor.prototype.paintVertexShape = function(c, x, y, w, h)
{
};

mxCellRenderer.registerShape(mxShapeIOS7Anchor.prototype.cst.ANCHOR, mxShapeIOS7Anchor);

//**********************************************************************************************************************************************************
//Rounded rectangle (adjustable rounding)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7RRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7RRect, mxShape);

mxShapeIOS7RRect.prototype.cst = {
		RRECT : 'mxgraph.ios7ui.rrect',
		R_SIZE : 'rSize'
};

mxShapeIOS7RRect.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:3}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7RRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeIOS7RRect.prototype.cst.R_SIZE, '10'));
	c.roundrect(0, 0, w, h, rSize);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeIOS7RRect.prototype.cst.RRECT, mxShapeIOS7RRect);

//**********************************************************************************************************************************************************
//Left Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7LeftButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7LeftButton, mxShape);

mxShapeIOS7LeftButton.prototype.cst = {
		LEFT_BUTTON : 'mxgraph.ios7ui.leftButton',
		R_SIZE : 'rSize'
};

mxShapeIOS7LeftButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:3}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7LeftButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeIOS7LeftButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.lineTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeIOS7LeftButton.prototype.cst.LEFT_BUTTON, mxShapeIOS7LeftButton);

//**********************************************************************************************************************************************************
//Right Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7RightButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7RightButton, mxShape);

mxShapeIOS7RightButton.prototype.cst = {
		RIGHT_BUTTON : 'mxgraph.ios7ui.rightButton',
		R_SIZE : 'rSize'
};

mxShapeIOS7RightButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:3}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7RightButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeIOS7RightButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeIOS7RightButton.prototype.cst.RIGHT_BUTTON, mxShapeIOS7RightButton);

//**********************************************************************************************************************************************************
//Top Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7TopButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7TopButton, mxShape);

mxShapeIOS7TopButton.prototype.cst = {
		TOP_BUTTON : 'mxgraph.ios7ui.topButton',
		R_SIZE : 'rSize'
};

mxShapeIOS7TopButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:3}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7TopButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeIOS7TopButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(w, h);
	c.lineTo(0, h);
	c.lineTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeIOS7TopButton.prototype.cst.TOP_BUTTON, mxShapeIOS7TopButton);

//**********************************************************************************************************************************************************
//Bottom Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7BottomButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7BottomButton, mxShape);

mxShapeIOS7BottomButton.prototype.cst = {
		BOTTOM_BUTTON : 'mxgraph.ios7ui.bottomButton',
		R_SIZE : 'rSize'
};

mxShapeIOS7BottomButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:3},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7BottomButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeIOS7BottomButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(w, 0);
	c.lineTo(0, 0);
	c.lineTo(0, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 0, rSize, h);
	c.lineTo(w - rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 0, w, h - rSize);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeIOS7BottomButton.prototype.cst.BOTTOM_BUTTON, mxShapeIOS7BottomButton);

//**********************************************************************************************************************************************************
//Horizontal Lines
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7HorLines(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7HorLines, mxShape);

mxShapeIOS7HorLines.prototype.cst = {
		HOR_LINES : 'mxgraph.ios7ui.horLines'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7HorLines.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.rect(0, 0, w, h);
	c.fill();
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.moveTo(0, h);
	c.lineTo(w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeIOS7HorLines.prototype.cst.HOR_LINES, mxShapeIOS7HorLines);

//**********************************************************************************************************************************************************
//rect with margins
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7MarginRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7MarginRect, mxShape);

mxShapeIOS7MarginRect.prototype.customProperties = [
	{name: 'rx', dispName: 'Hor. Rounding Size', type: 'float', min:0, defVal:3},
	{name: 'ry', dispName: 'Ver. Rounding Size', type: 'float', min:0, defVal:3},
	{name: 'rectMargin', dispName: 'Global Margin', type: 'float', min:0, defVal:5},
	{name: 'rectMarginTop', dispName: 'Top Margin', type: 'float', min:0, defVal:0},
	{name: 'rectMarginLeft', dispName: 'Left Margin', type: 'float', min:0, defVal:0},
	{name: 'rectMarginBottom', dispName: 'Bottom Margin', type: 'float', min:0, defVal:0},
	{name: 'rectMarginRight', dispName: 'Right Margin', type: 'float', min:0, defVal:0}
];

mxShapeIOS7MarginRect.prototype.cst = {
		SHAPE_MARGIN_RECT : 'mxgraph.ios7ui.marginRect',
		MARGIN : 'rectMargin',
		RX : 'rx',
		RY : 'ry',
		MARGIN_TOP : 'rectMarginTop',
		MARGIN_LEFT : 'rectMarginLeft',
		MARGIN_BOTTOM : 'rectMarginBottom',
		MARGIN_RIGHT : 'rectMarginRight'
};
/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7MarginRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxShapeIOS7MarginRect.prototype.background = function(c, x, y, w, h, state)
{
	var margin = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7MarginRect.prototype.cst.MARGIN, '0'));
	var marginTop = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7MarginRect.prototype.cst.MARGIN_TOP, '0'));
	var marginLeft = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7MarginRect.prototype.cst.MARGIN_LEFT, '0'));
	var marginBottom = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7MarginRect.prototype.cst.MARGIN_BOTTOM, '0'));
	var marginRight = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7MarginRect.prototype.cst.MARGIN_RIGHT, '0'));
	var rx = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7MarginRect.prototype.cst.RX, '0'));
	var ry = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7MarginRect.prototype.cst.RY, '0'));

	var x1 = margin + marginLeft;
	var y1 = margin + marginTop;
	var w1 = w - marginRight - x1 - margin;
	var h1 = h - marginBottom - y1 - margin;

	if (w1 >0 && h1 > 0)
	{
		c.begin();
		c.roundrect(x1, y1, w1, h1, rx, ry);
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeIOS7MarginRect.prototype.cst.SHAPE_MARGIN_RECT, mxShapeIOS7MarginRect);

//**********************************************************************************************************************************************************
//Callout
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7Callout(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7Callout, mxShape);

mxShapeIOS7Callout.prototype.cst = {
		SHAPE_CALLOUT : 'mxgraph.ios7ui.callout'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7Callout.prototype.paintVertexShape = function(c, x, y, w, h)
{
	
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxShapeIOS7Callout.prototype.background = function(c, x, y, w, h, state)
{
	var r = 10;
	
	if (w >= 30 && h >= 20)
	{
		c.begin();
		c.moveTo(15, h - r * 0.3);
		c.arcTo(r * 2, r, 0, 0, 1, 0, h);
		c.arcTo(r * 1.5, r * 1.5, 0, 0, 0, 10, h - r * 1);
		c.lineTo(r, r);
		c.arcTo(r, r, 0, 0, 1, r * 2, 0);
		c.lineTo(w - r, 0);
		c.arcTo(r, r, 0, 0, 1, w, r);
		c.lineTo(w, h - r);
		c.arcTo(r, r, 0, 0, 1, w - r, h);
		c.lineTo(r * 2, h);
		c.arcTo(r, r, 0, 0, 1, r * 1.5, h - r * 0.3);
		c.close();
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeIOS7Callout.prototype.cst.SHAPE_CALLOUT, mxShapeIOS7Callout);

//**********************************************************************************************************************************************************
//Select Bar
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIOS7SelectBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.dy = 0.5;
	this.dx = 0.5;
	this.dx2 = 70;
	this.size = 10;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7SelectBar, mxActor);

mxShapeIOS7SelectBar.prototype.cst = {
		SELECT_BAR : 'mxgraph.ios7ui.selectBar'
};

mxShapeIOS7SelectBar.prototype.customProperties = [
	{name: 'dx', dispName: 'Callout Position', type: 'float', min:0, defVal:120},
	{name: 'dx2', dispName: 'Field Size', type: 'float', min:0, defVal: 75},
	{name: 'size', dispName: 'Rounding size', type: 'float', min:0, defVal:5},
	{name: 'dy', dispName: 'Callout Size', type: 'float', min:0, defVal:5}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7SelectBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
	var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, 'dx2', this.dx2))));
	var r = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
	var dy = Math.max(0, Math.min(h, (w - Math.max(20, r) - r) / 2, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));

	r = Math.min(h / 2, w / 2, r);
	dx = Math.max(r + dy, dx);
	dx = Math.min(w - r - dy, w - 20 - dy, dx);
	
	c.begin();
	c.moveTo(dx - dy, h);
	c.lineTo(r, h);
	c.arcTo(r, r, 0, 0, 1, 0, h - r);
	c.lineTo(0, r);
	c.arcTo(r, r, 0, 0, 1, r, 0);
	c.lineTo(w - r, 0);
	c.arcTo(r, r, 0, 0, 1, w, r);
	c.lineTo(w, h - r);
	c.arcTo(r, r, 0, 0, 1, w - r, h);
	c.lineTo(dx + dy, h);
	c.lineTo(dx, h + dy);
	c.close();
	c.fillAndStroke();
	
	c.setShadow(false);
	
	c.begin();
	c.moveTo(w - Math.max(20, r), 0);
	c.lineTo(w - Math.max(20, r), h);
	c.stroke();

	var currDx = dx2;
	
	c.begin();
	
	while (currDx < (w - Math.max(20, r)))
	{
		c.moveTo(currDx, 0);
		c.lineTo(currDx, h);
		
		currDx = currDx + dx2;
	}
	
	c.stroke();
	
	var w1 = Math.min(Math.max(20, r), h);
	var x1 = w - w1 * 0.5;
	var y1 = h * 0.5;
	
	c.setFillColor(mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, ''));
	c.begin();
	c.moveTo(x1 - w1 * 0.15, y1 - w1 * 0.225);
	c.lineTo(x1 + w1 * 0.25, y1);
	c.lineTo(x1 - w1 * 0.15, y1 + w1 * 0.225);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeIOS7SelectBar.prototype.cst.SELECT_BAR, mxShapeIOS7SelectBar);

mxShapeIOS7SelectBar.prototype.constraints = null;

Graph.handleFactory[mxShapeIOS7SelectBar.prototype.cst.SELECT_BAR] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx'], function(bounds)
			{
				var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

				return new mxPoint(bounds.x + dx, bounds.y + bounds.height);
			}, function(bounds, pt)
			{
				var y = parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy)) * 0.6;
				this.state.style['dx'] = Math.round(100 * Math.max(y, Math.min(bounds.width - y, pt.x - bounds.x))) / 100;
			})];

	var handle2 = Graph.createHandle(state, ['dy'], function(bounds)
			{
				var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'dy', this.dy))));

				return new mxPoint(bounds.x + parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx)), bounds.y + bounds.height + dy);
			}, function(bounds, pt)
			{
				this.state.style['dy'] = Math.round(100 * Math.max(0, Math.min(bounds.height, pt.y - bounds.y - bounds.height))) / 100;
			});

	handles.push(handle2);

	var handle3 = Graph.createHandle(state, ['size'], function(bounds)
			{
				var size = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'size', this.size))));

				return new mxPoint(bounds.x + bounds.width - size, bounds.y + 10);
			}, function(bounds, pt)
			{
				this.state.style['size'] = Math.round(100 * Math.max(0, Math.min(bounds.width / 2, bounds.height / 2, bounds.x + bounds.width - pt.x))) / 100;
			});
	
	handles.push(handle3);

	var handle4 = Graph.createHandle(state, ['dx2'], function(bounds)
			{
				var dx2 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx2', this.dx2))));

				return new mxPoint(bounds.x + dx2, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['dx2'] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
			});

	handles.push(handle4);

	return handles;

}

//**********************************************************************************************************************************************************
//slider
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
//mxShapeIOS7SelectBar
function mxShapeIOS7Slider2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIOS7Slider2, mxShape);

mxShapeIOS7Slider2.prototype.cst = {
		SHAPE_SLIDER : 'mxgraph.ios7ui.slider',
		BAR_POS : 'barPos',
		HANDLE_SIZE : 'handleSize'
};

mxShapeIOS7Slider2.prototype.customProperties = [
	{name: 'barPos', dispName: 'Handle Position', type: 'float', min:0, max:1, defVal:20},
	{name: 'handleSize', dispName: 'Handle Size', type: 'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIOS7Slider2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(true);
};

mxShapeIOS7Slider2.prototype.background = function(c, x, y, w, h)
{
	var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7Slider2.prototype.cst.HANDLE_SIZE, '10'));
	var barPos = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7Slider2.prototype.cst.BAR_POS, '40')) / 100;

	barPos = Math.max(0, Math.min(1, barPos));

	c.save();
	c.setStrokeColor('#bbbbbb');
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.fillAndStroke();
	

	c.restore();
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(barPos * w, h * 0.5);
	c.fillAndStroke();
	
	c.setStrokeColor('#bbbbbb');
	c.begin();
	c.ellipse(barPos * w - hSize * 0.5, h * 0.5 - hSize * 0.5, hSize, hSize);
	c.fillAndStroke();

};

mxCellRenderer.registerShape(mxShapeIOS7Slider2.prototype.cst.SHAPE_SLIDER, mxShapeIOS7Slider2);

mxShapeIOS7Slider2.prototype.constraints = null;

Graph.handleFactory[mxShapeIOS7Slider2.prototype.cst.SHAPE_SLIDER] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'barPos', 0.4))));

				return new mxPoint(bounds.x + barPos * bounds.width / 100, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100;
			})];
			
	return handles;
};


/**
 * $Id: mxMockupButtons.js,v 1.8 2013/05/16 06:09:21 mate Exp $
 * Copyright (c) 2006-2010, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Multiline Button
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupMultiButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupMultiButton, mxShape);

mxShapeMockupMultiButton.prototype.cst = {
		MAIN_TEXT : 'mainText',
		SHAPE_MULTILINE_BUTTON : 'mxgraph.mockup.buttons.multiButton',
		SUB_TEXT : 'subText',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize',
		BUTTON_STYLE : 'buttonStyle',
		ROUND : 'round',
		CHEVRON : 'chevron'
};

mxShapeMockupMultiButton.prototype.customProperties = [
	{name: 'buttonStyle', dispName: 'Style', type: 'enum', defVal:'round',
		enumList: [{val: 'round', dispName: 'Round'}, {val: 'chevron', dispName: 'Chevron'}]
	}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupMultiButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxShapeMockupMultiButton.prototype.cst.MAIN_TEXT, 'Main Text');
	var subText = mxUtils.getValue(this.style, mxShapeMockupMultiButton.prototype.cst.SUB_TEXT, 'Sub Text');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupMultiButton.prototype.cst.TEXT_COLOR, '#666666');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupMultiButton.prototype.cst.TEXT_SIZE, '17');
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	c.setFontStyle(mxConstants.FONT_BOLD);
	this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
	this.subText(c, x, y, w, h, subText, fontSize / 1.4, fontColor);
};

mxShapeMockupMultiButton.prototype.background = function(c, x, y, w, h)
{
	var buttonStyle = mxUtils.getValue(this.style, mxShapeMockupMultiButton.prototype.cst.BUTTON_STYLE, mxShapeMockupMultiButton.prototype.cst.ROUND).toString();
	var rSize = 10;
	c.begin();

	if (buttonStyle === mxShapeMockupMultiButton.prototype.cst.ROUND)
	{
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(w - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
		c.lineTo(w, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	}
	else if (buttonStyle === mxShapeMockupMultiButton.prototype.cst.CHEVRON)
	{
		c.moveTo(0, h * 0.1);
		c.arcTo(w * 0.0372, h * 0.1111, 0, 0, 1, w * 0.0334, 0);
		c.lineTo(w * 0.768, 0);
		c.arcTo(w * 0.0722, h * 0.216, 0, 0, 1, w * 0.8014, h * 0.0399);
		c.lineTo(w * 0.99, h * 0.4585);
		c.arcTo(w * 0.09, h * 0.1, 0, 0, 1, w * 0.99, h * 0.5415);
		c.lineTo(w * 0.8014, h * 0.9568);
		c.arcTo(w * 0.0722, h * 0.216, 0, 0, 1, w * 0.768, h);
		c.lineTo(w * 0.0334, h);
		c.arcTo(w * 0.0372, h * 0.1111, 0, 0, 1, 0, h * 0.9);
	}

	c.close();	
	c.fillAndStroke();
};

mxShapeMockupMultiButton.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w * 0.5, h * 0.4, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxShapeMockupMultiButton.prototype.subText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.text(w * 0.5, h * 0.7, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeMockupMultiButton.prototype.cst.SHAPE_MULTILINE_BUTTON, mxShapeMockupMultiButton);

//**********************************************************************************************************************************************************
//Button
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupButton, mxShape);

mxShapeMockupButton.prototype.cst = {
		MAIN_TEXT : 'mainText',
		SHAPE_BUTTON : 'mxgraph.mockup.buttons.button',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize',
		BUTTON_STYLE : 'buttonStyle',
		ROUND : 'round',
		CHEVRON : 'chevron'
};

mxShapeMockupButton.prototype.customProperties = [
	{name: 'buttonStyle', dispName: 'Style', type: 'enum', defVal:'round', 
		enumList: [{val: 'round', dispName: 'Round'}, {val: 'chevron', dispName: 'Chevron'}]
	}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxShapeMockupButton.prototype.cst.MAIN_TEXT, 'Main Text');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupButton.prototype.cst.TEXT_COLOR, '#666666').toString();
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupButton.prototype.cst.TEXT_SIZE, '17').toString();
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
};

mxShapeMockupButton.prototype.background = function(c, x, y, w, h)
{
	var buttonStyle = mxUtils.getValue(this.style, mxShapeMockupButton.prototype.cst.BUTTON_STYLE, mxShapeMockupButton.prototype.cst.ROUND).toString();
	var rSize = 10;
	c.begin();

	if (buttonStyle === mxShapeMockupButton.prototype.cst.ROUND)
	{
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(w - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
		c.lineTo(w, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	}
	else if (buttonStyle === mxShapeMockupButton.prototype.cst.CHEVRON)
	{
		c.moveTo(0, h * 0.1);
		c.arcTo(w * 0.0372, h * 0.1111, 0, 0, 1, w * 0.0334, 0);
		c.lineTo(w * 0.768, 0);
		c.arcTo(w * 0.0722, h * 0.216, 0, 0, 1, w * 0.8014, h * 0.0399);
		c.lineTo(w * 0.99, h * 0.4585);
		c.arcTo(w * 0.09, h * 0.1, 0, 0, 1, w * 0.99, h * 0.5415);
		c.lineTo(w * 0.8014, h * 0.9568);
		c.arcTo(w * 0.0722, h * 0.216, 0, 0, 1, w * 0.768, h);
		c.lineTo(w * 0.0334, h);
		c.arcTo(w * 0.0372, h * 0.1111, 0, 0, 1, 0, h * 0.9);
	}

	c.close();	
	c.fillAndStroke();
};

mxShapeMockupButton.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.setFontStyle(mxConstants.FONT_BOLD);
	c.text(w / 2, h / 2, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeMockupButton.prototype.cst.SHAPE_BUTTON, mxShapeMockupButton);

//**********************************************************************************************************************************************************
//Horizontal Button Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupHorButtonBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupHorButtonBar, mxShape);

mxShapeMockupHorButtonBar.prototype.cst = {
		MAIN_TEXT : 'mainText',
		SHAPE_HOR_BUTTON_BAR : 'mxgraph.mockup.buttons.horButtonBar',
		TEXT_COLOR : 'textColor',
		TEXT_COLOR2 : 'textColor2',
		STROKE_COLOR2 : 'strokeColor2',
		FILL_COLOR2 : 'fillColor2',
		SELECTED : '+',			//must be 1 char
		TEXT_SIZE : 'textSize'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupHorButtonBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var textStrings = mxUtils.getValue(this.style, mxShapeMockupHorButtonBar.prototype.cst.MAIN_TEXT, '+Button 1, Button 2, Button 3').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupHorButtonBar.prototype.cst.TEXT_COLOR, '#666666');
	var selectedFontColor = mxUtils.getValue(this.style, mxShapeMockupHorButtonBar.prototype.cst.TEXT_COLOR2, '#ffffff');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupHorButtonBar.prototype.cst.TEXT_SIZE, '17').toString();
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var separatorColor = mxUtils.getValue(this.style, mxShapeMockupHorButtonBar.prototype.cst.STROKE_COLOR2, '#c4c4c4');
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var selectedFillColor = mxUtils.getValue(this.style, mxShapeMockupHorButtonBar.prototype.cst.FILL_COLOR2, '#008cff');
	var buttonNum = textStrings.length;
	var buttonWidths = new Array(buttonNum);
	var buttonTotalWidth = 0;
	var selectedButton = -1;
	var rSize = 10; //rounding size
	var labelOffset = 5;

	for (var i = 0; i < buttonNum; i++)
	{
		var buttonText = textStrings[i];

		if(buttonText.charAt(0) === mxShapeMockupHorButtonBar.prototype.cst.SELECTED)
		{
			buttonText = textStrings[i].substring(1);
			selectedButton = i;
		}

		buttonWidths[i] = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		buttonTotalWidth += buttonWidths[i];
	}

	var trueH = Math.max(h, fontSize * 1.5, 20);
	var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
	var trueW = Math.max(w, minW);

	c.translate(x, y);
	this.background(c, trueW, trueH, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton);
	c.setShadow(false);

	c.setFontStyle(mxConstants.FONT_BOLD);
	var currWidth = 0;

	for (var i = 0; i < buttonNum; i++)
	{
		if (i === selectedButton)
		{
			c.setFontColor(selectedFontColor);
		}
		else
		{
			c.setFontColor(fontColor);
		}

		currWidth = currWidth + labelOffset;
		this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
		currWidth = currWidth + buttonWidths[i] + labelOffset;
	}
};

mxShapeMockupHorButtonBar.prototype.background = function(c, w, h, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton)
{
	c.begin();

	//draw the frame
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();
	c.fillAndStroke();

	//draw the button separators
	c.setStrokeColor(separatorColor);
	c.begin();
	for (var i = 1; i < buttonNum; i++)
	{
		if (i !== selectedButton && i !== (selectedButton + 1))
		{
			var currWidth = 0;

			for (var j = 0; j < i; j++)
			{
				currWidth += buttonWidths[j] + 2 * labelOffset;
			}

			currWidth = currWidth * w / minW;
			c.moveTo(currWidth, 0);
			c.lineTo(currWidth, h);
		}
	}

	c.stroke();

	//draw the selected button
	var buttonLeft = 0;
	c.setFillColor(selectedFillColor);

	for (var i = 0; i < selectedButton; i++)
	{
		buttonLeft += buttonWidths[i] + 2 * labelOffset;
	}

	buttonLeft = buttonLeft * w / minW;
	var buttonRight = (buttonWidths[selectedButton] + 2 * labelOffset) * w / minW;
	buttonRight += buttonLeft;

	if (selectedButton === 0)
	{
		c.begin();
		// we draw a path for the first button
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(buttonRight, 0);
		c.lineTo(buttonRight, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
		c.close();
		c.fill();
	}
	else if (selectedButton === buttonNum - 1)
	{
		c.begin();
		// we draw a path for the last button
		c.moveTo(buttonLeft, 0);
		c.lineTo(buttonRight - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, buttonRight, rSize);
		c.lineTo(buttonRight, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, buttonRight - rSize, h);
		c.lineTo(buttonLeft, h);
		c.close();
		c.fill();
	}
	else if (selectedButton !== -1)
	{
		c.begin();
		// we draw a path rectangle for one of the buttons in the middle
		c.moveTo(buttonLeft, 0);
		c.lineTo(buttonRight, 0);
		c.lineTo(buttonRight, h);
		c.lineTo(buttonLeft, h);
		c.close();
		c.fill();
	}

	//draw the frame again, to achieve a nicer effect
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.begin();
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();
	c.stroke();
};

mxShapeMockupHorButtonBar.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW)
{
	if(textString.charAt(0) === mxShapeMockupHorButtonBar.prototype.cst.SELECTED)
	{
		textString = textString.substring(1);
	}

	c.begin();
	c.setFontSize(fontSize);
	c.text((w + buttonWidth * 0.5) * trueW / minW, h * 0.5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeMockupHorButtonBar.prototype.cst.SHAPE_HOR_BUTTON_BAR, mxShapeMockupHorButtonBar);

//**********************************************************************************************************************************************************
//Vertical Button Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupVerButtonBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupVerButtonBar, mxShape);

mxShapeMockupVerButtonBar.prototype.cst = {
		MAIN_TEXT : 'mainText',
		SHAPE_VER_BUTTON_BAR : 'mxgraph.mockup.buttons.verButtonBar',
		TEXT_COLOR : 'textColor',
		TEXT_COLOR2 : 'textColor2',
		STROKE_COLOR2 : 'strokeColor2',
		FILL_COLOR2 : 'fillColor2',
		SELECTED : '+',			//must be 1 char
		TEXT_SIZE : 'textSize'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupVerButtonBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var textStrings = mxUtils.getValue(this.style, mxShapeMockupVerButtonBar.prototype.cst.MAIN_TEXT, '+Button 1, Button 2, Button 3').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupVerButtonBar.prototype.cst.TEXT_COLOR, '#666666');
	var selectedFontColor = mxUtils.getValue(this.style, mxShapeMockupVerButtonBar.prototype.cst.TEXT_COLOR2, '#ffffff');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupVerButtonBar.prototype.cst.TEXT_SIZE, '17').toString();
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var separatorColor = mxUtils.getValue(this.style, mxShapeMockupVerButtonBar.prototype.cst.STROKE_COLOR2, '#c4c4c4');
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var selectedFillColor = mxUtils.getValue(this.style, mxShapeMockupVerButtonBar.prototype.cst.FILL_COLOR2, '#008cff');
	var buttonNum = textStrings.length;
	var maxButtonWidth = 0;
	var selectedButton = -1;
	var rSize = 10; //rounding size
	var labelOffset = 5;

	for (var i = 0; i < buttonNum; i++)
	{
		var buttonText = textStrings[i];

		if(buttonText.charAt(0) === mxShapeMockupVerButtonBar.prototype.cst.SELECTED)
		{
			buttonText = textStrings[i].substring(1);
			selectedButton = i;
		}

		var currWidth = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currWidth > maxButtonWidth)
		{
			maxButtonWidth = currWidth;
		}
	}

	var minButtonHeight =  fontSize * 1.5;
	var minH = buttonNum * minButtonHeight;
	var trueH = Math.max(h, minH);
	var minW = 2 * labelOffset + maxButtonWidth;
	var trueW = Math.max(w, minW);

	c.translate(x, y);

	this.background(c, trueW, trueH, rSize, buttonNum, labelOffset, buttonNum * minButtonHeight, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton, minButtonHeight);
	c.setShadow(false);

	var currWidth = 0;
	c.setFontStyle(mxConstants.FONT_BOLD);

	for (var i = 0; i < buttonNum; i++)
	{
		if (i === selectedButton)
		{
			c.setFontColor(selectedFontColor);
		}
		else
		{
			c.setFontColor(fontColor);
		}

		currWidth = currWidth + labelOffset;
		var currHeight = (i * minButtonHeight + minButtonHeight * 0.5) * trueH / minH;
		this.buttonText(c, trueW, currHeight, textStrings[i], fontSize);
	}
};

mxShapeMockupVerButtonBar.prototype.background = function(c, w, h, rSize, buttonNum, labelOffset, minH, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton, minButtonHeight)
{
	c.begin();

	//draw the frame
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();
	c.fillAndStroke();

	//draw the button separators
	c.setStrokeColor(separatorColor);
	c.begin();

	for (var i = 1; i < buttonNum; i++)
	{
		if (i !== selectedButton && i !== (selectedButton + 1))
		{
			var currHeight = i * minButtonHeight * h / minH;

			c.moveTo(0, currHeight);
			c.lineTo(w, currHeight);
		}
	}

	c.stroke();

	//draw the selected button
	c.setFillColor(selectedFillColor);

	if (selectedButton === 0)
	{
		// we draw a path for the first button
		c.begin();
		var buttonBottom = minButtonHeight * h / minH;
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(w - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
		c.lineTo(w, buttonBottom);
		c.lineTo(0, buttonBottom);
		c.close();
		c.fill();
	}
	else if (selectedButton === buttonNum - 1)
	{
		// we draw a path for the last button
		c.begin();
		var buttonTop = h - minButtonHeight * h / minH;
		c.moveTo(0, buttonTop);
		c.lineTo(w, buttonTop);
		c.lineTo(w, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
		c.close();
		c.fill();
	}
	else if (selectedButton !== -1)
	{
		// we draw a path rectangle for one of the buttons in the middle
		c.begin();
		var buttonTop = minButtonHeight * selectedButton * h / minH;
		var buttonBottom = minButtonHeight * (selectedButton + 1) * h / minH;
		c.moveTo(0, buttonTop);
		c.lineTo(w, buttonTop);
		c.lineTo(w, buttonBottom);
		c.lineTo(0, buttonBottom);
		c.close();
		c.fill();
	}

//	//draw the frame again, to achieve a nicer effect
	c.begin();
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();
	c.stroke();
};

mxShapeMockupVerButtonBar.prototype.buttonText = function(c, w, h, textString, fontSize)
{
	if(textString.charAt(0) === mxShapeMockupVerButtonBar.prototype.cst.SELECTED)
	{
		textString = textString.substring(1);
	}

	c.begin();
	c.setFontSize(fontSize);
	c.text((w * 0.5), h, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeMockupVerButtonBar.prototype.cst.SHAPE_VER_BUTTON_BAR, mxShapeMockupVerButtonBar);

//**********************************************************************************************************************************************************
//On-Off Button
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupOnOffButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupOnOffButton, mxShape);

mxShapeMockupOnOffButton.prototype.cst = {
		SHAPE_ON_OFF_BUTTON : 'mxgraph.mockup.buttons.onOffButton',
		BUTTON_STATE : 'buttonState',
		STATE_ON : 'on',
		STATE_OFF : 'off',
		FILL_COLOR2 : 'fillColor2',
		MAIN_TEXT : 'mainText',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize'
};

mxShapeMockupOnOffButton.prototype.customProperties = [
	{name: 'buttonState', dispName: 'Button State', type: 'enum',
		enumList: [{val: 'on', dispName: 'On'}, {val: 'off', dispName: 'Off'}]
	}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupOnOffButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	w = Math.max(w, 10);
	h = Math.max(h, 10);

	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupOnOffButton.prototype.background = function(c, x, y, w, h)
{
	c.roundrect(0, 0, w, h, 10, 10);
	c.fillAndStroke();

};

mxShapeMockupOnOffButton.prototype.foreground = function(c, x, y, w, h)
{
	var state = mxUtils.getValue(this.style, mxShapeMockupOnOffButton.prototype.cst.BUTTON_STATE, mxShapeMockupOnOffButton.prototype.cst.STATE_ON);
	var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupOnOffButton.prototype.cst.FILL_COLOR2, '#008cff');
	var textColor = mxUtils.getValue(this.style, mxShapeMockupOnOffButton.prototype.cst.TEXT_COLOR, '#ffffff,#999999').toString().split(',');
	var mainText = mxUtils.getValue(this.style, mxShapeMockupOnOffButton.prototype.cst.MAIN_TEXT, 'ON,OFF').toString().split(',');
	var textSize = mxUtils.getValue(this.style, mxShapeMockupOnOffButton.prototype.cst.TEXT_SIZE, '17');

	if (state === mxShapeMockupOnOffButton.prototype.cst.STATE_ON)
	{
		c.setFillColor(fillColor2);
		c.setFontColor(textColor[0]);
		c.roundrect(0, 0, w * 0.75, h, 10, 10);
	}
	else
	{
		c.setFontColor(textColor[1]);
		c.roundrect(w * 0.25, 0, w * 0.75, h, 10, 10);
	}

	c.fillAndStroke();
	c.setFontSize(textSize);
	c.setFontStyle(mxConstants.FONT_BOLD);

	if(state === mxShapeMockupOnOffButton.prototype.cst.STATE_ON)
	{
		c.text(w * 0.375, h * 0.5, 0, 0, mainText[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
	else if (state === mxShapeMockupOnOffButton.prototype.cst.STATE_OFF)
	{
		c.text(w * 0.625, h * 0.5, 0, 0, mainText[1], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
};

mxCellRenderer.registerShape(mxShapeMockupOnOffButton.prototype.cst.SHAPE_ON_OFF_BUTTON, mxShapeMockupOnOffButton);

//**********************************************************************************************************************************************************
//Rounded rectangle (adjustable rounding)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupRRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupRRect, mxShape);

mxShapeMockupRRect.prototype.cst = {
		RRECT : 'mxgraph.mockup.rrect',
		R_SIZE : 'rSize'
};

mxShapeMockupRRect.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupRRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupRRect.prototype.cst.R_SIZE, '10'));
	c.roundrect(0, 0, w, h, rSize);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupRRect.prototype.cst.RRECT, mxShapeMockupRRect);

//**********************************************************************************************************************************************************
//Anchor (a dummy shape without visuals used for anchoring)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupAnchor(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupAnchor, mxShape);

mxShapeMockupAnchor.prototype.cst = {
		ANCHOR : 'mxgraph.mockup.anchor'
};

mxShapeMockupAnchor.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupAnchor.prototype.paintVertexShape = function(c, x, y, w, h)
{
};

mxCellRenderer.registerShape(mxShapeMockupAnchor.prototype.cst.ANCHOR, mxShapeMockupAnchor);

//**********************************************************************************************************************************************************
//Top Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupTopButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupTopButton, mxShape);

mxShapeMockupTopButton.prototype.cst = {
		TOP_BUTTON : 'mxgraph.mockup.topButton',
		R_SIZE : 'rSize'
};

mxShapeMockupTopButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupTopButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupTopButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupTopButton.prototype.cst.TOP_BUTTON, mxShapeMockupTopButton);

//**********************************************************************************************************************************************************
//Bottom Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupBottomButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupBottomButton, mxShape);

mxShapeMockupBottomButton.prototype.cst = {
		BOTTOM_BUTTON : 'mxgraph.mockup.bottomButton',
		R_SIZE : 'rSize'
};

mxShapeMockupBottomButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupBottomButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupBottomButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupBottomButton.prototype.cst.BOTTOM_BUTTON, mxShapeMockupBottomButton);

//**********************************************************************************************************************************************************
//Right Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupRightButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupRightButton, mxShape);

mxShapeMockupRightButton.prototype.cst = {
		RIGHT_BUTTON : 'mxgraph.mockup.rightButton',
		R_SIZE : 'rSize'
};

mxShapeMockupRightButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupRightButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupRightButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupRightButton.prototype.cst.RIGHT_BUTTON, mxShapeMockupRightButton);

//**********************************************************************************************************************************************************
//Left Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupLeftButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupLeftButton, mxShape);

mxShapeMockupLeftButton.prototype.cst = {
		LEFT_BUTTON : 'mxgraph.mockup.leftButton',
		R_SIZE : 'rSize'
};

mxShapeMockupLeftButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupLeftButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupLeftButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.lineTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupLeftButton.prototype.cst.LEFT_BUTTON, mxShapeMockupLeftButton);


/**
 * $Id: mxMockupContainers.js,v 1.10 2013/07/09 11:19:51 mate Exp $
 * Copyright (c) 2006-2010, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Video Player
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupVideoPlayer(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.barPos = 20;
	this.barHeight = 30;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupVideoPlayer, mxShape);

mxShapeMockupVideoPlayer.prototype.cst = {
		FILL_COLOR2 : 'fillColor2',
		TEXT_COLOR : 'textColor',
		STROKE_COLOR2 : 'strokeColor2',
		STROKE_COLOR3 : 'strokeColor3',
		SHAPE_VIDEO_PLAYER : 'mxgraph.mockup.containers.videoPlayer',
		BAR_POS : 'barPos',
		BAR_HEIGHT : 'barHeight'
};

mxShapeMockupVideoPlayer.prototype.customProperties = [
	{name: 'fillColor2', dispName: 'Fill2 Color', type: 'color'},
	{name: 'textColor', dispName: 'Text Color', type: 'color'},
	{name: 'strokeColor2', dispName: 'Stroke2 Color', type: 'color'},
	{name: 'strokeColor3', dispName: 'Stroke3 Color', type: 'color'},
	{name: 'barPos', dispName: 'Handle Position', type: 'float', min:0, max:100, defVal:20},
	{name: 'barHeight', dispName: 'Video Bar Height', type: 'float', min:0, defVal:30} 
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupVideoPlayer.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var buttonColor = mxUtils.getValue(this.style, mxShapeMockupVideoPlayer.prototype.cst.FILL_COLOR2, '#c4c4c4');
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var filledColor = mxUtils.getValue(this.style, mxShapeMockupVideoPlayer.prototype.cst.STROKE_COLOR2, '#008cff');
	var emptyColor = mxUtils.getValue(this.style, mxShapeMockupVideoPlayer.prototype.cst.STROKE_COLOR3, '#c4c4c4');
	var barHeight = mxUtils.getValue(this.style, mxShapeMockupVideoPlayer.prototype.cst.BAR_HEIGHT, '30');

	w = Math.max(w, 5 * barHeight);
	h = Math.max(h, barHeight + 10);

	c.translate(x, y);
	this.background(c, x, y, w, h, bgColor, frameColor);
	c.setShadow(false);
	this.otherShapes(c, x, y, w, h, buttonColor, frameColor, filledColor, emptyColor, barHeight);
};

mxShapeMockupVideoPlayer.prototype.background = function(c, x, y, w, h, bgColor, frameColor)
{
	c.setFillColor(bgColor);
	c.setStrokeColor(frameColor);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();	
	c.fillAndStroke();
};

mxShapeMockupVideoPlayer.prototype.otherShapes = function(c, x, y, w, h, buttonColor, frameColor, filledColor, emptyColor, barHeight)
{
	var barPos = mxUtils.getValue(this.style, mxShapeMockupVideoPlayer.prototype.cst.BAR_POS, '20');
	barPos = Math.max(0, barPos);
	barPos = Math.min(100, barPos);

	var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '1');
	var buttonR = 8;
	var barY = h - barHeight;

	var barMin = buttonR;
	var barMax = w - buttonR;
	var barRange = barMax - barMin;
	var realBarPos = barRange * barPos / 100;
	var barEnd = barMin + realBarPos;

	//progress bar
	c.setStrokeColor(filledColor);
	c.begin();
	c.moveTo(0, barY);
	c.lineTo(barEnd, barY);
	c.stroke();
	c.setStrokeColor(emptyColor);
	c.begin();
	c.moveTo(barEnd, barY);
	c.lineTo(w, barY);
	c.stroke();

	//progress bar button
	c.setStrokeColor(frameColor);
	c.begin();
	c.ellipse(barEnd - buttonR, barY - buttonR, 2 * buttonR, 2 * buttonR);
	c.fillAndStroke();

	c.begin();
	c.setStrokeWidth(strokeWidth / 2);
	c.ellipse(barEnd - buttonR * 0.5, barY - buttonR * 0.5, buttonR, buttonR);
	c.fillAndStroke();
	c.setStrokeWidth(strokeWidth);

	var iconSize = barHeight * 0.3;
	var iconY = h - (barHeight + iconSize) * 0.5;
	var iconX = barHeight * 0.3;
	c.setFillColor(buttonColor);
	c.setStrokeColor(buttonColor);

	//play icon
	c.begin();
	c.moveTo(iconX, iconY);
	c.lineTo(iconX + iconSize, iconY + iconSize * 0.5);
	c.lineTo(iconX, iconY + iconSize);
	c.close();
	c.fillAndStroke();

	//volume icon
	var speakerX = barHeight;
	var speakerY = h - barHeight;
	c.moveTo(speakerX + barHeight * 0.05, speakerY + barHeight * 0.4);
	c.lineTo(speakerX + barHeight * 0.15, speakerY + barHeight * 0.4);
	c.lineTo(speakerX + barHeight * 0.3, speakerY + barHeight * 0.25);
	c.lineTo(speakerX + barHeight * 0.3, speakerY + barHeight * 0.75);
	c.lineTo(speakerX + barHeight * 0.15, speakerY + barHeight * 0.6);
	c.lineTo(speakerX + barHeight * 0.05, speakerY + barHeight * 0.6);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(speakerX + barHeight * 0.4, speakerY + barHeight * 0.35);
	c.arcTo(barHeight * 0.2, barHeight * 0.3, 0, 0, 1, speakerX + barHeight * 0.4, speakerY + barHeight * 0.65);
	c.moveTo(speakerX + barHeight * 0.425, speakerY + barHeight * 0.25);
	c.arcTo(barHeight * 0.225, barHeight * 0.35, 0, 0, 1, speakerX + barHeight * 0.425, speakerY + barHeight * 0.75);
	c.stroke();

	//fullscreen button
	var screenX = w - barHeight * 1.3;
	c.begin();
	c.moveTo(screenX + barHeight * 0.1, speakerY + barHeight * 0.4);
	c.lineTo(screenX + barHeight * 0.1, speakerY + barHeight * 0.3);
	c.lineTo(screenX + barHeight * 0.25, speakerY + barHeight * 0.3);

	c.moveTo(screenX + barHeight * 0.1, speakerY + barHeight * 0.6);
	c.lineTo(screenX + barHeight * 0.1, speakerY + barHeight * 0.7);
	c.lineTo(screenX + barHeight * 0.25, speakerY + barHeight * 0.7);

	c.moveTo(screenX + barHeight * 0.9, speakerY + barHeight * 0.4);
	c.lineTo(screenX + barHeight * 0.9, speakerY + barHeight * 0.3);
	c.lineTo(screenX + barHeight * 0.75, speakerY + barHeight * 0.3);

	c.moveTo(screenX + barHeight * 0.9, speakerY + barHeight * 0.6);
	c.lineTo(screenX + barHeight * 0.9, speakerY + barHeight * 0.7);
	c.lineTo(screenX + barHeight * 0.75, speakerY + barHeight * 0.7);
	c.stroke();

	var textColor = mxUtils.getValue(this.style, mxShapeMockupVideoPlayer.prototype.cst.TEXT_COLOR, '#666666');
	c.begin();
	c.setFontSize(barHeight * 0.5);
	c.setFontColor(textColor);
	c.text(barHeight * 1.9, h - barHeight * 0.45, 0, 0, '0:00/3:53', mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeMockupVideoPlayer.prototype.cst.SHAPE_VIDEO_PLAYER, mxShapeMockupVideoPlayer);

Graph.handleFactory[mxShapeMockupVideoPlayer.prototype.cst.SHAPE_VIDEO_PLAYER] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'barPos', this.barPos))));

				var barH = parseFloat(mxUtils.getValue(this.state.style, 'barHeight', this.barHeight));

				return new mxPoint(bounds.x + ((bounds.width - 16) * barPos / bounds.width) / 100 * bounds.width + 8, bounds.y + bounds.height - barH - 20);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(1000 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 1000;
			})];

	var handle2 = Graph.createHandle(state, ['barHeight'], function(bounds)
			{
				var barHeight = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, 'barHeight', this.barHeight))));

				return new mxPoint(bounds.x + bounds.width - 20, bounds.y + bounds.height - barHeight);
			}, function(bounds, pt)
			{
				this.state.style['barHeight'] = Math.round(1000 * Math.max(0, Math.min(bounds.height, bounds.y + bounds.height - pt.y))) / 1000;
			});
	
	handles.push(handle2);

	return handles;
}

//**********************************************************************************************************************************************************
//Accordion (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupAccordion(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupAccordion, mxShape);

mxShapeMockupAccordion.prototype.cst = {
		TEXT_COLOR : 'textColor',
		TEXT_COLOR2 : 'textColor2',
		TEXT_SIZE : 'textSize',
		SHAPE_ACCORDION : 'mxgraph.mockup.containers.accordion',
		STROKE_COLOR2 : 'strokeColor2',
		FILL_COLOR2 : 'fillColor2',
		SELECTED : '+',			// must be 1 char
		MAIN_TEXT : 'mainText'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupAccordion.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var textStrings = mxUtils.getValue(this.style, mxShapeMockupAccordion.prototype.cst.MAIN_TEXT, '+Group 1, Group 2, Group 3').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupAccordion.prototype.cst.TEXT_COLOR, '#666666');
	var selectedFontColor = mxUtils.getValue(this.style, mxShapeMockupAccordion.prototype.cst.TEXT_COLOR2, '#ffffff');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupAccordion.prototype.cst.TEXT_SIZE, '17').toString();
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var separatorColor = mxUtils.getValue(this.style, mxShapeMockupAccordion.prototype.cst.STROKE_COLOR2, '#c4c4c4');
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var selectedFillColor = mxUtils.getValue(this.style, mxShapeMockupAccordion.prototype.cst.FILL_COLOR2, '#008cff');
	var buttonNum = textStrings.length;
	var maxButtonWidth = 0;
	var selectedButton = -1;
	var rSize = 10; //rounding size
	var labelOffset = 5;

	for (var i = 0; i < buttonNum; i++)
	{
		var buttonText = textStrings[i];

		if(buttonText.charAt(0) === mxShapeMockupAccordion.prototype.cst.SELECTED)
		{
			buttonText = textStrings[i].substring(1);
			selectedButton = i;
		}

		var currWidth = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currWidth > maxButtonWidth)
		{
			maxButtonWidth = currWidth;
		}
	}

	var minButtonHeight =  fontSize * 1.5;
	var minH = buttonNum * minButtonHeight;
	var trueH = Math.max(h, minH);
	var minW = 2 * labelOffset + maxButtonWidth;
	var trueW = Math.max(w, minW);

	c.translate(x, y);

	this.background(c, trueW, trueH, rSize, buttonNum, labelOffset, buttonNum * minButtonHeight, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton, minButtonHeight);
	c.setShadow(false);

	var currWidth = 0;

	for (var i = 0; i < buttonNum; i++)
	{
		if (i === selectedButton)
		{
			c.setFontColor(selectedFontColor);
		}
		else
		{
			c.setFontColor(fontColor);
		}

		currWidth = currWidth + labelOffset;
		var currHeight = 0;

		if (selectedButton === -1 || i <= selectedButton)
		{	
			currHeight = (i * minButtonHeight + minButtonHeight * 0.5);
		}
		else
		{
			currHeight = trueH - (buttonNum - i - 0.5) * minButtonHeight;
		}

		this.buttonText(c, trueW, currHeight, textStrings[i], fontSize);
	}
};

mxShapeMockupAccordion.prototype.background = function(c, w, h, rSize, buttonNum, labelOffset, minH, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton, minButtonHeight)
{
	c.begin();

	//draw the frame
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();

	//draw the button separators
	c.setStrokeColor(separatorColor);
	c.begin();

	for (var i = 1; i < buttonNum; i++)
	{
		if (i !== selectedButton)
		{
			if (selectedButton === -1 || i < selectedButton)
			{
				var currHeight = i * minButtonHeight;
				c.moveTo(0, currHeight);
				c.lineTo(w, currHeight);
			}
			else
			{
				var currHeight = h - (buttonNum - i) * minButtonHeight;
				c.moveTo(0, currHeight);
				c.lineTo(w, currHeight);
			}
		}
	}

	c.stroke();

	//draw the selected button
	c.setStrokeColor(mxConstants.NONE);
	c.setFillColor(selectedFillColor);

	if (selectedButton !== -1)
	{
		c.begin();
		var buttonTop = minButtonHeight * selectedButton;
		var buttonBottom = minButtonHeight * (selectedButton + 1);
		c.moveTo(0, buttonTop);
		c.lineTo(w, buttonTop);
		c.lineTo(w, buttonBottom);
		c.lineTo(0, buttonBottom);
		c.close();
		c.fill();
	}

//	//draw the frame again, to achieve a nicer effect
	c.begin();
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.stroke();
};

mxShapeMockupAccordion.prototype.buttonText = function(c, w, h, textString, fontSize)
{
	if(textString.charAt(0) === mxShapeMockupAccordion.prototype.cst.SELECTED)
	{
		textString = textString.substring(1);
	}

	c.begin();
	c.setFontSize(fontSize);
	c.text((w * 0.5), h, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeMockupAccordion.prototype.cst.SHAPE_ACCORDION, mxShapeMockupAccordion);

//**********************************************************************************************************************************************************
//Browser Window
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupBrowserWindow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupBrowserWindow, mxShape);

mxShapeMockupBrowserWindow.prototype.cst = {
		STROKE_COLOR2 : 'strokeColor2',
		STROKE_COLOR3 : 'strokeColor3',
		MAIN_TEXT : 'mainText',
		SHAPE_BROWSER_WINDOW : 'mxgraph.mockup.containers.browserWindow'

};

mxShapeMockupBrowserWindow.prototype.customProperties = [
	{name: 'strokeColor2', dispName: 'Stroke2 Color', type: 'color'},
	{name: 'strokeColor3', dispName: 'Stroke3 Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupBrowserWindow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var closeColor = mxUtils.getValue(this.style, mxShapeMockupBrowserWindow.prototype.cst.STROKE_COLOR2, '#008cff');
	var insideColor = mxUtils.getValue(this.style, mxShapeMockupBrowserWindow.prototype.cst.STROKE_COLOR3, '#c4c4c4');
	w = Math.max(w, 260);
	h = Math.max(h, 110);
	c.translate(x, y);
	this.background(c, x, y, w, h, bgColor, frameColor);
	c.setShadow(false);
	this.otherShapes(c, x, y, w, h, frameColor, insideColor, closeColor);
};

mxShapeMockupBrowserWindow.prototype.background = function(c, x, y, w, h, bgColor, frameColor)
{
	c.setFillColor(bgColor);
	c.setStrokeColor(frameColor);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();	
	c.fillAndStroke();
};

mxShapeMockupBrowserWindow.prototype.otherShapes = function(c, x, y, w, h, frameColor, insideColor, closeColor)
{
	var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '1');
	var mainText = mxUtils.getValue(this.style, mxShapeMockupBrowserWindow.prototype.cst.MAIN_TEXT, 'http://www.draw.io,Page 1').toString().split(',');

	//window buttons
	c.setStrokeColor(frameColor);
	c.ellipse(w - 75, 5, 20, 20);
	c.stroke();

	c.ellipse(w - 50, 5, 20, 20);
	c.stroke();

	c.setStrokeColor(closeColor);
	c.ellipse(w - 25, 5, 20, 20);
	c.stroke();

	c.setStrokeColor(insideColor);
	//lines
	c.begin();
	c.moveTo(0, 40);
	c.lineTo(30, 40);
	c.lineTo(30, 15);
	c.arcTo(5, 5, 0, 0, 1, 35, 10);
	c.lineTo(170, 10);
	c.arcTo(5, 5, 0, 0, 1, 175, 15);
	c.lineTo(175, 40);
	c.lineTo(w, 40);
	c.stroke();

	c.begin();
	c.moveTo(0, 110);
	c.lineTo(w, 110);
	c.stroke();

	//address field
	c.begin();
	c.moveTo(100, 60);
	c.arcTo(5, 5, 0, 0, 1, 105, 55);
	c.lineTo(w - 15, 55);
	c.arcTo(5, 5, 0, 0, 1, w - 10, 60);
	c.lineTo(w - 10, 85);
	c.arcTo(5, 5, 0, 0, 1, w - 15, 90);
	c.lineTo(105, 90);
	c.arcTo(5, 5, 0, 0, 1, 100, 85);
	c.close();
	c.stroke();

	//text
	var textColor = mxUtils.getValue(this.style, mxShapeMockupBrowserWindow.prototype.cst.TEXT_COLOR, '#666666');
	c.setFontColor(textColor);
	c.setFontSize(17);
	c.text(65, 25, 0, 0, mainText[1], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(130, 73, 0, 0, mainText[0], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.stroke();

	//icon on tab
	c.translate(37, 17);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(11, 0);
	c.lineTo(15, 4);
	c.lineTo(15, 18);
	c.lineTo(0, 18);
	c.close();
	c.stroke();

	c.setStrokeWidth(strokeWidth * 0.5); //maybe because of this (read later)
	c.begin();
	c.moveTo(11, 0);
	c.lineTo(11, 4);
	c.lineTo(15, 5);
	c.stroke();

	//icon in address bar
	c.setStrokeWidth(strokeWidth * 2); // i'm not sure why i have to multiply here
	c.translate(70, 47);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(11, 0);
	c.lineTo(15, 4);
	c.lineTo(15, 18);
	c.lineTo(0, 18);
	c.close();
	c.stroke();

	c.setStrokeWidth(strokeWidth * 0.5);
	c.begin();
	c.moveTo(11, 0);
	c.lineTo(11, 4);
	c.lineTo(15, 5);
	c.stroke();

	//back
	var iSi = 20; //icon size
	c.setFillColor(insideColor);
	c.begin();
	c.setStrokeWidth(strokeWidth * 2); // i'm not sure why i have to multiply here
	c.translate(-95, 0);
	c.moveTo(0, iSi * 0.5);
	c.lineTo(iSi * 0.5, 0);
	c.lineTo(iSi * 0.5, iSi * 0.3);
	c.lineTo(iSi, iSi * 0.3);
	c.lineTo(iSi, iSi * 0.7);
	c.lineTo(iSi * 0.5, iSi * 0.7);
	c.lineTo(iSi * 0.5, iSi);
	c.close();
	c.fillAndStroke();

	//forward
	c.begin();
	c.translate(30, 0);
	c.moveTo(iSi, iSi * 0.5);
	c.lineTo(iSi * 0.5, 0);
	c.lineTo(iSi * 0.5, iSi * 0.3);
	c.lineTo(0, iSi * 0.3);
	c.lineTo(0, iSi * 0.7);
	c.lineTo(iSi * 0.5, iSi * 0.7);
	c.lineTo(iSi * 0.5, iSi);
	c.close();
	c.fillAndStroke();

	//refresh
	c.begin();
	c.translate(30, 0);
	c.moveTo(iSi * 0.78, iSi * 0.665);
	c.arcTo(iSi * 0.3, iSi * 0.3, 0, 1, 1, iSi * 0.675, iSi * 0.252);
	c.lineTo(iSi * 0.595, iSi * 0.325);
	c.lineTo(iSi * 0.99, iSi * 0.415);
	c.lineTo(iSi * 0.9, iSi * 0.04);
	c.lineTo(iSi * 0.815, iSi * 0.12);
	c.arcTo(iSi * 0.49, iSi * 0.49, 0, 1, 0, iSi * 0.92, iSi * 0.8);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupBrowserWindow.prototype.cst.SHAPE_BROWSER_WINDOW, mxShapeMockupBrowserWindow);

//**********************************************************************************************************************************************************
//User, Male
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupUserMale(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupUserMale, mxShape);

mxShapeMockupUserMale.prototype.cst = {
		STROKE_COLOR2 : 'strokeColor2',
		SHAPE_MALE_USER : 'mxgraph.mockup.containers.userMale'
};

mxShapeMockupUserMale.prototype.customProperties = [
	{name: 'strokeColor2', dispName: 'Stroke2 Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupUserMale.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var insideColor = mxUtils.getValue(this.style, mxShapeMockupUserMale.prototype.cst.STROKE_COLOR2, '#008cff');
	c.translate(x, y);
	this.background(c, x, y, w, h, bgColor, frameColor);
	c.setShadow(false);
	this.otherShapes(c, x, y, w, h, insideColor, frameColor);
};

mxShapeMockupUserMale.prototype.background = function(c, x, y, w, h, bgColor, frameColor)
{
	c.setFillColor(bgColor);
	c.setStrokeColor(frameColor);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();	
	c.fillAndStroke();
};

mxShapeMockupUserMale.prototype.otherShapes = function(c, x, y, w, h, insideColor, frameColor)
{
	//head left
	c.setStrokeColor(insideColor);
	c.setLineCap('round');
	c.setLineJoin('round');
	c.begin();
	c.moveTo(w * 0.5, h * 0.6721);
	c.curveTo(w * 0.3891, h * 0.6721, w * 0.31, h * 0.5648, w * 0.31, h * 0.3962);
	c.curveTo(w * 0.31, h * 0.3656, w * 0.3012, h * 0.3473, w * 0.3051, h * 0.3227);
	c.curveTo(w * 0.3126, h * 0.2762, w * 0.3124, h * 0.2212, w * 0.332, h * 0.1939);
	c.curveTo(w * 0.354, h * 0.1633, w * 0.4382, h * 0.12, w * 0.5, h * 0.12);
	c.stroke();

	//left ear
	c.begin();
	c.moveTo(w * 0.3046, h * 0.3716);
	c.curveTo(w * 0.3046, h * 0.3716, w * 0.3046, h * 0.341, w * 0.2826, h * 0.3594);
	c.curveTo(w * 0.2606, h * 0.3778, w * 0.2661, h * 0.4452, w * 0.266, h * 0.4452);
	c.quadTo(w * 0.2715, h * 0.4942, w * 0.277, h * 0.5065);
	c.curveTo(w * 0.2825, h * 0.5187, w * 0.277, h * 0.5187, w * 0.2935, h * 0.5371);
	c.curveTo(w * 0.31, h * 0.5554, w * 0.3375, h * 0.5615, w * 0.3375, h * 0.5616);
	c.stroke();

	// left shoulder
	c.begin();
	c.moveTo(w * 0.3829, h * 0.6213);
	c.curveTo(w * 0.3829, h * 0.6213, w * 0.405, h * 0.7704, w * 0.2921, h * 0.7888);
	c.curveTo(w * 0.2536, h * 0.795, w * 0.1328, h * 0.85, w * 0.1052, h * 0.8745);
	c.curveTo(w * 0.0776, h * 0.899, w * 0.0641, h * 0.9316, w * 0.0571, h * 0.9622);
	c.quadTo(w * 0.05, h, w * 0.05, h);
	c.stroke();

	// left hairline
	c.begin();
	c.moveTo(w * 0.3427, h * 0.4185);
	c.curveTo(w * 0.3427, h * 0.4185, w * 0.3427, h * 0.3839, w * 0.3427, h * 0.3593);
	c.curveTo(w * 0.3427, h * 0.3348, w * 0.3663, h * 0.3103, w * 0.3718, h * 0.3041);
	c.curveTo(w * 0.3773, h * 0.298, w * 0.3822, h * 0.2673, w * 0.3877, h * 0.2551);
	c.curveTo(w * 0.3932, h * 0.2429, w * 0.4095, h * 0.2429, w * 0.4259, h * 0.2367);
	c.curveTo(w * 0.4424, h * 0.2306, w * 0.4984, h * 0.2357, w * 0.4984, h * 0.2357);
	c.stroke();

	//shirt
	c.begin();
	c.moveTo(w * 0.365, h * 0.7427);
	c.curveTo(w * 0.365, h * 0.7427, w * 0.3772, h * 0.8076, w * 0.4286, h * 0.8224);
	c.curveTo(w * 0.4816, h * 0.8377, w * 0.5028, h * 0.8347, w * 0.5028, h * 0.8347);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.3322, h * 0.7764);
	c.curveTo(w * 0.3322, h * 0.7764, w * 0.3556, h * 0.8386, w * 0.4038, h * 0.8684);
	c.curveTo(w * 0.4533, h * 0.8991, w * 0.5029, h * 0.8929, w * 0.5029, h * 0.8929);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.2717, h * 0.9);
	c.lineTo(w * 0.2717, h);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.1671, h * 0.8991);
	c.curveTo(w * 0.1671, h * 0.8991, w * 0.1726, h * 0.9114, w * 0.1836, h * 0.9481);
	c.curveTo(w * 0.1946, h * 0.9849, w * 0.2, h, w * 0.2, h);
	c.stroke();

	//head right
	c.begin();
	c.moveTo(w * 0.5, h * 0.6721);
	c.curveTo(w * 0.6109, h * 0.6721, w * 0.69, h * 0.5648, w * 0.69, h * 0.3962);
	c.curveTo(w * 0.69, h * 0.3656, w * 0.6988, h * 0.3473, w * 0.6949, h * 0.3227);
	c.curveTo(w * 0.6847, h * 0.2762, w * 0.6876, h * 0.2212, w * 0.668, h * 0.1939);
	c.curveTo(w * 0.646, h * 0.1633, w * 0.5618, h * 0.12, w * 0.5, h * 0.12);
	c.stroke();

	//right ear
	c.begin();
	c.moveTo(w * 0.6954, h * 0.3716);
	c.curveTo(w * 0.6954, h * 0.3716, w * 0.6954, h * 0.341, w * 0.7174, h * 0.3594);
	c.curveTo(w * 0.7394, h * 0.3778, w * 0.7339, h * 0.4452, w * 0.734, h * 0.4452);
	c.quadTo(w * 0.7285, h * 0.4942, w * 0.723, h * 0.5065);
	c.curveTo(w * 0.7175, h * 0.5187, w * 0.723, h * 0.5187, w * 0.7065, h * 0.5371);
	c.curveTo(w * 0.69, h * 0.5554, w * 0.6625, h * 0.5615, w * 0.6625, h * 0.5616);
	c.stroke();

	// right shoulder
	c.begin();
	c.moveTo(w * 0.6171, h * 0.6213);
	c.curveTo(w * 0.6171, h * 0.6213, w * 0.595, h * 0.7704, w * 0.7079, h * 0.7888);
	c.curveTo(w * 0.7464, h * 0.795, w * 0.8672, h * 0.85, w * 0.8948, h * 0.8745);
	c.curveTo(w * 0.9224, h * 0.899, w * 0.9359, h * 0.9316, w * 0.9429, h * 0.9622);
	c.quadTo(w * 0.95, h, w * 0.95, h);
	c.stroke();

	// right hairline
	c.begin();
	c.moveTo(w * 0.6573, h * 0.4185);
	c.curveTo(w * 0.6573, h * 0.4185, w * 0.6573, h * 0.3839, w * 0.6573, h * 0.3593);
	c.curveTo(w * 0.6573, h * 0.3348, w * 0.6337, h * 0.3103, w * 0.6282, h * 0.3041);
	c.curveTo(w * 0.6227, h * 0.298, w * 0.6178, h * 0.2673, w * 0.6123, h * 0.2551);
	c.curveTo(w * 0.6068, h * 0.2429, w * 0.5905, h * 0.2429, w * 0.5741, h * 0.2367);
	c.curveTo(w * 0.5576, h * 0.2306, w * 0.5016, h * 0.2357, w * 0.5016, h * 0.2357);
	c.stroke();

	//shirt, right
	c.begin();
	c.moveTo(w * 0.635, h * 0.7427);
	c.curveTo(w * 0.635, h * 0.7427, w * 0.6228, h * 0.8076, w * 0.5714, h * 0.8224);
	c.curveTo(w * 0.5184, h * 0.8377, w * 0.4972, h * 0.8347, w * 0.4972, h * 0.8347);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.6678, h * 0.7764);
	c.curveTo(w * 0.6678, h * 0.7764, w * 0.6444, h * 0.8386, w * 0.5962, h * 0.8684);
	c.curveTo(w * 0.5467, h * 0.8991, w * 0.4971, h * 0.8929, w * 0.4971, h * 0.8929);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.7283, h * 0.9);
	c.lineTo(w * 0.7283, h);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.8329, h * 0.8991);
	c.curveTo(w * 0.8329, h * 0.8991, w * 0.8274, h * 0.9114, w * 0.8164, h * 0.9481);
	c.curveTo(w * 0.8054, h * 0.9849, w * 0.8, h, w * 0.8, h);
	c.stroke();

	c.setStrokeColor(frameColor);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();	
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupUserMale.prototype.cst.SHAPE_MALE_USER, mxShapeMockupUserMale);

//**********************************************************************************************************************************************************
//User, Female
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupUserFemale(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupUserFemale, mxShape);

mxShapeMockupUserFemale.prototype.cst = {
		STROKE_COLOR2 : 'strokeColor2',
		SHAPE_FEMALE_USER : 'mxgraph.mockup.containers.userFemale'
};

mxShapeMockupUserFemale.prototype.customProperties = [
	{name: 'strokeColor2', dispName: 'Stroke2 Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupUserFemale.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var insideColor = mxUtils.getValue(this.style, mxShapeMockupUserFemale.prototype.cst.STROKE_COLOR2, '#008cff');
	c.translate(x, y);
	this.background(c, x, y, w, h, bgColor, frameColor);
	c.setShadow(false);
	this.otherShapes(c, x, y, w, h, insideColor, frameColor);
};

mxShapeMockupUserFemale.prototype.background = function(c, x, y, w, h, bgColor, frameColor)
{
	c.setFillColor(bgColor);
	c.setStrokeColor(frameColor);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();	
	c.fillAndStroke();
};

mxShapeMockupUserFemale.prototype.otherShapes = function(c, x, y, w, h, insideColor, frameColor)
{
	//head left
	c.setStrokeColor(insideColor);
	c.setLineCap('round');
	c.setLineJoin('round');
	c.begin();
	c.moveTo(w * 0.3148, h * 0.468);
	c.curveTo(w * 0.3045, h * 0.3195, w * 0.3176, h * 0.2383, w * 0.3302, h * 0.2069);
	c.curveTo(w * 0.3508, h * 0.1557, w * 0.44, h * 0.1156, w * 0.5026, h * 0.1156);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.5029, h * 0.6728);
	c.curveTo(w * 0.4616, h * 0.6728, w * 0.4018, h * 0.6177, w * 0.3663, h * 0.5653);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.3108, h * 0.4021);
	c.curveTo(w * 0.3108, h * 0.4021, w * 0.3091, h * 0.3765, w * 0.2891, h * 0.3933);
	c.curveTo(w * 0.2691, h * 0.4101, w * 0.2782, h * 0.4661, w * 0.2782, h * 0.4661);
	c.quadTo(w * 0.2862, h * 0.5067, w * 0.2922, h * 0.5166);
	c.curveTo(w * 0.2982, h * 0.5265, w * 0.2929, h * 0.5268, w * 0.3097, h * 0.5412);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.4038, h * 0.6176);
	c.curveTo(w * 0.4038, h * 0.6176, w * 0.4324, h * 0.7778, w * 0.3375, h * 0.7963);
	c.curveTo(w * 0.3054, h * 0.8026, w * 0.1753, h * 0.8578, w * 0.15, h * 0.8826);
	c.curveTo(w * 0.1247, h * 0.9074, w * 0.1126, h * 0.9412, w * 0.1063, h * 0.9722);
	c.curveTo(w * 0.10, h * 1.0032, w * 0.1, h, w * 0.1, h);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.6377, h * 0.3365);
	c.curveTo(w * 0.5927, h * 0.2634, w * 0.5206, h * 0.2634, w * 0.5206, h * 0.2634);
	c.quadTo(w * 0.3769, h * 0.2591, w * 0.3713, h * 0.2659);
	c.curveTo(w * 0.3657, h * 0.2727, w * 0.3405, h * 0.3674, w * 0.3405, h * 0.3946);
	c.curveTo(w * 0.3405, h * 0.4218, w * 0.3405, h * 0.4602, w * 0.3405, h * 0.4602);
	c.quadTo(w * 0.3546, h * 0.6401, w * 0.3546, h * 0.6626);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.2931, h * 0.818);
	c.curveTo(w * 0.2931, h * 0.818, w * 0.3224, h * 0.9159, w * 0.3826, h * 0.9677);
	c.curveTo(w * 0.4446, h * 1.01, w * 0.5065, h, w * 0.5065, h);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.2995, h * 0.9106);
	c.lineTo(w * 0.2995, h);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.2081, h * 0.907);
	c.curveTo(w * 0.2081, h * 0.907, w * 0.2131, h * 0.9194, w * 0.2232, h * 0.9565);
	c.curveTo(w * 0.2333, h * 0.9936, w * 0.24, h, w * 0.24, h);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.6951, h * 0.4988);
	c.curveTo(w * 0.6951, h * 0.4662, w * 0.7042, h * 0.3453, w * 0.7, h * 0.32);
	c.curveTo(w * 0.6923, h * 0.273, w * 0.6926, h * 0.2175, w * 0.6727, h * 0.19);
	c.curveTo(w * 0.6504, h * 0.159, w * 0.5651, h * 0.1157, w * 0.5025, h * 0.1157);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.5029, h * 0.6728);
	c.curveTo(w * 0.5546, h * 0.6728, w * 0.6107, h * 0.6316, w * 0.6461, h * 0.5602);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.696, h * 0.4022);
	c.curveTo(w * 0.696, h * 0.4022, w * 0.6983, h * 0.3766, w * 0.7179, h * 0.4106);
	c.curveTo(w * 0.7375, h * 0.4278, w * 0.7273, h * 0.4836, w * 0.7273, h * 0.4836);
	c.quadTo(w * 0.7184, h * 0.5241, w * 0.7123, h * 0.5338);
	c.curveTo(w * 0.7062, h * 0.5436, w * 0.7114, h * 0.544, w * 0.6943, h * 0.558);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.5995, h * 0.6278);
	c.curveTo(w * 0.5995, h * 0.6278, w * 0.5724, h * 0.7777, w * 0.6663, h * 0.7963);
	c.curveTo(w * 0.6984, h * 0.8026, w * 0.8386, h * 0.8578, w * 0.8638, h * 0.8826);
	c.curveTo(w * 0.8891, h * 0.9074, w * 0.9016, h * 0.9412, w * 0.9079, h * 0.9722);
	c.curveTo(w * 0.9142, h * 1.0032, w * 0.91, h, w * 0.91, h);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.6545, h * 0.6802);
	c.lineTo(w * 0.6545, h * 0.3986);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.7132, h * 0.8078);
	c.curveTo(w * 0.7132, h * 0.8078, w * 0.6839, h * 0.916, w * 0.6237, h * 0.9678);
	c.curveTo(w * 0.5617, h * 1.01, w * 0.4998, h, w * 0.4998, h);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.7111, h * 0.9106);
	c.lineTo(w * 0.7111, h);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.8075, h * 0.907);
	c.curveTo(w * 0.8075, h * 0.907, w * 0.8025, h * 0.9194, w * 0.7924, h * 0.9565);
	c.curveTo(w * 0.7823, h * 0.9936, w * 0.775, h, w * 0.775, h);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.3148, h * 0.5448);
	c.curveTo(w * 0.3148, h * 0.5448, w * 0.32, h * 0.6216, w * 0.3148, h * 0.6677);
	c.quadTo(w * 0.2891, h * 0.7343, w * 0.2891, h * 0.7343);
	c.lineTo(w * 0.3303, h * 0.7625);
	c.lineTo(w * 0.39, h * 0.7625);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.6852, h * 0.5448);
	c.curveTo(w * 0.6852, h * 0.5448, w * 0.68, h * 0.6216, w * 0.6852, h * 0.6677);
	c.quadTo(w * 0.7109, h * 0.7343, w * 0.7109, h * 0.7343);
	c.lineTo(w * 0.6697, h * 0.7625);
	c.lineTo(w * 0.62, h * 0.7625);
	c.stroke();

	c.setStrokeColor(frameColor);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();	
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupUserFemale.prototype.cst.SHAPE_FEMALE_USER, mxShapeMockupUserFemale);

//**********************************************************************************************************************************************************
//Group
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupGroup(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupGroup, mxShape);

mxShapeMockupGroup.prototype.cst = {
		MAIN_TEXT : 'mainText',
		TEXT_SIZE : 'textSize',
		TEXT_COLOR : 'textColor',
		FILL_COLOR2 : 'fillColor2',
		SHAPE_GROUP : 'mxgraph.mockup.containers.group'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupGroup.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var groupString = mxUtils.getValue(this.style, mxShapeMockupGroup.prototype.cst.MAIN_TEXT, 'Group').toString();
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupGroup.prototype.cst.TEXT_SIZE, '17');

	var textWidth = mxUtils.getSizeForString(groupString, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

	if (textWidth === 0)
	{
		textWidth = Math.max(80, textWidth);
	}

	c.translate(x, y);

	w = Math.max(w, textWidth + 15);
	h = Math.max(h, fontSize + 10);

	this.background(c, w, h, textWidth, fontSize);
	c.setShadow(false);
	this.foreground(c, w, h, textWidth, fontSize);
	this.buttonText(c, w, h, groupString, fontSize);
};

mxShapeMockupGroup.prototype.background = function(c, w, h, textWidth, fontSize)
{
	c.roundrect(0, fontSize * 0.5, w, h - fontSize * 0.5, 5, 5);
	c.fillAndStroke();
};

mxShapeMockupGroup.prototype.foreground = function(c, w, h, textWidth, fontSize)
{
	var fillColor = mxUtils.getValue(this.style, mxShapeMockupGroup.prototype.cst.FILL_COLOR2, '#000000');
	c.setFillColor(fillColor);
	c.roundrect(3, 0, textWidth + 6, fontSize * 1.5, fontSize * 0.25, fontSize * 0.25);
	c.fill();
};

mxShapeMockupGroup.prototype.buttonText = function(c, w, h, textString, fontSize)
{
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupGroup.prototype.cst.TEXT_COLOR, '#ffffff');

	c.setFontColor(fontColor);
	c.setFontSize(fontSize);
	c.text(6, 0, 0, 0, textString, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_TOP, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeMockupGroup.prototype.cst.SHAPE_GROUP, mxShapeMockupGroup);

//**********************************************************************************************************************************************************
//Window
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupWindow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupWindow, mxShape);

mxShapeMockupWindow.prototype.cst = {
		MAIN_TEXT : 'mainText',
		TEXT_SIZE : 'textSize',
		TEXT_COLOR : 'textColor',
		STROKE_COLOR2 : 'strokeColor2',
		STROKE_COLOR3 : 'strokeColor3',
		SHAPE_WINDOW : 'mxgraph.mockup.containers.window'
};

mxShapeMockupWindow.prototype.customProperties = [
	{name: 'strokeColor2', dispName: 'Stroke2 Color', type: 'color'},
	{name: 'strokeColor3', dispName: 'Stroke3 Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupWindow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var closeColor = mxUtils.getValue(this.style, mxShapeMockupWindow.prototype.cst.STROKE_COLOR2, '#008cff');
	var insideColor = mxUtils.getValue(this.style, mxShapeMockupWindow.prototype.cst.STROKE_COLOR3, '#c4c4c4');
	c.translate(x, y);

	h = Math.max(h, 30);
	w = Math.max(w, 90);

	this.background(c, x, y, w, h, bgColor, frameColor);
	c.setShadow(false);
	this.otherShapes(c, x, y, w, h, frameColor, insideColor, closeColor);
};

mxShapeMockupWindow.prototype.background = function(c, x, y, w, h, bgColor, frameColor)
{
	c.setFillColor(bgColor);
	c.setStrokeColor(frameColor);
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupWindow.prototype.otherShapes = function(c, x, y, w, h, frameColor, insideColor, closeColor)
{
	var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '1');

	//window buttons
	c.setStrokeColor(frameColor);
	c.ellipse(w - 75, 5, 20, 20);
	c.stroke();

	c.ellipse(w - 50, 5, 20, 20);
	c.stroke();

	c.setStrokeColor(closeColor);
	c.ellipse(w - 25, 5, 20, 20);
	c.stroke();

	c.setStrokeColor(insideColor);
	//lines
	c.begin();
	c.moveTo(0, 30);
	c.lineTo(w, 30);
	c.stroke();

	//text
	var windowTitle = mxUtils.getValue(this.style, mxShapeMockupWindow.prototype.cst.MAIN_TEXT, 'Window Title');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupWindow.prototype.cst.TEXT_COLOR, '#666666');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupWindow.prototype.cst.TEXT_SIZE, '17').toString();

	c.setFontColor(fontColor);
	c.setFontSize(fontSize);
	c.text(10, 15, 0, 0, windowTitle, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupWindow.prototype.cst.SHAPE_WINDOW, mxShapeMockupWindow);

//**********************************************************************************************************************************************************
//Horizontal Tab Bar (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupHorTabBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupHorTabBar, mxShape);

mxShapeMockupHorTabBar.prototype.cst = {
		BLOCK : 'block',
		CONE : 'cone',
		HALF_CONE : 'halfCone',
		ROUND : 'round',
		TEXT_SIZE : 'textSize',
		TAB_NAMES : 'tabs',
		TAB_STYLE : 'tabStyle',
		STYLE_FILLCOLOR2 : 'fillColor2',
		TEXT_COLOR : 'textColor',
		SEL_TEXT_COLOR : 'textColor2',
		SHAPE_HOR_TAB_BAR : 'mxgraph.mockup.containers.horTabBar'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
//TODO tab widths are fixed, so tab text length is a bit of an issue. Cannot be fixed while we use labels for tab names
mxShapeMockupHorTabBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.TEXT_SIZE, '17').toString();
	var tabNames = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.TAB_NAMES, 'Tab 1,+Tab 2,Tab 3').toString().split(',');

	var tabH = fontSize * 1.5;
	var startOffset = 10;
	var tabOffset = 5;
	var labelOffset = 10;
	var tabCount = tabNames.length;
	var minW = 2 * startOffset + (tabCount - 1) * tabOffset + tabCount * 2 * labelOffset;
	var rSize = 5;
	var labelWidths = new Array();
	var selectedTab = -1;

	for (var i = 0; i < tabCount; i++)
	{
		var currLabel = tabNames[i];

		if(currLabel.charAt(0) === '+')
		{
			currLabel = currLabel.substring(1);
			selectedTab = i;
		}

		currW = mxUtils.getSizeForString(currLabel, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currW === 0)
		{
			labelWidths[i] = 40;
		}
		else
		{
			labelWidths[i] = currW;
		};

		minW = minW + labelWidths[i];
	}

	w = Math.max(w, minW);
	h = Math.max(h, tabH + rSize);

	c.translate(x, y);

	this.background(c, w, h, rSize, tabH);
	c.setShadow(false);
	this.backTabs(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab);
	this.focusTab(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab);
	this.tabText(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab, tabNames);
};

mxShapeMockupHorTabBar.prototype.background = function(c, w, h, rSize, tabH)
{
	c.begin();
	c.moveTo(0, tabH + rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, tabH);
	c.lineTo(w - rSize, tabH);
	c.arcTo(rSize, rSize, 0, 0, 1, w, tabH + rSize);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

mxShapeMockupHorTabBar.prototype.backTabs = function(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab)
{
	var tabStyle = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.TAB_STYLE, mxShapeMockupHorTabBar.prototype.cst.BLOCK);

	var currW = startOffset;
	for (var i=0; i < tabCount; i++)
	{
		var tabW = labelWidths[i] + 2 * labelOffset;

		if (selectedTab !== i)
		{
			if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.BLOCK)
			{
				c.rect(currW, 0, tabW, tabH);
			}
			else if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.CONE)
			{
				c.begin();
				c.moveTo(currW, tabH);
				c.lineTo(currW + labelOffset * 0.5, 0);
				c.lineTo(currW + tabW - labelOffset * 0.5, 0);
				c.lineTo(currW + tabW, tabH);
			}
			else if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.HALF_CONE)
			{
				c.begin();
				c.moveTo(currW, tabH);
				c.lineTo(currW + labelOffset * 0.5, 0);
				c.lineTo(currW + tabW, 0);
				c.lineTo(currW + tabW, tabH);
			}
			else if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.ROUND)
			{
				c.begin();
				c.moveTo(currW - rSize, tabH);
				c.arcTo(rSize, rSize, 0, 0, 0, currW, tabH - rSize);
				c.lineTo(currW, rSize);
				c.arcTo(rSize, rSize, 0, 0, 1, currW + rSize, 0);
				c.lineTo(currW + tabW - rSize, 0);
				c.arcTo(rSize, rSize, 0, 0, 1, currW + tabW, rSize);
				c.lineTo(currW + tabW, tabH - rSize);
				c.arcTo(rSize, rSize, 0, 0, 0, currW + tabW + rSize, tabH);
			}

			c.fillAndStroke();
		}

		currW = currW + tabW + tabOffset;
	}
};

mxShapeMockupHorTabBar.prototype.focusTab = function(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab)
{
	var tabStyle = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.TAB_STYLE, mxShapeMockupHorTabBar.prototype.cst.BLOCK);
	var selectedFill = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.STYLE_FILLCOLOR2, '#008cff');

	var currW = startOffset;
	c.setStrokeColor(selectedFill);
	c.setFillColor(selectedFill);

	for (var i=0; i <= selectedTab; i++)
	{
		var tabW = labelWidths[i] + 2 * labelOffset;

		if (selectedTab === i)
		{
			if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.BLOCK)
			{
				c.begin();
				c.moveTo(0, tabH + rSize);
				c.arcTo(rSize, rSize, 0, 0, 1, rSize, tabH);
				c.lineTo(currW, tabH);
				c.lineTo(currW, 0);
				c.lineTo(currW + tabW, 0);
				c.lineTo(currW + tabW, tabH);
				c.lineTo(w - rSize, tabH);
				c.arcTo(rSize, rSize, 0, 0, 1, w, tabH + rSize);
				c.close();
			}
			else if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.CONE)
			{
				c.begin();
				c.moveTo(0, tabH + rSize);
				c.arcTo(rSize, rSize, 0, 0, 1, rSize, tabH);
				c.lineTo(currW, tabH);
				c.lineTo(currW + labelOffset * 0.5, 0);
				c.lineTo(currW + tabW - labelOffset * 0.5, 0);
				c.lineTo(currW + tabW, tabH);
				c.lineTo(w - rSize, tabH);
				c.arcTo(rSize, rSize, 0, 0, 1, w, tabH + rSize);
				c.close();
			}
			else if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.HALF_CONE)
			{
				c.begin();
				c.moveTo(0, tabH + rSize);
				c.arcTo(rSize, rSize, 0, 0, 1, rSize, tabH);
				c.lineTo(currW, tabH);
				c.lineTo(currW + labelOffset * 0.5, 0);
				c.lineTo(currW + tabW, 0);
				c.lineTo(currW + tabW, tabH);
				c.lineTo(w - rSize, tabH);
				c.arcTo(rSize, rSize, 0, 0, 1, w, tabH + rSize);
				c.close();
			}
			else if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.ROUND)
			{
				c.begin();
				c.moveTo(0, tabH + rSize);
				c.arcTo(rSize, rSize, 0, 0, 1, rSize, tabH);
				c.lineTo(currW - rSize, tabH);
				c.arcTo(rSize, rSize, 0, 0, 0, currW, tabH - rSize);
				c.lineTo(currW, rSize);
				c.arcTo(rSize, rSize, 0, 0, 1, currW + rSize, 0);
				c.lineTo(currW + tabW - rSize, 0);
				c.arcTo(rSize, rSize, 0, 0, 1, currW + tabW, rSize);
				c.lineTo(currW + tabW, tabH - rSize);
				c.arcTo(rSize, rSize, 0, 0, 0, currW + tabW + rSize, tabH);
				c.lineTo(w - rSize, tabH);
				c.arcTo(rSize, rSize, 0, 0, 1, w, tabH + rSize);
				c.close();
			}

			c.fillAndStroke();
		}

		currW = currW + tabW + tabOffset;
	}
};

mxShapeMockupHorTabBar.prototype.tabText = function(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab, tabNames)
{
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.TEXT_COLOR, '#666666');
	var selFontColor = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.SEL_TEXT_COLOR, '#ffffff');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.TEXT_SIZE, '17').toString();

	c.setFontColor(fontColor);
	c.setFontSize(fontSize);

	var currW = startOffset;

	for (var i=0; i < tabCount; i++)
	{
		var currLabel = tabNames[i];

		if (i === selectedTab)
		{
			c.setFontColor(selFontColor);
		}

		if (currLabel.charAt(0) === '+')
		{
			currLabel = currLabel.substring(1);
		}

		var tabW = labelWidths[i] + 2 * labelOffset;

		c.text(currW + labelOffset, tabH * 0.5, 0, 0, currLabel, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

		currW = currW + tabW + tabOffset;

		if (i === selectedTab)
		{
			c.setFontColor(fontColor);
		}
	}

};

mxCellRenderer.registerShape(mxShapeMockupHorTabBar.prototype.cst.SHAPE_HOR_TAB_BAR, mxShapeMockupHorTabBar);

//**********************************************************************************************************************************************************
//Vertical Tab Bar (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
//TODO tab widths are fixed, so tab text length is a bit of an issue. Cannot be fixed while we use labels for tab names
function mxShapeMockupVerTabBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupVerTabBar, mxShape);

mxShapeMockupVerTabBar.prototype.cst = {
		BLOCK : 'block',
		ROUND : 'round',
		TEXT_SIZE : 'textSize',
		TAB_NAMES : 'tabs',
		TAB_STYLE : 'tabStyle',
		STYLE_FILLCOLOR2 : 'fillColor2',
		TEXT_COLOR : 'textColor',
		SEL_TEXT_COLOR : 'textColor2',
		SHAPE_VER_TAB_BAR : 'mxgraph.mockup.containers.verTabBar'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupVerTabBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.TEXT_SIZE, '17').toString();
	var tabNames = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.TAB_NAMES, 'Tab 1,+Tab 2,Tab 3').toString().split(',');

	var tabH = fontSize * 1.5;
	var startOffset = 10;
	var tabOffset = 5;
	var labelOffset = 10;
	var tabCount = tabNames.length;
	var rSize = 5;
	var labelWidths = new Array();
	var selectedTab = -1;
	for (var i = 0; i < tabCount; i++)
	{
		var currLabel = tabNames[i];

		if(currLabel.charAt(0) === '+')
		{
			currLabel = currLabel.substring(1);
			selectedTab = i;
		}

		var currW = mxUtils.getSizeForString(currLabel, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currW === 0)
		{
			labelWidths[i] = 42;
		}
		else
		{
			labelWidths[i] = currW;
		}
	}

	var tabW = 2 * labelOffset + Math.max.apply(Math, labelWidths);
	var minW = tabW + rSize;
	w = Math.max(w, minW);
	h = Math.max(h, 2 * startOffset + tabCount * tabH + (tabCount - 1) * tabOffset);

	c.translate(x, y);

	this.background(c, w, h, rSize, tabW);
	c.setShadow(false);
	this.backTabs(c, w, h, rSize, tabH, tabW, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab);
	this.focusTab(c, w, h, rSize, tabH, tabW, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab);
	this.tabText(c, w, h, rSize, tabH, tabW, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab, tabNames);
};

mxShapeMockupVerTabBar.prototype.background = function(c, w, h, rSize, tabW)
{
	c.begin();
	c.moveTo(tabW + rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, tabW, h - rSize);
	c.lineTo(tabW, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, tabW + rSize, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.close();
	c.fillAndStroke();
};

mxShapeMockupVerTabBar.prototype.backTabs = function(c, w, h, rSize, tabH, tabW, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab)
{
	var tabStyle = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.TAB_STYLE, mxShapeMockupVerTabBar.prototype.cst.BLOCK);

	var currH = startOffset;

	for (var i=0; i < tabCount; i++)
	{
		if (selectedTab !== i)
		{
			if (tabStyle === mxShapeMockupVerTabBar.prototype.cst.BLOCK)
			{
				c.rect(0, currH, tabW, tabH);
			}
			else if (tabStyle === mxShapeMockupVerTabBar.prototype.cst.ROUND)
			{
				c.begin();
				c.moveTo(tabW, currH + tabH + rSize);
				c.arcTo(rSize, rSize, 0, 0, 0, tabW - rSize, currH + tabH);
				c.lineTo(rSize, currH + tabH);
				c.arcTo(rSize, rSize, 0, 0, 1, 0, currH + tabH - rSize);
				c.lineTo(0, currH + rSize);
				c.arcTo(rSize, rSize, 0, 0, 1, rSize, currH);
				c.lineTo(tabW - rSize, currH);
				c.arcTo(rSize, rSize, 0, 0, 0, tabW, currH - rSize);
			}

			c.fillAndStroke();
		}

		currH = currH + tabH + tabOffset;
	}
};

mxShapeMockupVerTabBar.prototype.focusTab = function(c, w, h, rSize, tabH, tabW, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab)
{
	var tabStyle = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.TAB_STYLE, mxShapeMockupVerTabBar.prototype.cst.BLOCK);
	var selectedFill = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.STYLE_FILLCOLOR2, '#008cff');

	if (selectedTab !== -1)
	{

		var currH = startOffset + (tabH  + tabOffset) * selectedTab;
		c.setStrokeColor(selectedFill);
		c.setFillColor(selectedFill);

		if (tabStyle === mxShapeMockupVerTabBar.prototype.cst.BLOCK)
		{
			c.begin();
			c.moveTo(tabW + rSize, h);
			c.arcTo(rSize, rSize, 0, 0, 1, tabW, h - rSize);
			c.lineTo(tabW, currH + tabH);
			c.lineTo(0, currH + tabH);
			c.lineTo(0, currH);
			c.lineTo(tabW, currH);
			c.lineTo(tabW, rSize);
			c.arcTo(rSize, rSize, 0, 0, 1, tabW + rSize, 0);
			c.close();
		}
		else if (tabStyle === mxShapeMockupVerTabBar.prototype.cst.ROUND)
		{
			c.begin();
			c.moveTo(tabW + rSize, h);
			c.arcTo(rSize, rSize, 0, 0, 1, tabW, h - rSize);
			c.lineTo(tabW, currH + tabH + rSize);
			c.arcTo(rSize, rSize, 0, 0, 0, tabW - rSize, currH + tabH);
			c.lineTo(rSize, currH + tabH);
			c.arcTo(rSize, rSize, 0, 0, 1, 0, currH + tabH - rSize);
			c.lineTo(0, currH + rSize);
			c.arcTo(rSize, rSize, 0, 0, 1, rSize, currH);
			c.lineTo(tabW - rSize, currH);
			c.arcTo(rSize, rSize, 0, 0, 0, tabW, currH - rSize);
			c.lineTo(tabW, rSize);
			c.arcTo(rSize, rSize, 0, 0, 1, tabW + rSize, 0);
			c.close();
		}

		c.fillAndStroke();
	}

};

mxShapeMockupVerTabBar.prototype.tabText = function(c, w, h, rSize, tabH, tabW, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab, tabNames)
{
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.TEXT_COLOR, '#666666');
	var selFontColor = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.SEL_TEXT_COLOR, '#ffffff');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.TEXT_SIZE, '17').toString();

	c.setFontColor(fontColor);
	c.setFontSize(fontSize);

	var currH = startOffset;

	for (var i=0; i < tabCount; i++)
	{
		var currLabel = tabNames[i];

		if (i === selectedTab)
		{
			c.setFontColor(selFontColor);
		}

		if (currLabel.charAt(0) === '+')
		{
			currLabel = currLabel.substring(1);
		}

		c.text(tabW * 0.5, currH + tabH * 0.5, 0, 0, currLabel, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

		currH = currH + tabH + tabOffset;

		if (i === selectedTab)
		{
			c.setFontColor(fontColor);
		}
	}

};

mxCellRenderer.registerShape(mxShapeMockupVerTabBar.prototype.cst.SHAPE_VER_TAB_BAR, mxShapeMockupVerTabBar);

//**********************************************************************************************************************************************************
//Alert Box (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupAlertBox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupAlertBox, mxShape);

mxShapeMockupAlertBox.prototype.cst = {
		MAIN_TEXT : 'mainText',
		SUB_TEXT : 'subText',
		BUTTON_TEXT : 'buttonText',
		TEXT_SIZE : 'textSize',
		TEXT_COLOR : 'textColor',
		STROKE_COLOR2 : 'strokeColor2',
		STROKE_COLOR3 : 'strokeColor3',
		SHAPE_ALERT_BOX : 'mxgraph.mockup.containers.alertBox'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupAlertBox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var closeColor = mxUtils.getValue(this.style, mxShapeMockupAlertBox.prototype.cst.STROKE_COLOR2, '#008cff');
	var insideColor = mxUtils.getValue(this.style, mxShapeMockupAlertBox.prototype.cst.STROKE_COLOR3, '#c4c4c4');
	c.translate(x, y);

	h = Math.max(h, 75);
	w = Math.max(w, 90);

	this.background(c, x, y, w, h, bgColor, frameColor);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, frameColor, insideColor, closeColor);
};

mxShapeMockupAlertBox.prototype.background = function(c, x, y, w, h, bgColor, frameColor)
{
	c.setFillColor(bgColor);
	c.setStrokeColor(frameColor);
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupAlertBox.prototype.foreground = function(c, x, y, w, h, frameColor, insideColor, closeColor)
{
	var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '1');

	c.setStrokeColor(closeColor);
	c.ellipse(w - 25, 5, 20, 20);
	c.stroke();

	c.setStrokeColor(insideColor);
	c.begin();
	c.moveTo(0, 30);
	c.lineTo(w, 30);
	c.stroke();

	//buttons
	var windowTitle = mxUtils.getValue(this.style, mxShapeMockupAlertBox.prototype.cst.MAIN_TEXT, 'Window Title').toString();
	var subText = mxUtils.getValue(this.style, mxShapeMockupAlertBox.prototype.cst.SUB_TEXT, 'Sub Text').toString().split(',');
	var buttonText = mxUtils.getValue(this.style, mxShapeMockupAlertBox.prototype.cst.BUTTON_TEXT, 'OK,Cancel').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupAlertBox.prototype.cst.TEXT_COLOR, '#666666');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupAlertBox.prototype.cst.TEXT_SIZE, '17').toString();

	var buttonCount = buttonText.length;
	var buttonOffset = 10;
	var buttonW = (w - buttonOffset * (buttonCount + 1)) / buttonCount;

	c.setFontColor(fontColor);
	c.setFontSize(fontSize);
	c.text(10, 15, 0, 0, windowTitle, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	var currW = buttonOffset;

	for (var i = 0; i < buttonText.length; i++)
	{
		if (buttonText[i] !== '')
		{
			c.rect(currW, h - 10 - fontSize * 1.5, buttonW, fontSize * 1.5);
			c.stroke();
			c.text(currW + buttonW * 0.5, h - 10 - fontSize * 0.75, 0, 0, buttonText[i], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		}

		currW = currW + buttonW + buttonOffset;
	}


	for (var i = 0; i < subText.length; i++)
	{
		c.text(w * 0.5, 30 + fontSize * (i * 1.5 + 0.75), 0, 0, subText[i], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}

	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupAlertBox.prototype.cst.SHAPE_ALERT_BOX, mxShapeMockupAlertBox);

//**********************************************************************************************************************************************************
//Rounded rectangle (adjustable rounding)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupContainersRRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupContainersRRect, mxShape);

mxShapeMockupContainersRRect.prototype.cst = {
		RRECT : 'mxgraph.mockup.containers.rrect',
		R_SIZE : 'rSize'
};

mxShapeMockupContainersRRect.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupContainersRRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupContainersRRect.prototype.cst.R_SIZE, '10'));
	c.roundrect(0, 0, w, h, rSize);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupContainersRRect.prototype.cst.RRECT, mxShapeMockupContainersRRect);

//**********************************************************************************************************************************************************
//Anchor (a dummy shape without visuals used for anchoring)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupContainersAnchor(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupContainersAnchor, mxShape);

mxShapeMockupContainersAnchor.prototype.cst = {
		ANCHOR : 'mxgraph.mockup.containers.anchor'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupContainersAnchor.prototype.paintVertexShape = function(c, x, y, w, h)
{
};

mxCellRenderer.registerShape(mxShapeMockupContainersAnchor.prototype.cst.ANCHOR, mxShapeMockupContainersAnchor);

//**********************************************************************************************************************************************************
//Top Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupContrainersTopButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupContrainersTopButton, mxShape);

mxShapeMockupContrainersTopButton.prototype.cst = {
		TOP_BUTTON : 'mxgraph.mockup.containers.topButton',
		R_SIZE : 'rSize'
};

mxShapeMockupContrainersTopButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupContrainersTopButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupContrainersTopButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupContrainersTopButton.prototype.cst.TOP_BUTTON, mxShapeMockupContrainersTopButton);

//**********************************************************************************************************************************************************
//Left Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupContainersLeftButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupContainersLeftButton, mxShape);

mxShapeMockupContainersLeftButton.prototype.cst = {
		LEFT_BUTTON : 'mxgraph.mockup.containers.leftButton',
		R_SIZE : 'rSize'
};

mxShapeMockupContainersLeftButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupContainersLeftButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupContainersLeftButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.lineTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupContainersLeftButton.prototype.cst.LEFT_BUTTON, mxShapeMockupContainersLeftButton);

//**********************************************************************************************************************************************************
//rect with margins
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupContainersMarginRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupContainersMarginRect, mxShape);

mxShapeMockupContainersMarginRect.prototype.cst = {
		SHAPE_MARGIN_RECT : 'mxgraph.mockup.containers.marginRect',
		MARGIN : 'rectMargin',
		MARGIN_TOP : 'rectMarginTop',
		MARGIN_LEFT : 'rectMarginLeft',
		MARGIN_BOTTOM : 'rectMarginBottom',
		MARGIN_RIGHT : 'rectMarginRight'
};

mxShapeMockupContainersMarginRect.prototype.customProperties = [
	{name: 'rectMargin', dispName: 'Global Margin', type: 'float', min:0, defVal:0},
	{name: 'rectMarginTop', dispName: 'Top Margin', type: 'float', min:0, defVal:0},
	{name: 'rectMarginLeft', dispName: 'Left Margin', type: 'float', min:0, defVal:0},
	{name: 'rectMarginBottom', dispName: 'Bottom Margin', type: 'float', min:0, defVal:0},
	{name: 'rectMarginRight', dispName: 'Right Margin', type: 'float', min:0, defVal:0}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupContainersMarginRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxShapeMockupContainersMarginRect.prototype.background = function(c, x, y, w, h, state)
{
	var margin = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect.prototype.cst.MARGIN, '0'));
	var marginTop = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect.prototype.cst.MARGIN_TOP, '0'));
	var marginLeft = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect.prototype.cst.MARGIN_LEFT, '0'));
	var marginBottom = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect.prototype.cst.MARGIN_BOTTOM, '0'));
	var marginRight = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect.prototype.cst.MARGIN_RIGHT, '0'));

	var x1 = margin + marginLeft;
	var y1 = margin + marginTop;
	var w1 = w - marginRight - x1 - margin;
	var h1 = h - marginBottom - y1 - margin;

	if (w1 >0 && h1 > 0)
	{
		c.begin();
		c.roundrect(x1, y1, w1, h1, 10, 10);
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeMockupContainersMarginRect.prototype.cst.SHAPE_MARGIN_RECT, mxShapeMockupContainersMarginRect);

//**********************************************************************************************************************************************************
//rect with margins (not rounded)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupContainersMarginRect2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupContainersMarginRect2, mxShape);

mxShapeMockupContainersMarginRect2.prototype.cst = {
		SHAPE_MARGIN_RECT : 'mxgraph.mockup.containers.marginRect2',
		MARGIN : 'rectMargin',
		MARGIN_TOP : 'rectMarginTop',
		MARGIN_LEFT : 'rectMarginLeft',
		MARGIN_BOTTOM : 'rectMarginBottom',
		MARGIN_RIGHT : 'rectMarginRight'
};

mxShapeMockupContainersMarginRect2.prototype.customProperties = [
	{name: 'rectMargin', dispName: 'Global Margin', type: 'float', min:0, defVal:0},
	{name: 'rectMarginTop', dispName: 'Top Margin', type: 'float', min:0, defVal:0},
	{name: 'rectMarginLeft', dispName: 'Left Margin', type: 'float', min:0, defVal:0},
	{name: 'rectMarginBottom', dispName: 'Bottom Margin', type: 'float', min:0, defVal:0},
	{name: 'rectMarginRight', dispName: 'Right Margin', type: 'float', min:0, defVal:0}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupContainersMarginRect2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxShapeMockupContainersMarginRect2.prototype.background = function(c, x, y, w, h, state)
{
	var margin = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect2.prototype.cst.MARGIN, '0'));
	var marginTop = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect2.prototype.cst.MARGIN_TOP, '0'));
	var marginLeft = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect2.prototype.cst.MARGIN_LEFT, '0'));
	var marginBottom = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect2.prototype.cst.MARGIN_BOTTOM, '0'));
	var marginRight = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect2.prototype.cst.MARGIN_RIGHT, '0'));

	var x1 = margin + marginLeft;
	var y1 = margin + marginTop;
	var w1 = w - marginRight - x1 - margin;
	var h1 = h - marginBottom - y1 - margin;

	if (w1 >0 && h1 > 0)
	{
		c.begin();
		c.rect(x1, y1, w1, h1);
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeMockupContainersMarginRect2.prototype.cst.SHAPE_MARGIN_RECT, mxShapeMockupContainersMarginRect2);


/**
 * $Id: mxMockupForms.js,v 1.11 2013/05/24 05:21:33 mate Exp $
 * Copyright (c) 2006-2010, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Checkbox Group (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupCheckboxGroup(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupCheckboxGroup, mxShape);

mxShapeMockupCheckboxGroup.prototype.cst = {
		MAIN_TEXT : 'mainText',
		TEXT_SIZE : 'textSize',
		TEXT_COLOR : 'textColor',
		SELECTED : '+',				// must be 1 char
		SHAPE_CHECKBOX_GROUP : 'mxgraph.mockup.forms.checkboxGroup'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupCheckboxGroup.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var fontColor = mxUtils.getValue(this.style, mxShapeMockupCheckboxGroup.prototype.cst.TEXT_COLOR, '#666666,#008cff').toString().split(',');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupCheckboxGroup.prototype.cst.TEXT_SIZE, '17').toString();
	var optionText = mxUtils.getValue(this.style, mxShapeMockupCheckboxGroup.prototype.cst.MAIN_TEXT, 'Option 1').toString().split(',');
	var optionNum = optionText.length;
	var buttonSize = 15;
	var lineH = Math.max(fontSize * 1.5, buttonSize);
	var maxTextWidth = 0;
	var selected = -1;
	var labelOffset = 2.5;
	var minH = optionNum * lineH;
	var trueH = Math.max(h, minH);

	//get min width and selected option 
	for (var i = 0; i < optionNum; i++)
	{
		var currText = optionText[i];

		if(currText.charAt(0) === mxShapeMockupCheckboxGroup.prototype.cst.SELECTED)
		{
			currText = optionText[i].substring(1);
			selected = i;
		}

		var currWidth = mxUtils.getSizeForString(currText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currWidth > maxTextWidth)
		{
			maxTextWidth = currWidth;
		}
	}

	var minW = 2 * labelOffset + maxTextWidth + 2 * buttonSize;
	var trueW = Math.max(w, minW);

	//draw the background
	c.rect(0, 0, trueW, trueH);
	c.fillAndStroke();
	c.setShadow(false);

	c.setFontSize(fontSize);

	for (var i = 0; i < optionNum; i++)
	{
		var currHeight = (i * lineH + lineH * 0.5) * trueH / minH;

		var currText = optionText[i];

		if(currText.charAt(0) === mxShapeMockupCheckboxGroup.prototype.cst.SELECTED)
		{
			c.setFontColor(fontColor[1]);
			currText = optionText[i].substring(1);
			selected = i;
		}
		else
		{
			c.setFontColor(fontColor[0]);
		}

		c.text(buttonSize * 2 + labelOffset, currHeight, 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

		var iconX = buttonSize * 0.5;
		var iconY = currHeight - buttonSize * 0.5;
		c.setFillColor('#dddddd');
		c.setStrokeColor('#999999');

		if (selected === i)
		{
			c.setGradient('#aaaaaa', '#666666', iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
			c.rect(iconX, iconY, buttonSize, buttonSize);
			c.fillAndStroke();
			c.setStrokeColor('#333333');
			c.begin();
			c.moveTo(iconX + buttonSize * 0.25, iconY + buttonSize * 0.5);
			c.lineTo(iconX + buttonSize * 0.5, iconY + buttonSize * 0.75);
			c.lineTo(iconX + buttonSize * 0.75, iconY + buttonSize * 0.25);
			c.stroke();
		}
		else
		{
			c.setGradient('#eeeeee', '#cccccc', iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
			c.rect(iconX, iconY, buttonSize, buttonSize);
			c.fillAndStroke();
		}

		selected = -1;
	}
};

mxCellRenderer.registerShape(mxShapeMockupCheckboxGroup.prototype.cst.SHAPE_CHECKBOX_GROUP, mxShapeMockupCheckboxGroup);

//**********************************************************************************************************************************************************
//Radio Button Group
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupRadioGroup(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupRadioGroup, mxShape);

mxShapeMockupRadioGroup.prototype.cst = {
		MAIN_TEXT : 'mainText',
		TEXT_SIZE : 'textSize',
		TEXT_COLOR : 'textColor',
		SELECTED : '+',				// must be 1 char
		SHAPE_RADIO_GROUP : 'mxgraph.mockup.forms.radioGroup'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupRadioGroup.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var fontColor = mxUtils.getValue(this.style, mxShapeMockupRadioGroup.prototype.cst.TEXT_COLOR, '#666666,#008cff').toString().split(',');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupRadioGroup.prototype.cst.TEXT_SIZE, '17').toString();
	var optionText = mxUtils.getValue(this.style, mxShapeMockupRadioGroup.prototype.cst.MAIN_TEXT, 'Option 1').toString().split(',');
	var optionNum = optionText.length;
	var buttonSize = 15;
	var lineH = Math.max(fontSize * 1.5, buttonSize);
	var maxTextWidth = 0;
	var selected = -1;
	var labelOffset = 2.5;
	var minH = optionNum * lineH;
	var trueH = Math.max(h, minH);

	//get min width and selected option 
	for (var i = 0; i < optionNum; i++)
	{
		var currText = optionText[i];

		if(currText.charAt(0) === mxShapeMockupRadioGroup.prototype.cst.SELECTED)
		{
			currText = optionText[i].substring(1);
			selected = i;
		}

		var currWidth = mxUtils.getSizeForString(currText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currWidth > maxTextWidth)
		{
			maxTextWidth = currWidth;
		}
	}

	var minW = 2 * labelOffset + maxTextWidth + 2 * buttonSize;
	var trueW = Math.max(w, minW);

	//draw the background
	c.rect(0, 0, trueW, trueH);
	c.fillAndStroke();
	c.setShadow(false);

	c.setFontSize(fontSize);

	for (var i = 0; i < optionNum; i++)
	{
		var currHeight = (i * lineH + lineH * 0.5) * trueH / minH;

		var currText = optionText[i];

		if(currText.charAt(0) === mxShapeMockupRadioGroup.prototype.cst.SELECTED)
		{
			c.setFontColor(fontColor[1]);
			currText = optionText[i].substring(1);
			selected = i;
		}
		else
		{
			c.setFontColor(fontColor[0]);
		}

		c.text(buttonSize * 2 + labelOffset, currHeight, 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

		var iconX = buttonSize * 0.5;
		var iconY = currHeight - buttonSize * 0.5;
		c.setStrokeColor('#999999');

		if (selected === i)
		{
			c.setGradient('#aaaaaa', '#666666', iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
			c.ellipse(iconX, iconY, buttonSize, buttonSize);
			c.fillAndStroke();
			c.setFillColor('#333333');
			c.setStrokeColor('#333333');
			c.ellipse(iconX + buttonSize * 0.25, iconY + buttonSize * 0.25, buttonSize * 0.5, buttonSize * 0.5);
			c.fillAndStroke();
		}
		else
		{
			c.setGradient('#eeeeee', '#cccccc', iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
			c.ellipse(iconX, iconY, buttonSize, buttonSize);
			c.fillAndStroke();
		}
	}
};

mxCellRenderer.registerShape(mxShapeMockupRadioGroup.prototype.cst.SHAPE_RADIO_GROUP, mxShapeMockupRadioGroup);

//**********************************************************************************************************************************************************
//Color Picker
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupColorPicker(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupColorPicker, mxShape);

mxShapeMockupColorPicker.prototype.cst = {
		COLOR : 'chosenColor',
		SHAPE_COLOR_PICKER : 'mxgraph.mockup.forms.colorPicker'
};

mxShapeMockupColorPicker.prototype.customProperties = [
	{name: 'chosenColor', dispName: 'Current Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupColorPicker.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var chosenColor = mxUtils.getValue(this.style, mxShapeMockupColorPicker.prototype.cst.COLOR, '#aaddff');

	c.translate(x, y);

	c.setStrokeColor('#999999');
	c.roundrect(0, 0, w, h, w * 0.05, h * 0.05);
	c.fillAndStroke();
	c.setShadow(false);

	c.setFillColor(chosenColor);
	c.rect(w * 0.1, h * 0.1, w * 0.8, h * 0.8);
	c.fill();

	c.setFillColor('#ffffff');
	c.begin();
	c.moveTo(w * 0.75, h * 0.75);
	c.lineTo(w * 0.75, h);
	c.lineTo(w * 0.95, h);
	c.arcTo(w * 0.05, h * 0.05, 0, 0, 0, w, h * 0.95);
	c.lineTo(w, h * 0.75);
	c.close();
	c.fill();

	c.setFillColor('#999999');
	c.begin();
	c.moveTo(w * 0.77, h * 0.77);
	c.lineTo(w * 0.875, h * 0.98);
	c.lineTo(w * 0.98, h * 0.77);
	c.close();
	c.fill();

	c.roundrect(0, 0, w, h, w * 0.05, h * 0.05);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupColorPicker.prototype.cst.SHAPE_COLOR_PICKER, mxShapeMockupColorPicker);

//**********************************************************************************************************************************************************
//Combo box
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupComboBox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupComboBox, mxShape);

mxShapeMockupComboBox.prototype.cst = {
		MAIN_TEXT : 'mainText',
		FILL_COLOR2 : 'fillColor2',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize',
		SHAPE_COMBO_BOX : 'mxgraph.mockup.forms.comboBox'
};

mxShapeMockupComboBox.prototype.customProperties = [
	{name: 'fillColor2', dispName: 'Fill2 Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupComboBox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
	this.mainText(c, x, y, w, h);
};

mxShapeMockupComboBox.prototype.background = function(c, x, y, w, h)
{
	c.setFillColor('#ffffff');
	c.roundrect(0, 0, w, h, 5, 5);
	c.fillAndStroke();
};

mxShapeMockupComboBox.prototype.foreground = function(c, x, y, w, h)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '').toString();
	var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupComboBox.prototype.cst.FILL_COLOR2, '').toString();
	c.setGradient(fillColor, fillColor2, w - 30, 0, 30, h, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.begin();
	c.moveTo(w - 30, 0);
	c.lineTo(w - 5, 0);
	c.arcTo(5, 5, 0, 0, 1, w, 5);
	c.lineTo(w, h - 5);
	c.arcTo(5, 5, 0, 0, 1, w - 5, h);
	c.lineTo(w - 30, h);
	c.close();
	c.fillAndStroke();

	c.setFillColor('#ffffff');
	c.begin();
	c.moveTo(w - 22, h * 0.5 - 5);
	c.lineTo(w - 15, h * 0.5 + 5);
	c.lineTo(w - 8, h * 0.5 - 5);
	c.fill();
};

mxShapeMockupComboBox.prototype.mainText = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxShapeMockupComboBox.prototype.cst.MAIN_TEXT, 'Main Text');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupComboBox.prototype.cst.TEXT_COLOR, '#666666').toString();
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupComboBox.prototype.cst.TEXT_SIZE, '17').toString();

	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(5, h * 0.5, 0, 0, mainText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeMockupComboBox.prototype.cst.SHAPE_COMBO_BOX, mxShapeMockupComboBox);

//**********************************************************************************************************************************************************
//Spinner
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupSpinner(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupSpinner, mxShape);

mxShapeMockupSpinner.prototype.cst = {
		LAYOUT : 'spinLayout',
		SPINNER_STYLE : 'spinStyle',
		ADJ_STYLE : 'adjStyle',
		LAYOUT_RIGHT : 'right',
		LAYOUT_LEFT : 'left',
		LAYOUT_TOP : 'top',
		LAYOUT_BOTTOM : 'bottom',
		LAYOUT_VERTICAL : 'vertical',
		LAYOUT_HORIZONTAL : 'horizontal',
		SPINNER_MERGED : 'merged',
		SPINNER_NORMAL : 'normal',
		ADJ_TRIANGLE : 'triangle',
		ADJ_PLUSMINUS : 'plusMinus',
		ADJ_ARROW : 'arrow',

		MAIN_TEXT : 'mainText',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize',
		SHAPE_SPINNER : 'mxgraph.mockup.forms.spinner'
};

mxShapeMockupSpinner.prototype.customProperties = [
	{name: 'spinLayout', dispName: 'Layout', type: 'enum', 
		enumList: [{val: 'right', dispName: 'Right'}, {val: 'left', dispName: 'Left'}, {val: 'top', dispName: 'Top'}, {val: 'bottom', dispName: 'Bottom'}, {val: 'vertical', dispName: 'Vertical'}, {val: 'horizontal', dispName: 'Horizontal'}]
	},
	{name: 'spinStyle', dispName: 'Spinner Style', type: 'enum', 
		enumList: [{val: 'merged', dispName: 'Merged'}, {val: 'normal', dispName: 'Normal'}]
	},
	{name: 'adjStyle', dispName: 'Button Style', type: 'enum', 
		enumList: [{val: 'triangle', dispName: 'Triangle'}, {val: 'plusMinus', dispName: '+/-'}, {val: 'arrow', dispName: 'Arrow'}]
	}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupSpinner.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var spinnerLayout = mxUtils.getValue(this.style, mxShapeMockupSpinner.prototype.cst.LAYOUT, mxShapeMockupSpinner.prototype.cst.LAYOUT_RIGHT);
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h, spinnerLayout);
	this.mainText(c, w, h, spinnerLayout);
};

mxShapeMockupSpinner.prototype.background = function(c, w, h)
{
	c.setFillColor('#ffffff');
	c.roundrect(0, 0, w, h, 10, 10);
	c.fillAndStroke();
};

mxShapeMockupSpinner.prototype.foreground = function(c, w, h, spinnerLayout)
{

	var spinnerStyle = mxUtils.getValue(this.style, mxShapeMockupSpinner.prototype.cst.SPINNER_STYLE, mxShapeMockupSpinner.prototype.cst.SPINNER_NORMAL);
	var adjStyle = mxUtils.getValue(this.style, mxShapeMockupSpinner.prototype.cst.ADJ_STYLE, mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE);
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');

	c.setFillColor(fillColor);

	if (spinnerStyle === mxShapeMockupSpinner.prototype.cst.SPINNER_NORMAL)
	{
		if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_RIGHT)
		{
			c.begin();
			c.moveTo(w - 20, 0);
			c.lineTo(w - 20, h);
			c.moveTo(w - 20, h * 0.5);
			c.lineTo(w, h * 0.5);
			c.stroke();
		}
		else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_LEFT)
		{
			c.begin();
			c.moveTo(20, 0);
			c.lineTo(20, h);
			c.moveTo(20, h * 0.5);
			c.lineTo(0, h * 0.5);
			c.stroke();
		}
		else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_TOP)
		{
			c.begin();
			c.moveTo(0, 15);
			c.lineTo(w, 15);
			c.moveTo(w * 0.5, 15);
			c.lineTo(w * 0.5, 0);
			c.stroke();
		}
		else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_BOTTOM)
		{
			c.begin();
			c.moveTo(0, h - 15);
			c.lineTo(w, h - 15);
			c.moveTo(w * 0.5, h - 15);
			c.lineTo(w * 0.5, h);
			c.stroke();
		}
		else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_VERTICAL)
		{
			c.begin();
			c.moveTo(0, 15);
			c.lineTo(w, 15);
			c.moveTo(0, h - 15);
			c.lineTo(w, h - 15);
			c.stroke();
		}
		else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_HORIZONTAL)
		{
			c.begin();
			c.moveTo(20, 0);
			c.lineTo(20, h);
			c.moveTo(w - 20, 0);
			c.lineTo(w - 20, h);
			c.stroke();
		}
	}

	c.setStrokeColor(fillColor);

	if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_RIGHT)
	{
		if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE)
		{
			c.begin();
			c.moveTo(w - 14, h * 0.25 + 4.5);
			c.lineTo(w - 10, h * 0.25 - 2.5);
			c.lineTo(w - 6, h * 0.25 + 4.5);
			c.close();
			c.fillAndStroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS)
		{
			c.begin();
			c.moveTo(w - 10, h * 0.25 - 4);
			c.lineTo(w - 10, h * 0.25 + 4);
			c.moveTo(w - 14, h * 0.25);
			c.lineTo(w - 6, h * 0.25);
			c.stroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW)
		{
			c.begin();
			c.moveTo(w - 14, h * 0.25 + 1.5);
			c.lineTo(w - 10, h * 0.25 - 2.5);
			c.lineTo(w - 6, h * 0.25 + 1.5);
			c.close();
			c.moveTo(w - 10, h * 0.25 + 4.5);
			c.lineTo(w - 10, h * 0.25 - 2.5);
			c.fillAndStroke();
		}
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_LEFT)
	{
		if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE)
		{
			c.begin();
			c.moveTo(14, h * 0.25 + 4.5);
			c.lineTo(10, h * 0.25 - 2.5);
			c.lineTo(6, h * 0.25 + 4.5);
			c.close();
			c.fillAndStroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS)
		{
			c.begin();
			c.moveTo(10, h * 0.25 - 4);
			c.lineTo(10, h * 0.25 + 4);
			c.moveTo(14, h * 0.25);
			c.lineTo(6, h * 0.25);
			c.stroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW)
		{
			c.begin();
			c.moveTo(14, h * 0.25 + 1.5);
			c.lineTo(10, h * 0.25 - 2.5);
			c.lineTo(6, h * 0.25 + 1.5);
			c.close();
			c.moveTo(10, h * 0.25 + 4.5);
			c.lineTo(10, h * 0.25 - 2.5);
			c.fillAndStroke();
		}
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_TOP)
	{
		if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE)
		{
			c.begin();
			c.moveTo(w * 0.75 + 4, 12);
			c.lineTo(w * 0.75, 5);
			c.lineTo(w * 0.75 - 4, 12);
			c.close();
			c.fillAndStroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS)
		{
			c.begin();
			c.moveTo(w * 0.75, 3.5);
			c.lineTo(w * 0.75, 11.5);
			c.moveTo(w * 0.75 + 4, 7.5);
			c.lineTo(w * 0.75 - 4, 7.5);
			c.stroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW)
		{
			c.begin();
			c.moveTo(w * 0.75 + 4, 9);
			c.lineTo(w * 0.75, 5);
			c.lineTo(w * 0.75 - 4, 9);
			c.close();
			c.moveTo(w * 0.75, 12);
			c.lineTo(w * 0.75, 5);
			c.fillAndStroke();
		}
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_BOTTOM)
	{
		if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE)
		{
			c.begin();
			c.moveTo(w * 0.75 + 4, h - 5);
			c.lineTo(w * 0.75, h - 12);
			c.lineTo(w * 0.75 - 4, h - 5);
			c.close();
			c.fillAndStroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS)
		{
			c.begin();
			c.moveTo(w * 0.75, h - 3.5);
			c.lineTo(w * 0.75, h - 11.5);
			c.moveTo(w * 0.75 + 4, h - 7.5);
			c.lineTo(w * 0.75 - 4, h - 7.5);
			c.stroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW)
		{
			c.begin();
			c.moveTo(w * 0.75 + 4, h - 6);
			c.lineTo(w * 0.75, h - 10);
			c.lineTo(w * 0.75 - 4, h - 6);
			c.close();
			c.moveTo(w * 0.75, h - 3);
			c.lineTo(w * 0.75, h - 10);
			c.fillAndStroke();
		}
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_VERTICAL)
	{
		if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE)
		{
			c.begin();
			c.moveTo(w * 0.5 + 4, 12);
			c.lineTo(w * 0.5, 5);
			c.lineTo(w * 0.5 - 4, 12);
			c.close();
			c.fillAndStroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS)
		{
			c.begin();
			c.moveTo(w * 0.5, 3.5);
			c.lineTo(w * 0.5, 11.5);
			c.moveTo(w * 0.5 + 4, 7.5);
			c.lineTo(w * 0.5 - 4, 7.5);
			c.stroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW)
		{
			c.begin();
			c.moveTo(w * 0.5 + 4, 9);
			c.lineTo(w * 0.5, 5);
			c.lineTo(w * 0.5 - 4, 9);
			c.close();
			c.moveTo(w * 0.5, 12);
			c.lineTo(w * 0.5, 5);
			c.fillAndStroke();
		}
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_HORIZONTAL)
	{
		if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE)
		{
			c.begin();
			c.moveTo(w - 6, h * 0.5 + 4.5);
			c.lineTo(w - 10, h * 0.5 - 2.5);
			c.lineTo(w - 14, h * 0.5 + 4.5);
			c.close();
			c.fillAndStroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS)
		{
			c.begin();
			c.moveTo(w - 10, h * 0.5 - 4);
			c.lineTo(w - 10, h * 0.5 + 4);
			c.moveTo(w - 14, h * 0.5);
			c.lineTo(w - 6, h * 0.5);
			c.stroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW)
		{
			c.begin();
			c.moveTo(w - 14, h * 0.5 + 1.5);
			c.lineTo(w - 10, h * 0.5 - 2.5);
			c.lineTo(w - 6, h * 0.5 + 1.5);
			c.close();
			c.moveTo(w - 10, h * 0.5 + 4.5);
			c.lineTo(w - 10, h * 0.5 - 2.5);
			c.fillAndStroke();
		}
	}

	if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_RIGHT)
	{
		if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE)
		{
			c.begin();
			c.moveTo(w - 14, h * 0.75 - 4.5);
			c.lineTo(w - 10, h * 0.75 + 2.5);
			c.lineTo(w - 6, h * 0.75 - 4.5);
			c.close();
			c.fillAndStroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS)
		{
			c.begin();
			c.moveTo(w - 14, h * 0.75);
			c.lineTo(w - 6, h * 0.75);
			c.stroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW)
		{
			c.begin();
			c.moveTo(w - 14, h * 0.75 - 1.5);
			c.lineTo(w - 10, h * 0.75 + 2.5);
			c.lineTo(w - 6, h * 0.75 - 1.5);
			c.close();
			c.moveTo(w - 10, h * 0.75 - 4.5);
			c.lineTo(w - 10, h * 0.75 + 2.5);
			c.fillAndStroke();
		}
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_LEFT)
	{
		if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE)
		{
			c.begin();
			c.moveTo(14, h * 0.75 - 4.5);
			c.lineTo(10, h * 0.75 + 2.5);
			c.lineTo(6, h * 0.75 - 4.5);
			c.close();
			c.fillAndStroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS)
		{
			c.begin();
			c.moveTo(14, h * 0.75);
			c.lineTo(6, h * 0.75);
			c.stroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW)
		{
			c.begin();
			c.moveTo(14, h * 0.75 - 1.5);
			c.lineTo(10, h * 0.75 + 2.5);
			c.lineTo(6, h * 0.75 - 1.5);
			c.close();
			c.moveTo(10, h * 0.75 - 4.5);
			c.lineTo(10, h * 0.75 + 2.5);
			c.fillAndStroke();
		}
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_TOP)
	{
		if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE)
		{
			c.begin();
			c.moveTo(w * 0.25 + 4, 5);
			c.lineTo(w * 0.25, 12);
			c.lineTo(w * 0.25 - 4, 5);
			c.close();
			c.fillAndStroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS)
		{
			c.begin();
			c.moveTo(w * 0.25 + 4, 7.5);
			c.lineTo(w * 0.25 - 4, 7.5);
			c.stroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW)
		{
			c.begin();
			c.moveTo(w * 0.25 + 4, 6);
			c.lineTo(w * 0.25, 10);
			c.lineTo(w * 0.25 - 4, 6);
			c.close();
			c.moveTo(w * 0.25, 3);
			c.lineTo(w * 0.25, 10);
			c.fillAndStroke();
		}
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_BOTTOM)
	{
		if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE)
		{
			c.begin();
			c.moveTo(w * 0.25 + 4, h - 12);
			c.lineTo(w * 0.25, h - 5);
			c.lineTo(w * 0.25 - 4, h - 12);
			c.close();
			c.fillAndStroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS)
		{
			c.begin();
			c.moveTo(w * 0.25 + 4, h - 7.5);
			c.lineTo(w * 0.25 - 4, h - 7.5);
			c.stroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW)
		{
			c.begin();
			c.moveTo(w * 0.25 + 4, h - 9);
			c.lineTo(w * 0.25, h - 5);
			c.lineTo(w * 0.25 - 4, h - 9);
			c.close();
			c.moveTo(w * 0.25, h - 12);
			c.lineTo(w * 0.25, h - 5);
			c.fillAndStroke();
		}
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_VERTICAL)
	{
		if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE)
		{
			c.begin();
			c.moveTo(w * 0.5 + 4, h - 12);
			c.lineTo(w * 0.5, h - 5);
			c.lineTo(w * 0.5 - 4, h - 12);
			c.close();
			c.fillAndStroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS)
		{
			c.begin();
			c.moveTo(w * 0.5 + 4, h - 7.5);
			c.lineTo(w * 0.5 - 4, h - 7.5);
			c.stroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW)
		{
			c.begin();
			c.moveTo(w * 0.5 + 4, h - 9);
			c.lineTo(w * 0.5, h - 5);
			c.lineTo(w * 0.5 - 4, h - 9);
			c.close();
			c.moveTo(w * 0.5, h - 12);
			c.lineTo(w * 0.5, h - 5);
			c.fillAndStroke();
		}
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_HORIZONTAL)
	{
		if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE)
		{
			c.begin();
			c.moveTo(6, h * 0.5 - 4.5);
			c.lineTo(10, h * 0.5 + 2.5);
			c.lineTo(14, h * 0.5 - 4.5);
			c.close();
			c.fillAndStroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS)
		{
			c.begin();
			c.moveTo(14, h * 0.5);
			c.lineTo(6, h * 0.5);
			c.stroke();
		}
		else if(adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW)
		{
			c.begin();
			c.moveTo(14, h * 0.5 - 1.5);
			c.lineTo(10, h * 0.5 + 2.5);
			c.lineTo(6, h * 0.5 - 1.5);
			c.close();
			c.moveTo(10, h * 0.5 - 4.5);
			c.lineTo(10, h * 0.5 + 2.5);
			c.fillAndStroke();
		}
	}
};

mxShapeMockupSpinner.prototype.mainText = function(c, w, h, spinnerLayout)
{
	var spinnerText = mxUtils.getValue(this.style, mxShapeMockupSpinner.prototype.cst.MAIN_TEXT, '100').toString();
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupSpinner.prototype.cst.TEXT_SIZE, '17');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupSpinner.prototype.cst.TEXT_COLOR, '#666666');
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);

	if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_RIGHT)
	{
		c.text((w - 20) * 0.5, h * 0.5, 0, 0, spinnerText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_LEFT)
	{
		c.text((w + 20) * 0.5, h * 0.5, 0, 0, spinnerText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_TOP)
	{
		c.text(w * 0.5, (h + 15) * 0.5, 0, 0, spinnerText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_BOTTOM)
	{
		c.text(w * 0.5, (h - 15) * 0.5, 0, 0, spinnerText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_VERTICAL)
	{
		c.text(w * 0.5, h * 0.5, 0, 0, spinnerText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
	else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_HORIZONTAL)
	{
		c.text(w * 0.5, h * 0.5, 0, 0, spinnerText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
};

mxCellRenderer.registerShape(mxShapeMockupSpinner.prototype.cst.SHAPE_SPINNER, mxShapeMockupSpinner);

//**********************************************************************************************************************************************************
//Menu Bar (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupMenuBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupMenuBar, mxShape);

mxShapeMockupMenuBar.prototype.cst = {
		MAIN_TEXT : 'mainText',
		SHAPE_MENU_BAR : 'mxgraph.mockup.forms.menuBar',
		TEXT_COLOR : 'textColor',
		TEXT_COLOR2 : 'textColor2',
		STROKE_COLOR2 : 'strokeColor2',
		FILL_COLOR2 : 'fillColor2',
		SELECTED : '+',			//must be 1 char
		TEXT_SIZE : 'textSize'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupMenuBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var textStrings = mxUtils.getValue(this.style, mxShapeMockupMenuBar.prototype.cst.MAIN_TEXT, '+Menu 1, Menu 2, Menu 3').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupMenuBar.prototype.cst.TEXT_COLOR, '#666666');
	var selectedFontColor = mxUtils.getValue(this.style, mxShapeMockupMenuBar.prototype.cst.TEXT_COLOR2, '#ffffff');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupMenuBar.prototype.cst.TEXT_SIZE, '17').toString();
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var separatorColor = mxUtils.getValue(this.style, mxShapeMockupMenuBar.prototype.cst.STROKE_COLOR2, '#c4c4c4');
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var selectedFillColor = mxUtils.getValue(this.style, mxShapeMockupMenuBar.prototype.cst.FILL_COLOR2, '#008cff');
	var buttonNum = textStrings.length;
	var buttonWidths = new Array(buttonNum);
	var buttonTotalWidth = 0;
	var selectedButton = -1;
	var rSize = 10; //rounding size
	var labelOffset = 5;

	for (var i = 0; i < buttonNum; i++)
	{
		var buttonText = textStrings[i];

		if(buttonText.charAt(0) === mxShapeMockupMenuBar.prototype.cst.SELECTED)
		{
			buttonText = textStrings[i].substring(1);
			selectedButton = i;
		}

		buttonWidths[i] = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		buttonTotalWidth += buttonWidths[i];
	}

	var trueH = Math.max(h, fontSize * 1.5, 20);
	var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
	var trueW = Math.max(w, minW);

	c.translate(x, y);
	this.background(c, trueW, trueH, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton);
	c.setShadow(false);

	var currWidth = 0;

	for (var i = 0; i < buttonNum; i++)
	{
		if (i === selectedButton)
		{
			c.setFontColor(selectedFontColor);
		}
		else
		{
			c.setFontColor(fontColor);
		}

		currWidth = currWidth + labelOffset;
		this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
		currWidth = currWidth + buttonWidths[i] + labelOffset;
	}
};

mxShapeMockupMenuBar.prototype.background = function(c, w, h, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton)
{
	//draw the frame
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.rect(0, 0, w, h);
	c.fillAndStroke();

	//draw the button separators
	c.setStrokeColor(separatorColor);
	c.begin();

	for (var i = 1; i < buttonNum; i++)
	{
		if (i !== selectedButton && i !== (selectedButton + 1))
		{
			var currWidth = 0;

			for (var j = 0; j < i; j++)
			{
				currWidth += buttonWidths[j] + 2 * labelOffset;
			}

			currWidth = currWidth * w / minW;
			c.moveTo(currWidth, 0);
			c.lineTo(currWidth, h);
		}
	}

	c.stroke();

	//draw the selected menu
	if (selectedButton !== -1)
	{
		var buttonLeft = 0;
		c.setFillColor(selectedFillColor);

		for (var i = 0; i < selectedButton; i++)
		{
			buttonLeft += buttonWidths[i] + 2 * labelOffset;
		}

		buttonLeft = buttonLeft * w / minW;
		var buttonRight = (buttonWidths[selectedButton] + 2 * labelOffset) * w / minW;
		buttonRight += buttonLeft;

		c.rect(buttonLeft, 0, buttonRight - buttonLeft, h);
		c.fill();
	}

	//draw the frame again, for a nicer effect
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.rect(0, 0, w, h);
	c.stroke();
};

mxShapeMockupMenuBar.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW)
{
	if(textString.charAt(0) === mxShapeMockupMenuBar.prototype.cst.SELECTED)
	{
		textString = textString.substring(1);
	}

	c.setFontSize(fontSize);
	c.text((w + buttonWidth * 0.5) * trueW / minW, h * 0.5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeMockupMenuBar.prototype.cst.SHAPE_MENU_BAR, mxShapeMockupMenuBar);

//**********************************************************************************************************************************************************
//Horizontal Slider
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupHorSlider(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupHorSlider, mxShape);

mxShapeMockupHorSlider.prototype.cst = {
		STYLE : 'sliderStyle',
		SLIDER_BASIC : 'basic',
		SLIDER_FANCY : 'fancy',
		SLIDER_POS : 'sliderPos',
		HANDLE_TRIANGLE : 'triangle',
		HANDLE_CIRCLE : 'circle',
		HANDLE_HANDLE : 'handle',
		HANDLE_STYLE : 'handleStyle',
		FILL_COLOR2 : 'fillColor2',
		SHAPE_HOR_SLIDER : 'mxgraph.mockup.forms.horSlider'
};

mxShapeMockupHorSlider.prototype.customProperties = [
	{name: 'sliderStyle', dispName: 'Slider Style', type: 'enum', 
		enumList: [{val: 'basic', dispName: 'Basic'}, {val: 'fancy', dispName: 'Fancy'}]
	},
	{name: 'handleStyle', dispName: 'Handle Style', type: 'enum', 
		enumList: [{val: 'triangle', dispName: 'Triangle'}, {val: 'circle', dispName: 'Circle'}, {val: 'handle', dispName: 'Handle'}]
	},
	{name: 'sliderPos', dispName: 'Handle Position', type: 'float'},
	{name: 'fillColor2', dispName: 'Fill2 Color', type: 'color'},
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupHorSlider.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var sliderStyle = mxUtils.getValue(this.style, mxShapeMockupHorSlider.prototype.cst.STYLE, mxShapeMockupHorSlider.prototype.cst.SLIDER_BASIC);
	var rSize = 5;

	c.translate(x, y);
	this.background(c, w, h, rSize, sliderStyle);
	c.setShadow(false);
	this.foreground(c, w, h, rSize, sliderStyle);
	this.sliderPos = 20;
};

mxShapeMockupHorSlider.prototype.background = function(c, w, h, rSize, sliderStyle)
{

	if (sliderStyle === mxShapeMockupHorSlider.prototype.cst.SLIDER_BASIC)
	{
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
	else if (sliderStyle === mxShapeMockupHorSlider.prototype.cst.SLIDER_FANCY)
	{
		c.roundrect(0, h * 0.5 - rSize, w, 2 * rSize, rSize, rSize);
		c.fillAndStroke();
	}
};

mxShapeMockupHorSlider.prototype.foreground = function(c, w, h, rSize, sliderStyle)
{
	var sliderPos = mxUtils.getValue(this.style, mxShapeMockupHorSlider.prototype.cst.SLIDER_POS, '20');
	var handleStyle = mxUtils.getValue(this.style, mxShapeMockupHorSlider.prototype.cst.HANDLE_STYLE, mxShapeMockupHorSlider.prototype.cst.HANDLE_CIRCLE);
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupHorSlider.prototype.cst.FILL_COLOR2, '#ddeeff');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#999999');
	sliderPos = Math.min(100, sliderPos);
	sliderPos = Math.max(0, sliderPos);

	if (sliderStyle === mxShapeMockupHorSlider.prototype.cst.SLIDER_BASIC)
	{
		c.setStrokeColor(fillColor2);
		var barCenterPos = w * sliderPos / 100;
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(barCenterPos, h * 0.5);
		c.stroke();
		c.setStrokeColor(strokeColor);
	}
	else if (sliderStyle === mxShapeMockupHorSlider.prototype.cst.SLIDER_FANCY)
	{
		var barCenterPos = 10 + (w - 10) * sliderPos / 100;
		c.setFillColor(fillColor2);
		c.roundrect(0, h * 0.5 - rSize, barCenterPos, 2 * rSize, rSize, rSize);
		c.fillAndStroke();
		c.setFillColor(fillColor);
	}

	var handleCenterPos = 5 + (w - 10) * sliderPos / 100;

	if (handleStyle === mxShapeMockupHorSlider.prototype.cst.HANDLE_CIRCLE)
	{
		c.ellipse(handleCenterPos - 10, h * 0.5 - 10, 20, 20);
		c.fillAndStroke();
	}
	else if (handleStyle === mxShapeMockupHorSlider.prototype.cst.HANDLE_TRIANGLE)
	{
		c.begin();
		c.moveTo(handleCenterPos - 10, h * 0.5 + 10);
		c.lineTo(handleCenterPos, h * 0.5 - 10);
		c.lineTo(handleCenterPos + 10, h * 0.5 + 10);
		c.close();
		c.fillAndStroke();
	}
	else if (handleStyle === mxShapeMockupHorSlider.prototype.cst.HANDLE_HANDLE)
	{
		c.begin();
		c.moveTo(handleCenterPos - 7, h * 0.5 + 10);
		c.lineTo(handleCenterPos - 7, h * 0.5);
		c.lineTo(handleCenterPos, h * 0.5 - 10);
		c.lineTo(handleCenterPos + 7, h * 0.5);
		c.lineTo(handleCenterPos + 7, h * 0.5 + 10);
		c.close();
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeMockupHorSlider.prototype.cst.SHAPE_HOR_SLIDER, mxShapeMockupHorSlider);

Graph.handleFactory[mxShapeMockupHorSlider.prototype.cst.SHAPE_HOR_SLIDER] = function(state)
{
	var handles = [Graph.createHandle(state, ['sliderPos'], function(bounds)
			{
				var sliderPos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'sliderPos', this.sliderPos))));

				return new mxPoint(bounds.x + ((bounds.width - 10) * sliderPos / bounds.width) / 100 * bounds.width + 5, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['sliderPos'] = Math.round(1000 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 1000;
			})];

	return handles;
}

//**********************************************************************************************************************************************************
//List Box (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupListBox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupListBox, mxShape);

mxShapeMockupListBox.prototype.cst = {
		MAIN_TEXT : 'mainText',
		SUB_TEXT : 'subText',
		BUTTON_TEXT : 'buttonText',
		TEXT_SIZE : 'textSize',
		TEXT_COLOR : 'textColor',
		STROKE_COLOR2 : 'strokeColor2',
		STROKE_COLOR3 : 'strokeColor3',
		SELECTED_COLOR : 'selectedColor',
		SELECTED : '+',			//must be 1 char
		SHAPE_LIST_BOX : 'mxgraph.mockup.forms.listBox'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupListBox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupListBox.prototype.cst.TEXT_SIZE, '17').toString();

	var selectedButton = -1;
	var maxShapeWidth = w;
	var subText = mxUtils.getValue(this.style, mxShapeMockupListBox.prototype.cst.SUB_TEXT, 'Sub Text').toString().split(',');

	for (var i = 0; i < subText.length; i++)
	{
		var itemText = subText[i];

		if(itemText.charAt(0) === mxShapeMockupListBox.prototype.cst.SELECTED)
		{
			itemText = subText[i].substring(1);
			selectedButton = i;
		}

		var currWidth = mxUtils.getSizeForString(itemText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currWidth > maxShapeWidth)
		{
			maxShapeWidth = currWidth;
		}
	}



	c.translate(x, y);

	w = Math.min(w, maxShapeWidth);
	h = Math.max(h, 30 + subText.length * fontSize * 1.5);

	this.background(c, w, h, bgColor, frameColor);
	c.setShadow(false);
	this.foreground(c, w, h, frameColor, selectedButton, subText, fontSize);
};

mxShapeMockupListBox.prototype.background = function(c, w, h, bgColor, frameColor)
{
	c.setFillColor(bgColor);
	c.setStrokeColor(frameColor);
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupListBox.prototype.foreground = function(c, w, h, frameColor, selectedButton, subText, fontSize)
{
	var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '1');
	var selectedColor = mxUtils.getValue(this.style, mxShapeMockupListBox.prototype.cst.SELECTED_COLOR, '#ddeeff');

	if(selectedButton !== -1)
	{
		c.setFillColor(selectedColor);
		c.rect(0, 30 + selectedButton * fontSize * 1.5, w, fontSize * 1.5);
		c.fill();
	}

	c.begin();
	c.moveTo(0, 30);
	c.lineTo(w, 30);
	c.stroke();

	//buttons
	var windowTitle = mxUtils.getValue(this.style, mxShapeMockupListBox.prototype.cst.MAIN_TEXT, 'Window Title').toString();
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupListBox.prototype.cst.TEXT_COLOR, '#666666,#008cff').toString().split(',');

	c.setFontColor(fontColor[1]);
	c.setFontSize(fontSize);
	c.text(10, 15, 0, 0, windowTitle, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.setFontColor(fontColor[0]);

	for (var i = 0; i < subText.length; i++)
	{
		var currText = subText[i];

		if(currText.charAt(0) === mxShapeMockupListBox.prototype.cst.SELECTED)
		{
			currText = subText[i].substring(1);
		}

		c.text(10, 30 + fontSize * (i * 1.5 + 0.75), 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}

	c.rect(0, 0, w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupListBox.prototype.cst.SHAPE_LIST_BOX, mxShapeMockupListBox);

//**********************************************************************************************************************************************************
//Password Field
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupPwField(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupPwField, mxShape);

mxShapeMockupPwField.prototype.cst = {
		MAIN_TEXT : 'mainText',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize',
		SHAPE_PW_FIELD : 'mxgraph.mockup.forms.pwField'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupPwField.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupPwField.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupPwField.prototype.foreground = function(c, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxShapeMockupPwField.prototype.cst.MAIN_TEXT, '******');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupPwField.prototype.cst.TEXT_COLOR, '#666666');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupPwField.prototype.cst.TEXT_SIZE, '17');

	c.setFontColor(fontColor);
	c.setFontSize(fontSize);

	c.text(5, h * 0.5, 0, 0, mainText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeMockupPwField.prototype.cst.SHAPE_PW_FIELD, mxShapeMockupPwField);

//**********************************************************************************************************************************************************
//Splitter
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupSplitter(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupSplitter, mxShape);

mxShapeMockupSplitter.prototype.cst = {
		MAIN_TEXT : 'mainText',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize',
		SHAPE_SPLITTER : 'mxgraph.mockup.forms.splitter'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupSplitter.prototype.paintVertexShape = function(c, x, y, w, h)
{
	w = Math.max(w, 35);
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupSplitter.prototype.background = function(c, w, h)
{
	c.begin();
	c.moveTo(0, h * 0.5 - 5);
	c.lineTo(w, h * 0.5 - 5);
	c.lineTo(w, h * 0.5 + 5);
	c.lineTo(0, h * 0.5 + 5);
	c.close();
	c.fill();
};

mxShapeMockupSplitter.prototype.foreground = function(c, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#999999');

	c.begin();
	c.moveTo(0, h * 0.5 - 5);
	c.lineTo(w, h * 0.5 - 5);
	c.moveTo(w, h * 0.5 + 5);
	c.lineTo(0, h * 0.5 + 5);
	c.stroke();

	c.setFillColor(strokeColor);
	c.ellipse(w * 0.5 - 17, h * 0.5 - 2, 4, 4);
	c.fill();
	c.ellipse(w * 0.5 - 2, h * 0.5 - 2, 4, 4);
	c.fill();
	c.ellipse(w * 0.5 + 13, h * 0.5 - 2, 4, 4);
	c.fill();
};

mxCellRenderer.registerShape(mxShapeMockupSplitter.prototype.cst.SHAPE_SPLITTER, mxShapeMockupSplitter);

//**********************************************************************************************************************************************************
//Wedge Bar (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupWedgeBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupWedgeBar, mxShape);

mxShapeMockupWedgeBar.prototype.cst = {
		BLOCK : 'block',
		CONE : 'cone',
		HALF_CONE : 'halfCone',
		ROUND : 'round',
		TEXT_SIZE : 'textSize',
		TAB_NAMES : 'tabs',
		TAB_STYLE : 'tabStyle',
		STYLE_FILLCOLOR2 : 'fillColor2',
		TEXT_COLOR : 'textColor',
		SEL_TEXT_COLOR : 'textColor2',
		SHAPE_WEDGE_BAR : 'mxgraph.mockup.forms.wedgeBar'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupWedgeBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.TEXT_SIZE, '17').toString();
	var tabNames = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.TAB_NAMES, 'Tab 1,+Tab 2,Tab 3').toString().split(',');

	var tabH = fontSize * 1.5;
	var startOffset = 10;
	var tabOffset = 5;
	var labelOffset = 10;
	var tabCount = tabNames.length;
	var minW = 2 * startOffset + (tabCount - 1) * tabOffset + tabCount * 2 * labelOffset;
	var rSize = 5;
	var labelWidths = new Array();
	var selectedTab = -1;

	for (var i = 0; i < tabCount; i++)
	{
		var currLabel = tabNames[i];

		if(currLabel.charAt(0) === '+')
		{
			currLabel = currLabel.substring(1);
			selectedTab = i;
		}

		var currW = mxUtils.getSizeForString(currLabel, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currW === 0)
		{
			labelWidths[i] = 42;
		}
		else
		{
			labelWidths[i] = currW;
		}

		minW = minW + labelWidths[i];
	}

	w = Math.max(w, minW);
	h = Math.max(h, tabH + rSize);

	c.translate(x, y);

	c.setShadow(false);
	this.backTabs(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab);
	this.focusTab(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab);
	this.tabText(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab, tabNames);
};

mxShapeMockupWedgeBar.prototype.backTabs = function(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab)
{
	var tabStyle = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.TAB_STYLE, mxShapeMockupWedgeBar.prototype.cst.BLOCK);

	var currW = startOffset;
	for (var i=0; i < tabCount; i++)
	{
		var tabW = labelWidths[i] + 2 * labelOffset;

		if (selectedTab !== i)
		{
			if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.BLOCK)
			{
				c.begin();
				c.moveTo(currW, tabH);
				c.lineTo(currW, 0);
				c.lineTo(currW + tabW, 0);
				c.lineTo(currW + tabW, tabH);
			}
			else if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.CONE)
			{
				c.begin();
				c.moveTo(currW, tabH);
				c.lineTo(currW + labelOffset * 0.5, 0);
				c.lineTo(currW + tabW - labelOffset * 0.5, 0);
				c.lineTo(currW + tabW, tabH);
			}
			else if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.HALF_CONE)
			{
				c.begin();
				c.moveTo(currW, tabH);
				c.lineTo(currW + labelOffset * 0.5, 0);
				c.lineTo(currW + tabW, 0);
				c.lineTo(currW + tabW, tabH);
			}
			else if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.ROUND)
			{
				c.begin();
				c.moveTo(currW - rSize, tabH);
				c.arcTo(rSize, rSize, 0, 0, 0, currW, tabH - rSize);
				c.lineTo(currW, rSize);
				c.arcTo(rSize, rSize, 0, 0, 1, currW + rSize, 0);
				c.lineTo(currW + tabW - rSize, 0);
				c.arcTo(rSize, rSize, 0, 0, 1, currW + tabW, rSize);
				c.lineTo(currW + tabW, tabH - rSize);
				c.arcTo(rSize, rSize, 0, 0, 0, currW + tabW + rSize, tabH);
			}

			c.fillAndStroke();
		}

		currW = currW + tabW + tabOffset;
	}
};

mxShapeMockupWedgeBar.prototype.focusTab = function(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab)
{
	var tabStyle = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.TAB_STYLE, mxShapeMockupWedgeBar.prototype.cst.BLOCK);
	var selectedFill = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.STYLE_FILLCOLOR2, '#008cff');

	var currW = startOffset;
	c.setStrokeColor(selectedFill);
	c.setFillColor(selectedFill);

	for (var i=0; i <= selectedTab; i++)
	{
		var tabW = labelWidths[i] + 2 * labelOffset;

		if (selectedTab === i)
		{
			if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.BLOCK)
			{
				c.begin();
				c.moveTo(currW, tabH);
				c.lineTo(currW, 0);
				c.lineTo(currW + tabW, 0);
				c.lineTo(currW + tabW, tabH);
			}
			else if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.CONE)
			{
				c.begin();
				c.moveTo(currW, tabH);
				c.lineTo(currW + labelOffset * 0.5, 0);
				c.lineTo(currW + tabW - labelOffset * 0.5, 0);
				c.lineTo(currW + tabW, tabH);
			}
			else if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.HALF_CONE)
			{
				c.begin();
				c.moveTo(currW, tabH);
				c.lineTo(currW + labelOffset * 0.5, 0);
				c.lineTo(currW + tabW, 0);
				c.lineTo(currW + tabW, tabH);
			}
			else if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.ROUND)
			{
				c.begin();
				c.moveTo(currW - rSize, tabH);
				c.arcTo(rSize, rSize, 0, 0, 0, currW, tabH - rSize);
				c.lineTo(currW, rSize);
				c.arcTo(rSize, rSize, 0, 0, 1, currW + rSize, 0);
				c.lineTo(currW + tabW - rSize, 0);
				c.arcTo(rSize, rSize, 0, 0, 1, currW + tabW, rSize);
				c.lineTo(currW + tabW, tabH - rSize);
				c.arcTo(rSize, rSize, 0, 0, 0, currW + tabW + rSize, tabH);
			}

			c.fillAndStroke();
		}

		currW = currW + tabW + tabOffset;
	}
};

mxShapeMockupWedgeBar.prototype.tabText = function(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab, tabNames)
{
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.TEXT_COLOR, '#666666');
	var selFontColor = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.SEL_TEXT_COLOR, '#ffffff');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.TEXT_SIZE, '17').toString();

	c.setFontColor(fontColor);
	c.setFontSize(fontSize);

	var currW = startOffset;

	for (var i=0; i < tabCount; i++)
	{
		var currLabel = tabNames[i];

		if (i === selectedTab)
		{
			c.setFontColor(selFontColor);
		}

		if (currLabel.charAt(0) === '+')
		{
			currLabel = currLabel.substring(1);
		}

		var tabW = labelWidths[i] + 2 * labelOffset;

		c.text(currW + labelOffset, tabH * 0.5, 0, 0, currLabel, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

		currW = currW + tabW + tabOffset;

		if (i === selectedTab)
		{
			c.setFontColor(fontColor);
		}
	}

};

mxCellRenderer.registerShape(mxShapeMockupWedgeBar.prototype.cst.SHAPE_WEDGE_BAR, mxShapeMockupWedgeBar);

//**********************************************************************************************************************************************************
//Search Box
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupSearchBox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupSearchBox, mxShape);

mxShapeMockupSearchBox.prototype.cst = {
		MAIN_TEXT : 'mainText',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize',
		STROKE_COLOR2 : 'strokeColor2',
		SHAPE_SEARCH_BOX : 'mxgraph.mockup.forms.searchBox'
};

mxShapeMockupSearchBox.prototype.customProperties = [
	{name: 'strokeColor2', dispName: 'Icon Color', type: 'color'},
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupSearchBox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupSearchBox.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupSearchBox.prototype.foreground = function(c, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxShapeMockupSearchBox.prototype.cst.MAIN_TEXT, 'Search');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupSearchBox.prototype.cst.TEXT_COLOR, '#666666');
	var strokeColor2 = mxUtils.getValue(this.style, mxShapeMockupSearchBox.prototype.cst.STROKE_COLOR2, '#008cff');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupSearchBox.prototype.cst.TEXT_SIZE, '17');

	c.setFontColor(fontColor);
	c.setFontSize(fontSize);

	c.text(5, h * 0.5, 0, 0, mainText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setStrokeColor(strokeColor2);
	c.ellipse(w - 15, h * 0.5 - 8, 10, 10);
	c.stroke();
	c.begin();
	c.moveTo(w - 19, h * 0.5 + 9);
	c.lineTo(w - 13, h * 0.5 + 1);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupSearchBox.prototype.cst.SHAPE_SEARCH_BOX, mxShapeMockupSearchBox);

//**********************************************************************************************************************************************************
//Sign In (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupSignIn(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupSignIn, mxShape);

mxShapeMockupSignIn.prototype.cst = {
		MAIN_TEXT : 'mainText',
		TEXT_COLOR : 'textColor',
		TEXT_COLOR2 : 'textColor2',
		TEXT_SIZE : 'textSize',
		TEXT_SIZE2 : 'textSize2',
		STROKE_COLOR2 : 'strokeColor2',
		FILL_COLOR2 : 'fillColor2',
		SHAPE_SIGN_IN : 'mxgraph.mockup.forms.signIn'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupSignIn.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupSignIn.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupSignIn.prototype.foreground = function(c, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxShapeMockupSignIn.prototype.cst.MAIN_TEXT, 'Sign In,User Name:,johndoe,Password:,********,Forgot Password?,New User,SIGN IN,SIGN UP').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupSignIn.prototype.cst.TEXT_COLOR, '#666666');
	var fontColor2 = mxUtils.getValue(this.style, mxShapeMockupSignIn.prototype.cst.TEXT_COLOR2, '#ffffff');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupSignIn.prototype.cst.TEXT_SIZE, '12');
	var fontSize2 = mxUtils.getValue(this.style, mxShapeMockupSignIn.prototype.cst.TEXT_SIZE2, '15');
	var strokeColor2 = mxUtils.getValue(this.style, mxShapeMockupSignIn.prototype.cst.STROKE_COLOR2, '#ddeeff');
	var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupSignIn.prototype.cst.FILL_COLOR2, '#66bbff');

	c.setFillColor(fillColor2);
	c.roundrect(w * 0.09, h * 0.52, w * 0.36, h * 0.09, 5, 5);
	c.fill();

	c.roundrect(w * 0.09, h * 0.84, w * 0.36, h * 0.09, 5, 5);
	c.fill();

	c.rect(w * 0.05, h * 0.22, w * 0.75, h * 0.08);
	c.stroke();

	c.rect(w * 0.05, h * 0.4, w * 0.75, h * 0.08);
	c.stroke();


	c.setStrokeColor(strokeColor2);
	c.setStrokeWidth(2);

	c.begin();	
	c.moveTo(w * 0.05, h * 0.12);
	c.lineTo(w * 0.95, h * 0.12);
	c.moveTo(w * 0.05, h * 0.72);
	c.lineTo(w * 0.95, h * 0.72);
	c.stroke();


	c.setFontColor(fontColor);
	c.setFontSize(fontSize);
	c.text(w * 0.05, h * 0.1, 0, 0, mainText[0], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_BOTTOM, 0, null, 0, 0, 0);
	c.text(w * 0.05, h * 0.2, 0, 0, mainText[1], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_BOTTOM, 0, null, 0, 0, 0);
	c.text(w * 0.075, h * 0.26, 0, 0, mainText[2], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.05, h * 0.38, 0, 0, mainText[3], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_BOTTOM, 0, null, 0, 0, 0);
	c.text(w * 0.075, h * 0.44, 0, 0, mainText[4], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.05, h * 0.8, 0, 0, mainText[6], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setStrokeWidth(1);
	c.setFontColor('#9999ff');
	c.setStrokeColor('#9999ff');
	var forgotW = mxUtils.getSizeForString(mainText[5], fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
	c.text(w * 0.05, h * 0.7, 0, 0, mainText[5], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_BOTTOM, 0, null, 0, 0, 0);

	c.begin();
	c.moveTo(w * 0.05, h * 0.7);
	c.lineTo(w * 0.05 + forgotW, h * 0.7);
	c.stroke();

	c.setFontColor(fontColor2);
	c.setFontStyle(mxConstants.FONT_BOLD);
	c.setFontSize(fontSize2);
	c.text(w * 0.27, h * 0.565, 0, 0, mainText[7], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.27, h * 0.885, 0, 0, mainText[8], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeMockupSignIn.prototype.cst.SHAPE_SIGN_IN, mxShapeMockupSignIn);

//**********************************************************************************************************************************************************
//Calendar (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupCalendar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupCalendar, mxShape);

mxShapeMockupCalendar.prototype.cst = {
		SHAPE_CALENDAR : 'mxgraph.mockup.forms.calendar',
		DAYS : 'days',
		SELECTED_DAY : 'selDay',
		PREV_DAYS : 'prevDays',
		FIRST_DAY : 'firstDay',
		START_ON : 'startOn',
		DAY_NAMES : 'dayNames',
		MAIN_TEXT : 'mainText',
		TEXT_SIZE : 'textSize',
		TEXT_COLOR : 'textColor',
		TEXT_COLOR2 : 'textColor2',
		STROKE_COLOR2 : 'strokeColor2',
		FILL_COLOR2 : 'fillColor2'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupCalendar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupCalendar.prototype.background = function(c, w, h)
{
	c.roundrect(0, 0, w, h, w * 0.0312, h * 0.0286);
	c.fillAndStroke();
};

mxShapeMockupCalendar.prototype.foreground = function(c, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#999999');
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var strokeColor2 = mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.STROKE_COLOR2, '#008cff');
	var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.FILL_COLOR2, '#ddeeff');
	var mainText = mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.MAIN_TEXT, '');
	var textSize = mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.TEXT_SIZE, '15');
	var textColor = mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.TEXT_COLOR, '#999999');
	var textColor2 = mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.TEXT_COLOR2, '#ffffff');
	var days = parseInt(mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.DAYS, '30'), 10);
	var prevDays = parseInt(mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.PREV_DAYS, '31'), 10);
	//month starts on Monday
	var firstDay = parseInt(mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.FIRST_DAY, '0'), 10);
	//week starts with Monday
	var startOn = parseInt(mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.START_ON, '6', 10));
	var dayNames = mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.DAY_NAMES, 'Mo,Tu,We,Th,Fr,Sa,Su').toString().split(',');
	var selDay = parseInt(mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.SELECTED_DAY, '24'), 10);

	fistDay = Math.max(firstDay, 0);
	startOn = Math.max(startOn, 0);
	fistDay = Math.min(firstDay, 6);
	startOn = Math.min(startOn, 6);

	//buttons
	c.roundrect(w * 0.05, h * 0.0457, w * 0.1438, h * 0.1029, w * 0.025, h * 0.0229);
	c.stroke();
	c.roundrect(w * 0.8125, h * 0.0457, w * 0.1438, h * 0.1029, w * 0.025, h * 0.0229);
	c.stroke();

	//button markers
	c.setStrokeWidth(2);
	c.setStrokeColor(strokeColor2);
	c.begin();
	c.moveTo(w * 0.1438, h * 0.0743);
	c.lineTo(w * 0.1, h * 0.0971);
	c.lineTo(w * 0.1438, h * 0.12);
	c.moveTo(w * 0.8625, h * 0.0743);
	c.lineTo(w * 0.9062, h * 0.0971);
	c.lineTo(w * 0.8625, h * 0.12);
	c.stroke();

	c.setFontSize(textSize);
	c.setFontColor(textColor);
	c.text(w * 0.5, h * 0.0971, 0, 0, mainText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	//write day names
	var range = w * 0.875;
	var cellSize = range / 7;

	for (var i = 0; i < 7; i++)
	{
		var currX = w * 0.0625 + cellSize * 0.5 + i * cellSize;
		var j = i + startOn;

		if (j > 6)
		{
			j = j - 7;
		}

		c.text(currX, h * 0.2114, 0, 0, dayNames[j], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}

	c.setStrokeWidth(1);
	//1st day is on first weekday as default
	var x = 0;
	var selX = -1;
	var selY = -1;

	//check if we need to write days from previous month
	if (firstDay !== startOn)
	{
		c.setStrokeColor(strokeColor);
		c.setFillColor(fillColor2);

		var diff = firstDay - startOn;
		if (diff < 0)
		{
			diff = diff + 7;
		}

		for (var i = 0; i < diff; i++)
		{
			var currX = w * 0.0625 + i * cellSize;
			c.rect(currX, h * 0.2686, cellSize, h * 0.1143);
			c.fillAndStroke();
			var tmp = prevDays - diff + i + 1;

			c.text(currX + cellSize * 0.5, h * 0.2686 + cellSize * 0.5, 0, 0, tmp.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		}

		x = diff;
	}

	//now we need to write the actual month days...
	c.setFillColor(fillColor);
	c.setStrokeColor(strokeColor);
	//week begins in first row
	var y = 0;

	for (var i = 0; i < days; i++)
	{
		var d = i + 1; 
		var currX = w * 0.0625 + x * cellSize;
		var currY = h * 0.2686 + y * h * 0.1143;

		if (d === selDay)
		{
			selX = currX;
			selY = currY;
		}
		else
		{
			c.rect(currX, currY, cellSize, h * 0.1143);
			c.fillAndStroke();
			c.text(currX + cellSize * 0.5, currY + cellSize * 0.5, 0, 0, d.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		}

		if (x < 6)
		{
			x++;
		}
		else
		{
			x = 0;
			y++;
		}
	}

	var i = 1;
	c.setFillColor(fillColor2);

	while (y < 6)
	{
		var currX = w * 0.0625 + x * cellSize;
		var currY = h * 0.2686 + y * h * 0.1143;
		c.rect(currX, currY, cellSize, h * 0.1143);
		c.fillAndStroke();

		c.text(currX + cellSize * 0.5, currY + cellSize * 0.5, 0, 0, i.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

		if (x < 6)
		{
			x++;
		}
		else
		{
			x = 0;
			y++;
		}

		i++;
	}

	if (selX >= 0)
	{
		c.setStrokeColor('#ff0000');
		c.setStrokeWidth(2);
		c.setFillColor(strokeColor2);
		c.setFontColor(textColor2);

		c.rect(selX, selY, cellSize, h * 0.1143);
		c.fillAndStroke();
		c.text(selX + cellSize * 0.5, selY + cellSize * 0.5, 0, 0, selDay.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
};

mxCellRenderer.registerShape(mxShapeMockupCalendar.prototype.cst.SHAPE_CALENDAR, mxShapeMockupCalendar);

//**********************************************************************************************************************************************************
//Email Form
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupEmailForm(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupEmailForm, mxShape);

mxShapeMockupEmailForm.prototype.cst = {
		MAIN_TEXT : 'mainText',
		TEXT_COLOR : 'textColor',
		SHOW_CC : 'showCC',
		SHOW_BCC : 'showBCC',
		TEXT_SIZE : 'textSize',
		SHAPE_EMAIL_FORM : 'mxgraph.mockup.forms.emailForm'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupEmailForm.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupEmailForm.prototype.cst.TEXT_SIZE, '12');
	var showCC = mxUtils.getValue(this.style, mxShapeMockupEmailForm.prototype.cst.SHOW_CC, 'true');
	var showBCC = mxUtils.getValue(this.style, mxShapeMockupEmailForm.prototype.cst.SHOW_BCC, 'true');
	var tabX = fontSize * 4;

	var optCount = 0;
	
	if (showCC === 'true')
	{
		optCount++;
	}
	
	if (showBCC === 'true')
	{
		optCount++;
	}
	
	w = Math.max(w, fontSize * 5);
	h = Math.max(h, fontSize * 10.5 + optCount * fontSize * 3);
	
	c.translate(x, y);
	this.background(c, w, h, fontSize, tabX, showCC, showBCC);
	c.setShadow(false);
	this.foreground(c, w, h, fontSize, tabX, showCC, showBCC);
};

mxShapeMockupEmailForm.prototype.background = function(c, w, h, fontSize, tabX, showCC, showBCC)
{
	var messX = fontSize * 9;

	if (showCC === 'true')
	{
		messX = messX + fontSize * 3;
		c.rect(tabX, fontSize * 9, w - tabX, fontSize * 1.5);
		c.fillAndStroke();
	}

	if (showBCC === 'true')
	{
		c.rect(tabX, messX, w - tabX, fontSize * 1.5);
		messX = messX + fontSize * 3;
		c.fillAndStroke();
	}

	c.rect(tabX, 0, w - tabX, fontSize * 1.5);
	c.fillAndStroke();
	c.rect(tabX, fontSize * 3, w - tabX, fontSize * 1.5);
	c.fillAndStroke();
	c.rect(tabX, fontSize * 6, w - tabX, fontSize * 1.5);
	c.fillAndStroke();
	c.rect(0, messX, w, h - messX);
	c.fillAndStroke();
};

mxShapeMockupEmailForm.prototype.foreground = function(c, w, h, fontSize, tabX, showCC, showBCC)
{
	var mainText = mxUtils.getValue(this.style, mxShapeMockupEmailForm.prototype.cst.MAIN_TEXT, 'john@jgraph.com,Greeting,fred@jgraph.com,,,Lorem ipsum').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupEmailForm.prototype.cst.TEXT_COLOR, '#666666');

	c.setFontColor(fontColor);
	c.setFontSize(fontSize);

	c.text(tabX - fontSize * 0.5, fontSize * 0.75, 0, 0, 'From', mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(tabX - fontSize * 0.5, fontSize * 3.75, 0, 0, 'Subject', mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(tabX - fontSize * 0.5, fontSize * 6.75, 0, 0, 'To', mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.text(tabX + fontSize * 0.5, fontSize * 0.75, 0, 0, mainText[0], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(tabX + fontSize * 0.5, fontSize * 3.75, 0, 0, mainText[1], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(tabX + fontSize * 0.5, fontSize * 6.75, 0, 0, mainText[2], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	
	var messX = fontSize * 9;

	if (showCC === 'true')
	{
		messX = messX + fontSize * 3;
		c.text(tabX - fontSize * 0.5, fontSize * 9.75, 0, 0, 'CC', mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		c.text(tabX + fontSize * 0.5, fontSize * 9.75, 0, 0, mainText[3], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}

	if (showBCC === 'true')
	{
		c.text(tabX - fontSize * 0.5, messX + fontSize * 0.75, 0, 0, 'BCC', mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		c.text(tabX + fontSize * 0.5, messX + fontSize * 0.75, 0, 0, mainText[4], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		messX = messX + fontSize * 3;
	}

	c.text(fontSize * 0.5, messX + fontSize * 0.75, 0, 0, mainText[5], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeMockupEmailForm.prototype.cst.SHAPE_EMAIL_FORM, mxShapeMockupEmailForm);

//**********************************************************************************************************************************************************
//Rounded rectangle (adjustable rounding)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupFormsRRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupFormsRRect, mxShape);

mxShapeMockupFormsRRect.prototype.cst = {
		RRECT : 'mxgraph.mockup.forms.rrect',
		R_SIZE : 'rSize'
};

mxShapeMockupFormsRRect.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupFormsRRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupFormsRRect.prototype.cst.R_SIZE, '10'));
	c.roundrect(0, 0, w, h, rSize);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupFormsRRect.prototype.cst.RRECT, mxShapeMockupFormsRRect);

//**********************************************************************************************************************************************************
//Anchor (a dummy shape without visuals used for anchoring)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupFormsAnchor(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupFormsAnchor, mxShape);

mxShapeMockupFormsAnchor.prototype.cst = {
		ANCHOR : 'mxgraph.mockup.forms.anchor'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupFormsAnchor.prototype.paintVertexShape = function(c, x, y, w, h)
{
};

mxCellRenderer.registerShape(mxShapeMockupFormsAnchor.prototype.cst.ANCHOR, mxShapeMockupFormsAnchor);

//**********************************************************************************************************************************************************
//Checkbox
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupFormsCheckbox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupFormsCheckbox, mxShape);

mxShapeMockupFormsCheckbox.prototype.cst = {
		CHECKBOX : 'mxgraph.mockup.forms.checkbox'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupFormsCheckbox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.rect(0, 0, w, h);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w * 0.8, h * 0.2);
	c.lineTo(w * 0.4, h * 0.8);
	c.lineTo(w * 0.25, h * 0.6);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupFormsCheckbox.prototype.cst.CHECKBOX, mxShapeMockupFormsCheckbox);

//**********************************************************************************************************************************************************
//U Rect
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupFormsURect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupFormsURect, mxShape);

mxShapeMockupFormsURect.prototype.cst = {
		U_RECT : 'mxgraph.mockup.forms.uRect'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupFormsURect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(0, h);
	c.lineTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupFormsURect.prototype.cst.U_RECT, mxShapeMockupFormsURect);


/**
 * $Id: mxMockupGraphics.js,v 1.5 2013/05/22 12:28:49 mate Exp $
 * Copyright (c) 2006-2010, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Bar Chart
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupBarChart(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupBarChart, mxShape);

mxShapeMockupBarChart.prototype.cst = {
		STROKE_COLOR2 : 'strokeColor2',
		STROKE_COLOR3 : 'strokeColor3',
		FILL_COLOR2 : 'fillColor2',
		FILL_COLOR3 : 'fillColor3',
		SHAPE_BAR_CHART : 'mxgraph.mockup.graphics.barChart'
};

mxShapeMockupBarChart.prototype.customProperties = [
	{name: 'strokeColor2', dispName: 'Stroke2 Color', type: 'color'},
	{name: 'strokeColor3', dispName: 'Stroke3 Color', type: 'color'},
	{name: 'fillColor2', dispName: 'Fill2 Color', type: 'color'},
	{name: 'fillColor3', dispName: 'Fill3 Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupBarChart.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.background(c, x, y, w, h);

	var bgFill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, 'none');

	if (bgFill !== 'none')
	{
		c.setShadow(false);
	}

	this.bars(c, x, y, w, h);
};

mxShapeMockupBarChart.prototype.background = function(c, x, y, w, h, bgColor, frameColor)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupBarChart.prototype.bars = function(c, x, y, w, h)
{
	var barStroke = mxUtils.getValue(this.style, mxShapeMockupBarChart.prototype.cst.STROKE_COLOR2, 'none');
	var coordStroke = mxUtils.getValue(this.style, mxShapeMockupBarChart.prototype.cst.STROKE_COLOR3, '#666666');
	var barFill1 = mxUtils.getValue(this.style, mxShapeMockupBarChart.prototype.cst.FILL_COLOR2, '#008cff');
	var barFill2 = mxUtils.getValue(this.style, mxShapeMockupBarChart.prototype.cst.FILL_COLOR3, '#dddddd');

	var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '1');

	c.setStrokeColor(barStroke);
	c.setFillColor(barFill1);
	c.rect(0, h * 0.2, w * 0.75, h * 0.05);
	c.fillAndStroke();
	c.rect(0, h * 0.45, w * 0.6, h * 0.05);
	c.fillAndStroke();
	c.rect(0, h * 0.7, w * 0.95, h * 0.05);
	c.fillAndStroke();

	c.setFillColor(barFill2);
	c.rect(0, h * 0.25, w * 0.85, h * 0.05);
	c.fillAndStroke();
	c.rect(0, h * 0.5, w * 0.65, h * 0.05);
	c.fillAndStroke();
	c.rect(0, h * 0.75, w * 0.8, h * 0.05);
	c.fillAndStroke();

	c.setStrokeWidth(strokeWidth * 2);
	c.setStrokeColor(coordStroke);

	c.setShadow(false);
	c.begin();
	c.moveTo(0,0);
	c.lineTo(0, h);
	c.lineTo(w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupBarChart.prototype.cst.SHAPE_BAR_CHART, mxShapeMockupBarChart);

//**********************************************************************************************************************************************************
//Column Chart
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupColumnChart(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupColumnChart, mxShape);

mxShapeMockupColumnChart.prototype.cst = {
		STROKE_COLOR2 : 'strokeColor2',
		STROKE_COLOR3 : 'strokeColor3',
		FILL_COLOR2 : 'fillColor2',
		FILL_COLOR3 : 'fillColor3',
		SHAPE_COLUMN_CHART : 'mxgraph.mockup.graphics.columnChart'
};

mxShapeMockupColumnChart.prototype.customProperties = [
	{name: 'strokeColor2', dispName: 'Bar Stroke Color', type: 'color'},
	{name: 'strokeColor3', dispName: 'Coord System Color', type: 'color'},
	{name: 'fillColor2', dispName: 'Bar1 Color', type: 'color'},
	{name: 'fillColor3', dispName: 'Bar2 Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupColumnChart.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.background(c, x, y, w, h);

	var bgFill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, 'none');

	if (bgFill !== 'none')
	{
		c.setShadow(false);
	}

	this.bars(c, x, y, w, h);
};

mxShapeMockupColumnChart.prototype.background = function(c, x, y, w, h, bgColor, frameColor)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupColumnChart.prototype.bars = function(c, x, y, w, h)
{
	var barStroke = mxUtils.getValue(this.style, mxShapeMockupColumnChart.prototype.cst.STROKE_COLOR2, 'none');
	var coordStroke = mxUtils.getValue(this.style, mxShapeMockupColumnChart.prototype.cst.STROKE_COLOR3, '#666666');
	var barFill1 = mxUtils.getValue(this.style, mxShapeMockupColumnChart.prototype.cst.FILL_COLOR2, '#008cff');
	var barFill2 = mxUtils.getValue(this.style, mxShapeMockupColumnChart.prototype.cst.FILL_COLOR3, '#dddddd');

	var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '1');

	c.setStrokeColor(barStroke);
	c.setFillColor(barFill1);
	c.rect(w * 0.2, h * 0.25, w * 0.05, h * 0.75);
	c.fillAndStroke();
	c.rect(w * 0.45, h * 0.4, w * 0.05, h * 0.6);
	c.fillAndStroke();
	c.rect(w * 0.7, h * 0.05, w * 0.05, h * 0.95);
	c.fillAndStroke();

	c.setFillColor(barFill2);
	c.rect(w * 0.25, h * 0.15, w * 0.05, h * 0.85);
	c.fillAndStroke();
	c.rect(w * 0.5, h * 0.35, w * 0.05, h * 0.65);
	c.fillAndStroke();
	c.rect(w * 0.75, h * 0.2, w * 0.05, h * 0.8);
	c.fillAndStroke();

	c.setStrokeWidth(strokeWidth * 2);
	c.setStrokeColor(coordStroke);

	c.setShadow(false);

	c.begin();
	c.moveTo(0,0);
	c.lineTo(0, h);
	c.lineTo(w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupColumnChart.prototype.cst.SHAPE_COLUMN_CHART, mxShapeMockupColumnChart);

//**********************************************************************************************************************************************************
//Line Chart
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupLineChart(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupLineChart, mxShape);

mxShapeMockupLineChart.prototype.cst = {
		STROKE_COLOR2 : 'strokeColor2',
		STROKE_COLOR3 : 'strokeColor3',
		STROKE_COLOR4 : 'strokeColor4',
		SHAPE_LINE_CHART : 'mxgraph.mockup.graphics.lineChart'
};

mxShapeMockupLineChart.prototype.customProperties = [
	{name: 'strokeColor2', dispName: 'Coord. System Color', type: 'color'},
	{name: 'strokeColor3', dispName: 'Line1 Color', type: 'color'},
	{name: 'strokeColor4', dispName: 'Line2 Color', type: 'color'},
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupLineChart.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.background(c, x, y, w, h);

	var bgFill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, 'none');

	if (bgFill !== 'none')
	{
		c.setShadow(false);
	}

	this.bars(c, x, y, w, h);
};

mxShapeMockupLineChart.prototype.background = function(c, x, y, w, h, bgColor, frameColor)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupLineChart.prototype.bars = function(c, x, y, w, h)
{
	var coordStroke = mxUtils.getValue(this.style, mxShapeMockupLineChart.prototype.cst.STROKE_COLOR2, '#666666');
	var line1Stroke = mxUtils.getValue(this.style, mxShapeMockupLineChart.prototype.cst.STROKE_COLOR3, '#008cff');
	var line2Stroke = mxUtils.getValue(this.style, mxShapeMockupLineChart.prototype.cst.STROKE_COLOR4, '#dddddd');

	var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '1');

	c.setStrokeWidth(strokeWidth * 2);
	c.setStrokeColor(line2Stroke);
	c.begin();
	c.moveTo(0, h);
	c.lineTo(w * 0.3, h * 0.5);
	c.lineTo(w * 0.6, h * 0.74);
	c.lineTo(w * 0.9, h * 0.24);
	c.stroke();

	c.setStrokeColor(line1Stroke);
	c.begin();
	c.moveTo(0, h);
	c.lineTo(w * 0.3, h * 0.65);
	c.lineTo(w * 0.6, h * 0.6);
	c.lineTo(w * 0.9, h * 0.35);
	c.stroke();

	c.setStrokeColor(coordStroke);
	c.setShadow(false);

	c.begin();
	c.moveTo(0,0);
	c.lineTo(0, h);
	c.lineTo(w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupLineChart.prototype.cst.SHAPE_LINE_CHART, mxShapeMockupLineChart);

//**********************************************************************************************************************************************************
//Pie Chart
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupPieChart(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupPieChart, mxShape);

mxShapeMockupPieChart.prototype.cst = {
		PARTS : 'parts',
		PART_COLORS : 'partColors',
		SHAPE_PIE_CHART : 'mxgraph.mockup.graphics.pieChart'
};

mxShapeMockupPieChart.prototype.customProperties = [
	{name: 'partsCount', dispName: 'partsCount', type: 'int', defVal: 4, dependentProps: ['partColors', 'parts']},
	{name: 'partColors', dispName: 'Part Colors', type: 'staticArr', subType: 'color', sizeProperty: 'partsCount', subDefVal: '#FFFFFF'},
	{name: 'parts', dispName: 'Part Sizes', type: 'staticArr', subType: 'int', sizeProperty: 'partsCount', subDefVal: '10'},
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupPieChart.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupPieChart.prototype.background = function(c, x, y, w, h, bgColor, frameColor)
{
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupPieChart.prototype.foreground = function(c, x, y, w, h)
{
	var parts = mxUtils.getValue(this.style, mxShapeMockupPieChart.prototype.cst.PARTS, '10,20,30').toString().split(',');
	var partNum = parts.length;
	var partColors = mxUtils.getValue(this.style, mxShapeMockupPieChart.prototype.cst.PART_COLORS, '#333333,#666666,#999999').toString().split(',');
	var total = 0;

	for (var i = 0; i < partNum; i++)
	{
		total = total + parseInt(parts[i], 10);
	}


	for (var i = 0; i < partNum; i++)
	{
		if (partColors.length > i)
		{
			c.setFillColor(partColors[i]);
		}
		else
		{
			c.setFillColor('#ff0000');
		}

		var beginPerc = 0;
		var endPerc = 0;
		var currPerc = parseInt(parts[i], 10) / total;

		if (currPerc === 0.5)
		{
			currPerc = 0.501;
		}

		for (var j = 0; j < i; j++)
		{
			beginPerc = beginPerc + parseInt(parts[j], 10) / total;
		}

		endPerc = currPerc + beginPerc;
		var startAngle = 2 * Math.PI * beginPerc;
		var endAngle = 2 * Math.PI * endPerc;

		var x1 = w * 0.5 - w * Math.sin(startAngle) * 0.5;
		var y1 = h * 0.5 - h * Math.cos(startAngle) * 0.5;
		var x2 = w * 0.5 - w * Math.sin(endAngle) * 0.5;
		var y2 = h * 0.5 - h * Math.cos(endAngle) * 0.5;		
		var largeArc = 1;
		var sweep = 1;

		if (endPerc - beginPerc < 0.5)
		{
			largeArc = 0;
		}

		c.begin();
		c.moveTo(w * 0.5, h * 0.5);
		c.lineTo(x2, y2);
		c.arcTo(w * 0.5, h * 0.5, 0, largeArc, 1, x1, y1);
		c.close();
		c.fillAndStroke();
	}
};

mxCellRenderer.registerShape(mxShapeMockupPieChart.prototype.cst.SHAPE_PIE_CHART, mxShapeMockupPieChart);

//**********************************************************************************************************************************************************
//Icon Grid (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupIconGrid(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupIconGrid, mxShape);

mxShapeMockupIconGrid.prototype.cst = {
		GRID_SIZE : 'gridSize',
		SHAPE_ICON_GRID : 'mxgraph.mockup.graphics.iconGrid'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupIconGrid.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var gridSize = mxUtils.getValue(this.style, mxShapeMockupIconGrid.prototype.cst.GRID_SIZE, '3,3').toString().split(',');
	this.background(c, w, h, gridSize);
	c.setShadow(false);

	this.foreground(c, w, h, gridSize);
};

mxShapeMockupIconGrid.prototype.background = function(c, w, h, gridSize)
{
	var boxSizeX = w / (parseInt(gridSize[0],10) + (gridSize[0]-1) * 0.5);
	var boxSizeY = h / (parseInt(gridSize[1],10) + (gridSize[1]-1) * 0.5);

	for (var i = 0; i < gridSize[0]; i++)
	{
		for (var j = 0; j < gridSize[1]; j++)
		{
			c.rect(boxSizeX * 1.5 * i, boxSizeY * 1.5 * j, boxSizeX, boxSizeY);
			c.fillAndStroke();
		}
	}
};

mxShapeMockupIconGrid.prototype.foreground = function(c, w, h, gridSize)
{
	var boxSizeX = w / (parseInt(gridSize[0],10) + (gridSize[0]-1) * 0.5);
	var boxSizeY = h / (parseInt(gridSize[1],10) + (gridSize[1]-1) * 0.5);

	for (var i = 0; i < gridSize[0]; i++)
	{
		for (var j = 0; j < gridSize[1]; j++)
		{
			c.begin();
			c.moveTo(boxSizeX * 1.5 * i, boxSizeY * 1.5 * j);
			c.lineTo(boxSizeX * 1.5 * i + boxSizeX, boxSizeY * 1.5 * j + boxSizeY);
			c.moveTo(boxSizeX * 1.5 * i + boxSizeX, boxSizeY * 1.5 * j);
			c.lineTo(boxSizeX * 1.5 * i, boxSizeY * 1.5 * j + boxSizeY);
			c.stroke();
		}
	}
};

mxCellRenderer.registerShape(mxShapeMockupIconGrid.prototype.cst.SHAPE_ICON_GRID, mxShapeMockupIconGrid);

//**********************************************************************************************************************************************************
//Bubble Chart
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupBubbleChart(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupBubbleChart, mxShape);

mxShapeMockupBubbleChart.prototype.cst = {
		STROKE_COLOR2 : 'strokeColor2',
		STROKE_COLOR3 : 'strokeColor3',
		FILL_COLOR2 : 'fillColor2',
		FILL_COLOR3 : 'fillColor3',
		SHAPE_BUBBLE_CHART : 'mxgraph.mockup.graphics.bubbleChart'
};

mxShapeMockupBubbleChart.prototype.customProperties = [
	{name: 'strokeColor2', dispName: 'Bubble Stroke Color', type: 'color'},
	{name: 'strokeColor3', dispName: 'Coord. System Color', type: 'color'},
	{name: 'fillColor2', dispName: 'Bubble1 Color', type: 'color'},
	{name: 'fillColor3', dispName: 'Bubble2 Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupBubbleChart.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.background(c, x, y, w, h);

	var bgFill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, 'none');

	if (bgFill !== 'none')
	{
		c.setShadow(false);
	}

	this.bars(c, x, y, w, h);
};

mxShapeMockupBubbleChart.prototype.background = function(c, x, y, w, h, bgColor, frameColor)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupBubbleChart.prototype.bars = function(c, x, y, w, h)
{
	var barStroke = mxUtils.getValue(this.style, mxShapeMockupBubbleChart.prototype.cst.STROKE_COLOR2, 'none');
	var coordStroke = mxUtils.getValue(this.style, mxShapeMockupBubbleChart.prototype.cst.STROKE_COLOR3, '#666666');
	var barFill1 = mxUtils.getValue(this.style, mxShapeMockupBubbleChart.prototype.cst.FILL_COLOR2, '#008cff');
	var barFill2 = mxUtils.getValue(this.style, mxShapeMockupBubbleChart.prototype.cst.FILL_COLOR3, '#dddddd');

	var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '1');

	c.setStrokeColor(barStroke);
	c.setFillColor(barFill1);

	var cx = w * 0.4;
	var cy = h * 0.45; 
	var r = Math.min(h, w) * 0.14;
	c.ellipse(cx - r, cy - r, 2 * r, 2 * r);
	c.fillAndStroke();

	cx = w * 0.1;
	cy = h * 0.8; 
	r = Math.min(h, w) * 0.1;
	c.ellipse(cx - r, cy - r, 2 * r, 2 * r);
	c.fillAndStroke();

	cx = w * 0.7;
	cy = h * 0.7; 
	r = Math.min(h, w) * 0.22;
	c.ellipse(cx - r, cy - r, 2 * r, 2 * r);
	c.fillAndStroke();

	c.setFillColor(barFill2);
	cx = w * 0.15;
	cy = h * 0.25; 
	r = Math.min(h, w) * 0.19;
	c.ellipse(cx - r, cy - r, 2 * r, 2 * r);
	c.fillAndStroke();

	cx = w * 0.48;
	cy = h * 0.7; 
	r = Math.min(h, w) * 0.12;
	c.ellipse(cx - r, cy - r, 2 * r, 2 * r);
	c.fillAndStroke();

	cx = w * 0.74;
	cy = h * 0.17; 
	r = Math.min(h, w) * 0.1;
	c.ellipse(cx - r, cy - r, 2 * r, 2 * r);
	c.fillAndStroke();

	c.setStrokeWidth(strokeWidth * 2);
	c.setStrokeColor(coordStroke);

	c.setShadow(false);
	c.begin();
	c.moveTo(0,0);
	c.lineTo(0, h);
	c.lineTo(w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupBubbleChart.prototype.cst.SHAPE_BUBBLE_CHART, mxShapeMockupBubbleChart);

//**********************************************************************************************************************************************************
//Gauge
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupGauge(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.gaugePos = 25;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupGauge, mxShape);

mxShapeMockupGauge.prototype.cst = {
		SCALE_COLORS : 'scaleColors',
		GAUGE_LABELS : 'gaugeLabels',
		NEEDLE_COLOR : 'needleColor',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize',
		GAUGE_POS : 'gaugePos',
		SHAPE_GAUGE : 'mxgraph.mockup.graphics.gauge'
};

mxShapeMockupGauge.prototype.customProperties = [
	{name: 'scaleColors', dispName: 'Scale Colors', type: 'String'},
	{name: 'needleColor', dispName: 'Needle Color', type: 'color'},
	{name: 'gaugePos', dispName: 'Needle Position', type: 'float', min:0, max:100, defVal:25}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupGauge.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupGauge.prototype.background = function(c, w, h)
{
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupGauge.prototype.foreground = function(c, w, h)
{
	var gaugePos = mxUtils.getValue(this.style, mxShapeMockupGauge.prototype.cst.GAUGE_POS, '0');
	var scaleColors = mxUtils.getValue(this.style, mxShapeMockupGauge.prototype.cst.SCALE_COLORS, '#888888,#aaaaaa,#444444').toString().split(',');
	var gaugeLabels = mxUtils.getValue(this.style, mxShapeMockupGauge.prototype.cst.GAUGE_LABELS, 'CPU[%],0,100').toString().split(',');
	var needleColor = mxUtils.getValue(this.style, mxShapeMockupGauge.prototype.cst.NEEDLE_COLOR, '#008cff');
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var textColor = mxUtils.getValue(this.style, mxShapeMockupGauge.prototype.cst.TEXT_COLOR, '#666666');
	var textSize = mxUtils.getValue(this.style, mxShapeMockupGauge.prototype.cst.TEXT_SIZE, '12');

	gaugePos = Math.max(0, gaugePos);
	gaugePos = Math.min(100, gaugePos);

	c.setFillColor(scaleColors[1]);
	c.begin();
	c.moveTo(w * 0.05, h * 0.5);
	c.arcTo(w * 0.4, h * 0.4, 0, 0, 1, w * 0.95, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.arcTo(w * 0.5, h * 0.5, 0, 0, 0, 0, h * 0.5);
	c.close();
	c.fill();

	c.setFillColor(scaleColors[0]);
	c.begin();
	c.moveTo(w * 0.05, h * 0.5);
	c.arcTo(w * 0.45, h * 0.45, 0, 0, 0, w * 0.182, h * 0.818);
	c.lineTo(w * 0.146, h * 0.854);
	c.arcTo(w * 0.5, h * 0.5, 0, 0, 1, 0, h * 0.5);
	c.close();
	c.fill();

	c.setFillColor(scaleColors[2]);
	c.begin();
	c.moveTo(w, h * 0.5);
	c.arcTo(w * 0.5, h * 0.5, 0, 0, 1, w * 0.854, h * 0.854);
	c.lineTo(w * 0.818, h * 0.818);
	c.arcTo(w * 0.45, h * 0.45, 0, 0, 0, w * 0.95, h * 0.5);
	c.close();
	c.fill();

	c.setFontSize(textSize);
	c.setFontColor(textColor);
	c.text(w * 0.5, h * 0.3, 0, 0, gaugeLabels[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.2, h * 0.85, 0, 0, gaugeLabels[1], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.8, h * 0.85, 0, 0, gaugeLabels[2], mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	var needlePos = (0.75 * (2 * Math.PI * parseFloat(gaugePos) / 100) + 1.25 * Math.PI);

	var x1 = w * 0.5 + w * 0.38 * Math.sin(needlePos);
	var y1 = h * 0.5 - h * 0.38 * Math.cos(needlePos);
	var x2 = 0;
	var y2 = 0;
	c.setFillColor(needleColor);
	c.begin();
	c.moveTo(x1, y1);

	x1 = w * 0.5 + w * 0.05 * Math.cos(needlePos);
	y1 = h * 0.5 + h * 0.05 * Math.sin(needlePos);
	c.lineTo(x1, y1);

	x2 = w * 0.5 + w * (-0.05) * Math.sin(needlePos);
	y2 = h * 0.5 - h * (-0.05) * Math.cos(needlePos);
	c.arcTo(w * 0.05, h * 0.05, 0, 0, 1, x2, y2);

	x1 = x2;
	y1 = y2;
	x2 = w * 0.5 - w * 0.05 * Math.cos(needlePos);
	y2 = h * 0.5 - h * 0.05 * Math.sin(needlePos);
	c.arcTo(w * 0.05, h * 0.05, 0, 0, 1, x2, y2);
	c.close();
	c.fill();

	c.setFillColor(fillColor);
	c.begin();
	c.moveTo(w * 0.49, h * 0.49);
	c.lineTo(w * 0.51, h * 0.49);
	c.lineTo(w * 0.51, h * 0.51);
	c.lineTo(w * 0.49, h * 0.51);
	c.close();
	c.fill();

	c.begin();
	c.ellipse(0, 0, w, h);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.146, h * 0.854);
	c.lineTo(w * 0.219, h * 0.781);
	c.moveTo(w * 0.854, h * 0.854);
	c.lineTo(w * 0.781, h * 0.781);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupGauge.prototype.cst.SHAPE_GAUGE, mxShapeMockupGauge);

Graph.handleFactory[mxShapeMockupGauge.prototype.cst.SHAPE_GAUGE] = function(state)
{
	var handles = [Graph.createHandle(state, ['gaugePos'], function(bounds)
			{
				var gaugePos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'gaugePos', this.gaugePos))));

				return new mxPoint(bounds.x + bounds.width * 0.2 + gaugePos * 0.6 * bounds.width / 100, bounds.y + bounds.height * 0.8);
			}, function(bounds, pt)
			{
				this.state.style['gaugePos'] = Math.round(1000 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 1000;
			})];

	return handles;
}

//**********************************************************************************************************************************************************
//Plot Chart
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupPlotChart(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupPlotChart, mxShape);

mxShapeMockupPlotChart.prototype.cst = {
		STROKE_COLOR2 : 'strokeColor2',
		STROKE_COLOR3 : 'strokeColor3',
		SHAPES_COLORS : 'fillColor2',
		SHAPE_PLOT_CHART : 'mxgraph.mockup.graphics.plotChart'
};

mxShapeMockupPlotChart.prototype.customProperties = [
	{name: 'strokeColor2', dispName: 'Bubble Stroke Color', type: 'color'},
	{name: 'strokeColor3', dispName: 'Coord. System Color', type: 'color'},
	{name: 'fillColor2', dispName: 'Shapes Color', type: 'string'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupPlotChart.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.background(c, x, y, w, h);

	var bgFill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, 'none');

	if (bgFill !== 'none')
	{
		c.setShadow(false);
	}

	this.foreground(c, x, y, w, h);
};

mxShapeMockupPlotChart.prototype.background = function(c, x, y, w, h, bgColor, frameColor)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupPlotChart.prototype.foreground = function(c, x, y, w, h)
{
	var shapeStroke = mxUtils.getValue(this.style, mxShapeMockupPlotChart.prototype.cst.STROKE_COLOR2, '#dddddd');
	var coordStroke = mxUtils.getValue(this.style, mxShapeMockupPlotChart.prototype.cst.STROKE_COLOR3, '#666666');
	var shapesColors = mxUtils.getValue(this.style, mxShapeMockupPlotChart.prototype.cst.SHAPES_COLORS, '#00aaff,#0044ff,#008cff').toString().split(',');

	var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '1');
	var shapeSize = Math.min(w, h) * 0.03;

	c.setStrokeColor(shapeStroke);
	c.setFillColor(shapesColors[0]);

	var cx = w * 0.2;
	var cy = h * 0.8;
	c.begin();
	c.moveTo(cx - shapeSize * 0.5, cy - shapeSize * 0.5);
	c.lineTo(cx + shapeSize * 0.5, cy - shapeSize * 0.5);
	c.lineTo(cx + shapeSize * 0.5, cy + shapeSize * 0.5);
	c.lineTo(cx - shapeSize * 0.5, cy + shapeSize * 0.5);
	c.close();
	c.fillAndStroke();

	cx = w * 0.3;
	cy = h * 0.65;
	c.begin();
	c.moveTo(cx - shapeSize * 0.5, cy - shapeSize * 0.5);
	c.lineTo(cx + shapeSize * 0.5, cy - shapeSize * 0.5);
	c.lineTo(cx + shapeSize * 0.5, cy + shapeSize * 0.5);
	c.lineTo(cx - shapeSize * 0.5, cy + shapeSize * 0.5);
	c.close();
	c.fillAndStroke();

	cx = w * 0.6;
	cy = h * 0.44;
	c.begin();
	c.moveTo(cx - shapeSize * 0.5, cy - shapeSize * 0.5);
	c.lineTo(cx + shapeSize * 0.5, cy - shapeSize * 0.5);
	c.lineTo(cx + shapeSize * 0.5, cy + shapeSize * 0.5);
	c.lineTo(cx - shapeSize * 0.5, cy + shapeSize * 0.5);
	c.close();
	c.fillAndStroke();

	cx = w * 0.85;
	cy = h * 0.9;
	c.begin();
	c.moveTo(cx - shapeSize * 0.5, cy - shapeSize * 0.5);
	c.lineTo(cx + shapeSize * 0.5, cy - shapeSize * 0.5);
	c.lineTo(cx + shapeSize * 0.5, cy + shapeSize * 0.5);
	c.lineTo(cx - shapeSize * 0.5, cy + shapeSize * 0.5);
	c.close();
	c.fillAndStroke();

	c.setFillColor(shapesColors[1]);
	cx = w * 0.08;
	cy = h * 0.65;
	c.begin();
	c.moveTo(cx, cy - shapeSize * 0.5);
	c.lineTo(cx + shapeSize * 0.5, cy + shapeSize * 0.5);
	c.lineTo(cx - shapeSize * 0.5, cy + shapeSize * 0.5);
	c.close();
	c.fillAndStroke();

	cx = w * 0.58;
	cy = h * 0.85;
	c.begin();
	c.moveTo(cx, cy - shapeSize * 0.5);
	c.lineTo(cx + shapeSize * 0.5, cy + shapeSize * 0.5);
	c.lineTo(cx - shapeSize * 0.5, cy + shapeSize * 0.5);
	c.close();
	c.fillAndStroke();

	cx = w * 0.72;
	cy = h * 0.92;
	c.begin();
	c.moveTo(cx, cy - shapeSize * 0.5);
	c.lineTo(cx + shapeSize * 0.5, cy + shapeSize * 0.5);
	c.lineTo(cx - shapeSize * 0.5, cy + shapeSize * 0.5);
	c.close();
	c.fillAndStroke();

	c.setFillColor(shapesColors[2]);
	cx = w * 0.32;
	cy = h * 0.28;
	c.begin();
	c.moveTo(cx, cy - shapeSize * 0.75);
	c.lineTo(cx + shapeSize * 0.75, cy);
	c.lineTo(cx, cy + shapeSize * 0.75);
	c.lineTo(cx - shapeSize * 0.75, cy);
	c.close();
	c.fillAndStroke();

	cx = w * 0.92;
	cy = h * 0.45;
	c.begin();
	c.moveTo(cx, cy - shapeSize * 0.75);
	c.lineTo(cx + shapeSize * 0.75, cy);
	c.lineTo(cx, cy + shapeSize * 0.75);
	c.lineTo(cx - shapeSize * 0.75, cy);
	c.close();
	c.fillAndStroke();

	cx = w * 0.81;
	cy = h * 0.37;
	c.begin();
	c.moveTo(cx, cy - shapeSize * 0.75);
	c.lineTo(cx + shapeSize * 0.75, cy);
	c.lineTo(cx, cy + shapeSize * 0.75);
	c.lineTo(cx - shapeSize * 0.75, cy);
	c.close();
	c.fillAndStroke();

	cx = w * 0.51;
	cy = h * 0.7;
	c.begin();
	c.moveTo(cx, cy - shapeSize * 0.75);
	c.lineTo(cx + shapeSize * 0.75, cy);
	c.lineTo(cx, cy + shapeSize * 0.75);
	c.lineTo(cx - shapeSize * 0.75, cy);
	c.close();
	c.fillAndStroke();

	c.setStrokeWidth(strokeWidth * 2);
	c.setStrokeColor(coordStroke);

	c.setShadow(false);
	c.begin();
	c.moveTo(0,0);
	c.lineTo(0, h);
	c.lineTo(w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupPlotChart.prototype.cst.SHAPE_PLOT_CHART, mxShapeMockupPlotChart);

//**********************************************************************************************************************************************************
//Gantt Chart
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupGanttChart(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupGanttChart, mxShape);

mxShapeMockupGanttChart.prototype.cst = {
		STROKE_COLOR2 : 'strokeColor2',
		STROKE_COLOR3 : 'strokeColor3',
		SHAPES_COLORS : 'fillColor2',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize',
		SHAPE_GANTT_CHART : 'mxgraph.mockup.graphics.ganttChart'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupGanttChart.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupGanttChart.prototype.background = function(c, x, y, w, h, bgColor, frameColor)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupGanttChart.prototype.foreground = function(c, x, y, w, h)
{
	var shapesColors = mxUtils.getValue(this.style, mxShapeMockupGanttChart.prototype.cst.SHAPES_COLORS, '#888888,#bbbbbb').toString().split(',');
	var textColor = mxUtils.getValue(this.style, mxShapeMockupGanttChart.prototype.cst.TEXT_COLOR, '#666666');
	var textSize = mxUtils.getValue(this.style, mxShapeMockupGanttChart.prototype.cst.TEXT_SIZE, '#12');

	c.begin();
	c.moveTo(0, h * 0.13);
	c.lineTo(w, h * 0.13);
	c.moveTo(w * 0.4, 0);
	c.lineTo(w * 0.4, h);
	c.moveTo(w * 0.4, h * 0.065);
	c.lineTo(w, h * 0.065);
	c.moveTo(w * 0.03, 0);
	c.lineTo(w * 0.03, h * 0.13);
	c.moveTo(w * 0.1, 0);
	c.lineTo(w * 0.1, h * 0.13);
	c.moveTo(w * 0.315, 0);
	c.lineTo(w * 0.315, h * 0.13);
	c.moveTo(w * 0.45, h * 0.065);
	c.lineTo(w * 0.45, h * 0.13);
	c.moveTo(w * 0.5, h * 0.065);
	c.lineTo(w * 0.5, h);
	c.moveTo(w * 0.55, h * 0.065);
	c.lineTo(w * 0.55, h * 0.13);
	c.moveTo(w * 0.6, h * 0.065);
	c.lineTo(w * 0.6, h);
	c.moveTo(w * 0.65, h * 0.065);
	c.lineTo(w * 0.65, h * 0.13);
	c.moveTo(w * 0.7, h * 0.065);
	c.lineTo(w * 0.7, h);
	c.moveTo(w * 0.75, 0);
	c.lineTo(w * 0.75, h * 0.13);
	c.moveTo(w * 0.8, h * 0.065);
	c.lineTo(w * 0.8, h);
	c.moveTo(w * 0.85, h * 0.065);
	c.lineTo(w * 0.85, h * 0.13);
	c.moveTo(w * 0.9, h * 0.065);
	c.lineTo(w * 0.9, h);
	c.moveTo(w * 0.95, h * 0.065);
	c.lineTo(w * 0.95, h * 0.13);
	c.stroke();

	c.setFillColor(shapesColors[0]);
	c.begin();
	c.moveTo(w * 0.41, h * 0.15);
	c.lineTo(w * 0.64, h * 0.15);
	c.lineTo(w * 0.64, h * 0.18);
	c.lineTo(w * 0.625, h * 0.21);
	c.lineTo(w * 0.61, h * 0.18);
	c.lineTo(w * 0.44, h * 0.18);
	c.lineTo(w * 0.425, h * 0.21);
	c.lineTo(w * 0.41, h * 0.18);
	c.close();
	c.moveTo(w * 0.41, h * 0.24);
	c.lineTo(w * 0.49, h * 0.24);
	c.lineTo(w * 0.49, h * 0.275);
	c.lineTo(w * 0.41, h * 0.275);
	c.close();
	c.moveTo(w * 0.46, h * 0.31);
	c.lineTo(w * 0.64, h * 0.31);
	c.lineTo(w * 0.64, h * 0.345);
	c.lineTo(w * 0.46, h * 0.345);
	c.close();
	c.moveTo(w * 0.56, h * 0.39);
	c.lineTo(w * 0.69, h * 0.39);
	c.lineTo(w * 0.69, h * 0.425);
	c.lineTo(w * 0.56, h * 0.425);
	c.close();
	c.fill();

	c.setFillColor(shapesColors[1]);
	c.begin();
	c.moveTo(w * 0.46, h * 0.32);
	c.lineTo(w * 0.58, h * 0.32);
	c.lineTo(w * 0.58, h * 0.335);
	c.lineTo(w * 0.46, h * 0.335);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeMockupGanttChart.prototype.cst.SHAPE_GANTT_CHART, mxShapeMockupGanttChart);

//**********************************************************************************************************************************************************
//Simple Icon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupSimpleIcon(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupSimpleIcon, mxShape);

mxShapeMockupSimpleIcon.prototype.cst = {
		SIMPLE_ICON : 'mxgraph.mockup.graphics.simpleIcon'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupSimpleIcon.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.rect(0, 0, w, h);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, h);
	c.moveTo(0, h);
	c.lineTo(w, 0);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupSimpleIcon.prototype.cst.SIMPLE_ICON, mxShapeMockupSimpleIcon);

//**********************************************************************************************************************************************************
//Anchor (a dummy shape without visuals used for anchoring)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupGraphicsAnchor(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupGraphicsAnchor, mxShape);

mxShapeMockupGraphicsAnchor.prototype.cst = {
		ANCHOR : 'mxgraph.mockup.graphics.anchor'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupGraphicsAnchor.prototype.paintVertexShape = function(c, x, y, w, h)
{
};

mxCellRenderer.registerShape(mxShapeMockupGraphicsAnchor.prototype.cst.ANCHOR, mxShapeMockupGraphicsAnchor);

//**********************************************************************************************************************************************************
//Rounded rectangle (adjustable rounding)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupGraphicsRRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupGraphicsRRect, mxShape);

mxShapeMockupGraphicsRRect.prototype.cst = {
		RRECT : 'mxgraph.mockup.graphics.rrect',
		R_SIZE : 'rSize'
};

mxShapeMockupGraphicsRRect.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupGraphicsRRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupGraphicsRRect.prototype.cst.R_SIZE, '10'));
	c.roundrect(0, 0, w, h, rSize);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupGraphicsRRect.prototype.cst.RRECT, mxShapeMockupGraphicsRRect);


/**
 * $Id: mxMockupMarkup.js,v 1.5 2013/02/27 14:30:39 mate Exp $
 * Copyright (c) 2006-2010, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Horizontal Curly Brace
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupCurlyBrace(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupCurlyBrace, mxShape);

mxShapeMockupCurlyBrace.prototype.cst = {
		SHAPE_CURLY_BRACE : 'mxgraph.mockup.markup.curlyBrace'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupCurlyBrace.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxShapeMockupCurlyBrace.prototype.background = function(c, x, y, w, h)
{
	var midY = h * 0.5;
	var rSize = Math.min(w * 0.125, midY);
	c.begin();
	c.moveTo(0, midY + rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, midY);
	c.lineTo(w * 0.5 - rSize, midY);
	c.arcTo(rSize, rSize, 0, 0, 0, w * 0.5, midY - rSize);
	c.arcTo(rSize, rSize, 0, 0, 0, w * 0.5 + rSize, midY);
	c.lineTo(w - rSize, midY);
	c.arcTo(rSize, rSize, 0, 0, 1, w, midY + rSize);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupCurlyBrace.prototype.cst.SHAPE_CURLY_BRACE, mxShapeMockupCurlyBrace);

//**********************************************************************************************************************************************************
//Line
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupLine(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupLine, mxShape);

mxShapeMockupLine.prototype.cst = {
		SHAPE_LINE : 'mxgraph.mockup.markup.line'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupLine.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupLine.prototype.cst.SHAPE_LINE, mxShapeMockupLine);

//**********************************************************************************************************************************************************
//Scratch Out
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupScratchOut(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupScratchOut, mxShape);

mxShapeMockupScratchOut.prototype.cst = {
		SHAPE_SCRATCH_OUT : 'mxgraph.mockup.markup.scratchOut'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupScratchOut.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.begin();
	c.moveTo(w * 0.038, h * 0.095);
	c.curveTo(w * 0.038, h * 0.095, w * 0.289, h * -0.045, w * 0.186, h * 0.05);
	c.curveTo(w * 0.084, h * 0.145, w * -0.046, h * 0.251, w * 0.072, h * 0.208);
	c.curveTo(w * 0.191, h * 0.164, w * 0.522, h * -0.09, w * 0.366, h * 0.062);
	c.curveTo(w * 0.21, h * 0.215, w * -0.094, h * 0.38, w * 0.108, h * 0.304);
	c.curveTo(w * 0.309, h * 0.228, w * 0.73, h * -0.126, w * 0.544, h * 0.096);
	c.curveTo(w * 0.358, h * 0.319, w * -0.168, h * 0.592, w * 0.108, h * 0.476);
	c.curveTo(w * 0.382, h * 0.36, w * 0.972, h * -0.138, w * 0.779, h * 0.114);
	c.curveTo(w * 0.585, h * 0.365, w * -0.12, h * 0.688, w * 0.071, h * 0.639);
	c.curveTo(w * 0.262, h * 0.59, w * 1.174, h * 0.012, w * 0.936, h * 0.238);
	c.curveTo(w * 0.699, h * 0.462, w * -0.216, h * 0.855, w * 0.085, h * 0.806);
	c.curveTo(w * 0.386, h * 0.758, w * 1.185, h * 0.26, w * 0.935, h * 0.534);
	c.curveTo(w * 0.685, h * 0.808, w * -0.186, h * 0.94, w * 0.236, h * 0.895);
	c.curveTo(w * 0.659, h * 0.85, w * 1.095, h * 0.608, w * 0.905, h * 0.769);
	c.curveTo(w * 0.715, h * 0.93, w * 0.286, h * 0.962, w * 0.661, h * 0.931);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupScratchOut.prototype.cst.SHAPE_SCRATCH_OUT, mxShapeMockupScratchOut);

//**********************************************************************************************************************************************************
//Red X
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupRedX(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupRedX, mxShape);

mxShapeMockupRedX.prototype.cst = {
		SHAPE_RED_X : 'mxgraph.mockup.markup.redX'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupRedX.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.begin();
	c.moveTo(w * 0.1, 0);
	c.lineTo(w * 0.5, h * 0.4);
	c.lineTo(w * 0.9, 0);
	c.lineTo(w, h * 0.1);
	c.lineTo(w * 0.6, h * 0.5);
	c.lineTo(w, h * 0.9);
	c.lineTo(w * 0.9, h);
	c.lineTo(w * 0.5, h * 0.6);
	c.lineTo(w * 0.1, h);
	c.lineTo(0, h * 0.9);
	c.lineTo(w * 0.4, h * 0.5);
	c.lineTo(0, h * 0.1);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupRedX.prototype.cst.SHAPE_RED_X, mxShapeMockupRedX);
/**
 * $Id: mxMockupMisc.js,v 1.5 2013/02/28 13:50:11 mate Exp $
 * Copyright (c) 2006-2010, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Playback Controls
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupPlaybackControls(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupPlaybackControls, mxShape);

mxShapeMockupPlaybackControls.prototype.cst = {
		SHAPE_PLAYBACK_CONTROLS : 'mxgraph.mockup.misc.playbackControls',
		FILL_COLOR2 : 'fillColor2',
		STROKE_COLOR2 : 'strokeColor2',
		FILL_COLOR3 : 'fillColor3',
		STROKE_COLOR3 : 'strokeColor3'
};

mxShapeMockupPlaybackControls.prototype.customProperties = [
	{name: 'fillColor2', dispName: 'Outline Color', type: 'color'},
	{name: 'fillColor3', dispName: 'Symbol Color', type: 'color'},
	{name: 'strokeColor2', dispName: 'Outline Stroke Color', type: 'color'},
	{name: 'strokeColor3', dispName: 'Symbol Stroke Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupPlaybackControls.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var controlBarHeight = 30;
	var buttonSize = 22;
	var h = Math.max(h, controlBarHeight);
	var w = Math.max(225, w);

	c.translate(x, y);
	this.background(c, w, h, controlBarHeight);
	c.setShadow(false);
	this.foreground(c, w, h, controlBarHeight, buttonSize);
};

mxShapeMockupPlaybackControls.prototype.background = function(c, w, h, controlBarHeight)
{
	c.rect(0, (h - controlBarHeight) * 0.5, w, controlBarHeight);
	c.fillAndStroke();
}

mxShapeMockupPlaybackControls.prototype.foreground = function(c, w, h, controlBarHeight, buttonSize)
{
	var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupPlaybackControls.prototype.cst.FILL_COLOR2, '#99ddff');
	var strokeColor2 = mxUtils.getValue(this.style, mxShapeMockupPlaybackControls.prototype.cst.STROKE_COLOR2, 'none');
	var fillColor3 = mxUtils.getValue(this.style, mxShapeMockupPlaybackControls.prototype.cst.FILL_COLOR3, '#ffffff');
	var strokeColor3 = mxUtils.getValue(this.style, mxShapeMockupPlaybackControls.prototype.cst.STROKE_COLOR3, 'none');

	c.setStrokeColor(strokeColor2);
	c.setFillColor(fillColor2);
	c.ellipse(10, h * 0.5 - buttonSize * 0.5, buttonSize, buttonSize);
	c.fillAndStroke();
	c.ellipse(40, h * 0.5 - buttonSize * 0.5, buttonSize, buttonSize);
	c.fillAndStroke();
	c.ellipse(70, h * 0.5 - buttonSize * 0.5, buttonSize, buttonSize);
	c.fillAndStroke();
	c.ellipse(100, h * 0.5 - buttonSize * 0.5, buttonSize, buttonSize);
	c.fillAndStroke();
	c.ellipse(130, h * 0.5 - buttonSize * 0.5, buttonSize, buttonSize);
	c.fillAndStroke();
	c.ellipse(160, h * 0.5 - buttonSize * 0.5, buttonSize, buttonSize);
	c.fillAndStroke();
	c.ellipse(190, h * 0.5 - buttonSize * 0.5, buttonSize, buttonSize);
	c.fillAndStroke();


	c.setStrokeColor(strokeColor3);
	c.setFillColor(fillColor3);
	// start
	var t = h * 0.5 - controlBarHeight * 0.5;
	c.begin();
	c.moveTo(16, t + 10);
	c.lineTo(16, t + 20);
	c.lineTo(18, t + 20);
	c.lineTo(18, t + 10);
	c.close();
	c.moveTo(20, t + 15);
	c.lineTo(25, t + 20);
	c.lineTo(25, t + 10);
	c.close();
	c.fillAndStroke();
	// rewind
	c.begin();
	c.moveTo(44, t + 15);
	c.lineTo(49, t + 20);
	c.lineTo(49, t + 10);
	c.close();
	c.moveTo(51, t + 15);
	c.lineTo(56, t + 20);
	c.lineTo(56, t + 10);
	c.close();
	c.fillAndStroke();
	// back
	c.begin();
	c.moveTo(77, t + 15);
	c.lineTo(82, t + 20);
	c.lineTo(82, t + 10);
	c.close();
	c.fillAndStroke();
	// play/pause
	c.begin();
	c.moveTo(108, t + 10);
	c.lineTo(108, t + 20);
	c.lineTo(110, t + 20);
	c.lineTo(110, t + 10);
	c.close();
	c.moveTo(117, t + 15);
	c.lineTo(112, t + 20);
	c.lineTo(112, t + 10);
	c.close();
	c.fillAndStroke();
	// forward
	c.begin();
	c.moveTo(144, t + 15);
	c.lineTo(139, t + 20);
	c.lineTo(139, t + 10);
	c.close();
	c.fillAndStroke();
	// fast forward
	c.begin();
	c.moveTo(171, t + 15);
	c.lineTo(166, t + 20);
	c.lineTo(166, t + 10);
	c.close();
	c.moveTo(178, t + 15);
	c.lineTo(173, t + 20);
	c.lineTo(173, t + 10);
	c.close();
	c.fillAndStroke();
	// end
	c.begin();
	c.moveTo(203, t + 10);
	c.lineTo(203, t + 20);
	c.lineTo(205, t + 20);
	c.lineTo(205, t + 10);
	c.close();
	c.moveTo(201, t + 15);
	c.lineTo(196, t + 20);
	c.lineTo(196, t + 10);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupPlaybackControls.prototype.cst.SHAPE_PLAYBACK_CONTROLS, mxShapeMockupPlaybackControls);

//**********************************************************************************************************************************************************
//Progress Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupProgressBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.barPos = 20;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupProgressBar, mxShape);

mxShapeMockupProgressBar.prototype.cst = {
		SHAPE_PROGRESS_BAR : 'mxgraph.mockup.misc.progressBar',
		BAR_POS : 'barPos',
		FILL_COLOR2 : 'fillColor2'
};

mxShapeMockupProgressBar.prototype.customProperties = [
	{name: 'fillColor2', dispName: 'Outline Color', type: 'color'},
	{name: 'barPos', dispName: 'Handle Position', type: 'float', min:0, defVal:80}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupProgressBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupProgressBar.prototype.background = function(c, w, h)
{
	c.roundrect(0, h * 0.5 - 5, w, 10, 5, 5);
	c.fillAndStroke();
};

mxShapeMockupProgressBar.prototype.foreground = function(c, w, h)
{
	var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupProgressBar.prototype.cst.FILL_COLOR2, '#ddeeff');
	var barPos = mxUtils.getValue(this.style, mxShapeMockupProgressBar.prototype.cst.BAR_POS, '80');
	barPos = Math.min(barPos, 100);
	barPos = Math.max(barPos, 0);
	var deadzone = 0; 
	var virRange = w - 2 * deadzone;
	var truePos = deadzone + virRange * barPos / 100;

	c.setFillColor(fillColor2);
	c.roundrect(0, h * 0.5 - 5, truePos, 10, 5, 5);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupProgressBar.prototype.cst.SHAPE_PROGRESS_BAR, mxShapeMockupProgressBar);

Graph.handleFactory[mxShapeMockupProgressBar.prototype.cst.SHAPE_PROGRESS_BAR] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'barPos', this.barPos))));

				return new mxPoint(bounds.x + barPos * bounds.width / 100, bounds.y + bounds.height * 0.5);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(1000 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 1000;
			})];

	return handles;
}

//**********************************************************************************************************************************************************
//Shopping Cart
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupShoppingCart(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupShoppingCart, mxShape);

mxShapeMockupShoppingCart.prototype.cst = {
		SHAPE_SHOPPING_CART : 'mxgraph.mockup.misc.shoppingCart'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupShoppingCart.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.translate(x, y);

	c.setStrokeWidth(3);
	c.begin();
	c.moveTo(w * 0.975, h * 0.025);
	c.lineTo(w * 0.82, h * 0.055);
	c.lineTo(w * 0.59, h * 0.66);
	c.lineTo(w * 0.7, h * 0.765);
	c.arcTo(w * 0.06, h * 0.06, 0, 0, 1, w * 0.665, h * 0.86);
	c.lineTo(w * 0.05, h * 0.86);
	c.moveTo(w * 0.74, h * 0.26);
	c.lineTo(w * 0.03, h * 0.28);
	c.lineTo(w * 0.065, h * 0.61);
	c.lineTo(w * 0.59, h * 0.66);
	c.stroke();

	c.setStrokeWidth(1);
	c.begin();
	c.moveTo(w * 0.15, h * 0.28);
	c.lineTo(w * 0.15, h * 0.62);
	c.moveTo(w * 0.265, h * 0.275);
	c.lineTo(w * 0.265, h * 0.63);
	c.moveTo(w * 0.38, h * 0.27);
	c.lineTo(w * 0.38, h * 0.64);
	c.moveTo(w * 0.495, h * 0.265);
	c.lineTo(w * 0.495, h * 0.65);
	c.moveTo(w * 0.61, h * 0.265);
	c.lineTo(w * 0.61, h * 0.61);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.69, h * 0.405);
	c.lineTo(w * 0.045, h * 0.405);
	c.moveTo(w * 0.645, h * 0.52);
	c.lineTo(w * 0.055, h * 0.52);
	c.stroke();
	c.setFillColor(strokeColor);
	c.ellipse(w * 0.075, h * 0.89, w * 0.1, h * 0.1);
	c.fillAndStroke();
	c.ellipse(w * 0.62, h * 0.89, w * 0.1, h * 0.1);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupShoppingCart.prototype.cst.SHAPE_SHOPPING_CART, mxShapeMockupShoppingCart);

//**********************************************************************************************************************************************************
//Rating
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupRating(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupRating, mxShape);

mxShapeMockupRating.prototype.cst = {
		SHAPE_RATING : 'mxgraph.mockup.misc.rating',
		RATING_STYLE : 'ratingStyle',
		RATING_SCALE : 'ratingScale',
		RATING_HEART : 'heart',
		RATING_STAR : 'star',
		EMPTY_FILL_COLOR : 'emptyFillColor',
		GRADE : 'grade'
};

mxShapeMockupRating.prototype.customProperties = [
	{name: 'ratingStyle', dispName: 'Style', type: 'enum',
		enumList: [{val: 'heart', dispName: 'Heart'}, {val: 'star', dispName: 'Star'}]
	},
	{name: 'ratingScale', dispName: 'Max. Rating', type: 'int'},
	{name: 'grade', dispName: 'Current Rating', type: 'int'},
	{name: 'emptyFillColor', dispName: 'Fill2 Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupRating.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var ratingStyle = mxUtils.getValue(this.style, mxShapeMockupRating.prototype.cst.RATING_STYLE, mxShapeMockupRating.prototype.cst.RATING_STAR);
	var grade = mxUtils.getValue(this.style, mxShapeMockupRating.prototype.cst.GRADE, '5');
	var ratingScale = mxUtils.getValue(this.style, mxShapeMockupRating.prototype.cst.RATING_SCALE, '10');

	c.translate(x, y);

	if (ratingStyle === mxShapeMockupRating.prototype.cst.RATING_STAR)
	{
		for (var i = 0; i < grade; i++)
		{
			c.begin();
			c.moveTo(i * h * 1.5, 0.33 * h);
			c.lineTo(i * h * 1.5 + 0.364 * h, 0.33 * h);
			c.lineTo(i * h * 1.5 + 0.475 * h, 0);
			c.lineTo(i * h * 1.5 + 0.586 * h, 0.33 * h);
			c.lineTo(i * h * 1.5 + 0.95 * h, 0.33 * h);
			c.lineTo(i * h * 1.5 + 0.66 * h, 0.551 * h);
			c.lineTo(i * h * 1.5 + 0.775 * h, 0.9 * h);
			c.lineTo(i * h * 1.5 + 0.475 * h, 0.684 * h);
			c.lineTo(i * h * 1.5 + 0.175 * h, 0.9 * h);
			c.lineTo(i * h * 1.5 + 0.29 * h, 0.551 * h);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (ratingStyle === mxShapeMockupRating.prototype.cst.RATING_HEART)
	{
		for (var i = 0; i < grade; i++)
		{
			c.begin();
			c.moveTo(i * h * 1.5 + h * 0.519, h * 0.947);
			c.curveTo(i * h * 1.5 + h * 0.558, h * 0.908, i * h * 1.5 + h * 0.778, h * 0.682, i * h * 1.5 + h * 0.916, h * 0.54);
			c.curveTo(i * h * 1.5 + h * 1.039, h * 0.414, i * h * 1.5 + h * 1.036, h * 0.229, i * h * 1.5 + h * 0.924, h * 0.115);
			c.curveTo(i * h * 1.5 + h * 0.812, 0, i * h * 1.5 + h * 0.631, 0, i * h * 1.5 + h * 0.519, h * 0.115);
			c.curveTo(i * h * 1.5 + h * 0.408, 0, i * h * 1.5 + h * 0.227, 0, i * h * 1.5 + h * 0.115, h * 0.115);
			c.curveTo(i * h * 1.5 + h * 0.03, h * 0.229, i * h * 1.5, h * 0.414, i * h * 1.5 + h * 0.123, h * 0.54);
			c.close();
			c.fillAndStroke();
		}
	}

	var emptyFillColor = mxUtils.getValue(this.style, mxShapeMockupRating.prototype.cst.EMPTY_FILL_COLOR, '#ffffff');
	c.setFillColor(emptyFillColor);

	if (ratingStyle === mxShapeMockupRating.prototype.cst.RATING_STAR)
	{
		for (var i = grade; i < ratingScale; i++)
		{
			c.begin();
			c.moveTo(i * h * 1.5, 0.33 * h);
			c.lineTo(i * h * 1.5 + 0.364 * h, 0.33 * h);
			c.lineTo(i * h * 1.5 + 0.475 * h, 0);
			c.lineTo(i * h * 1.5 + 0.586 * h, 0.33 * h);
			c.lineTo(i * h * 1.5 + 0.95 * h, 0.33 * h);
			c.lineTo(i * h * 1.5 + 0.66 * h, 0.551 * h);
			c.lineTo(i * h * 1.5 + 0.775 * h, 0.9 * h);
			c.lineTo(i * h * 1.5 + 0.475 * h, 0.684 * h);
			c.lineTo(i * h * 1.5 + 0.175 * h, 0.9 * h);
			c.lineTo(i * h * 1.5 + 0.29 * h, 0.551 * h);
			c.close();
			c.fillAndStroke();
		}
	}
	else if (ratingStyle === mxShapeMockupRating.prototype.cst.RATING_HEART)
	{
		for (var i = grade; i < ratingScale; i++)
		{
			c.begin();
			c.moveTo(i * h * 1.5 + h * 0.519, h * 0.947);
			c.curveTo(i * h * 1.5 + h * 0.558, h * 0.908, i * h * 1.5 + h * 0.778, h * 0.682, i * h * 1.5 + h * 0.916, h * 0.54);
			c.curveTo(i * h * 1.5 + h * 1.039, h * 0.414, i * h * 1.5 + h * 1.036, h * 0.229, i * h * 1.5 + h * 0.924, h * 0.115);
			c.curveTo(i * h * 1.5 + h * 0.812, 0, i * h * 1.5 + h * 0.631, 0, i * h * 1.5 + h * 0.519, h * 0.115);
			c.curveTo(i * h * 1.5 + h * 0.408, 0, i * h * 1.5 + h * 0.227, 0, i * h * 1.5 + h * 0.115, h * 0.115);
			c.curveTo(i * h * 1.5 + h * 0.03, h * 0.229, i * h * 1.5, h * 0.414, i * h * 1.5 + h * 0.123, h * 0.54);
			c.close();
			c.fillAndStroke();
		}
	}
};

mxCellRenderer.registerShape(mxShapeMockupRating.prototype.cst.SHAPE_RATING, mxShapeMockupRating);

//**********************************************************************************************************************************************************
//Mail
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupMail(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupMail, mxShape);

mxShapeMockupMail.prototype.cst = {
		SHAPE_MAIL : 'mxgraph.mockup.misc.mail2'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupMail.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.rect(0, 0, w, h);
	c.fillAndStroke();

	c.setShadow(false);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w * 0.5, h * 0.5);
	c.lineTo(w, 0);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupMail.prototype.cst.SHAPE_MAIL, mxShapeMockupMail);

//**********************************************************************************************************************************************************
//Volume Slider
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupVolumeSlider(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
	this.barPos = 80;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupVolumeSlider, mxShape);

mxShapeMockupVolumeSlider.prototype.cst = {
		SHAPE_VOLUME_SLIDER : 'mxgraph.mockup.misc.volumeSlider',
		BAR_POS : 'barPos',
		FILL_COLOR2 : 'fillColor2'
};

mxShapeMockupVolumeSlider.prototype.customProperties = [
	{name: 'fillColor2', dispName: 'Fill2 Color', type: 'color'},
	{name: 'barPos', dispName: 'Handle Position', type: 'float'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupVolumeSlider.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var barPos = mxUtils.getValue(this.style, mxShapeMockupVolumeSlider.prototype.cst.BAR_POS, '80');
	var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupVolumeSlider.prototype.cst.FILL_COLOR2, '#ddeeff');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#999999');
	//only the progress bar handle needs to be drawn
	barPos = Math.min(barPos, 100);
	barPos = Math.max(barPos, 0);
	var controlBarHeight = 25;
	var h = Math.max(h, controlBarHeight);
	var w = Math.max(w, 3.5 * controlBarHeight);

	var speakerStartX = w - controlBarHeight;
	var speakerStartY = (h - controlBarHeight) * 0.5;
	c.begin();
	c.moveTo(speakerStartX + controlBarHeight * 0.05, speakerStartY + controlBarHeight * 0.35);
	c.lineTo(speakerStartX + controlBarHeight * 0.15, speakerStartY + controlBarHeight * 0.35);
	c.lineTo(speakerStartX + controlBarHeight * 0.3, speakerStartY + controlBarHeight * 0.2);
	c.lineTo(speakerStartX + controlBarHeight * 0.3, speakerStartY + controlBarHeight * 0.8);
	c.lineTo(speakerStartX + controlBarHeight * 0.15, speakerStartY + controlBarHeight * 0.65);
	c.lineTo(speakerStartX + controlBarHeight * 0.05, speakerStartY + controlBarHeight * 0.65);
	c.close();
	c.fill();

	//draw the handle based on barPos
	var barMin = 0;
	var barMax = w - controlBarHeight * 1.3;
	var videoBarStartY = (h - controlBarHeight) * 0.5;
	var barRange = barMax - barMin;
	var barPos = barRange * barPos / 100;
	var barEnd = barMin + barPos;

	var soundStartX = w - controlBarHeight;
	var soundStartY = (h - controlBarHeight) * 0.5;
	c.begin();
	c.moveTo(soundStartX + controlBarHeight * 0.4, soundStartY + controlBarHeight * 0.35);
	c.arcTo(controlBarHeight * 0.2, controlBarHeight * 0.3, 0, 0, 1, soundStartX + controlBarHeight * 0.4, soundStartY + controlBarHeight * 0.65);
	c.moveTo(soundStartX + controlBarHeight * 0.425, soundStartY + controlBarHeight * 0.25);
	c.arcTo(controlBarHeight * 0.225, controlBarHeight * 0.35, 0, 0, 1, soundStartX + controlBarHeight * 0.425, soundStartY + controlBarHeight * 0.75);
	c.moveTo(soundStartX + controlBarHeight * 0.5, soundStartY + controlBarHeight * 0.2);
	c.arcTo(controlBarHeight * 0.25, controlBarHeight * 0.4, 0, 0, 1, soundStartX + controlBarHeight * 0.5, soundStartY + controlBarHeight * 0.8);
	c.fillAndStroke();

	//now we draw the video progress bar
	var videoBarStartX = 0;
	var videoBarStartY = (h - controlBarHeight) * 0.5;
	var videoBarEndX = w - controlBarHeight * 1.3;
	c.roundrect(videoBarStartX, videoBarStartY + controlBarHeight * 0.35, videoBarEndX, controlBarHeight * 0.3, 5, 5);
	c.fill();
	c.setShadow(false);
	c.setFillColor(fillColor2);
	c.roundrect(barMin, videoBarStartY + controlBarHeight * 0.35, barEnd, controlBarHeight * 0.3, 5, 5);
	c.fill();

	
	c.ellipse(barEnd - controlBarHeight * 0.25, videoBarStartY + controlBarHeight * 0.25, controlBarHeight * 0.5, controlBarHeight * 0.5);
	c.fillAndStroke();

};

mxCellRenderer.registerShape(mxShapeMockupVolumeSlider.prototype.cst.SHAPE_VOLUME_SLIDER, mxShapeMockupVolumeSlider);

Graph.handleFactory[mxShapeMockupVolumeSlider.prototype.cst.SHAPE_VOLUME_SLIDER] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'barPos', this.barPos))));

				return new mxPoint(bounds.x + barPos * (bounds.width - 32.5) / 100, bounds.y + bounds.height * 0.5);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(1000 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 1000;
			})];

	return handles;
}

//**********************************************************************************************************************************************************
//Edit Icon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupEdit(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupEdit, mxShape);

mxShapeMockupEdit.prototype.cst = {
		SHAPE_EDIT : 'mxgraph.mockup.misc.editIcon'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupEdit.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#999999');

	c.translate(x, y);

	c.roundrect(0, 0, w, h, w * 0.05, h * 0.05);
	c.fillAndStroke();

	c.setShadow(false);
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.11, h * 0.8);
	c.lineTo(w * 0.2, h * 0.89);
	c.lineTo(w * 0.05, h * 0.95);
	c.close();
	c.moveTo(w * 0.74, h * 0.16);
	c.lineTo(w * 0.84, h * 0.26);
	c.lineTo(w * 0.22, h * 0.88);
	c.lineTo(w * 0.12, h * 0.78);
	c.close();
	c.moveTo(w * 0.755, h * 0.145);
	c.lineTo(w * 0.82, h * 0.08);
	c.lineTo(w * 0.92, h * 0.18);
	c.lineTo(w * 0.855, h * 0.245);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeMockupEdit.prototype.cst.SHAPE_EDIT, mxShapeMockupEdit);

//**********************************************************************************************************************************************************
//Print Icon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupPrint(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupPrint, mxShape);

mxShapeMockupPrint.prototype.cst = {
		SHAPE_PRINT : 'mxgraph.mockup.misc.printIcon'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupPrint.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#999999');

	c.translate(x, y);

	c.roundrect(0, 0, w, h, w * 0.05, h * 0.05);
	c.fillAndStroke();

	c.setShadow(false);
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.15, h * 0.58);
	c.arcTo(w * 0.03, h * 0.03, 0, 0, 1, w * 0.18, h * 0.55);
	c.lineTo(w * 0.82, h * 0.55);
	c.arcTo(w * 0.03, h * 0.03, 0, 0, 1, w * 0.85, h * 0.58);
	c.lineTo(w * 0.85, h * 0.82);
	c.arcTo(w * 0.03, h * 0.03, 0, 0, 1, w * 0.82, h * 0.85);
	c.lineTo(w * 0.18, h * 0.85);
	c.arcTo(w * 0.03, h * 0.03, 0, 0, 1, w * 0.15, h * 0.82);
	c.close();
	c.moveTo(w * 0.7, h * 0.52);
	c.lineTo(w * 0.3, h * 0.52);
	c.lineTo(w * 0.3, h * 0.15);
	c.lineTo(w * 0.55, h * 0.15);
	c.lineTo(w * 0.55, h * 0.3);
	c.lineTo(w * 0.7, h * 0.3);
	c.close();
	c.moveTo(w * 0.57, h * 0.15);
	c.lineTo(w * 0.7, h * 0.28);
	c.lineTo(w * 0.57, h * 0.28);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeMockupPrint.prototype.cst.SHAPE_PRINT, mxShapeMockupPrint);

//**********************************************************************************************************************************************************
//Print Icon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupShare(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupShare, mxShape);

mxShapeMockupShare.prototype.cst = {
		SHAPE_SHARE : 'mxgraph.mockup.misc.shareIcon'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupShare.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#999999');

	c.translate(x, y);

	c.roundrect(0, 0, w, h, w * 0.05, h * 0.05);
	c.fillAndStroke();

	c.setShadow(false);
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.15, h * 0.18);
	c.arcTo(w * 0.03, h * 0.03, 0, 0, 1, w * 0.18, h * 0.15);
	c.lineTo(w * 0.82, h * 0.15);
	c.arcTo(w * 0.03, h * 0.03, 0, 0, 1, w * 0.85, h * 0.18);
	c.lineTo(w * 0.85, h * 0.82);
	c.arcTo(w * 0.03, h * 0.03, 0, 0, 1, w * 0.82, h * 0.85);
	c.lineTo(w * 0.18, h * 0.85);
	c.arcTo(w * 0.03, h * 0.03, 0, 0, 1, w * 0.15, h * 0.82);
	c.close();
	c.fill();

	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	c.setFillColor(fillColor);
	c.begin();
	c.moveTo(w * 0.563, h * 0.34);
	c.arcTo(w * 0.095, h * 0.095, 0, 1, 1, w * 0.603, h * 0.42);
	c.lineTo(w * 0.44, h * 0.5);
	c.lineTo(w * 0.602, h * 0.582);
	c.arcTo(w * 0.095, h * 0.095, 0, 1, 1, w * 0.563, h * 0.653);
	c.lineTo(w * 0.403, h * 0.575);
	c.arcTo(w * 0.095, h * 0.095, 0, 1, 1, w * 0.4, h * 0.42);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxShapeMockupShare.prototype.cst.SHAPE_SHARE, mxShapeMockupShare);

//**********************************************************************************************************************************************************
//Trashcan Icon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupTrashcan(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupTrashcan, mxShape);

mxShapeMockupTrashcan.prototype.cst = {
		SHAPE_TRASHCAN : 'mxgraph.mockup.misc.trashcanIcon'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupTrashcan.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#999999');

	c.translate(x, y);

	c.roundrect(0, 0, w, h, w * 0.05, h * 0.05);
	c.fillAndStroke();

	c.setShadow(false);
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.24, h * 0.24);
	c.arcTo(w * 0.04, h * 0.04, 0, 0, 1, w * 0.24, h * 0.16);
	c.lineTo(w * 0.4, h * 0.16);
	c.lineTo(w * 0.4, h * 0.12);
	c.lineTo(w * 0.6, h * 0.12);
	c.lineTo(w * 0.6, h * 0.16);
	c.lineTo(w * 0.76, h * 0.16);
	c.arcTo(w * 0.04, h * 0.04, 0, 0, 1, w * 0.76, h * 0.24);
	c.close();
	c.fill();

	c.roundrect(w * 0.26, h * 0.3, w * 0.1, h * 0.6, w * 0.06, h * 0.06);
	c.fill();
	c.roundrect(w * 0.44, h * 0.3, w * 0.1, h * 0.6, w * 0.06, h * 0.06);
	c.fill();
	c.roundrect(w * 0.62, h * 0.3, w * 0.1, h * 0.6, w * 0.06, h * 0.06);
	c.fill();
};

mxCellRenderer.registerShape(mxShapeMockupTrashcan.prototype.cst.SHAPE_TRASHCAN, mxShapeMockupTrashcan);

//**********************************************************************************************************************************************************
//Copyright Icon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupCopyright(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupCopyright, mxShape);

mxShapeMockupCopyright.prototype.cst = {
		SHAPE_COPYRIGHT : 'mxgraph.mockup.misc.copyrightIcon'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupCopyright.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#999999');

	c.translate(x, y);

	c.ellipse(0, 0, w, h);
	c.fillAndStroke();

	c.setShadow(false);
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.713, h * 0.288);
	c.arcTo(w * 0.3, h * 0.3, 0, 1, 0, w * 0.713, h * 0.712);
	c.lineTo(w * 0.784, h * 0.783);
	c.arcTo(w * 0.4, h * 0.4, 0, 1, 1, w * 0.784, h * 0.217);
	c.close();
	c.fill();

};

mxCellRenderer.registerShape(mxShapeMockupCopyright.prototype.cst.SHAPE_COPYRIGHT, mxShapeMockupCopyright);

//**********************************************************************************************************************************************************
//Registered Icon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupRegistered(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupRegistered, mxShape);

mxShapeMockupRegistered.prototype.cst = {
		SHAPE_REGISTERED : 'mxgraph.mockup.misc.registeredIcon'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupRegistered.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#999999');

	c.translate(x, y);

	c.ellipse(0, 0, w, h);
	c.fillAndStroke();

	c.setShadow(false);
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.29, h * 0.9);
	c.lineTo(w * 0.29, h * 0.09);
	c.lineTo(w * 0.5, h * 0.09);
	c.arcTo(w * 0.2195, h * 0.2195, 0, 0, 1, w * 0.545, h * 0.525);
	c.lineTo(w * 0.738, h * 0.91);
	c.lineTo(w * 0.674, h * 0.91);
	c.lineTo(w * 0.4825, h * 0.53);
	c.lineTo(w * 0.35, h * 0.53);
	c.lineTo(w * 0.35, h * 0.9);
	c.close();
	c.moveTo(w * 0.35, h * 0.47);
	c.lineTo(w * 0.5, h * 0.47);
	c.arcTo(w * 0.15, h * 0.15, 0, 0, 0, w * 0.5, h * 0.15);
	c.lineTo(w * 0.35, h * 0.15);
	c.close();
	c.fill();

};

mxCellRenderer.registerShape(mxShapeMockupRegistered.prototype.cst.SHAPE_REGISTERED, mxShapeMockupRegistered);

//**********************************************************************************************************************************************************
//Volume Icon
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupVolume(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupVolume, mxShape);

mxShapeMockupVolume.prototype.cst = {
		SHAPE_VOLUME : 'mxgraph.mockup.misc.volumeIcon'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupVolume.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#999999');

	c.translate(x, y);

	c.roundrect(0, 0, w, h, w * 0.05, h * 0.05);
	c.fillAndStroke();

	c.setShadow(false);
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.1, h * 0.3);
	c.lineTo(w * 0.3, h * 0.3);
	c.lineTo(w * 0.5, h * 0.15);
	c.lineTo(w * 0.5, h * 0.85);
	c.lineTo(w * 0.3, h * 0.7);
	c.lineTo(w * 0.1, h * 0.7);
	c.close();
	c.fill();
	
	c.begin();
	c.moveTo(w * 0.6, h * 0.4);
	c.arcTo(w * 0.2, h * 0.2, 0, 0, 1, w * 0.6, h * 0.6);

	c.moveTo(w * 0.7, h * 0.3);
	c.arcTo(w * 0.3, h * 0.3, 0, 0, 1, w * 0.7, h * 0.7);
	
	c.moveTo(w * 0.8, h * 0.2);
	c.arcTo(w * 0.4, h * 0.4, 0, 0, 1, w * 0.8, h * 0.8);
	c.stroke();

};

mxCellRenderer.registerShape(mxShapeMockupVolume.prototype.cst.SHAPE_VOLUME, mxShapeMockupVolume);

//**********************************************************************************************************************************************************
//Ruler
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupRuler(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupRuler, mxShape);

mxShapeMockupRuler.prototype.cst = {
		SHAPE_RULER : 'mxgraph.mockup.misc.ruler',
		ORIENTATION : 'rulerOrient',
		UNIT_SIZE : 'unitSize',
		FACE_UP : 'up',
		FACE_DOWN : 'down'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupRuler.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupRuler.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupRuler.prototype.foreground = function(c, w, h)
{
	var facing = mxUtils.getValue(this.style, mxShapeMockupRuler.prototype.cst.ORIENTATION, mxShapeMockupRuler.prototype.cst.FACE_DOWN);
	var unitSize = mxUtils.getValue(this.style, mxShapeMockupRuler.prototype.cst.UNIT_SIZE, '10');
	
	unitSize = Math.max(unitSize, 1);
	
	var currX = unitSize;
	var i = 1;

	if (facing === mxShapeMockupRuler.prototype.cst.FACE_DOWN)
	{
		c.begin();
		
		while (currX < w)
		{
			var remainder = i % 10;

			if (remainder === 0)
			{
				c.moveTo(currX, h * 0.5);
				c.lineTo(currX, h);
			}
			else if ( remainder === 5)
			{
				c.moveTo(currX, h * 0.7);
				c.lineTo(currX, h);
			}
			else
			{
				c.moveTo(currX, h * 0.8);
				c.lineTo(currX, h);
			}

			currX = currX + unitSize;
			i = i + 1;
		}
		
		c.stroke();
	}
	else if (facing === mxShapeMockupRuler.prototype.cst.FACE_UP)
	{
		c.begin();
		
		while (currX < w)
		{
			var remainder = i % 10;

			if (remainder === 0)
			{
				c.moveTo(currX, h * 0.5);
				c.lineTo(currX, 0);
			}
			else if ( remainder === 5)
			{
				c.moveTo(currX, h * 0.3);
				c.lineTo(currX, 0);
			}
			else
			{
				c.moveTo(currX, h * 0.2);
				c.lineTo(currX, 0);
			}

			currX = currX + unitSize;
			i = i + 1;
		}
		
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapeMockupRuler.prototype.cst.SHAPE_RULER, mxShapeMockupRuler);

//**********************************************************************************************************************************************************
//Advanced Ruler 
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupRuler2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupRuler2, mxShape);

mxShapeMockupRuler2.prototype.cst = {
		SHAPE_RULER : 'mxgraph.mockup.misc.ruler2',
		ORIENTATION : 'rulerOrient',
		UNIT_SIZE : 'dx',
		FACE_UP : 'up',
		FACE_DOWN : 'down'
};

mxShapeMockupRuler2.prototype.customProperties = [
	{name: 'rulerOrient', dispName: 'Orientation', defVal:'up', type: 'enum',
		enumList: [{val: 'up', dispName: 'Up'}, {val: 'down', dispName: 'Down'}]
	},
	{name: 'dx', dispName: 'Unit Size', type: 'float', min:0, defVal:100}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupRuler2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupRuler2.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupRuler2.prototype.foreground = function(c, x, y, w, h)
{
	var facing = mxUtils.getValue(this.style, mxShapeMockupRuler2.prototype.cst.ORIENTATION, mxShapeMockupRuler2.prototype.cst.FACE_DOWN);
	var fontColor = mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, '#000000');
	var dx = mxUtils.getValue(this.style, 'dx', '100');
	var unitSize = dx / 10;
	this.state.style['spacingLeft'] = Math.round(1000 * Math.max(0, Math.min(w, dx))) / 1000 - 4;
	
	unitSize = Math.max(unitSize, 1);
	
	c.setFontColor(fontColor);
	
	var currX = unitSize;
	var i = 1;

	if (facing === mxShapeMockupRuler2.prototype.cst.FACE_DOWN)
	{
		c.begin();
		
		while (currX < w)
		{
			var remainder = i % 10;

			if (remainder === 0)
			{
				c.moveTo(currX, h - 10);
				c.lineTo(currX, h);
				
				var unit = this.state.view.graph.getLabel(this.state.cell);
				
				if (!isNaN(unit))
				{
					c.stroke();
					
					var num = i * Math.round(100 * unit) / 1000;
					
					if (i != 10 && num != 0)
					{
						c.text(currX, (h - 10) * 0.5, 0, 0, num.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
					}
					c.begin();
				}
			}
			else if ( remainder === 5)
			{
				c.moveTo(currX, h - 6);
				c.lineTo(currX, h);
			}
			else
			{
				c.moveTo(currX, h - 4);
				c.lineTo(currX, h);
			}

			currX = currX + unitSize;
			i = i + 1;
		}
		
		c.stroke();
	}
	else if (facing === mxShapeMockupRuler2.prototype.cst.FACE_UP)
	{
		c.begin();
		
		while (currX < w)
		{
			var remainder = i % 10;

			if (remainder === 0)
			{
				c.moveTo(currX, 10);
				c.lineTo(currX, 0);

				var unit = this.state.view.graph.getLabel(this.state.cell);
				
				if (!isNaN(unit))
				{
					c.stroke();
					
					var num = i * Math.round(100 * unit) / 1000;
					
					if (i != 10 && num != 0)
					{
						c.text(currX, (h + 10) * 0.5, 0, 0, num.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
					}
					c.begin();
				}
			}
			else if ( remainder === 5)
			{
				c.moveTo(currX, 6);
				c.lineTo(currX, 0);
			}
			else
			{
				c.moveTo(currX, 4);
				c.lineTo(currX, 0);
			}

			currX = currX + unitSize;
			i = i + 1;
		}
		
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapeMockupRuler2.prototype.cst.SHAPE_RULER, mxShapeMockupRuler2);

Graph.handleFactory[mxShapeMockupRuler2.prototype.cst.SHAPE_RULER] = function(state)
{
	var handles = [Graph.createHandle(state, ['dx', 'spacingLeft', 'align', 'varticalAlign', 'spacingBottom', 'spacingTop', 'spacingRight', 'spacing'], function(bounds)
			{
				var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'dx', this.dx))));

				return new mxPoint(bounds.x + dx, bounds.y + bounds.height - 10);
			}, function(bounds, pt)
			{
				this.state.style['dx'] = Math.round(1000 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 1000;
				this.state.style['spacingLeft'] = Math.round(1000 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 1000 - 4;
				this.state.style['align'] = 'left';
				this.state.style['verticalAlign'] = 'middle';
				
				var facing = mxUtils.getValue(this.state.style, 'rulerOrient', '1');
				
				if (facing == 'down')
				{
					this.state.style['spacingBottom'] = 10;
					this.state.style['spacingTop'] = 0;
				}
				else
				{
					this.state.style['spacingBottom'] = 0;
					this.state.style['spacingTop'] = 10;
				}
					
				this.state.style['spacingRight'] = 0;
				this.state.style['spacing'] = 0;
			})];

	return handles;
}

//**********************************************************************************************************************************************************
//Revision Table
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupRevisionTable(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupRevisionTable, mxShape);

mxShapeMockupRevisionTable.prototype.cst = {
		SHAPE_REVISION_TABLE : 'mxgraph.mockup.misc.revisionTable',
		MAIN_TEXT : 'mainText',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupRevisionTable.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupRevisionTable.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupRevisionTable.prototype.foreground = function(c, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxShapeMockupRevisionTable.prototype.cst.MAIN_TEXT, '').toString().split(',');
	var textColor = mxUtils.getValue(this.style, mxShapeMockupRevisionTable.prototype.cst.TEXT_COLOR, '#999999');
	var textSize = mxUtils.getValue(this.style, mxShapeMockupRevisionTable.prototype.cst.TEXT_SIZE, '17');
	
	c.begin();
	c.moveTo(0, h * 0.33);
	c.lineTo(w, h * 0.33);
	c.moveTo(0, h * 0.67);
	c.lineTo(w, h * 0.67);
	c.moveTo(w * 0.125, h * 0.33);
	c.lineTo(w * 0.125, h);
	c.moveTo(w * 0.5, h * 0.33);
	c.lineTo(w * 0.5, h);
	c.stroke();
	
	c.setFontSize(textSize);
	c.setFontColor(textColor);
	
	c.text(w * 0.5, h * 0.165, 0, 0, mainText[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.0625, h * 0.5, 0, 0, mainText[1], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.3125, h * 0.5, 0, 0, mainText[2], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.75, h * 0.5, 0, 0, mainText[3], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.0625, h * 0.835, 0, 0, mainText[4], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.3125, h * 0.835, 0, 0, mainText[5], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.75, h * 0.835, 0, 0, mainText[6], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

};

mxCellRenderer.registerShape(mxShapeMockupRevisionTable.prototype.cst.SHAPE_REVISION_TABLE, mxShapeMockupRevisionTable);

//**********************************************************************************************************************************************************
//Status Bar
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupStatusBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupStatusBar, mxShape);

mxShapeMockupStatusBar.prototype.cst = {
		SHAPE_STATUS_BAR : 'mxgraph.mockup.misc.statusBar',
		MAIN_TEXT : 'mainText',
		FILL_COLOR2 : 'fillColor2',
		STROKE_COLOR2 : 'strokeColor2',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupStatusBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	w = Math.max(w, 105);
	
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupStatusBar.prototype.background = function(c, w, h)
{
	c.rect(0, h * 0.5 - 15, w, 30);
	c.fillAndStroke();
};

mxShapeMockupStatusBar.prototype.foreground = function(c, w, h)
{
	var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupStatusBar.prototype.cst.FILL_COLOR2, '#ddeeff');
	var strokeColor2 = mxUtils.getValue(this.style, mxShapeMockupStatusBar.prototype.cst.STROKE_COLOR2, '#008cff');
	var mainText = mxUtils.getValue(this.style, mxShapeMockupStatusBar.prototype.cst.MAIN_TEXT, '').toString().split(',');
	var textColor = mxUtils.getValue(this.style, mxShapeMockupStatusBar.prototype.cst.TEXT_COLOR, '#999999');
	var textSize = mxUtils.getValue(this.style, mxShapeMockupStatusBar.prototype.cst.TEXT_SIZE, '17');
	
	c.setFillColor(fillColor2);
	c.roundrect(5, h * 0.5 - 10, (w - 75) * 0.46, 20, 5, 5);
	c.fill();

	c.roundrect(10 + (w - 75) * 0.46, h * 0.5 - 10, (w - 75) * 0.23, 20, 5, 5);
	c.fill();
	c.roundrect(15 + (w - 75) * 0.69, h * 0.5 - 10, (w - 75) * 0.276, 20, 5, 5);
	c.fill();
	
	c.setFontSize(textSize);
	c.setFontColor(textColor);
	c.text(10, h * 0.5, 0, 0, mainText[0], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(10 + (w - 75) * 0.575, h * 0.5, 0, 0, mainText[1], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(15 + (w - 75) * 0.828, h * 0.5, 0, 0, mainText[2], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	
	c.setStrokeColor(strokeColor2);
	c.ellipse(w - 25, h * 0.5 - 10, 20, 20);
	c.stroke();
	c.begin();
	c.moveTo(w - 55, h * 0.5 + 10);
	c.lineTo(w - 35, h * 0.5 + 10);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupStatusBar.prototype.cst.SHAPE_STATUS_BAR, mxShapeMockupStatusBar);

//**********************************************************************************************************************************************************
//Pin
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupPin(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupPin, mxShape);

mxShapeMockupPin.prototype.cst = {
		SHAPE_PIN : 'mxgraph.mockup.misc.pin',
		FILL_COLOR2 : 'fillColor2',
		FILL_COLOR3 : 'fillColor3'
};

mxShapeMockupPin.prototype.customProperties = [
	{name: 'fillColor2', dispName: 'Fill2 Color', type: 'color'},
	{name: 'fillColor3', dispName: 'Fill3 Color', type: 'color'}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupPin.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupPin.prototype.cst.FILL_COLOR2, '#000000');
	var fillColor3 = mxUtils.getValue(this.style, mxShapeMockupPin.prototype.cst.FILL_COLOR3, '#000000');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setShadow(false);
	c.translate(x, y);

	c.setStrokeWidth(3);
	c.setStrokeColor('#666666');
	c.begin();
	c.moveTo(w * 0.5, h * 0.4);
	c.lineTo(w * 0.5, h);
	c.stroke();

	c.setStrokeWidth(2);
	c.setStrokeColor(strokeColor);
	c.setGradient(fillColor2, fillColor3, 0, 0, w, h * 0.4, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.setAlpha(0.9);
	c.ellipse(0, 0, w, h * 0.4);
	c.fillAndStroke();

	c.setFillColor('#ffffff');
	c.setAlpha(0.5);
	c.ellipse(w * 0.2, h * 0.08, w * 0.3, h * 0.12);
	c.fill();
};

mxCellRenderer.registerShape(mxShapeMockupPin.prototype.cst.SHAPE_PIN, mxShapeMockupPin);

//**********************************************************************************************************************************************************
//Rounded rectangle (adjustable rounding)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupMiscRRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupMiscRRect, mxShape);

mxShapeMockupMiscRRect.prototype.cst = {
		RRECT : 'mxgraph.mockup.misc.rrect',
		R_SIZE : 'rSize'
};

mxShapeMockupMiscRRect.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:10}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupMiscRRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupMiscRRect.prototype.cst.R_SIZE, '10'));
	c.roundrect(0, 0, w, h, rSize);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupMiscRRect.prototype.cst.RRECT, mxShapeMockupMiscRRect);

//**********************************************************************************************************************************************************
//Anchor (a dummy shape without visuals used for anchoring)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupMiscAnchor(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupMiscAnchor, mxShape);

mxShapeMockupMiscAnchor.prototype.cst = {
		ANCHOR : 'mxgraph.mockup.misc.anchor'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupMiscAnchor.prototype.paintVertexShape = function(c, x, y, w, h)
{
};

mxCellRenderer.registerShape(mxShapeMockupMiscAnchor.prototype.cst.ANCHOR, mxShapeMockupMiscAnchor);


/**
 * $Id: mxMockupNavigation.js,v 1.5 2014/01/21 13:11:15 gaudenz Exp $
 * Copyright (c) 2006-2010, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Breadcrumb (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupBreadcrumb(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupBreadcrumb, mxShape);

mxShapeMockupBreadcrumb.prototype.cst = {
		SHAPE_BREADCRUMB : 'mxgraph.mockup.navigation.breadcrumb',
		MAIN_TEXT : 'mainText',
		TEXT_SIZE : 'textSize',
		TEXT_COLOR : 'textColor',
		TEXT_COLOR2 : 'textColor2'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupBreadcrumb.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var textStrings = mxUtils.getValue(this.style, mxShapeMockupBreadcrumb.prototype.cst.MAIN_TEXT, 'Layer 1, Layer 2, Layer 3').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupBreadcrumb.prototype.cst.TEXT_COLOR, '#666666');
	var selectedFontColor = mxUtils.getValue(this.style, mxShapeMockupBreadcrumb.prototype.cst.TEXT_COLOR2, '#008cff');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupBreadcrumb.prototype.cst.TEXT_SIZE, '17').toString();
	var separatorColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#c4c4c4');
	var buttonNum = textStrings.length;
	var buttonWidths = new Array(buttonNum);
	var buttonTotalWidth = 0;
	var labelOffset = 10;

	for (var i = 0; i < buttonNum; i++)
	{
		buttonWidths[i] = mxUtils.getSizeForString(textStrings[i], fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
		buttonTotalWidth += buttonWidths[i];
	}

	var trueH = Math.max(h, fontSize * 1.5, 20);
	var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
	var trueW = Math.max(w, minW);
	c.translate(x, y);
	c.setShadow(false);

	this.separators(c, trueW, trueH, buttonNum, buttonWidths, labelOffset, minW, separatorColor);
	var currWidth = 0;

	for (var i = 0; i < buttonNum; i++)
	{
		if (i + 1 === buttonNum)
		{
			c.setFontColor(selectedFontColor);
		}
		else
		{
			c.setFontColor(fontColor);
		}

		currWidth = currWidth + labelOffset;
		this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
		currWidth = currWidth + buttonWidths[i] + labelOffset;
	}
};

mxShapeMockupBreadcrumb.prototype.separators = function(c, w, h, buttonNum, buttonWidths, labelOffset, minW, separatorColor)
{
	//draw the button separators
	c.setStrokeColor(separatorColor);
	var midY = h * 0.5;
	var size = 5;
	c.begin();

	for (var i = 1; i < buttonNum; i++)
	{
		var currWidth = 0;

		for (var j = 0; j < i; j++)
		{
			currWidth += buttonWidths[j] + 2 * labelOffset;
		}

		currWidth = currWidth * w / minW;
		c.moveTo(currWidth - size * 0.5, midY - size);
		c.lineTo(currWidth + size * 0.5, midY);
		c.lineTo(currWidth - size * 0.5, midY + size);
	}
	c.stroke();
};

mxShapeMockupBreadcrumb.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW)
{
	c.begin();
	c.setFontSize(fontSize);
	c.text((w + buttonWidth * 0.5) * trueW / minW, h * 0.5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeMockupBreadcrumb.prototype.cst.SHAPE_BREADCRUMB, mxShapeMockupBreadcrumb);

//**********************************************************************************************************************************************************
//Step Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupStepBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupStepBar, mxShape);

mxShapeMockupStepBar.prototype.cst = {
		SHAPE_STEP_BAR : 'mxgraph.mockup.navigation.stepBar',
		SELECTED : '+',			//must be 1 char
		MAIN_TEXT : 'mainText',
		TEXT_SIZE : 'textSize',
		TEXT_COLOR : 'textColor',
		TEXT_COLOR2 : 'textColor2'
};

mxShapeMockupStepBar.prototype.customProperties = [
	{name: 'mainText', dispName: 'Text', type: 'string'},
	{name: 'textSize', dispName: 'Text Size', type: 'float'},
	{name: 'textColor', dispName: 'Text Color', type: 'color'},
	{name: 'textColor2', dispName: 'Text2 Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupStepBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var textStrings = mxUtils.getValue(this.style, mxShapeMockupStepBar.prototype.cst.MAIN_TEXT, 'Step 1, Step 2, Step 3').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupStepBar.prototype.cst.TEXT_COLOR, '#666666');
	var currColor = mxUtils.getValue(this.style, mxShapeMockupStepBar.prototype.cst.TEXT_COLOR2, '#008cff');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupStepBar.prototype.cst.TEXT_SIZE, '17').toString();
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#c4c4c4');
	var doneColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#666666');
	var buttonNum = textStrings.length;
	var buttonWidths = new Array(buttonNum);
	var buttonTotalWidth = 0;
	var labelOffset = 10;
	var selectedButton = -1;

	for (var i = 0; i < buttonNum; i++)
	{
		var buttonText = textStrings[i];

		if(buttonText.charAt(0) === mxShapeMockupStepBar.prototype.cst.SELECTED)
		{
			buttonText = textStrings[i].substring(1);
			selectedButton = i;
		}

		buttonWidths[i] = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		buttonTotalWidth += buttonWidths[i];
	}

	var trueH = Math.max(h, fontSize * 1.5, 20);
	var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
	var trueW = Math.max(w, minW);
	c.translate(x, y);

	this.stepLineBg(c, trueW, trueH, buttonNum, buttonWidths, labelOffset, minW, bgColor, fontSize, trueW);
	c.setShadow(false);

	this.stepLineFg(c, trueW, trueH, buttonNum, buttonWidths, labelOffset, minW, bgColor, doneColor, currColor, fontSize, trueW, selectedButton);
	var currWidth = 0;

	for (var i = 0; i < buttonNum; i++)
	{
		if (i >= selectedButton)
		{
			c.setFontColor(currColor);
		}
		else
		{
			c.setFontColor(fontColor);
		}

		currWidth = currWidth + labelOffset;
		this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
		currWidth = currWidth + buttonWidths[i] + labelOffset;
	}
};

mxShapeMockupStepBar.prototype.stepLineBg = function(c, w, h, buttonNum, buttonWidths, labelOffset, minW, bgColor, fontSize, trueW)
{
	//draw the button separators
	c.setStrokeColor(bgColor);
	c.setFillColor(bgColor);
	var midY = fontSize * 2;
	var size = 10;
	var startX = 0;
	var endX = 0;

	for (var i = 0; i < buttonNum; i++)
	{
		var currWidth = 0;

		for (var j = 0; j < i; j++)
		{
			currWidth += buttonWidths[j] + 2 * labelOffset;
		}

		currWidth += buttonWidths[i] * 0.5 + labelOffset;

		currWidth = currWidth * w / minW;

		if (i === 0)
		{
			startX = currWidth;	
		}
		else if (i + 1 === buttonNum)
		{
			endX = currWidth;
		}

		c.begin();
		c.ellipse(currWidth - size, midY - size, 2 * size, 2 * size);
		c.fillAndStroke();
	}

	c.begin();
	c.rect(startX, midY - size * 0.2, endX - startX, size * 0.4);
	c.fillAndStroke();
};

mxShapeMockupStepBar.prototype.stepLineFg = function(c, w, h, buttonNum, buttonWidths, labelOffset, minW, bgColor, doneColor, currColor, fontSize, trueW, selectedButton)
{
	//draw the button separators
	c.setStrokeColor(doneColor);
	var midY = fontSize * 2;
	var size = 10 * 0.75;
	var startX = 0;
	var endX = 0;
	var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '1');

	for (var i = 0; i <= selectedButton; i++)
	{
		var currWidth = 0;

		for (var j = 0; j < i; j++)
		{
			currWidth += buttonWidths[j] + 2 * labelOffset;
		}

		currWidth += buttonWidths[i] * 0.5 + labelOffset;

		currWidth = currWidth * w / minW;

		if (i === 0)
		{
			startX = currWidth;	
		}
		else if (i === selectedButton)
		{
			endX = currWidth;
		}
	}
	
	c.setFillColor(doneColor);
	c.begin();
	c.rect(startX, midY - size * 0.15, endX - startX, size * 0.3);
	c.fill();
	c.setFillColor(bgColor);

	for (var i = 0; i <= selectedButton; i++)
	{
		var currWidth = 0;

		for (var j = 0; j < i; j++)
		{
			currWidth += buttonWidths[j] + 2 * labelOffset;
		}

		currWidth += buttonWidths[i] * 0.5 + labelOffset;

		currWidth = currWidth * w / minW;

		if (i === 0)
		{
			startX = currWidth;	
		}
		else if (i + 1 === selectedButton)
		{
			endX = currWidth;
		}

		if (i < selectedButton)
		{
			c.setStrokeWidth(strokeWidth);
			c.begin();
			c.ellipse(currWidth - size, midY - size, 2 * size, 2 * size);
			c.fillAndStroke();

			c.setStrokeWidth(strokeWidth * 0.5);
			c.begin();
			c.ellipse(currWidth - size * 0.6, midY - size * 0.6, 2 * size * 0.6, 2 * size * 0.6);
			c.fillAndStroke();
		}
		else
		{
			c.setStrokeWidth(strokeWidth);
			c.setFillColor(bgColor);
			c.setStrokeColor(bgColor);
			c.begin();
			c.ellipse(currWidth - size / 0.75, midY - size / 0.75, 2 * size / 0.75, 2 * size / 0.75);
			c.fillAndStroke();

			c.setStrokeWidth(strokeWidth);
			c.setFillColor('#ffffff');
			c.setStrokeColor('#ffffff');
			c.begin();
			c.ellipse(currWidth - size, midY - size, 2 * size, 2 * size);
			c.fillAndStroke();

			c.setFillColor(currColor);
			c.setStrokeColor(currColor);
			c.setStrokeWidth(strokeWidth * 0.5);
			c.begin();
			c.ellipse(currWidth - size * 0.7, midY - size * 0.7, 2 * size * 0.7, 2 * size * 0.7);
			c.fillAndStroke();
		}
	}
};

mxShapeMockupStepBar.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW)
{
	if(textString.charAt(0) === mxShapeMockupStepBar.prototype.cst.SELECTED)
	{
		textString = textString.substring(1);
	}

	c.begin();
	c.setFontSize(fontSize);
	c.text((w + buttonWidth * 0.5) * trueW / minW, fontSize * 0.5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxShapeMockupStepBar.prototype.cst.SHAPE_STEP_BAR, mxShapeMockupStepBar);

//**********************************************************************************************************************************************************
//Cover Flow
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupCoverFlow(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupCoverFlow, mxShape);

mxShapeMockupCoverFlow.prototype.cst = {
		SHAPE_COVER_FLOW : 'mxgraph.mockup.navigation.coverFlow'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupCoverFlow.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(w * 0.0924, h * 0.07);
	c.lineTo(w * 0.005, h * 0.01);
	c.lineTo(w * 0.005, h * 0.99);
	c.lineTo(w * 0.0924, h * 0.93);

	c.moveTo(w * 0.1774, h * 0.09);
	c.lineTo(w * 0.0924, h * 0.01);
	c.lineTo(w * 0.0924, h * 0.99);
	c.lineTo(w * 0.1774, h * 0.91);

	c.moveTo(w * 0.3373, h * 0.22);
	c.lineTo(w * 0.1774, h * 0.01);
	c.lineTo(w * 0.1774, h * 0.99);
	c.lineTo(w * 0.3373, h * 0.78);

	c.moveTo(w * 0.912, h * 0.07);
	c.lineTo(w * 0.998, h * 0.01);
	c.lineTo(w * 0.998, h * 0.99);
	c.lineTo(w * 0.912, h * 0.93);

	c.moveTo(w * 0.8271, h * 0.09);
	c.lineTo(w * 0.912, h * 0.01);
	c.lineTo(w * 0.912, h * 0.99);
	c.lineTo(w * 0.8271, h * 0.91);

	c.moveTo(w * 0.6672, h * 0.22);
	c.lineTo(w * 0.8271, h * 0.01);
	c.lineTo(w * 0.8271, h * 0.99);
	c.lineTo(w * 0.6672, h * 0.78);

	c.moveTo(w * 0.3373, h * 0.005);
	c.lineTo(w * 0.3373, h * 0.995);
	c.lineTo(w * 0.6672, h * 0.995);
	c.lineTo(w * 0.6672, h * 0.005);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupCoverFlow.prototype.cst.SHAPE_COVER_FLOW, mxShapeMockupCoverFlow);

//**********************************************************************************************************************************************************
//Scroll Bar
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupScrollBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupScrollBar, mxShape);

mxShapeMockupScrollBar.prototype.cst = {
		SHAPE_SCROLL_BAR : 'mxgraph.mockup.navigation.scrollBar',
		FILL_COLOR2 : 'fillColor2',
		STROKE_COLOR2 : 'strokeColor2',
		BAR_POS : 'barPos'
};

mxShapeMockupScrollBar.prototype.customProperties = [
	{name: 'barPos', dispName: 'Handle Position', type: 'float'},
	{name: 'fillColor2', dispName: 'Fill2 Color', type: 'color'},
	{name: 'strokeColor2', dispName: 'Stroke2 Color', type: 'color'}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupScrollBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	h = 20;
	var buttonX = 20;
	w = Math.max(w, 2 * buttonX);
	
	c.translate(x, y);
	this.background(c, w, h, buttonX);
	c.setShadow(false);
	this.foreground(c, w, h, buttonX);
	this.barPos = 20;
};

mxShapeMockupScrollBar.prototype.background = function(c, w, h, buttonX)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
	c.begin();
	c.moveTo(buttonX, 0);
	c.lineTo(buttonX, h);
	c.moveTo(w - buttonX, 0);
	c.lineTo(w - buttonX, h);
	c.stroke();
}

mxShapeMockupScrollBar.prototype.foreground = function(c, w, h, buttonX)
{
	var barPos = mxUtils.getValue(this.style, mxShapeMockupScrollBar.prototype.cst.BAR_POS, '20');
	var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupScrollBar.prototype.cst.FILL_COLOR2, '#99ddff');
	var strokeColor2 = mxUtils.getValue(this.style, mxShapeMockupScrollBar.prototype.cst.STROKE_COLOR2, 'none');
	
	barPos = Math.max(0, barPos);
	barPos = Math.min(100, barPos);
	
	c.setStrokeColor(strokeColor2);
	c.setFillColor(fillColor2);
	
	c.begin();
	c.moveTo(buttonX * 0.2, h * 0.5);
	c.lineTo(buttonX * 0.8, h * 0.2);
	c.lineTo(buttonX * 0.8, h * 0.8);
	c.close();
	c.moveTo(w - buttonX * 0.2, h * 0.5);
	c.lineTo(w - buttonX * 0.8, h * 0.2);
	c.lineTo(w - buttonX * 0.8, h * 0.8);
	c.close();
	c.fillAndStroke();

	//draw the handle based on arg.barPos
	var barWidth = 60;
	var barMin = buttonX;
	var barMax = w - buttonX;
	barWidth = Math.min(barWidth, barMax - barMin);
	var barCenterMin = barMin + barWidth / 2;
	var barCenterMax = barMax - barWidth / 2;
	var barCenterRange = barCenterMax - barCenterMin;
	var barCenterPos = barCenterRange * barPos / 100;
	var barStart = barMin + barCenterPos;

	c.roundrect(barStart, h * 0.15, barWidth, h * 0.7, 5, 5);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupScrollBar.prototype.cst.SHAPE_SCROLL_BAR, mxShapeMockupScrollBar);

Graph.handleFactory[mxShapeMockupScrollBar.prototype.cst.SHAPE_SCROLL_BAR] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'barPos', this.barPos))));

				return new mxPoint(bounds.x + ((bounds.width - 100) * barPos / bounds.width) / 100 * bounds.width + 50, bounds.y + 10);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(1000 * Math.max(0, Math.min(100, (pt.x - bounds.x - 50) * 100 / (bounds.width - 100)))) / 1000;
			})];

	return handles;
}

//**********************************************************************************************************************************************************
//Pagination
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupPagination(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupPagination, mxShape);

mxShapeMockupPagination.prototype.cst = {
		MAIN_TEXT : 'linkText',
		TEXT_SIZE : 'textSize',
		TEXT_COLOR : 'textColor',
		SHAPE_PAGINATION : 'mxgraph.mockup.navigation.pagination'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupPagination.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxShapeMockupPagination.prototype.cst.MAIN_TEXT, '0-9 A B C D E F G H I J K L M N O P Q R S T U V X Y Z');
	var textSize = mxUtils.getValue(this.style, mxShapeMockupPagination.prototype.cst.TEXT_SIZE, '17');
	var textColor = mxUtils.getValue(this.style, mxShapeMockupPagination.prototype.cst.TEXT_COLOR, '#0000ff');

	c.translate(x, y);
	var width = mxUtils.getSizeForString(mainText, textSize, mxConstants.DEFAULT_FONTFAMILY).width;
	c.setStrokeColor(textColor);
	c.setFontSize(textSize);
	c.setFontColor(textColor);
	c.text(w * 0.5, h * 0.5, 0, 0, mainText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.begin();
	c.moveTo(w * 0.5 - width * 0.5, (h + parseInt(textSize, 10)) * 0.5);
	c.lineTo(w * 0.5 + width * 0.5, (h + parseInt(textSize, 10)) * 0.5);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupPagination.prototype.cst.SHAPE_PAGINATION, mxShapeMockupPagination);

//**********************************************************************************************************************************************************
//Page Control
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupPageControl(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupPageControl, mxShape);

mxShapeMockupPageControl.prototype.cst = {
		SHAPE_PAGE_CONTROL : 'mxgraph.mockup.navigation.pageControl'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupPageControl.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);


	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#000000');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');

	var rSize = Math.min(h * 0.5, w * 0.05);
	c.setFillColor(strokeColor);
	c.ellipse(0, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
	c.setFillColor(fillColor);
	c.ellipse(w * 0.35 - rSize, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
	c.ellipse(w * 0.65 - rSize, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
	c.ellipse(w - 2 * rSize, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
};

mxCellRenderer.registerShape(mxShapeMockupPageControl.prototype.cst.SHAPE_PAGE_CONTROL, mxShapeMockupPageControl);

//**********************************************************************************************************************************************************
//Map Navigator
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupMapNavigator(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupMapNavigator, mxShape);

mxShapeMockupMapNavigator.prototype.cst = {
		SHAPE_MAP_NAVIGATOR : 'mxgraph.mockup.navigation.mapNavigator',
		FILL_COLOR2 : 'fillColor2',
		STROKE_COLOR2 : 'strokeColor2',
		STROKE_COLOR3 : 'strokeColor3'
};

mxShapeMockupMapNavigator.prototype.customProperties = [
	{name: 'fillColor2', dispName: 'Fill2 Color', type: 'color'},
	{name: 'strokeColor2', dispName: 'Stroke2 Color', type: 'color'},
	{name: 'strokeColor3', dispName: 'Stroke3 Color', type: 'color'}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupMapNavigator.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupMapNavigator.prototype.background = function(c, w, h)
{
	c.ellipse(0, 0, w, h * 0.6);
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.35, h * 0.584);
	c.lineTo(w * 0.35, h * 0.95);
	c.arcTo(w * 0.083, h * 0.05, 0, 0, 0, w * 0.43, h);
	c.lineTo(w * 0.56, h);
	c.arcTo(w * 0.083, h * 0.05, 0, 0, 0, w * 0.65, h * 0.95);
	c.lineTo(w * 0.65, h * 0.584);
	c.fillAndStroke();
}

mxShapeMockupMapNavigator.prototype.foreground = function(c, w, h)
{
	var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupMapNavigator.prototype.cst.FILL_COLOR2, '#99ddff');
	var strokeColor2 = mxUtils.getValue(this.style, mxShapeMockupMapNavigator.prototype.cst.STROKE_COLOR2, 'none');
	var strokeColor3 = mxUtils.getValue(this.style, mxShapeMockupMapNavigator.prototype.cst.STROKE_COLOR3, '#ffffff');

	c.setFillColor(fillColor2);
	c.setStrokeColor(strokeColor2);
	c.ellipse(w * 0.4, h * 0.65, w * 0.2, h * 0.12);
	c.fillAndStroke();
	c.ellipse(w * 0.4, h * 0.85, w * 0.2, h * 0.12);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w * 0.1806, h * 0.34);
	c.lineTo(w * 0.1357, h * 0.366);
	c.lineTo(w * 0.0228, h * 0.3);
	c.lineTo(w * 0.1357, h * 0.234);
	c.lineTo(w * 0.1806, h * 0.26);
	c.lineTo(w * 0.1142, h * 0.3);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.433, h * 0.108);
	c.lineTo(w * 0.3881, h * 0.08);
	c.lineTo(w * 0.4994, h * 0.012);
	c.lineTo(w * 0.6123, h * 0.08);
	c.lineTo(w * 0.5658, h * 0.108);
	c.lineTo(w * 0.4994, h * 0.068);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.8198, h * 0.262);
	c.lineTo(w * 0.868, h * 0.233);
	c.lineTo(w * 0.9776, h * 0.3);
	c.lineTo(w * 0.868, h * 0.367);
	c.lineTo(w * 0.8198, h * 0.341);
	c.lineTo(w * 0.8863, h * 0.3);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.5641, h * 0.493);
	c.lineTo(w * 0.6123, h * 0.522);
	c.lineTo(w * 0.4994, h * 0.588);
	c.lineTo(w * 0.3881, h * 0.521);
	c.lineTo(w * 0.4363, h * 0.493);
	c.lineTo(w * 0.4994, h * 0.533);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.3333, h * 0.32);
	c.lineTo(w * 0.3333, h * 0.28);
	c.lineTo(w * 0.4163, h * 0.3);
	c.close();
	c.moveTo(w * 0.4662, h * 0.2);
	c.lineTo(w * 0.5326, h * 0.2);
	c.lineTo(w * 0.4994, h * 0.25);
	c.close()
	c.moveTo(w * 0.6654, h * 0.28);
	c.lineTo(w * 0.6654, h * 0.32);
	c.lineTo(w * 0.5824, h * 0.3);
	c.close();
	c.moveTo(w * 0.5326, h * 0.4);
	c.lineTo(w * 0.4662, h * 0.4);
	c.lineTo(w * 0.4994, h * 0.35);
	c.close();
	c.fillAndStroke();
	
	c.setStrokeWidth(2);
	c.setStrokeColor(strokeColor3);
	
	c.begin();
	c.moveTo(w * 0.5, h * 0.67);
	c.lineTo(w * 0.5, h * 0.75);
	c.moveTo(w * 0.43, h * 0.71);
	c.lineTo(w * 0.57, h * 0.71);
	c.moveTo(w * 0.43, h * 0.91);
	c.lineTo(w * 0.57, h * 0.91);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupMapNavigator.prototype.cst.SHAPE_MAP_NAVIGATOR, mxShapeMockupMapNavigator);

//**********************************************************************************************************************************************************
//Anchor (a dummy shape without visuals used for anchoring)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupNavigationAnchor(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupNavigationAnchor, mxShape);

mxShapeMockupNavigationAnchor.prototype.cst = {
		ANCHOR : 'mxgraph.mockup.navigation.anchor'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupNavigationAnchor.prototype.paintVertexShape = function(c, x, y, w, h)
{
};

mxCellRenderer.registerShape(mxShapeMockupNavigationAnchor.prototype.cst.ANCHOR, mxShapeMockupNavigationAnchor);


/**
 * $Id: mxMockupText.js,v 1.4 2013/05/24 07:12:36 mate Exp $
 * Copyright (c) 2006-2010, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Link
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupLink(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupLink, mxShape);

mxShapeMockupLink.prototype.cst = {
		LINK_TEXT : 'linkText',
		TEXT_SIZE : 'textSize',
		TEXT_COLOR : 'textColor',
		SHAPE_LINK : 'mxgraph.mockup.text.link'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupLink.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var linkText = mxUtils.getValue(this.style, mxShapeMockupLink.prototype.cst.LINK_TEXT, 'Link');
	var textSize = mxUtils.getValue(this.style, mxShapeMockupLink.prototype.cst.TEXT_SIZE, '17');
	var textColor = mxUtils.getValue(this.style, mxShapeMockupLink.prototype.cst.TEXT_COLOR, '#0000ff');

	c.translate(x, y);
	var width = mxUtils.getSizeForString(linkText, textSize, mxConstants.DEFAULT_FONTFAMILY).width;
	c.setStrokeColor(textColor);
	c.setFontSize(textSize);
	c.setFontColor(textColor);

	c.text(w * 0.5, h * 0.5, 0, 0, linkText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.begin();
	c.moveTo(w * 0.5 - width * 0.5, (h + parseInt(textSize, 10)) * 0.5);
	c.lineTo(w * 0.5 + width * 0.5, (h + parseInt(textSize, 10)) * 0.5);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupLink.prototype.cst.SHAPE_LINK, mxShapeMockupLink);

//**********************************************************************************************************************************************************
//Link Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupLinkBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupLinkBar, mxShape);

mxShapeMockupLinkBar.prototype.cst = {
		MAIN_TEXT : 'mainText',
		SHAPE_LINK_BAR : 'mxgraph.mockup.text.linkBar',
		TEXT_COLOR : 'textColor',
		TEXT_COLOR2 : 'textColor2',
		STROKE_COLOR2 : 'strokeColor2',
		FILL_COLOR2 : 'fillColor2',
		SELECTED : '+',			//must be 1 char
		TEXT_SIZE : 'textSize'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupLinkBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var textStrings = mxUtils.getValue(this.style, mxShapeMockupLinkBar.prototype.cst.MAIN_TEXT, '+Button 1, Button 2, Button 3').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupLinkBar.prototype.cst.TEXT_COLOR, '#666666');
	var selectedFontColor = mxUtils.getValue(this.style, mxShapeMockupLinkBar.prototype.cst.TEXT_COLOR2, '#ffffff');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupLinkBar.prototype.cst.TEXT_SIZE, '17').toString();
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var separatorColor = mxUtils.getValue(this.style, mxShapeMockupLinkBar.prototype.cst.STROKE_COLOR2, '#c4c4c4');
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var selectedFillColor = mxUtils.getValue(this.style, mxShapeMockupLinkBar.prototype.cst.FILL_COLOR2, '#008cff');
	var buttonNum = textStrings.length;
	var buttonWidths = new Array(buttonNum);
	var buttonTotalWidth = 0;
	var selectedButton = -1;
	var rSize = 10; //rounding size
	var labelOffset = 5;

	for (var i = 0; i < buttonNum; i++)
	{
		var buttonText = textStrings[i];

		if(buttonText.charAt(0) === mxShapeMockupLinkBar.prototype.cst.SELECTED)
		{
			buttonText = textStrings[i].substring(1);
			selectedButton = i;
		}

		var currW = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currW === 0)
		{
			buttonWidths[i] = 42;
		}
		else
		{
			buttonWidths[i] = currW;
		}

		buttonTotalWidth += buttonWidths[i];
	}

	var trueH = Math.max(h, fontSize * 1.5, 20);
	var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
	var trueW = Math.max(w, minW);

	c.translate(x, y);
	this.background(c, trueW, trueH, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton);
	c.setShadow(false);

	var currWidth = 0;

	for (var i = 0; i < buttonNum; i++)
	{
		if (i === selectedButton)
		{
			c.setFontColor(selectedFontColor);
			c.setStrokeColor(selectedFontColor);
		}
		else
		{
			c.setFontColor(fontColor);
			c.setStrokeColor(fontColor);
		}

		currWidth = currWidth + labelOffset;
		this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
		currWidth = currWidth + buttonWidths[i] + labelOffset;
	}
};

mxShapeMockupLinkBar.prototype.background = function(c, w, h, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton)
{
	c.begin();

	//draw the frame
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.rect(0, 0, w, h);
	c.fillAndStroke();

	//draw the button separators
	c.setStrokeColor(separatorColor);
	c.begin();

	for (var i = 1; i < buttonNum; i++)
	{
		if (i !== selectedButton && i !== (selectedButton + 1))
		{
			var currWidth = 0;

			for (var j = 0; j < i; j++)
			{
				currWidth += buttonWidths[j] + 2 * labelOffset;
			}

			currWidth = currWidth * w / minW;
			c.moveTo(currWidth, 0);
			c.lineTo(currWidth, h);
		}
	}

	c.stroke();

	//draw the selected button
	var buttonLeft = 0;
	c.setFillColor(selectedFillColor);

	for (var i = 0; i < selectedButton; i++)
	{
		buttonLeft += buttonWidths[i] + 2 * labelOffset;
	}

	buttonLeft = buttonLeft * w / minW;
	var buttonRight = (buttonWidths[selectedButton] + 2 * labelOffset) * w / minW;
	buttonRight += buttonLeft;

	if (selectedButton === 0)
	{
		c.rect(0, 0, buttonRight, h);
		c.fill();
	}
	else if (selectedButton === buttonNum - 1)
	{
		c.rect(buttonLeft, 0, buttonRight - buttonLeft, h);
		c.fill();
	}
	else if (selectedButton !== -1)
	{
		c.rect(buttonLeft, 0, buttonRight - buttonLeft, h);
		c.fill();
	}

	//draw the frame again, to achieve a nicer effect
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.rect(0, 0, w, h);
	c.stroke();
};

mxShapeMockupLinkBar.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW)
{
	if(textString.charAt(0) === mxShapeMockupLinkBar.prototype.cst.SELECTED)
	{
		textString = textString.substring(1);
	}

	c.begin();
	c.setFontSize(fontSize);
	c.text((w + buttonWidth * 0.5) * trueW / minW, h * 0.5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	var textW = mxUtils.getSizeForString(textString, fontSize, mxConstants.DEFAULT_FONTFAMILY).width * 0.5;

	if (textString !== null && textString !== '')
	{
		c.begin();
		c.moveTo((w + buttonWidth * 0.5) * trueW / minW - textW, h * 0.5 + fontSize * 0.5);
		c.lineTo((w + buttonWidth * 0.5) * trueW / minW + textW, h * 0.5 + fontSize * 0.5);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapeMockupLinkBar.prototype.cst.SHAPE_LINK_BAR, mxShapeMockupLinkBar);

//**********************************************************************************************************************************************************
//Callout
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupCallout(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupCallout, mxShape);

mxShapeMockupCallout.prototype.cst = {
		CALLOUT_TEXT : 'linkText',
		CALLOUT_DIR : 'callDir',
		CALLOUT_STYLE : 'callStyle',
		STYLE_LINE : 'line',
		STYLE_RECT : 'rect',
		STYLE_ROUNDRECT : 'roundRect',
		DIR_NW : 'NW',
		DIR_NE : 'NE',
		DIR_SE : 'SE',
		DIR_SW : 'SW',
		TEXT_SIZE : 'textSize',
		TEXT_COLOR : 'textColor',
		SHAPE_CALLOUT : 'mxgraph.mockup.text.callout'
};

mxShapeMockupCallout.prototype.customProperties = [
	{name: 'callDir', dispName: 'Direction', type: 'enum',
		enumList:[{val: 'NW', dispName:'North-West'},
			      {val: 'NE', dispName:'North-East'},
			      {val: 'SE', dispName:'South-East'},
			      {val: 'SW', dispName:'South-West'}]},
	{name: 'callStyle', dispName: 'Style', type: 'enum',
		enumList:[{val: 'line', dispName:'Line'},
			      {val: 'rect', dispName:'Rectangle'}]}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupCallout.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var calloutText = mxUtils.getValue(this.style, mxShapeMockupCallout.prototype.cst.CALLOUT_TEXT, 'Callout');
	var textSize = mxUtils.getValue(this.style, mxShapeMockupCallout.prototype.cst.TEXT_SIZE, '17');
	var textColor = mxUtils.getValue(this.style, mxShapeMockupCallout.prototype.cst.TEXT_COLOR, '#666666');
	var callStyle = mxUtils.getValue(this.style, mxShapeMockupCallout.prototype.cst.CALLOUT_STYLE, mxShapeMockupCallout.prototype.cst.STYLE_LINE);
	var callDir = mxUtils.getValue(this.style, mxShapeMockupCallout.prototype.cst.CALLOUT_DIR, mxShapeMockupCallout.prototype.cst.DIR_NW);
	var textWidth = mxUtils.getSizeForString(calloutText, textSize, mxConstants.DEFAULT_FONTFAMILY).width;
	textWidth = textWidth * 1.2;

	if (textWidth == 0)
	{
		textWidth = 70;
	}

	c.translate(x, y);
	c.setFontSize(textSize);
	c.setFontColor(textColor);
	var callH = textSize * 1.5; 

	if (callDir === mxShapeMockupCallout.prototype.cst.DIR_NW)
	{
		if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_LINE)
		{
			c.begin();
			c.moveTo(0, callH);
			c.lineTo(textWidth, callH);
			c.lineTo(w, h);
			c.stroke();
		}
		else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_RECT)
		{
			c.rect(0,0, textWidth, callH);
			c.fillAndStroke();
			c.begin();
			c.moveTo(textWidth * 0.5, callH);
			c.lineTo(w, h);
			c.stroke();
		}
		else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_ROUNDRECT)
		{
			c.roundrect(0, 0, textWidth, callH, callH * 0.25, callH * 0.25);
			c.fillAndStroke();
			c.begin();
			c.moveTo(textWidth * 0.5, callH);
			c.lineTo(w, h);
			c.stroke();
		}

		c.text(textWidth * 0.5, callH * 0.5, 0, 0, calloutText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
	else if (callDir === mxShapeMockupCallout.prototype.cst.DIR_NE)
	{
		if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_LINE)
		{
			c.begin();
			c.moveTo(w, callH);
			c.lineTo(w - textWidth, callH);
			c.lineTo(0, h);
			c.stroke();
		}
		else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_RECT)
		{
			c.rect(w - textWidth,0, textWidth, callH);
			c.fillAndStroke();
			c.begin();
			c.moveTo(w - textWidth * 0.5, callH);
			c.lineTo(0, h);
			c.stroke();
		}
		else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_ROUNDRECT)
		{
			c.roundrect(w - textWidth,0, textWidth, callH, callH * 0.25, callH * 0.25);
			c.fillAndStroke();
			c.begin();
			c.moveTo(w - textWidth * 0.5, callH);
			c.lineTo(0, h);
			c.stroke();
		}

		c.text(w - textWidth * 0.5, callH * 0.5, 0, 0, calloutText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
	else if (callDir === mxShapeMockupCallout.prototype.cst.DIR_SE)
	{
		if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_LINE)
		{
			c.begin();
			c.moveTo(w, h);
			c.lineTo(w - textWidth, h);
			c.lineTo(0, 0);
			c.stroke();
		}
		else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_RECT)
		{
			c.rect(w - textWidth, h - callH, textWidth, callH);
			c.fillAndStroke();
			c.begin();
			c.moveTo(w - textWidth * 0.5, h - callH);
			c.lineTo(0, 0);
			c.stroke();
		}
		else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_ROUNDRECT)
		{
			c.roundrect(w - textWidth,h - callH, textWidth, callH, callH * 0.25, callH * 0.25);
			c.fillAndStroke();
			c.begin();
			c.moveTo(w - textWidth * 0.5, h - callH);
			c.lineTo(0, 0);
			c.stroke();
		}

		c.text(w - textWidth * 0.5, h - callH * 0.5, 0, 0, calloutText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
	else if (callDir === mxShapeMockupCallout.prototype.cst.DIR_SW)
	{
		if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_LINE)
		{
			c.begin();
			c.moveTo(0, h);
			c.lineTo(textWidth, h);
			c.lineTo(w, 0);
			c.stroke();
		}
		else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_RECT)
		{
			c.rect(0, h - callH, textWidth, callH);
			c.fillAndStroke();
			c.begin();
			c.moveTo(textWidth * 0.5, h - callH);
			c.lineTo(w, 0);
			c.stroke();
		}
		else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_ROUNDRECT)
		{
			c.roundrect(0, h - callH, textWidth, callH, callH * 0.25, callH * 0.25);
			c.fillAndStroke();
			c.begin();
			c.moveTo(textWidth * 0.5, h - callH);
			c.lineTo(w, 0);
			c.stroke();
		}

		c.text(textWidth * 0.5, h - callH * 0.5, 0, 0, calloutText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}

};

mxCellRenderer.registerShape(mxShapeMockupCallout.prototype.cst.SHAPE_CALLOUT, mxShapeMockupCallout);

//**********************************************************************************************************************************************************
//Sticky Note
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupStickyNote(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupStickyNote, mxShape);

mxShapeMockupStickyNote.prototype.cst = {
		MAIN_TEXT : 'mainText',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize',
		SHAPE_STICKY_NOTE : 'mxgraph.mockup.text.stickyNote'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupStickyNote.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupStickyNote.prototype.background = function(c, w, h)
{
	c.setFillColor('#ffffcc');
	c.begin();
	c.moveTo(w * 0.03, h * 0.07);
	c.lineTo(w * 0.89, h * 0.06);
	c.arcTo(2.81 * w, 2.92 * h, 1, 0, 0, w * 0.99, h * 0.98);
	c.lineTo(w * 0.09, h * 0.99);
	c.arcTo(2.81 * w, 2.92 * h, 1, 0, 1, w * 0.03, h * 0.07);
	c.close();
	c.fill();
};

mxShapeMockupStickyNote.prototype.foreground = function(c, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxShapeMockupStickyNote.prototype.cst.MAIN_TEXT, 'Note line 1,Note line 2,Note line 3').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupStickyNote.prototype.cst.TEXT_COLOR, '#666666').toString();
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupStickyNote.prototype.cst.TEXT_SIZE, '17').toString();

	c.setFillColor('#ff3300');
	c.begin();
	c.moveTo(w * 0.28 , 0);
	c.lineTo(w * 0.59, 0);
	c.lineTo(w * 0.6, h * 0.12);
	c.lineTo(w * 0.28, h * 0.13);
	c.close();
	c.fill();

	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	var lineNum = mainText.length;
	var textH = lineNum * fontSize * 1.5;

	for (var i = 0; i < mainText.length; i++)
	{
		c.text(w / 2, (h - textH) / 2 + i * fontSize * 1.5 + fontSize * 0.75, 0, 0, mainText[i], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
};

mxCellRenderer.registerShape(mxShapeMockupStickyNote.prototype.cst.SHAPE_STICKY_NOTE, mxShapeMockupStickyNote);

//**********************************************************************************************************************************************************
//Bulleted List
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupBulletedList(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupBulletedList, mxShape);

mxShapeMockupBulletedList.prototype.cst = {
		MAIN_TEXT : 'mainText',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize',
		BULLET_STYLE : 'bulletStyle',
		STYLE_HYPHEN : 'hyphen',
		STYLE_NUM : 'number',
		STYLE_DOT : 'dot',
		SHAPE_BULLETED_LIST : 'mxgraph.mockup.text.bulletedList'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupBulletedList.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupBulletedList.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupBulletedList.prototype.foreground = function(c, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxShapeMockupBulletedList.prototype.cst.MAIN_TEXT, 'Note line 1,Note line 2,Note line 3').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupBulletedList.prototype.cst.TEXT_COLOR, '#666666');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupBulletedList.prototype.cst.TEXT_SIZE, '17');
	var bulletStyle = mxUtils.getValue(this.style, mxShapeMockupBulletedList.prototype.cst.BULLET_STYLE, 'none');

	c.setFontColor(fontColor);
	c.setFontSize(fontSize);

	var bullet = '';

	for (var i = 0; i < mainText.length; i++)
	{
		var currText = '';

		if (bulletStyle === mxShapeMockupBulletedList.prototype.cst.STYLE_NUM)
		{
			currText = (i + 1) + ') ' + mainText[i]; 
		}
		else if (bulletStyle === mxShapeMockupBulletedList.prototype.cst.STYLE_HYPHEN)
		{
			currText = '- ' + mainText[i]; 
		}
		else if(bulletStyle === mxShapeMockupBulletedList.prototype.cst.STYLE_DOT)
		{
			currText = String.fromCharCode(8226) + ' ' + mainText[i]; 
		}
		else
		{
			currText = '  ' + mainText[i]; 
		}

		c.text(10, i * fontSize * 1.5 + fontSize * 0.75, 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
};

mxCellRenderer.registerShape(mxShapeMockupBulletedList.prototype.cst.SHAPE_BULLETED_LIST, mxShapeMockupBulletedList);

//**********************************************************************************************************************************************************
//Text Box
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupTextBox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupTextBox, mxShape);

mxShapeMockupTextBox.prototype.cst = {
		MAIN_TEXT : 'mainText',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize',
		SHAPE_TEXT_BOX : 'mxgraph.mockup.text.textBox'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupTextBox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupTextBox.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupTextBox.prototype.foreground = function(c, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxShapeMockupTextBox.prototype.cst.MAIN_TEXT, 'Note line 1').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupTextBox.prototype.cst.TEXT_COLOR, '#666666');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupTextBox.prototype.cst.TEXT_SIZE, '17');

	c.setFontColor(fontColor);
	c.setFontSize(fontSize);

	for (var i = 0; i < mainText.length; i++)
	{
		c.text(5, i * fontSize * 1.5 + fontSize * 0.75, 0, 0, mainText[i], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
};

mxCellRenderer.registerShape(mxShapeMockupTextBox.prototype.cst.SHAPE_TEXT_BOX, mxShapeMockupTextBox);

//**********************************************************************************************************************************************************
//Captcha
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupCaptcha(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupCaptcha, mxShape);

mxShapeMockupCaptcha.prototype.cst = {
		MAIN_TEXT : 'mainText',
		TEXT_COLOR : 'textColor',
		TEXT_SIZE : 'textSize',
		SHAPE_CAPTCHA : 'mxgraph.mockup.text.captcha'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupCaptcha.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxShapeMockupCaptcha.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupCaptcha.prototype.foreground = function(c, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxShapeMockupCaptcha.prototype.cst.MAIN_TEXT, 'Note line 1');
	var fontColor = mxUtils.getValue(this.style, mxShapeMockupCaptcha.prototype.cst.TEXT_COLOR, '#666666');
	var fontSize = mxUtils.getValue(this.style, mxShapeMockupCaptcha.prototype.cst.TEXT_SIZE, '25');

	c.setFillColor('#88aaff');
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w * 0.35, 0);
	c.lineTo(w * 0.55, h * 0.85);
	c.lineTo(w * 0.4, h * 0.75);
	c.close();
	c.fill();

	c.begin();
	c.moveTo(w * 0.7, h * 0.1);
	c.lineTo(w * 0.95, h * 0.23);
	c.lineTo(w, h * 0.4);
	c.lineTo(w, h * 0.9);
	c.lineTo(w, h);
	c.lineTo(w * 0.8, h);
	c.close();
	c.fill();

	c.setFontColor(fontColor);
	c.setFontSize(fontSize);

	c.text(w * 0.5, h * 0.5, 0, 0, mainText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.rect(0, 0, w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupCaptcha.prototype.cst.SHAPE_CAPTCHA, mxShapeMockupCaptcha);

//**********************************************************************************************************************************************************
//Alphanumeric
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupAlphanumeric(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupAlphanumeric, mxShape);

mxShapeMockupAlphanumeric.prototype.cst = {
		MAIN_TEXT : 'linkText',
		TEXT_SIZE : 'textSize',
		TEXT_COLOR : 'textColor',
		SHAPE_ALPHANUMERIC : 'mxgraph.mockup.text.alphanumeric'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupAlphanumeric.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxShapeMockupAlphanumeric.prototype.cst.MAIN_TEXT, '0-9 A B C D E F G H I J K L M N O P Q R S T U V X Y Z');
	var textSize = mxUtils.getValue(this.style, mxShapeMockupAlphanumeric.prototype.cst.TEXT_SIZE, '17');
	var textColor = mxUtils.getValue(this.style, mxShapeMockupAlphanumeric.prototype.cst.TEXT_COLOR, '#0000ff');

	c.translate(x, y);
	var width = mxUtils.getSizeForString(mainText, textSize, mxConstants.DEFAULT_FONTFAMILY).width;
	c.setStrokeColor(textColor);
	c.setFontSize(textSize);
	c.setFontColor(textColor);
	c.text(w * 0.5, h * 0.5, 0, 0, mainText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.begin();
	c.moveTo(w * 0.5 - width * 0.5, (h + parseInt(textSize, 10)) * 0.5);
	c.lineTo(w * 0.5 + width * 0.5, (h + parseInt(textSize, 10)) * 0.5);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupAlphanumeric.prototype.cst.SHAPE_ALPHANUMERIC, mxShapeMockupAlphanumeric);

//**********************************************************************************************************************************************************
//Rounded rectangle (adjustable rounding)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupTextRRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupTextRRect, mxShape);

mxShapeMockupTextRRect.prototype.cst = {
		RRECT : 'mxgraph.mockup.text.rrect',
		R_SIZE : 'rSize'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupTextRRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupTextRRect.prototype.cst.R_SIZE, '10'));
	c.roundrect(0, 0, w, h, rSize);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupTextRRect.prototype.cst.RRECT, mxShapeMockupTextRRect);


/**
 * $Id: mxMockupiOS.js,v 1.5 2013/11/12 06:25:46 mate Exp $
 * Copyright (c) 2006-2010, JGraph Ltd
 */

var mxMockupC =
{
		BAR_HEIGHT : 'barHeight',
		BAR_POS : 'barPos',
		BG_STYLE : 'bgStyle',
		BG_FLAT_GREEN : 'bgGreen',
		BG_FLAT_WHITE : 'bgWhite',
		BG_FLAT_GRAY : 'bgGray',
		BG_FLAT_CUSTOM : 'bgFlat',
		BG_MAP : 'bgMap',
		BG_STRIPED : 'bgStriped',
		BUTTON_STYLE : 'buttonStyle',
		BUTTON_TEXT : 'buttonText',
		BUTTON_STATE : 'buttonState',
		CHEVRON : 'chevron',
		GRID_SIZE : 'gridSize',
		POINTER_BOTTOM : 'bottom',
		POINTER_POS : 'pointerPos',
		POINTER_TOP : 'top',
		ROUND : 'round',
		SELECTED : '+', 		//has to be one character long
		STATE_ON : 'on',
		STATE_OFF : 'off',
		SUB_TEXT : 'subText',
		
		SHAPE_IADD_ICON : 'mxgraph.ios.iAddIcon',
		SHAPE_IALERT_BOX : 'mxgraph.ios.iAlertBox',
		SHAPE_IALPHA_LIST : 'mxgraph.ios.iAlphaList',
		SHAPE_IAPP_BAR : 'mxgraph.ios.iAppBar',
		SHAPE_IARROW_ICON : 'mxgraph.ios.iArrowIcon',
		SHAPE_IBG_FLAT : 'mxgraph.ios.iBgFlat',
		SHAPE_IBG_MAP : 'mxgraph.ios.iBgMap',
		SHAPE_IBG_STRIPED : 'mxgraph.ios.iBgStriped',
		SHAPE_IBUTTON : 'mxgraph.ios.iButton',
		SHAPE_IBUTTON_BACK : 'mxgraph.ios.iButtonBack',
		SHAPE_IBUTTON_FORWARD : 'mxgraph.ios.iButtonFw',
		SHAPE_IBUTTON_BAR : 'mxgraph.ios.iButtonBar',
		SHAPE_ICALL_BUTTONS : 'mxgraph.ios.iCallButtons',
		SHAPE_ICALL_DIALOG : 'mxgraph.ios.iCallDialog',
		SHAPE_ICHECKBOX_GROUP : 'mxgraph.ios.iCheckboxGroup',
		SHAPE_ICHECK_ICON : 'mxgraph.ios.iCheckIcon',
		SHAPE_ICLOUD_PROGRESS_BAR : 'mxgraph.ios.iCloudProgressBar',
		SHAPE_ICOMBO_BOX : 'mxgraph.ios.iComboBox',
		SHAPE_ICOPY : 'mxgraph.ios.iCopy',
		SHAPE_ICOPY_AREA : 'mxgraph.ios.iCopyArea',
		SHAPE_IICON_GRID : 'mxgraph.ios.iIconGrid',
		SHAPE_IDELETE_APP : 'mxgraph.ios.iDeleteApp',
		SHAPE_IDELETE_ICON : 'mxgraph.ios.iDeleteIcon',
		SHAPE_IDOWNLOAD_BAR : 'mxgraph.ios.iDownloadBar',
		SHAPE_IDIALOG_BOX : 'mxgraph.ios.iDialogBox',
		SHAPE_IDIRECTION : 'mxgraph.ios.iDir',
		SHAPE_IHOME_PAGE_CONTROL : 'mxgraph.ios.iHomePageControl',
		SHAPE_IKEYB_LETTERS : 'mxgraph.ios.iKeybLett',
		SHAPE_IKEYB_NUMBERS : 'mxgraph.ios.iKeybNumb',
		SHAPE_IKEYB_SYMBOLS : 'mxgraph.ios.iKeybSymb',
		SHAPE_ILOCATION_BAR : 'mxgraph.ios.iLocBar',
		SHAPE_ILOCK_BUTTON : 'mxgraph.ios.iLockButton',
		SHAPE_IHOR_BUTTON_BAR : 'mxgraph.ios.iHorButtonBar',
		SHAPE_IINFO_ICON : 'mxgraph.ios.iInfoIcon',
		SHAPE_ION_OFF_BUTTON : 'mxgraph.ios.iOnOffButton',
		SHAPE_IOPTION : 'mxgraph.ios.iOption',
		SHAPE_IPAGE_CONTROL : 'mxgraph.ios.iPageControl',
		SHAPE_IPAD : 'mxgraph.ios.iPad',
		SHAPE_IPHONE : 'mxgraph.ios.iPhone',
		SHAPE_IPIN : 'mxgraph.ios.iPin',
		SHAPE_IPREV_NEXT : 'mxgraph.ios.iPrevNext',
		SHAPE_IPROGRESS_BAR : 'mxgraph.ios.iProgressBar',
		SHAPE_IRADIO_GROUP : 'mxgraph.ios.iRadioGroup',
		SHAPE_ISLIDER : 'mxgraph.ios.iSlider',
		SHAPE_ISORT_FIND_ICON : 'mxgraph.ios.iSortFindIcon',
		SHAPE_ITEXT_INPUT : 'mxgraph.ios.iTextInput',
		SHAPE_ITOP_BAR : 'mxgraph.ios.iTopBar',
		SHAPE_ITOP_BAR_LOCKED : 'mxgraph.ios.iTopBarLocked',
		SHAPE_IURL_BAR : 'mxgraph.ios.iURLBar',
		SHAPE_IVIDEO_CONTROLS : 'mxgraph.ios.iVideoControls',
		SHAPE_ISCREEN_NAME_BAR: 'mxgraph.ios.iScreenNameBar',
			
		STYLE_FILLCOLOR2 : 'fillColor2',
		STYLE_FILLCOLOR3 : 'fillColor3',
		STYLE_TEXTCOLOR : 'textColor',
		STYLE_TEXTCOLOR2 : 'textColor2',
		STYLE_STROKECOLOR2 : 'strokeColor2',
		STYLE_STROKECOLOR3 : 'strokeColor3'
};

//**********************************************************************************************************************************************************
//iPhone Vertical
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiPhone(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiPhone, mxShape);

mxShapeMockupiPhone.prototype.customProperties = [
	{name: 'bgStyle', dispName: 'Background', type: 'enum', 
		enumList: [{val: 'bgGreen', dispName: 'Green'}, 
			       {val: 'bgWhite', dispName: 'White'}, 
			       {val: 'bgGray', dispName: 'Gray'}, 
			       {val: 'bgFlat', dispName: 'Flat'}, 
			       {val: 'bgMap', dispName: 'Map'}, 
			       {val: 'bgStriped', dispName: 'Striped'}]}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiPhone.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var rSize = 25;
	this.background(c, x, y, w, h, rSize);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, rSize);
};

mxShapeMockupiPhone.prototype.background = function(c, x, y, w, h, rSize)
{
	c.setFillColor('#000000');
	c.setStrokeColor('#000000');
	c.roundrect(0, 0, w, h, rSize, rSize);
	c.fillAndStroke();
};

mxShapeMockupiPhone.prototype.foreground = function(c, x, y, w, h, rSize)
{
	c.setStrokeWidth(1.5);

	c.begin();
	c.setGradient('#808080', '#000000', w * 0.325, 0, w * 0.675, h * 0.5, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.moveTo(w * 0.325, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h * 0.5);
	c.lineTo(w * 0.7, h * 0.5);
	c.close();
	c.fill();

	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '');
	var bgStyle = mxUtils.getValue(this.style, mxMockupC.BG_STYLE, mxMockupC.BG_FLAT_GREEN);

	c.setStrokeWidth(1);
	if (bgStyle === mxMockupC.BG_FLAT_WHITE)
	{
		c.setFillColor('#ffffff');
		c.rect(w * 0.0625, h * 0.15, w * 0.875, h * 0.7);
		c.fill();
	}
	else if (bgStyle === mxMockupC.BG_FLAT_GREEN)
	{
		c.setFillColor('#1f2923');
		c.rect(w * 0.0625, h * 0.15, w * 0.875, h * 0.7);
		c.fill();
	}
	else if (bgStyle === mxMockupC.BG_FLAT_GRAY)
	{
		c.setFillColor('#dddddd');
		c.rect(w * 0.0625, h * 0.15, w * 0.875, h * 0.7);
		c.fill();
	}
	else if (bgStyle === mxMockupC.BG_FLAT_CUSTOM)
	{
		c.setFillColor(fillColor);
		c.rect(w * 0.0625, h * 0.15, w * 0.875, h * 0.7);
		c.fill();
	}
	else if (bgStyle === mxMockupC.BG_STRIPED)
	{
		var xOld = x;
		var yOld = y;
		var wOld = w;
		var hOld = h;
		c.translate(w * 0.0625, h * 0.15);
		w = w * 0.875;
		h = h * 0.7;

		c.setFillColor('#5D7585');
		c.rect(0, 0, w, h);
		c.fillAndStroke();

		var strokeColor = '#18211b';
		var strokeColor2 = '#657E8F';

		c.setStrokeColor(strokeColor2);
		var i = 5;
		c.begin();

		while (i < w)
		{
			c.moveTo(i, 0);
			c.lineTo(i, h);
			i = i + 5;
		}

		c.stroke();

		c.setStrokeColor(strokeColor);
		c.begin();
		c.rect(0, 0, w, h);
		c.stroke();

		w = wOld;
		h = hOld;
		c.translate( - w * 0.0625, - h * 0.15);
	}
	else if (bgStyle === mxMockupC.BG_MAP)
	{
		var xOld = x;
		var yOld = y;
		var wOld = w;
		var hOld = h;
		c.translate(w * 0.0625, h * 0.15);
		w = w * 0.875;
		h = h * 0.7;

		c.setFillColor('#ffffff');
		c.rect(0, 0, w, h);
		c.fillAndStroke();

		var fillColor2 = '#96D1FF';
		var strokeColor = '#18211b';
		var strokeColor2 = '#008cff';

		c.setFillColor(fillColor2);
		c.setStrokeColor(strokeColor2);
		c.setStrokeWidth(1);

		c.begin();
		c.moveTo(0, 0);
		c.lineTo(w * 0.1171, 0);
		c.lineTo(w * 0.1136, h * 0.0438);
		c.lineTo(w * 0.0993, h * 0.054);
		c.lineTo(0, h * 0.0446);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.1993, 0);
		c.lineTo(w * 0.1914, h * 0.03884);
		c.lineTo(w * 0.1536, h * 0.0362);
		c.lineTo(w * 0.1586, 0);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.24, 0);
		c.lineTo(w * 0.2257, h * 0.054);
		c.lineTo(w * 0.2414, h * 0.0674);
		c.lineTo(w * 0.4707, h * 0.0835);
		c.lineTo(w * 0.5264, h * 0.0906);
		c.lineTo(w * 0.6429, h * 0.0929);
		c.arcTo(w * 0.0857, h * 0.0536, 0, 0, 0, w * 0.7193, h * 0.0621);
		c.arcTo(w * 0.48, h * 0.2143, 0, 0, 0, w * 0.7286, 0);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.8, 0);
		c.lineTo(w * 0.7886, h * 0.04554);
		c.arcTo(w * 0.0857, h * 0.0536, 0, 0, 0, w * 0.8164, h * 0.0875);
		c.arcTo(w * 0.1429, h * 0.0893, 0, 0, 0, w * 0.88, h * 0.1036);
		c.lineTo(w, h * 0.1112);
		c.lineTo(w, 0);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(0, h * 0.0933);
		c.lineTo(w * 0.08, h * 0.1036);
		c.lineTo(w * 0.1021, h * 0.1246);
		c.lineTo(w * 0.1007, h * 0.1768);
		c.lineTo(w * 0.0471, h * 0.2241);
		c.lineTo(0, h * 0.2527);
		c.close();
		c.fillAndStroke();

		c.ellipse(w * 0.1214, h * 0.0603, w * 0.0843, h * 0.0576);
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.1293, h * 0.1924);
		c.lineTo(w * 0.1729, h * 0.142);
		c.lineTo(w * 0.1407, h * 0.1411);
		c.lineTo(w * 0.14, h * 0.1777);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.4586, h * 0.1241);
		c.lineTo(w * 0.455, h * 0.1835);
		c.lineTo(w * 0.3893, h * 0.2246);
		c.lineTo(w * 0.2171, h * 0.1362);
		c.lineTo(w * 0.2171, h * 0.1308);
		c.lineTo(w * 0.2293, h * 0.1214);
		c.lineTo(w * 0.2857, h * 0.1174);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.5079, h * 0.1134);
		c.lineTo(w * 0.7307, h * 0.1223);
		c.lineTo(w * 0.7279, h * 0.1625);
		c.lineTo(w * 0.715, h * 0.1772);
		c.lineTo(w * 0.6929, h * 0.1688);
		c.lineTo(w * 0.625, h * 0.1795);
		c.lineTo(w * 0.4779, h * 0.2835);
		c.lineTo(w * 0.395, h * 0.2299);
		c.lineTo(w * 0.4657, h * 0.1826);
		c.lineTo(w * 0.4707, h * 0.1223);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w, h * 0.1362);
		c.lineTo(w * 0.7643, h * 0.1237);
		c.lineTo(w * 0.7543, h * 0.1562);
		c.lineTo(w * 0.7643, h * 0.1585);
		c.lineTo(w * 0.9186, h * 0.2366);
		c.lineTo(w, h * 0.1732);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.2079, h * 0.1545);
		c.lineTo(w * 0.3886, h * 0.2536);
		c.lineTo(w * 0.3414, h * 0.2933);
		c.lineTo(w * 0.1743, h * 0.1969);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.1579, h * 0.2134);
		c.lineTo(w * 0.3221, h * 0.3067);
		c.lineTo(w * 0.2957, h * 0.3237);
		c.lineTo(w * 0.1157, h * 0.2424);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.405, h * 0.2656);
		c.lineTo(w * 0.31, h * 0.3353);
		c.lineTo(w * 0.3693, h * 0.3661);
		c.lineTo(w * 0.4571, h * 0.2982);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.7121, h * 0.1848);
		c.lineTo(w * 0.6879, h * 0.1754);
		c.lineTo(w * 0.6329, h * 0.1844);
		c.lineTo(w * 0.61, h * 0.2018);
		c.lineTo(w * 0.6207, h * 0.2085);
		c.lineTo(w * 0.4986, h * 0.2982);
		c.lineTo(w * 0.535, h * 0.3237);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.5557, h * 0.3379);
		c.lineTo(w * 0.7464, h * 0.1826);
		c.lineTo(w * 0.8036, h * 0.2076);
		c.lineTo(w * 0.595, h * 0.3616);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.8293, h * 0.2188);
		c.lineTo(w * 0.8979, h * 0.2509);
		c.lineTo(w * 0.6936, h * 0.4125);
		c.lineTo(w * 0.6171, h * 0.3737);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w, h * 0.2138);
		c.lineTo(w * 0.6821, h * 0.4603);
		c.lineTo(w * 0.815, h * 0.5277);
		c.lineTo(w, h * 0.4);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(0, h * 0.317);
		c.lineTo(w * 0.0971, h * 0.2554);
		c.lineTo(w * 0.4121, h * 0.4143);
		c.lineTo(w * 0.3736, h * 0.4415);
		c.lineTo(w * 0.315, h * 0.4076);
		c.lineTo(w * 0.3093, h * 0.4116);
		c.lineTo(w * 0.3686, h * 0.4455);
		c.lineTo(w * 0.285, h * 0.5045);
		c.lineTo(w * 0.1114, h * 0.4134);
		c.lineTo(w * 0.025, h * 0.4603);
		c.lineTo(w * 0.0371, h * 0.4723);
		c.lineTo(w * 0.1114, h * 0.4371);
		c.lineTo(w * 0.2871, h * 0.5312);
		c.lineTo(w * 0.1929, h * 0.6058);
		c.lineTo(w * 0.2271, h * 0.6705);
		c.lineTo(w * 0.17, h * 0.7147);
		c.lineTo(w * 0.0314, h * 0.6321);
		c.lineTo(0, h * 0.6246);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.48, h * 0.3121);
		c.lineTo(w * 0.5157, h * 0.3375);
		c.lineTo(w * 0.4314, h * 0.3982);
		c.lineTo(w * 0.3929, h * 0.3786);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.3086, h * 0.5179);
		c.lineTo(w * 0.53, h * 0.3518);
		c.lineTo(w * 0.5757, h * 0.3745);
		c.lineTo(w * 0.3479, h * 0.5411);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.5964, h * 0.3884);
		c.lineTo(w * 0.6736, h * 0.4277);
		c.lineTo(w * 0.445, h * 0.5991);
		c.lineTo(w * 0.3664, h * 0.5531);
		c.lineTo(w * 0.5057, h * 0.4545);
		c.lineTo(w * 0.5507, h * 0.4754);
		c.lineTo(w * 0.5571, h * 0.4723);
		c.lineTo(w * 0.5114, h * 0.4504);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.4793, h * 0.6161);
		c.lineTo(w * 0.6771, h * 0.4643);
		c.lineTo(w * 0.8086, h * 0.5326);
		c.lineTo(w * 0.7471, h * 0.5817);
		c.lineTo(w * 0.7214, h * 0.567);
		c.lineTo(w * 0.715, h * 0.571);
		c.lineTo(w * 0.7421, h * 0.5871);
		c.lineTo(w * 0.6014, h * 0.6933);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w, h * 0.4371);
		c.lineTo(w * 0.8443, h * 0.546);
		c.lineTo(w * 0.9071, h * 0.5701);
		c.lineTo(w, h * 0.5022);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.8407, h * 0.5504);
		c.lineTo(w * 0.8993, h * 0.5759);
		c.lineTo(w * 0.6757, h * 0.7416);
		c.lineTo(w * 0.6286, h * 0.7139);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w, h * 0.5321);
		c.lineTo(w * 0.6979, h * 0.7549);
		c.lineTo(w * 0.7457, h * 0.7781);
		c.lineTo(w * 0.9814, h * 0.6094);
		c.lineTo(w, h * 0.6067);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w, h * 0.6254);
		c.lineTo(w * 0.7664, h * 0.792);
		c.lineTo(w * 0.9586, h * 0.9062);
		c.lineTo(w, h * 0.8786);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.3093, h * 0.5464);
		c.lineTo(w * 0.4271, h * 0.6152);
		c.lineTo(w * 0.245, h * 0.7643);
		c.lineTo(w * 0.185, h * 0.7228);
		c.lineTo(w * 0.2493, h * 0.6728);
		c.lineTo(w * 0.2214, h * 0.6143);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(0, h * 0.65);
		c.lineTo(w * 0.2179, h * 0.7826);
		c.lineTo(w * 0.1136, h * 0.8424);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(0, h * 0.7272);
		c.lineTo(w * 0.0821, h * 0.859);
		c.lineTo(0, h * 0.9085);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.4529, h * 0.6366);
		c.lineTo(w * 0.575, h * 0.7143);
		c.lineTo(w * 0.39, h * 0.8621);
		c.lineTo(w * 0.2657, h * 0.7902);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(0, h * 0.9415);
		c.lineTo(w * 0.1036, h * 0.8821);
		c.lineTo(w * 0.2343, h * 0.959);
		c.lineTo(w * 0.1721, h);
		c.lineTo(0, h);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.2586, h * 0.7951);
		c.lineTo(w * 0.3829, h * 0.8674);
		c.lineTo(w * 0.2543, h * 0.9451);
		c.lineTo(w * 0.1279, h * 0.8692);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.2836, h * 0.9639);
		c.lineTo(w * 0.4207, h * 0.8772);
		c.lineTo(w * 0.605, h * 0.7321);
		c.lineTo(w * 0.6521, h * 0.7634);
		c.lineTo(w * 0.3486, h);
		c.lineTo(w * 0.3393, h);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.3879, h);
		c.lineTo(w * 0.6721, h * 0.7759);
		c.lineTo(w * 0.7171, h * 0.7982);
		c.lineTo(w * 0.4564, h);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.4986, h);
		c.lineTo(w * 0.7386, h * 0.8125);
		c.lineTo(w * 0.9307, h * 0.925);
		c.lineTo(w * 0.8264, h);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.8671, h);
		c.lineTo(w * 0.9464, h * 0.9491);
		c.lineTo(w, h * 0.975);
		c.lineTo(w, h);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.2295, h);
		c.lineTo(w * 0.2648, h * 0.9792);
		c.lineTo(w * 0.2981, h);
		c.close();
		c.fillAndStroke();

		w = wOld;
		h = hOld;
		c.translate( - w * 0.0625, - h * 0.15);
	}

	c.setStrokeWidth(1);
	c.setStrokeColor('#18211b');
	c.rect(w * 0.0625, h * 0.15, w * 0.875, h * 0.7);
	c.stroke();

	c.setStrokeWidth(1.5);
	c.setAlpha(0.8);
	c.setStrokeColor('#dddddd');
	c.roundrect(0, 0, w, h, rSize, rSize);
	c.stroke();

	rSize = 22.5;
	c.begin();
	c.setStrokeColor('#666666');
	c.roundrect(5, 5, w - 10, h - 10, rSize, rSize);
	c.stroke();

	c.setAlpha(1);
	c.ellipse(w * 0.4875, h * 0.04125, w * 0.025, h * 0.0125);
	c.setStrokeWidth(2.5);
	c.setStrokeColor('#000000');
	c.setFillColor('#000099');
	c.fillAndStroke();

	c.begin();
	c.setStrokeWidth(1.5);
	c.setFillColor('#444444');
	c.setStrokeColor('#333333');
	rSize = 4;

	c.roundrect(w * 0.375, h * 0.075, w * 0.25, h * 0.01875, w * 0.02, h * 0.01);
	c.fillAndStroke();

	c.setGradient('#bbbbbb', '#000000', w * 0.4, h * 0.875, w * 0.2, h * 0.1, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.ellipse(w * 0.4, h * 0.875, w * 0.2, h * 0.1);
	c.fill();

	c.setAlpha(0.5);
	c.ellipse(w * 0.404, h * 0.876, w * 0.19, h * 0.095);
	c.stroke();

	c.begin();
	c.setAlpha(0.85);
	c.setFillColor('#000000');
	c.moveTo(w * 0.4025, h * 0.925);
	c.arcTo(w * 0.0975, h * 0.04625, 0, 0, 1, w * 0.5975, h * 0.925);
	c.arcTo(w * 0.2, h * 0.1, 0, 0, 1, w * 0.4025, h * 0.925);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.setAlpha(0.7);
	c.setStrokeWidth(1.5);
	c.setStrokeColor('#dddddd');
	rSize = 4;
	c.roundrect(w * 0.4575, h * 0.905, w * 0.0875, h * 0.04375, h * 0.00625, h * 0.00625);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IPHONE, mxShapeMockupiPhone);

//**********************************************************************************************************************************************************
//iPhone flat colored background
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiBgFlat(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiBgFlat, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiBgFlat.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
};

mxShapeMockupiBgFlat.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IBG_FLAT, mxShapeMockupiBgFlat);

//**********************************************************************************************************************************************************
//iPhone striped background
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiBgStriped(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiBgStriped, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiBgStriped.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupiBgStriped.prototype.background = function(c, x, y, w, h)
{
	c.setStrokeWidth(1);
	c.begin();
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupiBgStriped.prototype.foreground = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '');
	var strokeColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_STROKECOLOR2, '');

	c.setStrokeColor(strokeColor2);
	var i = 5;
	c.begin();

	while (i < w)
	{
		c.moveTo(i, 0);
		c.lineTo(i, h);
		i = i + 5;
	}

	c.stroke();

	c.setStrokeColor(strokeColor);
	c.begin();
	c.rect(0, 0, w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IBG_STRIPED, mxShapeMockupiBgStriped);

//**********************************************************************************************************************************************************
//iPhone map background
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiBgMap(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiBgMap, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiBgMap.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupiBgMap.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupiBgMap.prototype.foreground = function(c, x, y, w, h)
{
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '');
	var strokeColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_STROKECOLOR2, '');

	c.setFillColor(fillColor2);
	c.setStrokeColor(strokeColor2);
	c.setStrokeWidth(0.5);

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w * 0.1171, 0);
	c.lineTo(w * 0.1136, h * 0.0438);
	c.lineTo(w * 0.0993, h * 0.054);
	c.lineTo(0, h * 0.0446);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.1993, 0);
	c.lineTo(w * 0.1914, h * 0.03884);
	c.lineTo(w * 0.1536, h * 0.0362);
	c.lineTo(w * 0.1586, 0);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.24, 0);
	c.lineTo(w * 0.2257, h * 0.054);
	c.lineTo(w * 0.2414, h * 0.0674);
	c.lineTo(w * 0.4707, h * 0.0835);
	c.lineTo(w * 0.5264, h * 0.0906);
	c.lineTo(w * 0.6429, h * 0.0929);
	c.arcTo(w * 0.0857, h * 0.0536, 0, 0, 0, w * 0.7193, h * 0.0621);
	c.arcTo(w * 0.48, h * 0.2143, 0, 0, 0, w * 0.7286, 0);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.8, 0);
	c.lineTo(w * 0.7886, h * 0.04554);
	c.arcTo(w * 0.0857, h * 0.0536, 0, 0, 0, w * 0.8164, h * 0.0875);
	c.arcTo(w * 0.1429, h * 0.0893, 0, 0, 0, w * 0.88, h * 0.1036);
	c.lineTo(w, h * 0.1112);
	c.lineTo(w, 0);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(0, h * 0.0933);
	c.lineTo(w * 0.08, h * 0.1036);
	c.lineTo(w * 0.1021, h * 0.1246);
	c.lineTo(w * 0.1007, h * 0.1768);
	c.lineTo(w * 0.0471, h * 0.2241);
	c.lineTo(0, h * 0.2527);
	c.close();
	c.fillAndStroke();

	c.ellipse(w * 0.1214, h * 0.0603, w * 0.0843, h * 0.0576);
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.1293, h * 0.1924);
	c.lineTo(w * 0.1729, h * 0.142);
	c.lineTo(w * 0.1407, h * 0.1411);
	c.lineTo(w * 0.14, h * 0.1777);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.4586, h * 0.1241);
	c.lineTo(w * 0.455, h * 0.1835);
	c.lineTo(w * 0.3893, h * 0.2246);
	c.lineTo(w * 0.2171, h * 0.1362);
	c.lineTo(w * 0.2171, h * 0.1308);
	c.lineTo(w * 0.2293, h * 0.1214);
	c.lineTo(w * 0.2857, h * 0.1174);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.5079, h * 0.1134);
	c.lineTo(w * 0.7307, h * 0.1223);
	c.lineTo(w * 0.7279, h * 0.1625);
	c.lineTo(w * 0.715, h * 0.1772);
	c.lineTo(w * 0.6929, h * 0.1688);
	c.lineTo(w * 0.625, h * 0.1795);
	c.lineTo(w * 0.4779, h * 0.2835);
	c.lineTo(w * 0.395, h * 0.2299);
	c.lineTo(w * 0.4657, h * 0.1826);
	c.lineTo(w * 0.4707, h * 0.1223);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w, h * 0.1362);
	c.lineTo(w * 0.7643, h * 0.1237);
	c.lineTo(w * 0.7543, h * 0.1562);
	c.lineTo(w * 0.7643, h * 0.1585);
	c.lineTo(w * 0.9186, h * 0.2366);
	c.lineTo(w, h * 0.1732);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.2079, h * 0.1545);
	c.lineTo(w * 0.3886, h * 0.2536);
	c.lineTo(w * 0.3414, h * 0.2933);
	c.lineTo(w * 0.1743, h * 0.1969);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.1579, h * 0.2134);
	c.lineTo(w * 0.3221, h * 0.3067);
	c.lineTo(w * 0.2957, h * 0.3237);
	c.lineTo(w * 0.1157, h * 0.2424);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.405, h * 0.2656);
	c.lineTo(w * 0.31, h * 0.3353);
	c.lineTo(w * 0.3693, h * 0.3661);
	c.lineTo(w * 0.4571, h * 0.2982);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.7121, h * 0.1848);
	c.lineTo(w * 0.6879, h * 0.1754);
	c.lineTo(w * 0.6329, h * 0.1844);
	c.lineTo(w * 0.61, h * 0.2018);
	c.lineTo(w * 0.6207, h * 0.2085);
	c.lineTo(w * 0.4986, h * 0.2982);
	c.lineTo(w * 0.535, h * 0.3237);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.5557, h * 0.3379);
	c.lineTo(w * 0.7464, h * 0.1826);
	c.lineTo(w * 0.8036, h * 0.2076);
	c.lineTo(w * 0.595, h * 0.3616);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.8293, h * 0.2188);
	c.lineTo(w * 0.8979, h * 0.2509);
	c.lineTo(w * 0.6936, h * 0.4125);
	c.lineTo(w * 0.6171, h * 0.3737);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w, h * 0.2138);
	c.lineTo(w * 0.6821, h * 0.4603);
	c.lineTo(w * 0.815, h * 0.5277);
	c.lineTo(w, h * 0.4);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(0, h * 0.317);
	c.lineTo(w * 0.0971, h * 0.2554);
	c.lineTo(w * 0.4121, h * 0.4143);
	c.lineTo(w * 0.3736, h * 0.4415);
	c.lineTo(w * 0.315, h * 0.4076);
	c.lineTo(w * 0.3093, h * 0.4116);
	c.lineTo(w * 0.3686, h * 0.4455);
	c.lineTo(w * 0.285, h * 0.5045);
	c.lineTo(w * 0.1114, h * 0.4134);
	c.lineTo(w * 0.025, h * 0.4603);
	c.lineTo(w * 0.0371, h * 0.4723);
	c.lineTo(w * 0.1114, h * 0.4371);
	c.lineTo(w * 0.2871, h * 0.5312);
	c.lineTo(w * 0.1929, h * 0.6058);
	c.lineTo(w * 0.2271, h * 0.6705);
	c.lineTo(w * 0.17, h * 0.7147);
	c.lineTo(w * 0.0314, h * 0.6321);
	c.lineTo(0, h * 0.6246);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.48, h * 0.3121);
	c.lineTo(w * 0.5157, h * 0.3375);
	c.lineTo(w * 0.4314, h * 0.3982);
	c.lineTo(w * 0.3929, h * 0.3786);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.3086, h * 0.5179);
	c.lineTo(w * 0.53, h * 0.3518);
	c.lineTo(w * 0.5757, h * 0.3745);
	c.lineTo(w * 0.3479, h * 0.5411);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.5964, h * 0.3884);
	c.lineTo(w * 0.6736, h * 0.4277);
	c.lineTo(w * 0.445, h * 0.5991);
	c.lineTo(w * 0.3664, h * 0.5531);
	c.lineTo(w * 0.5057, h * 0.4545);
	c.lineTo(w * 0.5507, h * 0.4754);
	c.lineTo(w * 0.5571, h * 0.4723);
	c.lineTo(w * 0.5114, h * 0.4504);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.4793, h * 0.6161);
	c.lineTo(w * 0.6771, h * 0.4643);
	c.lineTo(w * 0.8086, h * 0.5326);
	c.lineTo(w * 0.7471, h * 0.5817);
	c.lineTo(w * 0.7214, h * 0.567);
	c.lineTo(w * 0.715, h * 0.571);
	c.lineTo(w * 0.7421, h * 0.5871);
	c.lineTo(w * 0.6014, h * 0.6933);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w, h * 0.4371);
	c.lineTo(w * 0.8443, h * 0.546);
	c.lineTo(w * 0.9071, h * 0.5701);
	c.lineTo(w, h * 0.5022);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.8407, h * 0.5504);
	c.lineTo(w * 0.8993, h * 0.5759);
	c.lineTo(w * 0.6757, h * 0.7416);
	c.lineTo(w * 0.6286, h * 0.7139);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w, h * 0.5321);
	c.lineTo(w * 0.6979, h * 0.7549);
	c.lineTo(w * 0.7457, h * 0.7781);
	c.lineTo(w * 0.9814, h * 0.6094);
	c.lineTo(w, h * 0.6067);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w, h * 0.6254);
	c.lineTo(w * 0.7664, h * 0.792);
	c.lineTo(w * 0.9586, h * 0.9062);
	c.lineTo(w, h * 0.8786);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.3093, h * 0.5464);
	c.lineTo(w * 0.4271, h * 0.6152);
	c.lineTo(w * 0.245, h * 0.7643);
	c.lineTo(w * 0.185, h * 0.7228);
	c.lineTo(w * 0.2493, h * 0.6728);
	c.lineTo(w * 0.2214, h * 0.6143);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(0, h * 0.65);
	c.lineTo(w * 0.2179, h * 0.7826);
	c.lineTo(w * 0.1136, h * 0.8424);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(0, h * 0.7272);
	c.lineTo(w * 0.0821, h * 0.859);
	c.lineTo(0, h * 0.9085);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.4529, h * 0.6366);
	c.lineTo(w * 0.575, h * 0.7143);
	c.lineTo(w * 0.39, h * 0.8621);
	c.lineTo(w * 0.2657, h * 0.7902);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(0, h * 0.9415);
	c.lineTo(w * 0.1036, h * 0.8821);
	c.lineTo(w * 0.2343, h * 0.959);
	c.lineTo(w * 0.1721, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.2586, h * 0.7951);
	c.lineTo(w * 0.3829, h * 0.8674);
	c.lineTo(w * 0.2543, h * 0.9451);
	c.lineTo(w * 0.1279, h * 0.8692);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.2836, h * 0.9639);
	c.lineTo(w * 0.4207, h * 0.8772);
	c.lineTo(w * 0.605, h * 0.7321);
	c.lineTo(w * 0.6521, h * 0.7634);
	c.lineTo(w * 0.3486, h);
	c.lineTo(w * 0.3393, h);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.3879, h);
	c.lineTo(w * 0.6721, h * 0.7759);
	c.lineTo(w * 0.7171, h * 0.7982);
	c.lineTo(w * 0.4564, h);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.4986, h);
	c.lineTo(w * 0.7386, h * 0.8125);
	c.lineTo(w * 0.9307, h * 0.925);
	c.lineTo(w * 0.8264, h);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.8671, h);
	c.lineTo(w * 0.9464, h * 0.9491);
	c.lineTo(w, h * 0.975);
	c.lineTo(w, h);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.2295, h);
	c.lineTo(w * 0.2648, h * 0.9792);
	c.lineTo(w * 0.2981, h);
	c.close();
	c.fillAndStroke();

	c.setStrokeWidth(1);
	c.setStrokeColor(strokeColor);
	c.begin();
	c.rect(0, 0, w, h);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IBG_MAP, mxShapeMockupiBgMap);

//**********************************************************************************************************************************************************
//Vertical Button Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiButtonBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiButtonBar, mxShape);

mxShapeMockupiButtonBar.prototype.customProperties = [
	{name: 'buttonText', dispName: 'Labels', type: 'string'},
	{name: 'textColor', dispName: 'Text Color', type: 'color'},
	{name: 'textColor2', dispName: 'Text2 Color', type: 'color'},
	{name: 'strokeColor2', dispName: 'Stroke2 Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiButtonBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var textStrings = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, '+Button 1, Button 2, Button 3').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR, '#666666');
	var selectedFontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, '#ffffff');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '17').toString();
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var separatorColor = mxUtils.getValue(this.style, mxMockupC.STYLE_STROKECOLOR2, '#c4c4c4');
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var buttonNum = textStrings.length;
	var maxButtonWidth = 0;
	var selectedButton = -1;
	var rSize = 2.5; //rounding size
	var labelOffset = 2.5;

	for (var i = 0; i < buttonNum; i++)
	{
		var buttonText = textStrings[i];

		if(buttonText.charAt(0) === mxMockupC.SELECTED)
		{
			buttonText = textStrings[i].substring(1);
			selectedButton = i;
		}

		var currWidth = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currWidth > maxButtonWidth)
		{
			maxButtonWidth = currWidth;
		}
	}

	var minButtonHeight =  fontSize * 1.5;
	var minH = buttonNum * minButtonHeight;
	var trueH = Math.max(h, minH);
	var minW = 2 * labelOffset + maxButtonWidth;
	var trueW = Math.max(w, minW);

	c.translate(x, y);

	this.background(c, trueW, trueH, rSize, buttonNum, labelOffset, buttonNum * minButtonHeight, frameColor, separatorColor, bgColor, selectedButton, minButtonHeight);
	c.setShadow(false);

	this.foreground(c, trueW, trueH, rSize, buttonNum, labelOffset, buttonNum * minButtonHeight, frameColor, separatorColor, bgColor, selectedButton, minButtonHeight);
	var currWidth = 0;

	for (var i = 0; i < buttonNum; i++)
	{
		if (i === selectedButton)
		{
			c.setFontColor(selectedFontColor);
		}
		else
		{
			c.setFontColor(fontColor);
		}

		currWidth = currWidth + labelOffset;
		var currHeight = (i * minButtonHeight + minButtonHeight * 0.5) * trueH / minH;
		this.buttonText(c, trueW, currHeight, textStrings[i], fontSize, separatorColor);
	}
};

mxShapeMockupiButtonBar.prototype.background = function(c, w, h, rSize, buttonNum, labelOffset, minH, frameColor, separatorColor, bgColor, selectedButton, minButtonHeight)
{
	c.begin();
	c.setStrokeWidth(1);

	//draw the frame
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();
	c.fillAndStroke();
};

mxShapeMockupiButtonBar.prototype.foreground = function(c, w, h, rSize, buttonNum, labelOffset, minH, frameColor, separatorColor, bgColor, selectedButton, minButtonHeight)
{
	//draw the button separators
	var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, '1');
	c.setStrokeWidth(strokeWidth);
	c.setStrokeColor(separatorColor);
	c.begin();

	for (var i = 1; i < buttonNum; i++)
	{
		if (i !== selectedButton && i !== (selectedButton + 1))
		{
			var currHeight = i * minButtonHeight * h / minH;

			c.moveTo(0, currHeight);
			c.lineTo(w, currHeight);
		}
	}

	c.stroke();

	//draw the selected button
	c.setStrokeColor(mxConstants.NONE);

	if (selectedButton === 0)
	{
		// we draw a path for the first button
		c.begin();
		var buttonBottom = minButtonHeight * h / minH;
		c.setGradient('#5D7585', '#008cff', 0, 0, w, buttonBottom, mxConstants.DIRECTION_SOUTH, 1, 1);
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(w - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
		c.lineTo(w, buttonBottom);
		c.lineTo(0, buttonBottom);
		c.close();
		c.fill();
	}
	else if (selectedButton === buttonNum - 1)
	{
		// we draw a path for the last button
		c.begin();
		var buttonTop = h - minButtonHeight * h / minH;
		c.setGradient('#5D7585', '#008cff', 0, buttonTop, w, h - buttonTop, mxConstants.DIRECTION_SOUTH, 1, 1);
		c.moveTo(0, buttonTop);
		c.lineTo(w, buttonTop);
		c.lineTo(w, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
		c.close();
		c.fill();
	}
	else if (selectedButton !== -1)
	{
		// we draw a path rectangle for one of the buttons in the middle
		c.begin();
		var buttonTop = minButtonHeight * selectedButton * h / minH;
		var buttonBottom = minButtonHeight * (selectedButton + 1) * h / minH;
		c.setGradient('#5D7585', '#008cff', 0, buttonTop, w, buttonBottom - buttonTop, mxConstants.DIRECTION_SOUTH, 1, 1);
		c.moveTo(0, buttonTop);
		c.lineTo(w, buttonTop);
		c.lineTo(w, buttonBottom);
		c.lineTo(0, buttonBottom);
		c.close();
		c.fill();
	}

//	//draw the frame again, to achieve a nicer effect
	c.begin();
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();
	c.stroke();
};

mxShapeMockupiButtonBar.prototype.buttonText = function(c, w, h, textString, fontSize, separatorColor)
{
	if(textString.charAt(0) === mxMockupC.SELECTED)
	{
		textString = textString.substring(1);
	}

	c.setFontSize(fontSize);
	c.text(10, h, 0, 0, textString, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	var mSize = fontSize * 0.5;
	c.setStrokeWidth(fontSize * 0.3);
	c.setStrokeColor(separatorColor);
	c.begin();
	c.moveTo(w - 20 - mSize, h - mSize);
	c.lineTo(w - 20, h);
	c.lineTo(w - 20 - mSize, h + mSize);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IBUTTON_BAR, mxShapeMockupiButtonBar);

//**********************************************************************************************************************************************************
//iPhone Application Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiAppBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiAppBar, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiAppBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupiAppBar.prototype.background = function(c, x, y, w, h)
{
	c.setGradient('#eeeeee', '#999999', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.rect(0, 0, w, h);
	c.fill();
};

mxShapeMockupiAppBar.prototype.foreground = function(c, x, y, w, h)
{
	c.setFillColor('#0099ff');
	c.rect(5, h * 0.5 + 1.75, 1.5, 2.5);
	c.fill();

	c.rect(7, h * 0.5 + 0.75, 1.5, 3.5);
	c.fill();

	c.rect(9, h * 0.5 - 0.25, 1.5, 4.5);
	c.fill();

	c.rect(11, h * 0.5 - 1.25, 1.5, 5.5);
	c.fill();

	c.rect(13, h * 0.5 - 2.25, 1.5, 6.5);
	c.fill();

	c.rect(15, h * 0.5 - 3.25, 1.5, 7.5);
	c.fill();

	c.setFillColor('#999999');
	c.ellipse(w - 56.5, h * 0.5 - 4, 8, 8);
	c.fill();

	c.setStrokeColor('#cccccc');
	c.begin();
	c.moveTo(w - 52.5, h * 0.5 - 3);
	c.lineTo(w - 52.5, h * 0.5);
	c.lineTo(w - 54.5, h * 0.5);
	c.stroke();

	c.setStrokeWidth(0.5);
	c.setStrokeColor('#333333');
	c.setFillColor('#990000');
	c.begin();
	c.moveTo(w - 45.5, h * 0.5);
	c.lineTo(w - 37.5, h * 0.5 - 5);
	c.lineTo(w - 41.5, h * 0.5 + 4);
	c.lineTo(w - 42, h * 0.5 + 0.5);
	c.close();
	c.fillAndStroke();

	c.setFillColor('#999999');
	c.setStrokeColor('#999999');
	c.begin();
	c.moveTo(w - 28.5, h * 0.5 + 3.5);
	c.arcTo(3.5, 3.5, 0, 1, 1, w - 26.5, h * 0.5 + 1);
	c.stroke();

	c.begin();
	c.moveTo(w - 27.25, h * 0.5 + 0.25);
	c.lineTo(w - 25.75, h * 0.5 + 0.25);
	c.lineTo(w - 26.5, h * 0.5 + 1.5);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w - 31, h * 0.5 - 0.5);
	c.arcTo(1, 1.5, 0, 0, 1, w - 29, h * 0.5 - 0.5);
	c.stroke();

	c.rect(w - 31.5, h * 0.5 - 0.5, 3, 2);
	c.fillAndStroke();

	c.setGradient('#eeeeee', '#444444', w - 20, h * 0.5 - 3, 16.5, 6, mxConstants.DIRECTION_NORTH, 1, 1);
	c.begin();
	c.moveTo(w - 20, h * 0.5 - 3);
	c.lineTo(w - 5, h * 0.5 - 3);
	c.lineTo(w - 5, h * 0.5 - 1);
	c.lineTo(w - 3.5, h * 0.5 - 1);
	c.lineTo(w - 3.5, h * 0.5 + 1);
	c.lineTo(w - 5, h * 0.5 + 1);
	c.lineTo(w - 5, h * 0.5 + 3);
	c.lineTo(w - 20, h * 0.5 + 3);
	c.close();
	c.fill();

	c.setGradient('#E2FFEB', '#008215', w - 20, h * 0.5 - 3, 10, 6, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.begin();
	c.moveTo(w - 20, h * 0.5 - 3);
	c.lineTo(w - 10, h * 0.5 - 3);
	c.lineTo(w - 10, h * 0.5 + 3);
	c.lineTo(w - 20, h * 0.5 + 3);
	c.close();
	c.fill();

	c.setStrokeColor('#666666');
	c.begin();
	c.moveTo(w - 20, h * 0.5 - 3);
	c.lineTo(w - 5, h * 0.5 - 3);
	c.lineTo(w - 5, h * 0.5 - 1);
	c.lineTo(w - 3.5, h * 0.5 - 1);
	c.lineTo(w - 3.5, h * 0.5 + 1);
	c.lineTo(w - 5, h * 0.5 + 1);
	c.lineTo(w - 5, h * 0.5 + 3);
	c.lineTo(w - 20, h * 0.5 + 3);
	c.close();
	c.stroke();

};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IAPP_BAR, mxShapeMockupiAppBar);

//**********************************************************************************************************************************************************
//iPhone Top Bar (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiTopBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiTopBar, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiTopBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupiTopBar.prototype.background = function(c, x, y, w, h)
{
	c.setAlpha(0.5);
	c.setFillColor('#999999');
	c.rect(0, 0, w, h);
	c.fill();
};

mxShapeMockupiTopBar.prototype.foreground = function(c, x, y, w, h)
{
	c.setFillColor('#cccccc');
	c.setStrokeColor('#cccccc');
	c.setFontColor('#cccccc');
	c.setFontSize(7.5);

	c.rect(5, h * 0.5 + 1.75, 1.5, 2.5);
	c.fill();

	c.rect(7, h * 0.5 + 0.75, 1.5, 3.5);
	c.fill();

	c.rect(9, h * 0.5 - 0.25, 1.5, 4.5);
	c.fill();

	c.rect(11, h * 0.5 - 1.25, 1.5, 5.5);
	c.fill();

	c.rect(13, h * 0.5 - 2.25, 1.5, 6.5);
	c.fill();

	c.rect(15, h * 0.5 - 3.25, 1.5, 7.5);
	c.fill();

	c.text(18, h * 0.5, 0, 0, 'CARRIER', mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.5, 0, 0, '11:15AM', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.begin();
	c.moveTo(w - 19, h * 0.5 - 2);
	c.lineTo(w - 10, h * 0.5 - 2);
	c.lineTo(w - 10, h * 0.5 + 2);
	c.lineTo(w - 19, h * 0.5 + 2);
	c.close();
	c.fill();

	c.begin();
	c.moveTo(w - 20, h * 0.5 - 3);
	c.lineTo(w - 5, h * 0.5 - 3);
	c.lineTo(w - 5, h * 0.5 - 1);
	c.lineTo(w - 3.5, h * 0.5 - 1);
	c.lineTo(w - 3.5, h * 0.5 + 1);
	c.lineTo(w - 5, h * 0.5 + 1);
	c.lineTo(w - 5, h * 0.5 + 3);
	c.lineTo(w - 20, h * 0.5 + 3);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ITOP_BAR, mxShapeMockupiTopBar);

//**********************************************************************************************************************************************************
//iPhone Top Bar 2
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupiTopBar2(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupiTopBar2, mxShape);

mxShapeMockupiTopBar2.prototype.cst = {
		SHAPE_ITOP_BAR2 : 'mxgraph.ios.iTopBar2'
};


/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupiTopBar2.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};
mxShapeMockupiTopBar2.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fill();
};

mxShapeMockupiTopBar2.prototype.foreground = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setFillColor(strokeColor);
	c.setStrokeColor(strokeColor);

	c.rect(5, h * 0.5 + 1.75, 1.5, 2.5);
	c.fill();

	c.rect(7, h * 0.5 + 0.75, 1.5, 3.5);
	c.fill();

	c.rect(9, h * 0.5 - 0.25, 1.5, 4.5);
	c.fill();

	c.rect(11, h * 0.5 - 1.25, 1.5, 5.5);
	c.fill();

	c.rect(13, h * 0.5 - 2.25, 1.5, 6.5);
	c.fill();

	c.rect(15, h * 0.5 - 3.25, 1.5, 7.5);
	c.fill();

	c.begin();
	c.moveTo(w - 19, h * 0.5 - 2);
	c.lineTo(w - 10, h * 0.5 - 2);
	c.lineTo(w - 10, h * 0.5 + 2);
	c.lineTo(w - 19, h * 0.5 + 2);
	c.close();
	c.fill();

	c.begin();
	c.moveTo(w - 20, h * 0.5 - 3);
	c.lineTo(w - 5, h * 0.5 - 3);
	c.lineTo(w - 5, h * 0.5 - 1);
	c.lineTo(w - 3.5, h * 0.5 - 1);
	c.lineTo(w - 3.5, h * 0.5 + 1);
	c.lineTo(w - 5, h * 0.5 + 1);
	c.lineTo(w - 5, h * 0.5 + 3);
	c.lineTo(w - 20, h * 0.5 + 3);
	c.close();
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupiTopBar2.prototype.cst.SHAPE_ITOP_BAR2, mxShapeMockupiTopBar2);

//**********************************************************************************************************************************************************
//iPhone Top Bar Locked
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiTopBarLocked(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiTopBarLocked, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiTopBarLocked.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupiTopBarLocked.prototype.background = function(c, x, y, w, h)
{
	c.setFillColor('#000000');
	c.rect(0, 0, w, h);
	c.fill();
};

mxShapeMockupiTopBarLocked.prototype.foreground = function(c, x, y, w, h)
{
	c.setFillColor('#cccccc');
	c.setStrokeColor('#cccccc');

	c.rect(5, h * 0.5 + 1.75, 1.5, 2.5);
	c.fill();

	c.rect(7, h * 0.5 + 0.75, 1.5, 3.5);
	c.fill();

	c.rect(9, h * 0.5 - 0.25, 1.5, 4.5);
	c.fill();

	c.rect(11, h * 0.5 - 1.25, 1.5, 5.5);
	c.fill();

	c.rect(13, h * 0.5 - 2.25, 1.5, 6.5);
	c.fill();

	c.rect(15, h * 0.5 - 3.25, 1.5, 7.5);
	c.fill();

	c.begin();
	c.moveTo(w * 0.5 - 2, h * 0.5 - 1);
	c.arcTo(2, 3, 0, 0, 1, w * 0.5 + 2, h * 0.5 - 1);
	c.stroke();

	c.rect(w * 0.5 - 3, h * 0.5 - 1, 6, 4);
	c.fillAndStroke();


	c.begin();
	c.moveTo(w - 19, h * 0.5 - 2);
	c.lineTo(w - 10, h * 0.5 - 2);
	c.lineTo(w - 10, h * 0.5 + 2);
	c.lineTo(w - 19, h * 0.5 + 2);
	c.close();
	c.fill();

	c.begin();
	c.moveTo(w - 20, h * 0.5 - 3);
	c.lineTo(w - 5, h * 0.5 - 3);
	c.lineTo(w - 5, h * 0.5 - 1);
	c.lineTo(w - 3.5, h * 0.5 - 1);
	c.lineTo(w - 3.5, h * 0.5 + 1);
	c.lineTo(w - 5, h * 0.5 + 1);
	c.lineTo(w - 5, h * 0.5 + 3);
	c.lineTo(w - 20, h * 0.5 + 3);
	c.close();
	c.stroke();

};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ITOP_BAR_LOCKED, mxShapeMockupiTopBarLocked);

//**********************************************************************************************************************************************************
//Button
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiButton, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, 'Main Text');
	var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, '#666666').toString();
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '8.5').toString();
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
};

mxShapeMockupiButton.prototype.background = function(c, x, y, w, h)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '').toString();
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '').toString();
	c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);

	c.roundrect(0, 0, w, h, 2.5, 2.5);
	c.fill();
};

mxShapeMockupiButton.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w / 2, h / 2, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IBUTTON, mxShapeMockupiButton);

//**********************************************************************************************************************************************************
//Button Back
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiButtonBack(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiButtonBack, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiButtonBack.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, 'Main Text');
	var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, '#666666').toString();
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '17').toString();
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
};

mxShapeMockupiButtonBack.prototype.background = function(c, x, y, w, h)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '').toString();
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '').toString();
	c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);

	rSize = 2.5;
	c.begin();
	c.moveTo(w, rSize);
	c.arcTo(rSize, rSize, 0, 0, 0, w - rSize, 0);
	c.lineTo(10, 0);
	c.lineTo(0.87, h * 0.5 - 0.75);
	c.arcTo(rSize, rSize, 0, 0, 0, 0.87, h * 0.5 + 0.75);
	c.lineTo(10, h);
	c.lineTo(w - rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 0, w, h - rSize);
	c.close();	
	c.fill();
};

mxShapeMockupiButtonBack.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w * 0.5 + 2.5, h * 0.5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IBUTTON_BACK, mxShapeMockupiButtonBack);

//**********************************************************************************************************************************************************
//Button Forward
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiButtonForward(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiButtonForward, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiButtonForward.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, 'Main Text');
	var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, '#666666').toString();
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '17').toString();
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
};

mxShapeMockupiButtonForward.prototype.background = function(c, x, y, w, h)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '').toString();
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '').toString();
	c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);

	rSize = 2.5;
	c.begin();
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - 10, 0);
	c.lineTo(w - 0.87, h * 0.5 - 0.75);
	c.arcTo(rSize, rSize, 0, 0, 1, w - 0.87, h * 0.5 + 0.75);
	c.lineTo(w - 10, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();	
	c.fill();
};

mxShapeMockupiButtonForward.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(w * 0.5 - 2.5, h * 0.5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IBUTTON_FORWARD, mxShapeMockupiButtonForward);

//**********************************************************************************************************************************************************
//Prev/Next Button
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiPrevNextButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiPrevNextButton, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiPrevNextButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupiPrevNextButton.prototype.background = function(c, x, y, w, h)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '').toString();
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '').toString();
	c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);

	var rSize = 5;
	c.roundrect(0, 0, w, h, rSize, rSize);
	c.fill();

	c.begin();
	c.moveTo(w * 0.5, 0);
	c.lineTo(w * 0.5, h);
	c.stroke();
};

mxShapeMockupiPrevNextButton.prototype.foreground = function(c, x, y, w, h)
{
	var fillColor3 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR3, '').toString();
	c.setFillColor(fillColor3);

	c.begin();
	c.moveTo(w * 0.25, h * 0.25);
	c.lineTo(w * 0.35, h * 0.75);
	c.lineTo(w * 0.15, h * 0.75);
	c.close();
	c.fill();

	c.begin();
	c.moveTo(w * 0.75, h * 0.75);
	c.lineTo(w * 0.85, h * 0.25);
	c.lineTo(w * 0.65, h * 0.25);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IPREV_NEXT, mxShapeMockupiPrevNextButton);

//**********************************************************************************************************************************************************
//Text Input
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiTextInput(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiTextInput, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiTextInput.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, 'Main Text');
	var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, '#000000').toString();
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '8').toString();
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
};

mxShapeMockupiTextInput.prototype.background = function(c, x, y, w, h)
{
	c.roundrect(0, 0, w, h, 2.5, 2.5);
	c.fillAndStroke();
};

mxShapeMockupiTextInput.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(2, h * 0.5, 0, 0, text, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ITEXT_INPUT, mxShapeMockupiTextInput);

//**********************************************************************************************************************************************************
//Radio Button Group (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiRadioGroup(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiRadioGroup, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiRadioGroup.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, '#666666').toString();
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '8').toString();
	var optionText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, 'Option 1').toString().split(',');
	var optionNum = optionText.length;
	var buttonSize = 5;
	var lineH = Math.max(fontSize * 1.5, buttonSize);
	var maxTextWidth = 0;
	var selected = -1;
	var labelOffset = 2.5;
	var minH = optionNum * lineH;
	var trueH = Math.max(h, minH);

	//get min width and selected option 
	for (var i = 0; i < optionNum; i++)
	{
		var currText = optionText[i];

		if(currText.charAt(0) === mxMockupC.SELECTED)
		{
			currText = optionText[i].substring(1);
			selected = i;
		}

		var currWidth = mxUtils.getSizeForString(currText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currWidth > maxTextWidth)
		{
			maxTextWidth = currWidth;
		}
	}

	var minW = 2 * labelOffset + maxTextWidth + 2 * buttonSize;
	var trueW = Math.max(w, minW);

	//draw the background
	c.roundrect(0, 0, trueW, trueH, 2.5, 2.5);
	c.fillAndStroke();
	c.setShadow(false);

	c.setFontSize(fontSize);
	c.setFontColor(fontColor);

	for (var i = 0; i < optionNum; i++)
	{
		var currHeight = (i * lineH + lineH * 0.5) * trueH / minH;

		var currText = optionText[i];

		if(currText.charAt(0) === mxMockupC.SELECTED)
		{
			currText = optionText[i].substring(1);
			selected = i;
		}

		c.text(buttonSize * 2 + labelOffset, currHeight, 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

		var iconX = buttonSize * 0.5;
		var iconY = currHeight - buttonSize * 0.5;
		c.setFillColor('#dddddd');
		c.setStrokeColor('#000000');

		if (selected === i)
		{
			c.setGradient('#aaaaaa', '#666666', iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
			c.ellipse(iconX, iconY, buttonSize, buttonSize);
			c.fillAndStroke();
			c.setFillColor('#333333');
			c.setStrokeColor('#333333');
			c.ellipse(iconX + buttonSize * 0.25, iconY + buttonSize * 0.25, buttonSize * 0.5, buttonSize * 0.5);
			c.fillAndStroke();
		}
		else
		{
			c.setGradient('#eeeeee', '#cccccc', iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
			c.ellipse(iconX, iconY, buttonSize, buttonSize);
			c.fillAndStroke();
		}
	}
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IRADIO_GROUP, mxShapeMockupiRadioGroup);

//**********************************************************************************************************************************************************
//Checkbox Group (LEGACY)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiCheckboxGroup(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiCheckboxGroup, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiCheckboxGroup.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, '#666666').toString();
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '8').toString();
	var optionText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, 'Option 1').toString().split(',');
	var optionNum = optionText.length;
	var buttonSize = 5;
	var lineH = Math.max(fontSize * 1.5, buttonSize);
	var maxTextWidth = 0;
	var selected = -1;
	var labelOffset = 2.5;
	var minH = optionNum * lineH;
	var trueH = Math.max(h, minH);

	//get min width and selected option 
	for (var i = 0; i < optionNum; i++)
	{
		var currText = optionText[i];

		if(currText.charAt(0) === mxMockupC.SELECTED)
		{
			currText = optionText[i].substring(1);
			selected = i;
		}

		var currWidth = mxUtils.getSizeForString(currText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		if (currWidth > maxTextWidth)
		{
			maxTextWidth = currWidth;
		}
	}

	var minW = 2 * labelOffset + maxTextWidth + 2 * buttonSize;
	var trueW = Math.max(w, minW);

	//draw the background
	c.roundrect(0, 0, trueW, trueH, 2.5, 2.5);
	c.fillAndStroke();
	c.setShadow(false);

	c.setFontSize(fontSize);
	c.setFontColor(fontColor);

	for (var i = 0; i < optionNum; i++)
	{
		var currHeight = (i * lineH + lineH * 0.5) * trueH / minH;

		var currText = optionText[i];

		if(currText.charAt(0) === mxMockupC.SELECTED)
		{
			currText = optionText[i].substring(1);
			selected = i;
		}

		c.text(buttonSize * 2 + labelOffset, currHeight, 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

		var iconX = buttonSize * 0.5;
		var iconY = currHeight - buttonSize * 0.5;
		c.setFillColor('#dddddd');
		c.setStrokeColor('#000000');

		if (selected === i)
		{
			c.setGradient('#aaaaaa', '#666666', iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
			c.rect(iconX, iconY, buttonSize, buttonSize);
			c.fillAndStroke();
			c.setStrokeColor('#333333');
			c.begin();
			c.moveTo(iconX + buttonSize * 0.25, iconY + buttonSize * 0.5);
			c.lineTo(iconX + buttonSize * 0.5, iconY + buttonSize * 0.75);
			c.lineTo(iconX + buttonSize * 0.75, iconY + buttonSize * 0.25);
			c.stroke();
		}
		else
		{
			c.setGradient('#eeeeee', '#cccccc', iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
			c.rect(iconX, iconY, buttonSize, buttonSize);
			c.fillAndStroke();
		}

		selected = -1;
	}
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ICHECKBOX_GROUP, mxShapeMockupiCheckboxGroup);

//**********************************************************************************************************************************************************
//Combo box
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiComboBox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiComboBox, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiComboBox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var mainText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, 'Main Text');
	var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, '#666666').toString();
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '8.5').toString();
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
	this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
};

mxShapeMockupiComboBox.prototype.background = function(c, x, y, w, h)
{
	c.setFillColor('#ffffff');
	c.roundrect(0, 0, w, h, 2.5, 2.5);
	c.fillAndStroke();
};

mxShapeMockupiComboBox.prototype.foreground = function(c, x, y, w, h)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '').toString();
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '').toString();
	c.setGradient(fillColor, fillColor2, w - 30, 0, 30, h, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.begin();
	c.moveTo(w - 15, 0);
	c.lineTo(w - 2.5, 0);
	c.arcTo(2.5, 2.5, 0, 0, 1, w, 2.5);
	c.lineTo(w, h - 2.5);
	c.arcTo(2.5, 2.5, 0, 0, 1, w - 2.5, h);
	c.lineTo(w - 15, h);
	c.close();
	c.fillAndStroke();

	c.setFillColor('#ffffff');
	c.begin();
	c.moveTo(w - 11, 5);
	c.lineTo(w - 7.5, 10);
	c.lineTo(w - 4, 5);
	c.fill();
};

mxShapeMockupiComboBox.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor)
{
	c.begin();
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);
	c.text(2.5, h * 0.5, 0, 0, text, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ICOMBO_BOX, mxShapeMockupiComboBox);

//**********************************************************************************************************************************************************
//On-Off Button
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiOnOffButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiOnOffButton, mxShape);

mxShapeMockupiOnOffButton.prototype.customProperties = [
	{ name: 'buttonState', dispName: 'State', type: 'enum',
		enumList: [{val: 'on', dispName: 'On'}, {val: 'off', dispName: 'Off'}]}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiOnOffButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	w = Math.max(w, 2 * h);
	var state = mxUtils.getValue(this.style, mxMockupC.BUTTON_STATE, mxMockupC.STATE_ON);
	this.background(c, x, y, w, h, state);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, state);
	this.mainText(c, x, y, w, h, state);
};

mxShapeMockupiOnOffButton.prototype.background = function(c, x, y, w, h, state)
{
	if (state === mxMockupC.STATE_ON)
	{
		c.setGradient('#E2FFEB', '#008215', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
		c.roundrect(0, 0, w, h, h * 0.5, h * 0.5);
		c.fillAndStroke();
	}
	else if (state === mxMockupC.STATE_OFF)
	{
		c.setGradient('#cc9999', '#881100', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
		c.roundrect(0, 0, w, h, h * 0.5, h * 0.5);
		c.fillAndStroke();
	}
};

mxShapeMockupiOnOffButton.prototype.foreground = function(c, x, y, w, h, state)
{
	if (state === mxMockupC.STATE_ON)
	{
		c.setGradient('#ffffff', '#888888', w - h, 0, h, h, mxConstants.DIRECTION_SOUTH, 1, 1);
		c.ellipse(w - h, 0, h, h);
		c.fillAndStroke();
	}
	else
	{
		c.setGradient('#ffffff', '#888888', 0, 0, h, h, mxConstants.DIRECTION_SOUTH, 1, 1);
		c.ellipse(0, 0, h, h);
		c.fillAndStroke();
	}
};

mxShapeMockupiOnOffButton.prototype.mainText = function(c, x, y, w, h, state)
{
	var mainText = mxUtils.getValue(this.style, 'mainText', null);
	c.setFontColor('#ffffff');
	c.setFontSize(8.5);
	
	if (mainText != '')
	{
		if(state === mxMockupC.STATE_ON)
		{
			c.text(w * 0.5 - h * 0.4, h * 0.5, 0, 0, mainText || 'ON', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		}
		else if (state === mxMockupC.STATE_OFF)
		{
			c.text(w * 0.5 + h * 0.4, h * 0.5, 0, 0, mainText || 'OFF', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		}
	}
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ION_OFF_BUTTON, mxShapeMockupiOnOffButton);

//**********************************************************************************************************************************************************
//Alert Box
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiAlertBox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiAlertBox, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiAlertBox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	w = Math.max(w, 15);
	h = Math.max(h, 15);
	c.translate(x, y);
	rSize = 7.5;
	this.background(c, x, y, w, h, rSize);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, rSize);
};

mxShapeMockupiAlertBox.prototype.background = function(c, x, y, w, h, rSize)
{
	c.setGradient('#497198', '#193168', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.setAlpha(0.8);
	c.setStrokeWidth(1);
	c.roundrect(0, 0, w, h, rSize, rSize);
	c.fillAndStroke();
};

mxShapeMockupiAlertBox.prototype.foreground = function(c, x, y, w, h, rSize)
{
	var mainText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, 'Main Text').toString().split(',');

	c.setStrokeColor('#497198');
	c.setGradient('#497198', '#c5cee1', 0, 0, w, 22.5, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.setAlpha(0.5);
	c.begin();
	c.moveTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, 17.5);
	c.arcTo(w * 1.67, h * 2.5, 0, 0, 1, 0, 17.5);
	c.lineTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.close();
	c.fillAndStroke();

	c.setAlpha(0.8);
	c.setStrokeColor('#ffffff');
	c.setStrokeWidth(1);
	c.roundrect(0, 0, w, h, rSize, rSize);
	c.stroke();

	c.setGradient('#497198', '#c5cee1', 5, h - 50, w - 20, 20, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.roundrect(5, h - 25, w - 10, 20, 2.5, 2.5);
	c.fillAndStroke();

	c.setAlpha(0.9);
	c.setFontSize(9.5);
	c.setFontColor('#ffffff');
	c.text(w * 0.5, h * 0.15, 0, 0, mainText[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setFontSize(8);
	c.text(w * 0.5, h * 0.4, 0, 0, mainText[2], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.55, 0, 0, mainText[3], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setFontSize(8.5);
	c.text(w * 0.5, h - 15, 0, 0, mainText[1], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IALERT_BOX, mxShapeMockupiAlertBox);

//**********************************************************************************************************************************************************
//Dialog Box
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiDialogBox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiDialogBox, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiDialogBox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	w = Math.max(w, 15);
	h = Math.max(h, 15);
	c.translate(x, y);
	rSize = 7.5;
	this.background(c, x, y, w, h, rSize);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, rSize);
};

mxShapeMockupiDialogBox.prototype.background = function(c, x, y, w, h, rSize)
{
	c.setGradient('#497198', '#193168', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.setAlpha(0.8);
	c.setStrokeWidth(1);
	c.roundrect(0, 0, w, h, rSize, rSize);
	c.fillAndStroke();
};

mxShapeMockupiDialogBox.prototype.foreground = function(c, x, y, w, h, rSize)
{
	var mainText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, 'Main Text').toString().split(',');

	c.setStrokeColor('#497198');
	c.setGradient('#497198', '#c5cee1', 0, 0, w, 22.5, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.setAlpha(0.5);
	c.begin();
	c.moveTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, 17.5);
	c.arcTo(w * 1.67, h * 2.5, 0, 0, 1, 0, 17.5);
	c.lineTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.close();
	c.fillAndStroke();

	c.setAlpha(0.8);
	c.setStrokeColor('#ffffff');
	c.setStrokeWidth(1);
	c.roundrect(0, 0, w, h, rSize, rSize);
	c.stroke();

	c.setGradient('#497198', '#c5cee1', 5, h - 25, w * 0.5 - 10, 20, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.roundrect(5, h - 25, w * 0.5 - 10, 20, 2.5, 2.5);
	c.fillAndStroke();

	c.roundrect(w * 0.5 + 2.5, h - 25, w * 0.5 - 10, 20, 2.5, 2.5);
	c.fillAndStroke();

	c.setAlpha(0.9);
	c.setFontSize(9.5);
	c.setFontColor('#ffffff');
	c.text(w * 0.5, h * 0.15, 0, 0, mainText[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setFontSize(8);
	c.text(w * 0.5, h * 0.4, 0, 0, mainText[3], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.55, 0, 0, mainText[4], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setFontSize(8.5);
	c.text(w * 0.25, h - 15, 0, 0, mainText[1], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.75, h - 15, 0, 0, mainText[2], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IDIALOG_BOX, mxShapeMockupiDialogBox);

//**********************************************************************************************************************************************************
//Lock Button
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiLockButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiLockButton, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiLockButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.setShadow(false);

	c.setAlpha(0.7);
	c.setGradient('#4A4F56', '#70757B', 0, 0, w, h, mxConstants.DIRECTION_NORTH, 1, 1);
	c.rect(0, 0, w, h);
	c.fill();

	c.setAlpha(0.8);
	c.setGradient('#18232D', '#1F2933', 10, 10, 154, 30, mxConstants.DIRECTION_NORTH, 1, 1);
	c.roundrect(10, h * 0.5 - 15, w - 20, 30, 7.5, 7.5);
	c.fill();

	c.setAlpha(1);
	c.setGradient('#E9F3FD', '#ADB7C1', 12.5, 12.5, 40, 25, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.roundrect(12.5, h * 0.5 - 12.5, 40, 25, 5, 5);
	c.fill();

	c.setAlpha(0.8);
	c.setStrokeWidth(0.5);
	c.setStrokeColor('#aabbbb');
	c.setGradient('#AEB7C1', '#667079', 20, 17.5, 25, 15, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.begin();
	c.moveTo(20, h * 0.5 - 3.5);
	c.lineTo(35, h * 0.5 - 3.5);
	c.lineTo(35, h * 0.5 - 7.5);
	c.lineTo(45, h * 0.5);
	c.lineTo(35, h * 0.5 + 7.5);
	c.lineTo(35, h * 0.5 + 3.5);
	c.lineTo(20, h * 0.5 + 3.5);
	c.close();
	c.fillAndStroke();
	
	var mainText = mxUtils.getValue(this.style, 'mainText', null);
	
	if (mainText != '')
	{
		c.setFontSize(12.5);
		c.setFontColor('#cccccc');
		c.text(w / 2 + 20.5, h / 2, 0, 0, 'slide to unlock', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ILOCK_BUTTON, mxShapeMockupiLockButton);

//**********************************************************************************************************************************************************
//Arrow Icon
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiArrowIcon(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiArrowIcon, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiArrowIcon.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '').toString();

	c.translate(x, y);
	this.background(c, x, y, w, h, strokeColor);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, strokeColor);
};

mxShapeMockupiArrowIcon.prototype.background = function(c, x, y, w, h, strokeColor)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '').toString();
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '').toString();
	c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);

	c.setStrokeWidth(1.5);
	c.setStrokeColor(strokeColor);
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupiArrowIcon.prototype.foreground = function(c, x, y, w, h, strokeColor)
{
	c.setStrokeWidth(2.5);
	c.begin();
	c.moveTo(w * 0.4, h * 0.22);
	c.lineTo(w * 0.65, h * 0.5);
	c.lineTo(w * 0.4, h * 0.78);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IARROW_ICON, mxShapeMockupiArrowIcon);

//**********************************************************************************************************************************************************
//Delete Icon
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiDeleteIcon(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiDeleteIcon, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiDeleteIcon.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '').toString();

	c.translate(x, y);
	this.background(c, x, y, w, h, strokeColor);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, strokeColor);
};

mxShapeMockupiDeleteIcon.prototype.background = function(c, x, y, w, h, strokeColor)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '').toString();
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '').toString();
	c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);

	c.setStrokeWidth(1.5);
	c.setStrokeColor(strokeColor);
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupiDeleteIcon.prototype.foreground = function(c, x, y, w, h, strokeColor)
{
	c.setStrokeWidth(2.5);
	c.begin();
	c.moveTo(w * 0.25, h * 0.5);
	c.lineTo(w * 0.75, h * 0.5);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IDELETE_ICON, mxShapeMockupiDeleteIcon);

//**********************************************************************************************************************************************************
//Add Icon
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiAddIcon(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiAddIcon, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiAddIcon.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '').toString();
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '').toString();
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '').toString();
	c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.setStrokeColor(strokeColor);


	c.translate(x, y);
	this.background(c, x, y, w, h, strokeColor);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, strokeColor);
};

mxShapeMockupiAddIcon.prototype.background = function(c, x, y, w, h, strokeColor)
{
	c.setStrokeWidth(1.5);
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupiAddIcon.prototype.foreground = function(c, x, y, w, h, strokeColor)
{
	c.setStrokeWidth(2.5);
	c.begin();
	c.moveTo(w * 0.25, h * 0.5);
	c.lineTo(w * 0.75, h * 0.5);
	c.moveTo(w * 0.5, h * 0.25);
	c.lineTo(w * 0.5, h * 0.75);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IADD_ICON, mxShapeMockupiAddIcon);

//**********************************************************************************************************************************************************
//Info Icon
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiInfoIcon(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiInfoIcon, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiInfoIcon.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '').toString();

	c.translate(x, y);
	this.background(c, x, y, w, h, strokeColor);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, strokeColor);
};

mxShapeMockupiInfoIcon.prototype.background = function(c, x, y, w, h, strokeColor)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '').toString();
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '').toString();
	c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);

	c.setStrokeWidth(1.5);
	c.setStrokeColor(strokeColor);
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupiInfoIcon.prototype.foreground = function(c, x, y, w, h, strokeColor)
{
	c.setStrokeWidth(2.5);
	c.begin();
	c.setFillColor('#ffffff');
	c.moveTo(w * 0.47, h * 0.334);
	c.arcTo(w * 0.1, h * 0.15, 60, 0, 1, w * 0.61, h * 0.42);
	c.lineTo(w * 0.51, h * 0.7);
	c.arcTo(w * 0.026, h * 0.03, 30, 0, 0, w * 0.54, h * 0.74);
	c.lineTo(w * 0.608, h * 0.684);
	c.arcTo(w * 0.02, h * 0.015, 0, 0, 1, w * 0.638, h * 0.706);
	c.arcTo(w * 0.45, h * 0.45, 0, 0, 1, w * 0.42, h * 0.865);
	c.arcTo(w * 0.1, h * 0.08, -15, 0, 1, w * 0.325, h * 0.77);
	c.lineTo(w * 0.358, h * 0.66);
	c.lineTo(w * 0.435, h * 0.46);
	c.arcTo(w * 0.023, h * 0.03, 0, 0, 0, w * 0.4, h * 0.43);
	c.lineTo(w * 0.338, h * 0.484);
	c.arcTo(w * 0.01, h * 0.015, 45, 0, 1, w * 0.31, h * 0.47);
	c.arcTo(w * 0.3, h * 0.3, 0, 0, 1, w * 0.47, h * 0.334);
	c.fill();

	c.begin();
	c.moveTo(w * 0.5438, h * 0.141);
	c.arcTo(w * 0.0776, h * 0.0898, 40, 0, 1, w * 0.6671, h * 0.2308);
	c.arcTo(w * 0.0776, h * 0.0898, 40, 0, 1, w * 0.5438, h * 0.141);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IINFO_ICON, mxShapeMockupiInfoIcon);


//**********************************************************************************************************************************************************
//Sort/Find Icon
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiSortFindIcon(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiSortFindIcon, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiSortFindIcon.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '').toString();

	c.translate(x, y);
	this.background(c, x, y, w, h, strokeColor);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, strokeColor);
};

mxShapeMockupiSortFindIcon.prototype.background = function(c, x, y, w, h, strokeColor)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '').toString();
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '').toString();
	c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);

	c.setStrokeWidth(1.5);
	c.setStrokeColor(strokeColor);
	c.roundrect(0, 0, w, h, w * 0.1, h * 0.1);
	c.fillAndStroke();
};

mxShapeMockupiSortFindIcon.prototype.foreground = function(c, x, y, w, h, strokeColor)
{
	c.setStrokeWidth((Math.min(h, w)) / 20);
	c.begin();
	c.setFillColor('#ffffff');
	c.moveTo(w * 0.1, h * 0.25);
	c.lineTo(w * 0.9, h * 0.25);
	c.moveTo(w * 0.1, h * 0.4);
	c.lineTo(w * 0.9, h * 0.4);
	c.moveTo(w * 0.1, h * 0.55);
	c.lineTo(w * 0.6, h * 0.55);
	c.moveTo(w * 0.1, h * 0.7);
	c.lineTo(w * 0.5, h * 0.7);
	c.stroke();

	c.begin();
	c.ellipse(w * 0.6, h * 0.6, w * 0.2, h * 0.2);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.77, h * 0.77);
	c.lineTo(w * 0.85, h * 0.85);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ISORT_FIND_ICON, mxShapeMockupiSortFindIcon);

//**********************************************************************************************************************************************************
//Check Icon
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiCheckIcon(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiCheckIcon, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiCheckIcon.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '').toString();

	c.translate(x, y);
	this.background(c, x, y, w, h, strokeColor);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, strokeColor);
};

mxShapeMockupiCheckIcon.prototype.background = function(c, x, y, w, h, strokeColor)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '').toString();
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '').toString();
	c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);

	c.setStrokeWidth(1.5);
	c.setStrokeColor(strokeColor);
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupiCheckIcon.prototype.foreground = function(c, x, y, w, h, strokeColor)
{
	c.setStrokeWidth(2.5);
	c.begin();
	c.moveTo(w * 0.25, h * 0.5);
	c.lineTo(w * 0.5, h * 0.65);
	c.lineTo(w * 0.75, h * 0.25);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ICHECK_ICON, mxShapeMockupiCheckIcon);

//**********************************************************************************************************************************************************
//Keyboard (letters)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiKeybLetters(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiKeybLetters, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiKeybLetters.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(true);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupiKeybLetters.prototype.background = function(c, x, y, w, h)
{
	c.setGradient('#8A97A7', '#425163', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);

	c.rect(0, 0, w, h);
	c.fill();
};

mxShapeMockupiKeybLetters.prototype.foreground = function(c, x, y, w, h, strokeColor)
{
	c.setGradient('#EEF3F9', '#DBE2E9', w * 0.0086, h * 0.03, w * 0.0776, h * 0.19, mxConstants.DIRECTION_SOUTH, 1, 1);
	rSizeX = w * 0.0144;
	rSizeY = h * 0.025;
	c.setFontSize(10.5);
	c.setFontColor('#000000');

	c.roundrect(w * 0.0086, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.0474, h * 0.125, 0, 0, 'Q', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.1092, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.148, h * 0.125, 0, 0, 'W', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.2098, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.2486, h * 0.125, 0, 0, 'E', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.3103, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.3491, h * 0.125, 0, 0, 'R', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.4109, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.4497, h * 0.125, 0, 0, 'T', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.5115, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.5503, h * 0.125, 0, 0, 'Y', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.6121, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.6509, h * 0.125, 0, 0, 'U', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.7126, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.7514, h * 0.125, 0, 0, 'I', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.8132, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.852, h * 0.125, 0, 0, 'O', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.9138, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.9526, h * 0.125, 0, 0, 'P', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.0632, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.102, h * 0.375, 0, 0, 'A', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.1638, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.2026, h * 0.375, 0, 0, 'S', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.2644, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.3032, h * 0.375, 0, 0, 'D', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.3649, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.4037, h * 0.375, 0, 0, 'F', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.4655, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.5043, h * 0.375, 0, 0, 'G', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.5661, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.6049, h * 0.375, 0, 0, 'H', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.6667, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.7055, h * 0.375, 0, 0, 'J', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.7672, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.806, h * 0.375, 0, 0, 'K', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.8678, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.9066, h * 0.375, 0, 0, 'L', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);


	c.roundrect(w * 0.1638, h * 0.53, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.2026, h * 0.625, 0, 0, 'Z', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.2644, h * 0.53, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.3032, h * 0.625, 0, 0, 'X', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.3649, h * 0.53, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.4037, h * 0.625, 0, 0, 'C', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.4655, h * 0.53, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.5043, h * 0.625, 0, 0, 'V', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.5661, h * 0.53, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.6049, h * 0.625, 0, 0, 'B', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.6667, h * 0.53, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.7055, h * 0.625, 0, 0, 'N', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.7672, h * 0.53, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.806, h * 0.625, 0, 0, 'M', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);


	c.roundrect(w * 0.2644, h * 0.78, w * 0.4799, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.setFontColor('#666666');
	c.text(w * 0.5043, h * 0.875, 0, 0, 'space', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setFontColor('#ffffff');

	c.setGradient('#8B98A8', '#677488', w * 0.0115, h * 0.53, w * 0.1207, h * 0.19, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.roundrect(w * 0.0115, h * 0.53, w * 0.1207, h * 0.19, rSizeX, rSizeY);
	c.fill();

	c.setGradient('#8B98A8', '#677488', w * 0.8736, h * 0.53, w * 0.115, h * 0.19, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.roundrect(w * 0.8736, h * 0.53, w * 0.115, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.setGradient('#8B98A8', '#677488', w * 0.0115, h * 0.78, w * 0.2299, h * 0.19, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.roundrect(w * 0.0115, h * 0.78, w * 0.2299, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.setGradient('#8B98A8', '#677488', w * 0.7672, h * 0.78, w * 0.2213, h * 0.19, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.roundrect(w * 0.7672, h * 0.78, w * 0.2213, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.1264, h * 0.875, 0, 0, '.?123', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.8779, h * 0.875, 0, 0, 'return', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setShadow(false);
	c.setLineJoin('round');
	c.setStrokeColor('#ffffff');
	c.setFillColor('#ffffff');
	c.setStrokeWidth(1.5);
	c.begin();
	c.moveTo(w * 0.0402, h * 0.635);
	c.lineTo(w * 0.0718, h * 0.58);
	c.lineTo(w * 0.1034, h * 0.635);
	c.lineTo(w * 0.0862, h * 0.635);
	c.lineTo(w * 0.0862, h * 0.67);
	c.lineTo(w * 0.0575, h * 0.67);
	c.lineTo(w * 0.0575, h * 0.635);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(w * 0.9109, h * 0.585);
	c.lineTo(w * 0.9655, h * 0.585);
	c.lineTo(w * 0.9655, h * 0.665);
	c.lineTo(w * 0.9109, h * 0.665);
	c.lineTo(w * 0.8879, h * 0.625);
	c.close();
	c.fillAndStroke();

	c.setStrokeColor('#677488');
	c.begin();
	c.moveTo(w * 0.9224, h * 0.605);
	c.lineTo(w * 0.9454, h * 0.645);
	c.moveTo(w * 0.9224, h * 0.645);
	c.lineTo(w * 0.9454, h * 0.605);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IKEYB_LETTERS, mxShapeMockupiKeybLetters);

//**********************************************************************************************************************************************************
//Keyboard (numbers)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiKeybNumbers(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiKeybNumbers, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiKeybNumbers.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(true);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupiKeybNumbers.prototype.background = function(c, x, y, w, h)
{
	c.setGradient('#8A97A7', '#425163', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);

	c.rect(0, 0, w, h);
	c.fill();
};

mxShapeMockupiKeybNumbers.prototype.foreground = function(c, x, y, w, h, strokeColor)
{
	c.setGradient('#EEF3F9', '#DBE2E9', w * 0.0086, h * 0.03, w * 0.0776, h * 0.19, mxConstants.DIRECTION_SOUTH, 1, 1);
	rSizeX = w * 0.0144;
	rSizeY = h * 0.025;
	c.setFontSize(10.5);
	c.setFontColor('#000000');

	c.roundrect(w * 0.0086, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.0474, h * 0.125, 0, 0, '1', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.1092, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.148, h * 0.125, 0, 0, '2', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.2098, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.2486, h * 0.125, 0, 0, '3', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.3103, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.3491, h * 0.125, 0, 0, '4', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.4109, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.4497, h * 0.125, 0, 0, '5', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.5115, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.5503, h * 0.125, 0, 0, '6', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.6121, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.6509, h * 0.125, 0, 0, '7', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.7126, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.7514, h * 0.125, 0, 0, '8', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.8132, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.852, h * 0.125, 0, 0, '9', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.9138, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.9526, h * 0.125, 0, 0, '0', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.0086, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.0474, h * 0.375, 0, 0, '-', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.1092, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.148, h * 0.375, 0, 0, '/', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.2098, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.2486, h * 0.375, 0, 0, ':', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.3103, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.3491, h * 0.375, 0, 0, ';', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.4109, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.4497, h * 0.375, 0, 0, '(', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.5115, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.5503, h * 0.375, 0, 0, ')', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.6121, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.6509, h * 0.375, 0, 0, '$', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.7126, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.7514, h * 0.375, 0, 0, '&', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.8132, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.852, h * 0.375, 0, 0, '@', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.9138, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.9526, h * 0.375, 0, 0, '\"', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.1638, h * 0.53, w * 0.1178, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.2227, h * 0.625, 0, 0, '.', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.3046, h * 0.53, w * 0.1178, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.3635, h * 0.625, 0, 0, ',', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.4454, h * 0.53, w * 0.1178, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.5043, h * 0.625, 0, 0, '?', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.5862, h * 0.53, w * 0.1178, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.6451, h * 0.625, 0, 0, '!', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.727, h * 0.53, w * 0.1178, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.7859, h * 0.625, 0, 0, '\'', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);


	c.roundrect(w * 0.2644, h * 0.78, w * 0.4799, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.setFontColor('#666666');
	c.text(w * 0.5043, h * 0.875, 0, 0, 'space', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setGradient('#8B98A8', '#677488', w * 0.0115, h * 0.53, w * 0.1207, h * 0.19, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.setFontColor('#ffffff');

	c.roundrect(w * 0.0115, h * 0.53, w * 0.1207, h * 0.19, rSizeX, rSizeY);
	c.fill();

	c.roundrect(w * 0.8736, h * 0.53, w * 0.115, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.roundrect(w * 0.0115, h * 0.78, w * 0.2299, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.roundrect(w * 0.7672, h * 0.78, w * 0.2213, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.0718, h * 0.625, 0, 0, '#+=', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.1264, h * 0.875, 0, 0, 'ABC', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.8779, h * 0.875, 0, 0, 'return', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setShadow(false);
	c.setLineJoin('round');
	c.setStrokeColor('#ffffff');
	c.setFillColor('#ffffff');
	c.setStrokeWidth(1.5);
	c.begin();
	c.moveTo(w * 0.9109, h * 0.585);
	c.lineTo(w * 0.9655, h * 0.585);
	c.lineTo(w * 0.9655, h * 0.665);
	c.lineTo(w * 0.9109, h * 0.665);
	c.lineTo(w * 0.8879, h * 0.625);
	c.close();
	c.fillAndStroke();

	c.setStrokeColor('#677488');
	c.begin();
	c.moveTo(w * 0.9224, h * 0.605);
	c.lineTo(w * 0.9454, h * 0.645);
	c.moveTo(w * 0.9224, h * 0.645);
	c.lineTo(w * 0.9454, h * 0.605);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IKEYB_NUMBERS, mxShapeMockupiKeybNumbers);

//**********************************************************************************************************************************************************
//Keyboard (symbols)
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiKeybSymbols(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiKeybSymbols, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiKeybSymbols.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(true);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupiKeybSymbols.prototype.background = function(c, x, y, w, h)
{
	c.setGradient('#8A97A7', '#425163', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);

	c.rect(0, 0, w, h);
	c.fill();
};

mxShapeMockupiKeybSymbols.prototype.foreground = function(c, x, y, w, h, strokeColor)
{
	c.setGradient('#EEF3F9', '#DBE2E9', w * 0.0086, h * 0.03, w * 0.0776, h * 0.19, mxConstants.DIRECTION_SOUTH, 1, 1);
	rSizeX = w * 0.0144;
	rSizeY = h * 0.025;
	c.setFontSize(10.5);
	c.setFontColor('#000000');

	c.roundrect(w * 0.0086, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.0474, h * 0.125, 0, 0, '[', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.1092, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.148, h * 0.125, 0, 0, ']', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.2098, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.2486, h * 0.125, 0, 0, '{', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.3103, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.3491, h * 0.125, 0, 0, '}', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.4109, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.4497, h * 0.125, 0, 0, '#', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.5115, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.5503, h * 0.125, 0, 0, '%', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.6121, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.6509, h * 0.125, 0, 0, '^', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.7126, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.7514, h * 0.125, 0, 0, '*', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.8132, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.852, h * 0.125, 0, 0, '+', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.9138, h * 0.03, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.9526, h * 0.125, 0, 0, '=', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.0086, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.0474, h * 0.375, 0, 0, '_', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.1092, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.148, h * 0.375, 0, 0, '\\', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.2098, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.2486, h * 0.375, 0, 0, '|', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.3103, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.3491, h * 0.375, 0, 0, '~', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.4109, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.4497, h * 0.375, 0, 0, '<', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.5115, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.5503, h * 0.375, 0, 0, '>', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.6121, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.6509, h * 0.375, 0, 0, String.fromCharCode(128), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.7126, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.7514, h * 0.375, 0, 0, String.fromCharCode(parseInt('00A3', 16)), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.8132, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.852, h * 0.375, 0, 0, String.fromCharCode(parseInt('00A5', 16)), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.9138, h * 0.28, w * 0.0776, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.9526, h * 0.375, 0, 0, String.fromCharCode(parseInt('0095', 16)), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.1638, h * 0.53, w * 0.1178, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.2227, h * 0.625, 0, 0, '.', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.3046, h * 0.53, w * 0.1178, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.3635, h * 0.625, 0, 0, ',', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.4454, h * 0.53, w * 0.1178, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.5043, h * 0.625, 0, 0, '?', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.5862, h * 0.53, w * 0.1178, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.6451, h * 0.625, 0, 0, '!', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.727, h * 0.53, w * 0.1178, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.7859, h * 0.625, 0, 0, '\'', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.roundrect(w * 0.2644, h * 0.78, w * 0.4799, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.setFontColor('#666666');
	c.text(w * 0.5043, h * 0.875, 0, 0, 'space', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setGradient('#8B98A8', '#677488', w * 0.0115, h * 0.53, w * 0.1207, h * 0.19, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.setFontColor('#ffffff');

	c.roundrect(w * 0.0115, h * 0.53, w * 0.1207, h * 0.19, rSizeX, rSizeY);
	c.fill();

	c.roundrect(w * 0.8736, h * 0.53, w * 0.115, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.roundrect(w * 0.0115, h * 0.78, w * 0.2299, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.roundrect(w * 0.7672, h * 0.78, w * 0.2213, h * 0.19, rSizeX, rSizeY);
	c.fill();
	c.text(w * 0.0718, h * 0.625, 0, 0, '123', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.1264, h * 0.875, 0, 0, 'ABC', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.8779, h * 0.875, 0, 0, 'return', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setShadow(false);
	c.setLineJoin('round');
	c.setStrokeColor('#ffffff');
	c.setFillColor('#ffffff');
	c.setStrokeWidth(1.5);
	c.begin();
	c.moveTo(w * 0.9109, h * 0.585);
	c.lineTo(w * 0.9655, h * 0.585);
	c.lineTo(w * 0.9655, h * 0.665);
	c.lineTo(w * 0.9109, h * 0.665);
	c.lineTo(w * 0.8879, h * 0.625);
	c.close();
	c.fillAndStroke();

	c.setStrokeColor('#677488');
	c.begin();
	c.moveTo(w * 0.9224, h * 0.605);
	c.lineTo(w * 0.9454, h * 0.645);
	c.moveTo(w * 0.9224, h * 0.645);
	c.lineTo(w * 0.9454, h * 0.605);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IKEYB_SYMBOLS, mxShapeMockupiKeybSymbols);

//**********************************************************************************************************************************************************
//Delete App
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiDeleteApp(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiDeleteApp, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiDeleteApp.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '').toString();

	c.translate(x, y);
	this.background(c, x, y, w, h, strokeColor);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupiDeleteApp.prototype.background = function(c, x, y, w, h, strokeColor)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '').toString();
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '').toString();
	c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);

	c.setStrokeWidth(1.5);
	c.setStrokeColor(strokeColor);
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupiDeleteApp.prototype.foreground = function(c, x, y, w, h)
{
	c.setStrokeWidth(2.5);
	c.begin();
	c.moveTo(w * 0.3, h * 0.3);
	c.lineTo(w * 0.7, h * 0.7);
	c.moveTo(w * 0.3, h * 0.7);
	c.lineTo(w * 0.7, h * 0.3);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IDELETE_APP, mxShapeMockupiDeleteApp);

//**********************************************************************************************************************************************************
//Direction
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiDirection(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiDirection, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiDirection.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupiDirection.prototype.background = function(c, x, y, w, h)
{
	c.setStrokeWidth(0.5);
	c.setStrokeColor('#008cff');
	c.ellipse(0, 0, w, h);
	c.stroke();
};

mxShapeMockupiDirection.prototype.foreground = function(c, x, y, w, h)
{
	c.setAlpha(1);
	c.setGradient('#ffffff', '#ffffff', w * 0.29, h * 0.2, w * 0.42, h * 0.3, mxConstants.DIRECTION_NORTH, 1, 0);
	c.begin();
	c.moveTo(w * 0.29, h * 0.2);
	c.lineTo(w * 0.5, h * 0.5);
	c.lineTo(w * 0.71, h * 0.2);
	c.fillAndStroke();

	c.setStrokeColor('#006cdf');
	c.setGradient('#ffffff', '#007cef', w * 0.47, h * 0.47, w * 0.06, h * 0.06, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.setAlpha(1);
	c.ellipse(w * 0.47, h * 0.47, w * 0.06, h * 0.06);
	c.fillAndStroke();

	c.setFillColor('#ffffff');
	c.setAlpha(0.8);
	c.ellipse(w * 0.4825, h * 0.4825, w * 0.015, h * 0.015);
	c.fill();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IDIRECTION, mxShapeMockupiDirection);

//**********************************************************************************************************************************************************
//Location Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiLocationBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiLocationBar, mxShape);

mxShapeMockupiLocationBar.prototype.customProperties = [
	{name: 'buttonText', dispName: 'Text', type: 'string'},
	{name: 'barPos', dispName: 'Callout Position', type: 'float', min:0, defVal:80},
	{name: 'pointerPos', dispName: 'Callout Orientation', type: 'enum',
		enumList: [{val: 'bottom', dispName: 'Bottom'}, {val: 'top', dispName: 'Top'}]
	}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiLocationBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupiLocationBar.prototype.background = function(c, x, y, w, h)
{
	var barPos = mxUtils.getValue(this.style, mxMockupC.BAR_POS, '80');
	barPos = Math.min(barPos, 100);
	barPos = Math.max(barPos, 0);
	var pointerPos = mxUtils.getValue(this.style, mxMockupC.POINTER_POS, mxMockupC.POINTER_BOTTOM);
	var rSize = 2.5;
	var deadzone = rSize + 7.5; // rounding + pointer width / 2 
	var virRange = w - 2 * deadzone;
	var truePos = deadzone + virRange * barPos / 100;
	c.setStrokeWidth(0.5);
	c.setStrokeColor('#000000');
	c.setAlpha(0.7);
	c.begin();

	if (pointerPos === mxMockupC.POINTER_BOTTOM)
	{
		c.setGradient('#000000', '#888888', 0, 0, w, h, mxConstants.DIRECTION_NORTH, 1, 1);
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(w - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
		c.lineTo(w, h - rSize - 7.5);
		c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h - 7.5);
		c.lineTo(truePos + 7.5, h - 7.5);
		c.lineTo(truePos, h);
		c.lineTo(truePos - 7.5, h - 7.5);
		c.lineTo(rSize, h - 7.5);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize - 7.5);
	}
	else if (pointerPos === mxMockupC.POINTER_TOP)
	{
		c.setGradient('#000000', '#888888', 0, 0, w, h, mxConstants.DIRECTION_NORTH, 1, 1);
		c.moveTo(0, rSize + 7.5);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 7.5);
		c.lineTo(truePos - 7.5, 7.5);
		c.lineTo(truePos, 0);
		c.lineTo(truePos + 7.5, 7.5);
		c.lineTo(w - rSize, 7.5);
		c.arcTo(rSize, rSize, 0, 0, 1, w, rSize + 7.5);
		c.lineTo(w, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	}

	c.close();
	c.fillAndStroke();
};

mxShapeMockupiLocationBar.prototype.foreground = function(c, x, y, w, h)
{
	var pointerPos = mxUtils.getValue(this.style, mxMockupC.POINTER_POS, mxMockupC.POINTER_BOTTOM);
	var locText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, 'Some Location');
	c.setAlpha(1);
	c.setFontColor('#ffffff');
	c.setFontSize(9.5);

	if (pointerPos === mxMockupC.POINTER_BOTTOM)
	{
		c.text(5, (h - 7.5) * 0.5, 0, 0, locText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		c.translate(w - 20, (h - 7.5) * 0.5 - 7.5);
	}
	else
	{
		c.text(5, (h + 7.5) * 0.5, 0, 0, locText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		c.translate(w - 20, (h + 7.5) * 0.5 - 7.5);
	}		

	w = 15;
	h = 15;

	c.setGradient('#8BbEff', '#135Ec8', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);

	c.setStrokeWidth(1.5);
	c.setStrokeColor('#ffffff');
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();

	c.setStrokeWidth(2.5);
	c.begin();
	c.moveTo(w * 0.4, h * 0.22);
	c.lineTo(w * 0.65, h * 0.5);
	c.lineTo(w * 0.4, h * 0.78);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ILOCATION_BAR, mxShapeMockupiLocationBar);

//**********************************************************************************************************************************************************
//Call Dialog
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiCallDialog(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiCallDialog, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiCallDialog.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var rSize = 5;
	c.translate(x, y);
	this.background(c, x, y, w, h, rSize);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, rSize);
};

mxShapeMockupiCallDialog.prototype.background = function(c, x, y, w, h, rSize)
{
	c.setAlpha(0.8);
	c.setStrokeColor('#888888');
	c.setStrokeWidth(1.5);
	c.setFillColor('#000000');
	c.roundrect(0, 0, w, h, rSize, rSize);
	c.fillAndStroke();
};

mxShapeMockupiCallDialog.prototype.foreground = function(c, x, y, w, h, rSize)
{

	c.begin();
	c.moveTo(w * 0.33, 0);
	c.lineTo(w * 0.33, h);
	c.moveTo(w * 0.67, 0);
	c.lineTo(w * 0.67, h);
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.stroke();

	c.setStrokeColor('#000000');
	c.setFillColor('#ffffff');
	c.setStrokeWidth(0.5);
	c.roundrect(w * 0.1433, h * 0.104, w * 0.0417, h * 0.148, w * 0.02, h * 0.024);
	c.fill();

	c.begin();
	c.moveTo(w * 0.14, h * 0.188);
	c.lineTo(w * 0.14, h * 0.228);
	c.arcTo(w * 0.025, h * 0.03, 0, 0, 0, w * 0.19, h * 0.228);
	c.lineTo(w * 0.19, h * 0.188);
	c.lineTo(w * 0.2, h * 0.188);
	c.lineTo(w * 0.2, h * 0.228);
	c.arcTo(w * 0.0367, h * 0.044, 0, 0, 1, w * 0.17, h * 0.27);
	c.lineTo(w * 0.17, h * 0.296);
	c.lineTo(w * 0.195, h * 0.296);
	c.lineTo(w * 0.195, h * 0.308);
	c.lineTo(w * 0.1367, h * 0.308);
	c.lineTo(w * 0.1367, h * 0.296);
	c.lineTo(w * 0.16, h * 0.296);
	c.lineTo(w * 0.16, h * 0.27);
	c.arcTo(w * 0.0367, h * 0.044, 0, 0, 1, w * 0.13, h * 0.228);
	c.lineTo(w * 0.13, h * 0.188);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.1033, h * 0.108);
	c.lineTo(w * 0.24, h * 0.286);
	c.lineTo(w * 0.2317, h * 0.298);
	c.lineTo(w * 0.095, h * 0.12);
	c.close();
	c.fillAndStroke();

	c.rect(w * 0.44, h * 0.128, w * 0.033, h * 0.04);
	c.fill();
	c.rect(w * 0.485, h * 0.128, w * 0.033, h * 0.04);
	c.fill();
	c.rect(w * 0.53, h * 0.128, w * 0.033, h * 0.04);
	c.fill();
	c.rect(w * 0.44, h * 0.186, w * 0.033, h * 0.04);
	c.fill();
	c.rect(w * 0.485, h * 0.186, w * 0.033, h * 0.04);
	c.fill();
	c.rect(w * 0.53, h * 0.186, w * 0.033, h * 0.04);
	c.fill();
	c.rect(w * 0.44, h * 0.244, w * 0.033, h * 0.04);
	c.fill();
	c.rect(w * 0.485, h * 0.244, w * 0.033, h * 0.04);
	c.fill();
	c.rect(w * 0.53, h * 0.244, w * 0.033, h * 0.04);
	c.fill();

	c.begin();
	c.moveTo(w * 0.7567, h * 0.18);
	c.lineTo(w * 0.785, h * 0.18);
	c.lineTo(w * 0.825, h * 0.128);
	c.lineTo(w * 0.825, h * 0.28);
	c.lineTo(w * 0.79, h * 0.234);
	c.lineTo(w * 0.7567, h * 0.234);
	c.close();
	c.fill();

	c.setStrokeWidth(1.5);
	c.setStrokeColor('#ffffff');
	c.begin();
	c.moveTo(w * 0.8383, h * 0.16);
	c.arcTo(w * 0.0533, h * 0.064, 0, 0, 1, w * 0.8383, h * 0.252);
	c.moveTo(w * 0.8583, h * 0.134);
	c.arcTo(w * 0.0817, h * 0.098, 0, 0, 1, w * 0.8583, h * 0.276);
	c.moveTo(w * 0.8767, h * 0.11);
	c.arcTo(w * 0.1133, h * 0.136, 0, 0, 1, w * 0.8767, h * 0.304);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.1467, h * 0.62);
	c.lineTo(w * 0.1833, h * 0.62);
	c.lineTo(w * 0.1833,h * 0.676);
	c.lineTo(w * 0.2267,h * 0.676);
	c.lineTo(w * 0.2267,h * 0.724);
	c.lineTo(w * 0.1833,h * 0.724);
	c.lineTo(w * 0.1833,h * 0.78);
	c.lineTo(w * 0.1467,h * 0.78);
	c.lineTo(w * 0.1467,h * 0.724);
	c.lineTo(w * 0.105,h * 0.724);
	c.lineTo(w * 0.105,h * 0.676);
	c.lineTo(w * 0.1467,h * 0.676);
	c.close();
	c.fill();

	c.rect(w * 0.4517, h * 0.624, w * 0.0333, h * 0.152);
	c.fill();

	c.rect(w * 0.5183, h * 0.624, w * 0.0333, h * 0.152);
	c.fill();

	c.begin();
	c.moveTo(w * 0.76, h * 0.752);
	c.arcTo(w * 0.1, h * 0.12, 0, 0, 1, w * 0.8033, h * 0.728);
	c.arcTo(w * 0.0167, h * 0.02, 0, 0, 0, w * 0.8167, h * 0.712);
	c.lineTo(w * 0.8175, h * 0.7);
	c.arcTo(w * 0.0267, h * 0.06, 0, 0, 1, w * 0.8067, h * 0.644);
	c.arcTo(w * 0.0287, h * 0.0344, 0, 0, 1, w * 0.8633, h * 0.644);
	c.arcTo(w * 0.0267, h * 0.06, 0, 0, 1, w * 0.855, h * 0.7);
	c.arcTo(w * 0.05, h * 0.724, 0, 0, 1, w * 0.8633, h * 0.724);
	c.arcTo(w * 0.1667, h * 0.75, 0, 0, 1, w * 0.9083, h * 0.75);
	c.lineTo(w * 0.9083, h * 0.78);
	c.lineTo(w * 0.76, h * 0.78);
	c.close();
	c.fill();

	c.setFontColor('#ffffff');
	c.setFontSize(8.5);
	c.text(w * 0.1667, h * 0.35, 0, 0, 'mute', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.35, 0, 0, 'keypad', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.8333, h * 0.35, 0, 0, 'speaker', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.1667, h * 0.85, 0, 0, 'add', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.85, 0, 0, 'pause', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.8333, h * 0.85, 0, 0, 'contacts', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setGradient('#808080', '#ffffff', 0, 0, w, h * 0.308, mxConstants.DIRECTION_NORTH, 1, 1);
	c.setAlpha(0.4);
	c.begin();
	c.moveTo(0, h * 0.308);
	c.lineTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h * 0.308);
	c.arcTo(w * 1.5, h * 1.8, 0, 0, 1, 0, h * 0.308);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ICALL_DIALOG, mxShapeMockupiCallDialog);

//**********************************************************************************************************************************************************
//Call Buttons
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiCallButtons(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiCallButtons, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiCallButtons.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupiCallButtons.prototype.background = function(c, x, y, w, h)
{
	c.setStrokeWidth(0.5);
	c.setStrokeColor('#008cff');
	c.setGradient('#0F1B2B', '#4F5B6B', 0, 0, w, h, mxConstants.DIRECTION_NORTH, 1, 1);
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapeMockupiCallButtons.prototype.foreground = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, h * 0.1667);
	c.lineTo(w, h * 0.1667);
	c.moveTo(0, h * 0.3333);
	c.lineTo(w, h * 0.3333);
	c.moveTo(0, h * 0.5);
	c.lineTo(w, h * 0.5);
	c.moveTo(0, h * 0.6667);
	c.lineTo(w, h * 0.6667);
	c.moveTo(0, h * 0.8333);
	c.lineTo(w, h * 0.8333);
	c.moveTo(w * 0.3333, h * 0.1667);
	c.lineTo(w * 0.3333, h);
	c.moveTo(w * 0.6667, h * 0.1667);
	c.lineTo(w * 0.6667, h);
	c.stroke();

	c.setFontSize(15.5);
	c.setFontColor('#ffffff');
	c.setFontStyle(mxConstants.FONT_BOLD);

	c.text(w * 0.5, h * 0.0834, 0, 0, '(123) 456-7890', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.text(w * 0.1667, h * 0.22, 0, 0, '1', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.22, 0, 0, '2', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.8333, h * 0.22, 0, 0, '3', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.text(w * 0.1667, h * 0.3867, 0, 0, '3', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.3867, 0, 0, '4', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.8333, h * 0.3867, 0, 0, '5', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.text(w * 0.1667, h * 0.5534, 0, 0, '6', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.5534, 0, 0, '7', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.8333, h * 0.5534, 0, 0, '8', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setFontSize(27.5);
	c.text(w * 0.1667, h * 0.76, 0, 0, '*', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.setFontSize(15.5);
	c.text(w * 0.5, h * 0.72, 0, 0, '0', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.8333, h * 0.75, 0, 0, '#', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setGradient('#E2FFEB', '#008215', w * 0.3333, h * 0.8333, w * 0.3333, h * 0.1667, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.rect(w * 0.3333, h * 0.8333, w * 0.3333, h * 0.1667);
	c.fillAndStroke();

	c.text(w * 0.5, h * 0.9168, 0, 0, 'Call', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setFontStyle(0);
	c.setFontSize(8);
	c.setFontColor('#bbbbbb');

	c.text(w * 0.5, h * 0.28, 0, 0, 'ABC', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.8333, h * 0.28, 0, 0, 'DEF', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.text(w * 0.1667, h * 0.4467, 0, 0, 'GHI', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.4467, 0, 0, 'JKL', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.8333, h * 0.4467, 0, 0, 'MNO', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.text(w * 0.1667, h * 0.6134, 0, 0, 'PQRS', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.6134, 0, 0, 'TUV', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.8333, h * 0.6134, 0, 0, 'WXYZ', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.text(w * 0.5, h * 0.78, 0, 0, '+', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setFillColor('#ffffff');
	c.begin();
	c.moveTo(w * 0.1028, h * 0.9464);
	c.arcTo(w * 0.0862, h * 0.0652, 0, 0, 1, w * 0.1402, h * 0.9333);
	c.arcTo(w * 0.0144, h * 0.0109, 0, 0, 0, w * 0.1517, h * 0.9246);
	c.lineTo(w * 0.1524, h * 0.9181);
	c.arcTo(w * 0.023, h * 0.0326, 0, 0, 1, w * 0.143, h * 0.8877);
	c.arcTo(w * 0.0247, h * 0.0187, 0, 0, 1, w * 0.1919, h * 0.8877);
	c.arcTo(w * 0.023, h * 0.0326, 0, 0, 1, w * 0.1847, h * 0.9181);
	c.arcTo(w * 0.0431, h * 0.0174, 0, 0, 0, w * 0.1919, h * 0.9311);
	c.arcTo(w * 0.1437, h * 0.1087, 0, 0, 1, w * 0.2307, h * 0.9453);
	c.lineTo(w * 0.2307, h * 0.9616);
	c.lineTo(w * 0.1028, h * 0.9616);
	c.close();
	c.fill();

	c.setStrokeColor('#ffffff');
	c.setStrokeWidth(2.5);
	c.setLineJoin('round');
	c.begin();
	c.moveTo(w * 0.79, h * 0.89);
	c.lineTo(w * 0.9, h * 0.89);
	c.lineTo(w * 0.9, h * 0.95);
	c.lineTo(w * 0.79, h * 0.95);
	c.lineTo(w * 0.76, h * 0.92);
	c.close();
	c.fillAndStroke();

	c.setStrokeColor('#0F1B2B');
	c.begin();
	c.moveTo(w * 0.82, h * 0.907);
	c.lineTo(w * 0.85, h * 0.933);
	c.moveTo(w * 0.82, h * 0.933);
	c.lineTo(w * 0.85, h * 0.907);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ICALL_BUTTONS, mxShapeMockupiCallButtons);

//**********************************************************************************************************************************************************
//Option
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiOption(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiOption, mxShape);

mxShapeMockupiOption.prototype.customProperties = [
	{name: 'buttonText', dispName: 'Text', type: 'string'},
	{name: 'barPos', dispName: 'Callout Position', type: 'float', min:0, defVal:80},
	{name: 'pointerPos', dispName: 'Callout Orientation', type: 'enum',
		enumList: [{val: 'bottom', dispName: 'Bottom'}, {val: 'top', dispName: 'Top'}]
	}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiOption.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapeMockupiOption.prototype.background = function(c, x, y, w, h)
{
	var barPos = mxUtils.getValue(this.style, mxMockupC.BAR_POS, '80');
	barPos = Math.min(barPos, 100);
	barPos = Math.max(barPos, 0);
	var pointerPos = mxUtils.getValue(this.style, mxMockupC.POINTER_POS, mxMockupC.POINTER_BOTTOM);
	var rSize = 2.5;
	var deadzone = rSize + 7.5; // rounding + pointer width / 2 
	var virRange = w - 2 * deadzone;
	var truePos = deadzone + virRange * barPos / 100;
	c.setStrokeWidth(0.5);
	c.setStrokeColor('#000000');
	c.setAlpha(0.9);
	c.begin();

	if (pointerPos === mxMockupC.POINTER_BOTTOM)
	{
		c.setGradient('#000000', '#888888', 0, 0, w, h, mxConstants.DIRECTION_NORTH, 1, 1);
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(w - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
		c.lineTo(w, h - rSize - 7.5);
		c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h - 7.5);
		c.lineTo(truePos + 7.5, h - 7.5);
		c.lineTo(truePos, h);
		c.lineTo(truePos - 7.5, h - 7.5);
		c.lineTo(rSize, h - 7.5);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize - 7.5);
	}
	else if (pointerPos === mxMockupC.POINTER_TOP)
	{
		c.setGradient('#000000', '#888888', 0, 0, w, h, mxConstants.DIRECTION_NORTH, 1, 1);
		c.moveTo(0, rSize + 7.5);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 7.5);
		c.lineTo(truePos - 7.5, 7.5);
		c.lineTo(truePos, 0);
		c.lineTo(truePos + 7.5, 7.5);
		c.lineTo(w - rSize, 7.5);
		c.arcTo(rSize, rSize, 0, 0, 1, w, rSize + 7.5);
		c.lineTo(w, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	}

	c.close();
	c.fillAndStroke();
};

mxShapeMockupiOption.prototype.foreground = function(c, x, y, w, h)
{
	var locText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, 'Some Location');
	var pointerPos = mxUtils.getValue(this.style, mxMockupC.POINTER_POS, mxMockupC.POINTER_BOTTOM);
	c.setAlpha(1);
	c.setFontColor('#ffffff');
	c.setFontSize(9.5);
	
	if (pointerPos === mxMockupC.POINTER_BOTTOM)
	{
		c.text(w * 0.5, (h - 7.5) * 0.5, 0, 0, locText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
	else
	{
		c.text(w * 0.5, (h + 7.5) * 0.5, 0, 0, locText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IOPTION, mxShapeMockupiOption);

//**********************************************************************************************************************************************************
//Alpha List
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiAlphaList(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiAlphaList, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiAlphaList.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.setShadow(false);
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '8');

	c.setFontColor('#999999');
	c.setFontSize(fontSize);
	c.text(w * 0.5, h * 0.069, 0, 0, 'A', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.1035, 0, 0, 'B', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.138, 0, 0, 'C', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.1725, 0, 0, 'D', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.207, 0, 0, 'E', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.2415, 0, 0, 'F', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.276, 0, 0, 'G', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.3105, 0, 0, 'H', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.345, 0, 0, 'I', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.3795, 0, 0, 'J', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.414, 0, 0, 'K', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.4485, 0, 0, 'L', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.483, 0, 0, 'M', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.5175, 0, 0, 'N', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.552, 0, 0, 'O', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.5865, 0, 0, 'P', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.621, 0, 0, 'Q', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.6555, 0, 0, 'R', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.69, 0, 0, 'S', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.7245, 0, 0, 'T', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.759, 0, 0, 'U', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.7935, 0, 0, 'V', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.828, 0, 0, 'W', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.8625, 0, 0, 'X', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.897, 0, 0, 'Y', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.9315, 0, 0, 'Z', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.text(w * 0.5, h * 0.966, 0, 0, '#', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setStrokeColor('#999999');
	c.ellipse(w * 0.5 - 2.25, h * 0.0345 - 3.5, 4.5, 4.5);
	c.stroke();

	c.begin();
	c.moveTo(w * 0.5 - 4.25, h * 0.0345 + 3);
	c.lineTo(w * 0.5 - 1.75, h * 0.0345);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IALPHA_LIST, mxShapeMockupiAlphaList);

//**********************************************************************************************************************************************************
//Horizontal Button Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiHorButtonBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiHorButtonBar, mxShape);

mxShapeMockupiHorButtonBar.prototype.customProperties = [
	{name: 'buttonText', dispName: 'Labels', type: 'string'},
	{name: 'textColor', dispName: 'Text Color', type: 'color'},
	{name: 'textColor2', dispName: 'Text2 Color', type: 'color'},
	{name: 'strokeColor2', dispName: 'Stroke2 Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiHorButtonBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var textStrings = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, '+Button 1, Button 2, Button 3').toString().split(',');
	var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR, '#666666');
	var selectedFontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, '#ffffff');
	var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, '8.5').toString();
	var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#666666');
	var separatorColor = mxUtils.getValue(this.style, mxMockupC.STYLE_STROKECOLOR2, '#c4c4c4');
	var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var selectedFillColor = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '#008cff');
	var buttonNum = textStrings.length;
	var buttonWidths = new Array(buttonNum);
	var buttonTotalWidth = 0;
	var selectedButton = -1;
	var rSize = 2.5; //rounding size
	var labelOffset = 2.5;

	for (var i = 0; i < buttonNum; i++)
	{
		var buttonText = textStrings[i];

		if(buttonText.charAt(0) === mxMockupC.SELECTED)
		{
			buttonText = textStrings[i].substring(1);
			selectedButton = i;
		}

		buttonWidths[i] = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;

		buttonTotalWidth += buttonWidths[i];
	}

	var trueH = Math.max(h, fontSize * 1.5, 10);
	var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
	var trueW = Math.max(w, minW);

	c.translate(x, y);
	this.background(c, trueW, trueH, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton);
	c.setShadow(false);

	var currWidth = 0;

	for (var i = 0; i < buttonNum; i++)
	{
		if (i === selectedButton)
		{
			c.setFontColor(selectedFontColor);
		}
		else
		{
			c.setFontColor(fontColor);
		}

		currWidth = currWidth + labelOffset;
		this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
		currWidth = currWidth + buttonWidths[i] + labelOffset;
	}
};

mxShapeMockupiHorButtonBar.prototype.background = function(c, w, h, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton)
{
	c.begin();

	//draw the frame
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();
	c.fillAndStroke();

	//draw the button separators
	c.setStrokeColor(separatorColor);
	c.begin();
	for (var i = 1; i < buttonNum; i++)
	{
		if (i !== selectedButton && i !== (selectedButton + 1))
		{
			var currWidth = 0;

			for (var j = 0; j < i; j++)
			{
				currWidth += buttonWidths[j] + 2 * labelOffset;
			}

			currWidth = currWidth * w / minW;
			c.moveTo(currWidth, 0);
			c.lineTo(currWidth, h);
		}
	}

	c.stroke();

	//draw the selected button
	var buttonLeft = 0;
	c.setStrokeColor(mxConstants.NONE);

	for (var i = 0; i < selectedButton; i++)
	{
		buttonLeft += buttonWidths[i] + 2 * labelOffset;
	}

	buttonLeft = buttonLeft * w / minW;
	var buttonRight = (buttonWidths[selectedButton] + 2 * labelOffset) * w / minW;
	buttonRight += buttonLeft;

	if (selectedButton === 0)
	{
		c.setGradient('#5D7585', '#008cff', 0, 0, buttonRight, h, mxConstants.DIRECTION_SOUTH, 1, 1);
		c.begin();
		// we draw a path for the first button
		c.moveTo(0, rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
		c.lineTo(buttonRight, 0);
		c.lineTo(buttonRight, h);
		c.lineTo(rSize, h);
		c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
		c.close();
		c.fill();
	}
	else if (selectedButton === buttonNum - 1)
	{
		c.setGradient('#5D7585', '#008cff', buttonLeft, 0, buttonRight - buttonLeft, h, mxConstants.DIRECTION_SOUTH, 1, 1);
		c.begin();
		// we draw a path for the last button
		c.moveTo(buttonLeft, 0);
		c.lineTo(buttonRight - rSize, 0);
		c.arcTo(rSize, rSize, 0, 0, 1, buttonRight, rSize);
		c.lineTo(buttonRight, h - rSize);
		c.arcTo(rSize, rSize, 0, 0, 1, buttonRight - rSize, h);
		c.lineTo(buttonLeft, h);
		c.close();
		c.fill();
	}
	else if (selectedButton !== -1)
	{
		c.setGradient('#5D7585', '#008cff', buttonLeft, 0, buttonRight - buttonLeft, h, mxConstants.DIRECTION_SOUTH, 1, 1);
		c.begin();
		// we draw a path rectangle for one of the buttons in the middle
		c.moveTo(buttonLeft, 0);
		c.lineTo(buttonRight, 0);
		c.lineTo(buttonRight, h);
		c.lineTo(buttonLeft, h);
		c.close();
		c.fill();
	}

	//draw the frame again, to achieve a nicer effect
	c.setStrokeColor(frameColor);
	c.setFillColor(bgColor);
	c.begin();
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();
	c.stroke();
};

mxShapeMockupiHorButtonBar.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW)
{
	if(textString.charAt(0) === mxMockupC.SELECTED)
	{
		textString = textString.substring(1);
	}

	c.begin();
	c.setFontSize(fontSize);
	c.text((w + buttonWidth * 0.5) * trueW / minW, h * 0.5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IHOR_BUTTON_BAR, mxShapeMockupiHorButtonBar);

//**********************************************************************************************************************************************************
//Pin
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiPin(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiPin, mxShape);

mxShapeMockupiPin.prototype.customProperties = [
	{name: 'fillColor2', dispName: 'Fill2 Color', type: 'color'},
	{name: 'fillColor3', dispName: 'Fill3 Color', type: 'color'}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiPin.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '#000000');
	var fillColor3 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR3, '#000000');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setShadow(false);
	c.translate(x, y);

	c.setStrokeWidth(1.5);
	c.setStrokeColor('#666666');
	c.begin();
	c.moveTo(w * 0.5, h * 0.4);
	c.lineTo(w * 0.5, h);
	c.stroke();

	c.setStrokeWidth(1);
	c.setStrokeColor(strokeColor);
	c.setGradient(fillColor2, fillColor3, 0, 0, w, h * 0.4, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.setAlpha(0.9);
	c.ellipse(0, 0, w, h * 0.4);
	c.fillAndStroke();

	c.setFillColor('#ffffff');
	c.setAlpha(0.5);
	c.ellipse(w * 0.2, h * 0.08, w * 0.3, h * 0.12);
	c.fill();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IPIN, mxShapeMockupiPin);

//**********************************************************************************************************************************************************
//Video Controls
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiVideoControls(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiVideoControls, mxShape);

mxShapeMockupiVideoControls.prototype.customProperties = [
	{name: 'barPos', dispName: 'Handle Position', type: 'float', min:0, defVal:20}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiVideoControls.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var rSize = 5;
	c.setStrokeWidth(1);
	c.setFillColor('#000000');
	c.setStrokeColor('#bbbbbb');
	c.setAlpha(0.7);
	c.roundrect(0, 0, w, h, rSize, rSize);
	c.fillAndStroke();
	c.setShadow(false);

	this.foreground(c, w, h, rSize);
};

mxShapeMockupiVideoControls.prototype.foreground = function(c, w, h, rSize)
{
	c.setGradient('#ffffff', '#ffffff', 0, 0, w, h * 0.5, mxConstants.DIRECTION_SOUTH, 0.8, 0.1);
	c.begin();
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h * 0.5);
	c.lineTo(0, h * 0.5);
	c.close();
	c.fill();

	c.setAlpha(1);
	c.setFillColor('#ffffff');
	c.setStrokeColor('#ffffff');
	var iconX = w * 0.1;
	var iconY = h * 0.35;

	c.begin();
	c.moveTo(iconX - 7.5, iconY - 2.5);
	c.arcTo(6, 6, 0, 0, 1, iconX, iconY - 2.5);
	c.arcTo(6, 6, 0, 0, 1, iconX + 7.5, iconY - 2.5);
	c.lineTo(iconX + 7.5, iconY + 4);
	c.arcTo(6, 6, 0, 0, 0, iconX, iconY + 4);
	c.arcTo(6, 6, 0, 0, 0, iconX - 7.5, iconY + 4);
	c.close();
	c.stroke();

	c.begin();
	c.moveTo(iconX, iconY - 2.5);
	c.lineTo(iconX, iconY + 4);
	c.stroke();

	iconX = w * 0.3;
	c.rect(iconX - 7.5, iconY - 5, 1, 10);
	c.fill();

	c.begin();
	c.moveTo(iconX - 6.5, iconY);
	c.lineTo(iconX + 0.5, iconY - 5);
	c.lineTo(iconX + 0.5, iconY + 5);
	c.close();
	c.fill();

	c.begin();
	c.moveTo(iconX + 0.5, iconY);
	c.lineTo(iconX + 7.5, iconY - 5);
	c.lineTo(iconX + 7.5, iconY + 5);
	c.close();
	c.fill();

	iconX = w * 0.5;
	c.begin();
	c.moveTo(iconX - 6, iconY - 5);
	c.lineTo(iconX + 6, iconY);
	c.lineTo(iconX - 6, iconY + 5);
	c.close();
	c.fill();

	iconX = w * 0.7;
	c.begin();
	c.moveTo(iconX - 7.5, iconY - 5);
	c.lineTo(iconX - 0.5, iconY);
	c.lineTo(iconX - 7.5, iconY + 5);
	c.close();
	c.fill();
	c.begin();
	c.moveTo(iconX - 0.5, iconY - 5);
	c.lineTo(iconX + 6.5, iconY);
	c.lineTo(iconX - 0.5, iconY + 5);
	c.close();
	c.fill();
	c.rect(iconX + 6.5, iconY - 5, 1, 10);
	c.fill();

	iconX = w * 0.9;
	c.rect(iconX - 7.5, iconY - 4, 15, 8);
	c.stroke();
	c.setStrokeWidth(0.5);
	c.begin();
	c.moveTo(iconX - 7.5, iconY - 4);
	c.lineTo(iconX, iconY + 1.5);
	c.lineTo(iconX + 7.5, iconY - 4);
	c.stroke();
	c.begin();
	c.moveTo(iconX - 7.5, iconY + 4);
	c.lineTo(iconX - 2, iconY);
	c.stroke();
	c.begin();
	c.moveTo(iconX + 7.5, iconY + 4);
	c.lineTo(iconX + 2, iconY);
	c.stroke();

	c.setGradient('#444444', '#ffffff', w * 0.1, h * 0.75 - 2.5, w * 0.8, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.roundrect(w * 0.1, h * 0.75 - 2.5, w * 0.8, 5, 2.5, 2.5);
	c.fill();

	var barPos = mxUtils.getValue(this.style, mxMockupC.BAR_POS, '80');
	barPos = Math.min(barPos, 100);
	barPos = Math.max(barPos, 0);
	var deadzone = w * 0.1; 
	var virRange = w - 2 * deadzone;
	var truePos = deadzone + virRange * barPos / 100;

	c.setGradient('#96D1FF', '#003377', w * 0.1, h * 0.75 - 5, truePos - w * 0.1, 10, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.begin();
	c.moveTo(truePos, h * 0.75 - 2.5);
	c.lineTo(truePos, h * 0.75 + 2.5);
	c.lineTo(w * 0.1 + 2.5, h * 0.75 + 2.5);
	c.arcTo(2.5, 2.5, 0, 0, 1, w * 0.1 + 2.5, h * 0.75 - 2.5);
	c.close();
	c.fill();

	c.setStrokeColor('#999999');
	c.setGradient('#444444', '#ffffff', truePos - 5, h * 0.75 - 5, 10, 10, mxConstants.DIRECTION_NORTH, 1, 1);
	c.ellipse(truePos - 5, h * 0.75 - 5, 10, 10);
	c.fillAndStroke();

	c.setStrokeColor('#dddddd');
	c.roundrect(0, 0, w, h, rSize, rSize);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IVIDEO_CONTROLS, mxShapeMockupiVideoControls);

Graph.handleFactory[mxMockupC.SHAPE_IVIDEO_CONTROLS] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'barPos', 40))));

				return new mxPoint(bounds.x + bounds.width * 0.1 + barPos * bounds.width * 0.8 / 100, bounds.y + bounds.height * 0.75);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.width * 0.1 - bounds.x) * 100 / (bounds.width * 0.8)))) / 100;
			})];
			
	return handles;
};

//**********************************************************************************************************************************************************
//URL Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiURLBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiURLBar, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiURLBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.setGradient('#cccccc', '#003377', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.rect(0, 0, w, h);
	c.fill();
	c.setShadow(false);

	this.foreground(c, w, h);
};

mxShapeMockupiURLBar.prototype.foreground = function(c, w, h)
{
	c.setStrokeWidth(0.5);
	c.setFillColor('#ffffff');
	c.setStrokeColor('#008cff');
	c.roundrect(w * 0.0287, h * 0.625 - 6.25, w * 0.7184, 12.5, 6.25, 6.25);
	c.fillAndStroke();

	c.setGradient('#cccccc', '#001144', w * 0.7816, h * 0.625 - 6.25, w * 0.1868, 12.5, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.setStrokeColor('#000000');
	c.roundrect(w * 0.7816, h * 0.625 - 6.25, w * 0.1868, 12.5, 2.5, 2.5);
	c.fillAndStroke();

	c.setFillColor('#bbbbbb');
	c.ellipse(w * 0.7471 - 11.5, h * 0.625 - 5, 10, 10);
	c.fill();

	c.setStrokeColor('#ffffff');
	c.setStrokeWidth(1.5);
	c.begin();
	c.moveTo(w * 0.7471 - 8.5, h * 0.625 - 2.5);
	c.lineTo(w * 0.7471 - 3.5, h * 0.625 + 2.5);
	c.moveTo(w * 0.7471 - 8.5, h * 0.625 + 2.5);
	c.lineTo(w * 0.7471 - 3.5, h * 0.625 - 2.5);
	c.stroke();

	var fieldText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, '').toString().split(',');
	c.setFontColor('#425664');
	c.setFontStyle(mxConstants.FONT_BOLD);
	c.setFontSize(8);
	c.text(w * 0.5, h * 0.2, 0, 0, fieldText[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.setFontColor('#000000');
	c.text(w * 0.06, h * 0.625, 0, 0, fieldText[1], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	c.setFontColor('#ffffff');
	c.text(w * 0.875, h * 0.625, 0, 0, fieldText[2], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IURL_BAR, mxShapeMockupiURLBar);

//**********************************************************************************************************************************************************
//Slider
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiSlider(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiSlider, mxShape);

mxShapeMockupiSlider.prototype.customProperties = [
	{name: 'barPos', dispName: 'Handle Position', type: 'float', min:0, defVal:20},
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiSlider.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.setShadow(false);

	this.foreground(c, w, h);
};

mxShapeMockupiSlider.prototype.foreground = function(c, w, h)
{
	c.setStrokeWidth(0.5);
	c.setGradient('#444444', '#ffffff', 0, h * 0.5 - 2.5, w, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.roundrect(0, h * 0.5 - 2.5, w, 5, 2.5, 2.5);
	c.fill();

	var barPos = mxUtils.getValue(this.style, mxMockupC.BAR_POS, '80');
	barPos = Math.min(barPos, 100);
	barPos = Math.max(barPos, 0);
	var deadzone = 0; 
	var virRange = w - 2 * deadzone;
	var truePos = deadzone + virRange * barPos / 100;

	c.setGradient('#96D1FF', '#003377', 2.5, h * 0.5 - 2.5, truePos - 2.5, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.begin();
	c.moveTo(truePos, h * 0.5 - 2.5);
	c.lineTo(truePos, h * 0.5 + 2.5);
	c.lineTo(2.5, h * 0.5 + 2.5);
	c.arcTo(2.5, 2.5, 0, 0, 1, 2.5, h * 0.5 - 2.5);
	c.close();
	c.fill();

	c.setStrokeColor('#999999');
	c.setGradient('#444444', '#ffffff', truePos - 5, h * 0.5 - 5, 10, 10, mxConstants.DIRECTION_NORTH, 1, 1);
	c.ellipse(truePos - 5, h * 0.5 - 5, 10, 10);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ISLIDER, mxShapeMockupiSlider);

Graph.handleFactory[mxMockupC.SHAPE_ISLIDER] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'barPos', 0.4))));

				return new mxPoint(bounds.x + barPos * bounds.width / 100, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100;
			})];
			
	return handles;
};


//**********************************************************************************************************************************************************
//Progress Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiProgressBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiProgressBar, mxShape);

mxShapeMockupiProgressBar.prototype.customProperties = [
	{name: 'barPos', dispName: 'Handle Position', type: 'float', min:0, defVal:40},
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiProgressBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.setShadow(false);

	this.foreground(c, w, h);
};

mxShapeMockupiProgressBar.prototype.foreground = function(c, w, h)
{
	c.setStrokeWidth(0.5);
	c.setGradient('#444444', '#ffffff', 0, h * 0.5 - 2.5, w, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.roundrect(0, h * 0.5 - 2.5, w, 5, 2.5, 2.5);
	c.fill();

	var barPos = mxUtils.getValue(this.style, mxMockupC.BAR_POS, '80');
	barPos = Math.min(barPos, 100);
	barPos = Math.max(barPos, 0);
	var deadzone = 0; 
	var virRange = w - 2 * deadzone;
	var truePos = deadzone + virRange * barPos / 100;

	c.setGradient('#96D1FF', '#003377', 2.5, h * 0.5 - 2.5, truePos - 2.5, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.begin();
	c.moveTo(truePos, h * 0.5 - 2.5);
	c.arcTo(2.5, 2.5, 0, 0, 1, truePos, h * 0.5 + 2.5);
	c.lineTo(2.5, h * 0.5 + 2.5);
	c.arcTo(2.5, 2.5, 0, 0, 1, 2.5, h * 0.5 - 2.5);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IPROGRESS_BAR, mxShapeMockupiProgressBar);

Graph.handleFactory[mxMockupC.SHAPE_IPROGRESS_BAR] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'barPos', 0.4))));

				return new mxPoint(bounds.x + barPos * bounds.width / 100, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100;
			})];
			
	return handles;
};

//**********************************************************************************************************************************************************
//iCloud Progress Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiCloudProgressBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiCloudProgressBar, mxShape);

mxShapeMockupiCloudProgressBar.prototype.customProperties = [
	{name: 'barPos', dispName: 'Handle Position', type: 'float', min:0, defVal:20},
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiCloudProgressBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.setShadow(false);

	this.foreground(c, w, h);
};

mxShapeMockupiCloudProgressBar.prototype.foreground = function(c, w, h)
{
	c.setStrokeWidth(0.5);
	c.setFillColor('#5C6E86');
	c.rect(0, h * 0.5 - 2.5, w, 5);
	c.fill();

	var barPos = mxUtils.getValue(this.style, mxMockupC.BAR_POS, '80');
	barPos = Math.min(barPos, 100);
	barPos = Math.max(barPos, 0);
	var deadzone = 0; 
	var virRange = w - 2 * deadzone;
	var truePos = deadzone + virRange * barPos / 100;

	c.setFillColor('#8AD155');
	c.rect(0, h * 0.5 - 2.5, truePos, 5);
	c.fill();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ICLOUD_PROGRESS_BAR, mxShapeMockupiCloudProgressBar);

Graph.handleFactory[mxMockupC.SHAPE_ICLOUD_PROGRESS_BAR] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'barPos', 0.4))));

				return new mxPoint(bounds.x + barPos * bounds.width / 100, bounds.y + bounds.height / 2);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100;
			})];
			
	return handles;
};

//**********************************************************************************************************************************************************
//Download Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiDownloadBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiDownloadBar, mxShape);

mxShapeMockupiDownloadBar.prototype.customProperties = [
	{name: 'barPos', dispName: 'Handle Position', type: 'float', min:0, defVal:30},
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiDownloadBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.setGradient('#00ccff', '#0066cc', 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.rect(0, 0, w, h);
	c.fill();
	c.setShadow(false);

	this.foreground(c, w, h);
};

mxShapeMockupiDownloadBar.prototype.foreground = function(c, w, h)
{
	var fieldText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, '');
	c.setFontColor('#ffffff');
	c.setFontStyle(mxConstants.FONT_BOLD);
	c.setFontSize(8);
	c.text(w * 0.5, h * 0.2, 0, 0, fieldText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	var barPos = mxUtils.getValue(this.style, mxMockupC.BAR_POS, '80');
	barPos = Math.min(barPos, 100);
	barPos = Math.max(barPos, 0);
	var deadzone = w * 0.1; 
	var virRange = w - 2 * deadzone;
	var truePos = deadzone + virRange * barPos / 100;

	c.setStrokeWidth(0.5);
	c.setGradient('#96D1FF', '#003377', deadzone, h * 0.65 - 2.5, w - 2 * deadzone, 5, mxConstants.DIRECTION_NORTH, 1, 1);
	c.roundrect(deadzone, h * 0.65 - 2.5, w - 2 * deadzone, 5, 2.5, 2.5);
	c.fill();

	c.setGradient('#aaaaaa', '#ffffff', deadzone + 2.5, h * 0.65 - 2.5, truePos - deadzone - 2.5, 5, mxConstants.DIRECTION_NORTH, 1, 1);
	c.begin();
	c.moveTo(truePos, h * 0.65 - 2.5);
	c.arcTo(2.5, 2.5, 0, 0, 1, truePos, h * 0.65 + 2.5);
	c.lineTo(deadzone + 2.5, h * 0.65 + 2.5);
	c.arcTo(2.5, 2.5, 0, 0, 1, deadzone + 2.5, h * 0.65 - 2.5);
	c.close();
	c.fill();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IDOWNLOAD_BAR, mxShapeMockupiDownloadBar);

Graph.handleFactory[mxMockupC.SHAPE_IDOWNLOAD_BAR] = function(state)
{
	var handles = [Graph.createHandle(state, ['barPos'], function(bounds)
			{
				var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, 'barPos', 40))));

				return new mxPoint(bounds.x + bounds.width * 0.1 + barPos * bounds.width * 0.8 / 100, bounds.y + bounds.height * 0.65);
			}, function(bounds, pt)
			{
				this.state.style['barPos'] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.width * 0.1 - bounds.x) * 100 / (bounds.width * 0.8)))) / 100;
			})];
			
	return handles;
};

//**********************************************************************************************************************************************************
//Screen Name Bar
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiScreenNameBar(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiScreenNameBar, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiScreenNameBar.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var rSize = 5;
	c.setStrokeWidth(0.5);
	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '#00ff00');
	c.setFillColor(fillColor2);
	c.rect(0, 0, w, h);
	c.fill();
	c.setShadow(false);

	this.foreground(c, w, h, rSize);
};

mxShapeMockupiScreenNameBar.prototype.foreground = function(c, w, h, rSize)
{
	var fillColor3 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR3, '#00ff00');
	c.setGradient(fillColor3, fillColor3, 0, 0, w, h * 0.5, mxConstants.DIRECTION_SOUTH, 0.8, 0.1);
	c.rect(0, 0, w, h * 0.5);
	c.fill();

	var fieldText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, '');
	var textColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR, '#00ff00');
	c.setFontColor(textColor);
	c.setFontSize(9.5);
	c.text(w * 0.5, h * 0.45, 0, 0, fieldText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ISCREEN_NAME_BAR, mxShapeMockupiScreenNameBar);

//**********************************************************************************************************************************************************
//Icon Grid
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiIconGrid(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiIconGrid, mxShape);

mxShapeMockupiIconGrid.prototype.customProperties = [
	{name: 'gridSize', dispName: 'Grid Size', type: 'string'},
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiIconGrid.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	var gridSize = mxUtils.getValue(this.style, mxMockupC.GRID_SIZE, '3,3').toString().split(',');
	this.background(c, w, h, gridSize);
	c.setShadow(false);

	this.foreground(c, w, h, gridSize);
};

mxShapeMockupiIconGrid.prototype.background = function(c, w, h, gridSize)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#00ff00');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#00ff00');
	c.setStrokeColor(strokeColor);
	c.setFillColor(fillColor);

	var boxSizeX = w / (parseInt(gridSize[0],10) + (gridSize[0]-1) * 0.5);
	var boxSizeY = h / (parseInt(gridSize[1],10) + (gridSize[1]-1) * 0.5);

	for (var i = 0; i < gridSize[0]; i++)
	{
		for (var j = 0; j < gridSize[1]; j++)
		{
			c.rect(boxSizeX * 1.5 * i, boxSizeY * 1.5 * j, boxSizeX, boxSizeY);
			c.fillAndStroke();
		}
	}
};

mxShapeMockupiIconGrid.prototype.foreground = function(c, w, h, gridSize)
{
	var boxSizeX = w / (parseInt(gridSize[0],10) + (gridSize[0]-1) * 0.5);
	var boxSizeY = h / (parseInt(gridSize[1],10) + (gridSize[1]-1) * 0.5);

	for (var i = 0; i < gridSize[0]; i++)
	{
		for (var j = 0; j < gridSize[1]; j++)
		{
			c.begin();
			c.moveTo(boxSizeX * 1.5 * i, boxSizeY * 1.5 * j);
			c.lineTo(boxSizeX * 1.5 * i + boxSizeX, boxSizeY * 1.5 * j + boxSizeY);
			c.moveTo(boxSizeX * 1.5 * i + boxSizeX, boxSizeY * 1.5 * j);
			c.lineTo(boxSizeX * 1.5 * i, boxSizeY * 1.5 * j + boxSizeY);
			c.stroke();
		}
	}
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IICON_GRID, mxShapeMockupiIconGrid);

//**********************************************************************************************************************************************************
//Copy
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiCopy(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiCopy, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiCopy.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var rSize = 5;
	c.translate(x, y);
	this.background(c, w, h, rSize);
	c.setShadow(false);

	this.foreground(c, w, h, rSize);
};

mxShapeMockupiCopy.prototype.background = function(c, w, h, rSize)
{
	c.begin();
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize - 7.5);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h - 7.5);
	c.lineTo(w * 0.5 + 7.5, h - 7.5);
	c.lineTo(w * 0.5, h);
	c.lineTo(w * 0.5 - 7.5, h - 7.5);
	c.lineTo(rSize, h - 7.5);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize - 7.5);
	c.close();
	c.fillAndStroke();
};

mxShapeMockupiCopy.prototype.foreground = function(c, w, h, rSize)
{
	var fillColor3 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR3, '#00ff00');
	c.setGradient(fillColor3, fillColor3, 0, 0, w, h * 0.5, mxConstants.DIRECTION_SOUTH, 0.8, 0.1);
	c.begin();
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, (h - 7.5) * 0.5);
	c.lineTo(0, (h - 7.5) * 0.5);
	c.close();
	c.fill();

	var fieldText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, '');
	var textColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR, '#00ff00');
	c.setFontColor(textColor);
	c.setFontSize(8.5);
	c.text(w * 0.5, (h - 7.5)* 0.45, 0, 0, fieldText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ICOPY, mxShapeMockupiCopy);

//**********************************************************************************************************************************************************
//Copy Area
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiCopyArea(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiCopyArea, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiCopyArea.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var rSize = 5;
	c.translate(x, y);
	this.background(c, w, h, rSize);
	c.setShadow(false);

	this.foreground(c, w, h, rSize);
};

mxShapeMockupiCopyArea.prototype.background = function(c, w, h, rSize)
{
	c.begin();
	c.moveTo(w * 0.5 - 20, 0 + rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w * 0.5 - 20 + rSize, 0);
	c.lineTo(w * 0.5 + 20 - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w * 0.5 + 20, rSize);
	c.lineTo(w * 0.5 + 20, 20 - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w * 0.5 + 20 - rSize, 20);
	c.lineTo(w * 0.5 + 7.5, 20);
	c.lineTo(w * 0.5, 27.5);
	c.lineTo(w * 0.5 - 7.5, 20);
	c.lineTo(w * 0.5 - 20 + rSize, 20);
	c.arcTo(rSize, rSize, 0, 0, 1, w * 0.5 - 20, 20 - rSize);
	c.close();
	c.fillAndStroke();
};

mxShapeMockupiCopyArea.prototype.foreground = function(c, w, h, rSize)
{
	c.setAlpha(0.3);
	c.setFillColor('#2266ff');
	c.rect(2.5, 27.5, w - 5, h - 30);
	c.fill();
	c.setAlpha(1);

	if (h > 27.5)
	{
		c.setStrokeColor('#ffffff');
		c.setGradient('#88ddff', '#2266ff', w * 0.5 - 2.5, 25, 5, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
		c.ellipse(w * 0.5 - 2.5, 25, 5, 5);
		c.fillAndStroke();
		c.setGradient('#88ddff', '#2266ff', w * 0.5 - 2.5, h - 5, 5, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
		c.ellipse(w * 0.5 - 2.5, h - 5, 5, 5);
		c.fillAndStroke();
		c.setGradient('#88ddff', '#2266ff', 0, h * 0.5 + 10, 5, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
		c.ellipse(0, h * 0.5 + 10, 5, 5);
		c.fillAndStroke();
		c.setGradient('#88ddff', '#2266ff', w - 5, h * 0.5 + 10, 5, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
		c.ellipse(w - 5, h * 0.5 + 10, 5, 5);
		c.fillAndStroke();
	}

	var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, '#00ff00');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#00ff00');

	c.setFillColor(fillColor2);
	c.setStrokeColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.5 - 20, 0 + rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w * 0.5 - 20 + rSize, 0);
	c.lineTo(w * 0.5 + 20 - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w * 0.5 + 20, rSize);
	c.lineTo(w * 0.5 + 20, 20 - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w * 0.5 + 20 - rSize, 20);
	c.lineTo(w * 0.5 + 7.5, 20);
	c.lineTo(w * 0.5, 27.5);
	c.lineTo(w * 0.5 - 7.5, 20);
	c.lineTo(w * 0.5 - 20 + rSize, 20);
	c.arcTo(rSize, rSize, 0, 0, 1, w * 0.5 - 20, 20 - rSize);
	c.close();
	c.fillAndStroke();

	var fillColor3 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR3, '#00ff00');
	c.setGradient(fillColor3, fillColor3, w * 0.5 - 20, 0, 40, 10, mxConstants.DIRECTION_SOUTH, 0.8, 0.1);
	c.begin();
	c.moveTo(w * 0.5 - 20, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w * 0.5 - 20 + rSize, 0);
	c.lineTo(w * 0.5 + 20 - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w * 0.5 + 20, rSize);
	c.lineTo(w * 0.5 + 20, 10);
	c.lineTo(w * 0.5 - 20, 10);
	c.close();
	c.fill();

	var fieldText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, '');
	var textColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR, '#00ff00');
	c.setFontColor(textColor);
	c.setFontSize(8.5);

	c.text(w * 0.5, 8.75, 0, 0, fieldText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_ICOPY_AREA, mxShapeMockupiCopyArea);

//**********************************************************************************************************************************************************
//Home Page Control
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiHomePageControl(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiHomePageControl, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiHomePageControl.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);


	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#000000');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	c.setStrokeColor(strokeColor);
	c.setFillColor(fillColor);

	var rSize = Math.min(h * 0.5, w * 0.05);
	c.ellipse(w * 0.35 - rSize, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
	c.ellipse(w * 0.65 - rSize, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
	c.ellipse(w - 2 * rSize, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();

	c.ellipse(rSize * 0.2, h * 0.5 - rSize * 0.8, rSize * 1.2, rSize * 1.2);
	c.stroke();
	c.begin();
	c.moveTo(rSize * 1.15, h * 0.5 + rSize * 0.25);
	c.lineTo(rSize * 1.6, h * 0.5 + rSize * 0.8);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IHOME_PAGE_CONTROL, mxShapeMockupiHomePageControl);

//**********************************************************************************************************************************************************
//Page Control
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiPageControl(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiPageControl, mxShape);

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiPageControl.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);


	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#000000');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');

	var rSize = Math.min(h * 0.5, w * 0.05);
	c.setFillColor(strokeColor);
	c.ellipse(0, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
	c.setFillColor(fillColor);
	c.ellipse(w * 0.35 - rSize, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
	c.ellipse(w * 0.65 - rSize, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
	c.ellipse(w - 2 * rSize, h * 0.5 - rSize, 2 * rSize, 2 * rSize);
	c.fill();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IPAGE_CONTROL, mxShapeMockupiPageControl);

//**********************************************************************************************************************************************************
//iPad
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapeMockupiPad(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapeMockupiPad, mxShape);

mxShapeMockupiPad.prototype.customProperties = [
	{name: 'bgStyle', dispName: 'Background', type: 'enum', 
		enumList: [{val: 'bgGreen', dispName: 'Green'}, {val: 'bgWhite', dispName: 'White'}, {val: 'bgGray', dispName: 'Gray'}, {val: 'bgFlat', dispName: 'Flat'}, {val: 'bgMap', dispName: 'Map'}, {val: 'bgStriped', dispName: 'Striped'}]
	}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapeMockupiPad.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var rSize = 25;
	c.translate(x, y);
	this.background(c, x, y, w, h, rSize);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, rSize);
};

mxShapeMockupiPad.prototype.background = function(c, x, y, w, h, rSize)
{
	c.setFillColor('#000000');
	c.setStrokeColor('#000000');
	c.roundrect(0, 0, w, h, rSize, rSize);
	c.fillAndStroke();
};

mxShapeMockupiPad.prototype.foreground = function(c, x, y, w, h, rSize)
{
	c.setStrokeWidth(1.5);
	c.setStrokeColor('#999999');

	c.begin();
	c.setStrokeColor('none');
	c.setFillColor('#808080');
	c.setGradient('#808080', '#000000', w * 0.325, 0, w * 0.675, h * 0.5, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.moveTo(w * 0.325, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h * 0.5);
	c.lineTo(w * 0.7, h * 0.5);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.setFillColor('#1f2923');
	c.setStrokeColor('#18211b');
	c.setStrokeWidth(1);

	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '');
	var bgStyle = mxUtils.getValue(this.style, mxMockupC.BG_STYLE, mxMockupC.BG_FLAT_GREEN);

	c.setStrokeWidth(1);

	if (bgStyle === mxMockupC.BG_FLAT_WHITE)
	{
		c.setFillColor('#ffffff');
		c.rect(w * 0.0928, h * 0.08, w * 0.8144, h * 0.816);
		c.fill();
	}
	else if (bgStyle === mxMockupC.BG_FLAT_GREEN)
	{
		c.setFillColor('#1f2923');
		c.rect(w * 0.0928, h * 0.08, w * 0.8144, h * 0.816);
		c.fill();
	}
	else if (bgStyle === mxMockupC.BG_FLAT_GRAY)
	{
		c.setFillColor('#dddddd');
		c.rect(w * 0.0928, h * 0.08, w * 0.8144, h * 0.816);
		c.fill();
	}
	else if (bgStyle === mxMockupC.BG_FLAT_CUSTOM)
	{
		c.setFillColor(fillColor);
		c.rect(w * 0.0928, h * 0.08, w * 0.8144, h * 0.816);
		c.fill();
	}
	else if (bgStyle === mxMockupC.BG_STRIPED)
	{
		var xOld = x;
		var yOld = y;
		var wOld = w;
		var hOld = h;
		c.translate(w * 0.0928, h * 0.08);
		w = w * 0.8144;
		h = h * 0.816;

		c.setFillColor('#5D7585');
		c.rect(0, 0, w, h);
		c.fillAndStroke();

		var strokeColor = '#18211b';
		var strokeColor2 = '#657E8F';

		c.setStrokeColor(strokeColor2);
		var i = 7;
		c.begin();

		while (i < w)
		{
			c.moveTo(i, 0);
			c.lineTo(i, h);
			i = i + 7;
		}

		c.stroke();

		c.setStrokeColor(strokeColor);
		c.begin();
		c.rect(0, 0, w, h);
		c.stroke();

		w = wOld;
		h = hOld;
		c.translate( - w * 0.0928, - h * 0.08);
	}
	else if (bgStyle === mxMockupC.BG_MAP)
	{
		var xOld = x;
		var yOld = y;
		var wOld = w;
		var hOld = h;
		c.translate(w * 0.0928, h * 0.08);
		w = w * 0.8144;
		h = h * 0.816;

		c.setFillColor('#ffffff');
		c.rect(0, 0, w, h);
		c.fillAndStroke();

		var fillColor2 = '#96D1FF';
		var strokeColor = '#18211b';
		var strokeColor2 = '#008cff';

		c.setFillColor(fillColor2);
		c.setStrokeColor(strokeColor2);
		c.setStrokeWidth(0.5);

		c.begin();
		c.moveTo(0, 0);
		c.lineTo(w * 0.1171, 0);
		c.lineTo(w * 0.1136, h * 0.0438);
		c.lineTo(w * 0.0993, h * 0.054);
		c.lineTo(0, h * 0.0446);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.1993, 0);
		c.lineTo(w * 0.1914, h * 0.03884);
		c.lineTo(w * 0.1536, h * 0.0362);
		c.lineTo(w * 0.1586, 0);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.24, 0);
		c.lineTo(w * 0.2257, h * 0.054);
		c.lineTo(w * 0.2414, h * 0.0674);
		c.lineTo(w * 0.4707, h * 0.0835);
		c.lineTo(w * 0.5264, h * 0.0906);
		c.lineTo(w * 0.6429, h * 0.0929);
		c.arcTo(w * 0.0857, h * 0.0536, 0, 0, 0, w * 0.7193, h * 0.0621);
		c.arcTo(w * 0.48, h * 0.2143, 0, 0, 0, w * 0.7286, 0);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.8, 0);
		c.lineTo(w * 0.7886, h * 0.04554);
		c.arcTo(w * 0.0857, h * 0.0536, 0, 0, 0, w * 0.8164, h * 0.0875);
		c.arcTo(w * 0.1429, h * 0.0893, 0, 0, 0, w * 0.88, h * 0.1036);
		c.lineTo(w, h * 0.1112);
		c.lineTo(w, 0);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(0, h * 0.0933);
		c.lineTo(w * 0.08, h * 0.1036);
		c.lineTo(w * 0.1021, h * 0.1246);
		c.lineTo(w * 0.1007, h * 0.1768);
		c.lineTo(w * 0.0471, h * 0.2241);
		c.lineTo(0, h * 0.2527);
		c.close();
		c.fillAndStroke();

		c.ellipse(w * 0.1214, h * 0.0603, w * 0.0843, h * 0.0576);
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.1293, h * 0.1924);
		c.lineTo(w * 0.1729, h * 0.142);
		c.lineTo(w * 0.1407, h * 0.1411);
		c.lineTo(w * 0.14, h * 0.1777);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.4586, h * 0.1241);
		c.lineTo(w * 0.455, h * 0.1835);
		c.lineTo(w * 0.3893, h * 0.2246);
		c.lineTo(w * 0.2171, h * 0.1362);
		c.lineTo(w * 0.2171, h * 0.1308);
		c.lineTo(w * 0.2293, h * 0.1214);
		c.lineTo(w * 0.2857, h * 0.1174);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.5079, h * 0.1134);
		c.lineTo(w * 0.7307, h * 0.1223);
		c.lineTo(w * 0.7279, h * 0.1625);
		c.lineTo(w * 0.715, h * 0.1772);
		c.lineTo(w * 0.6929, h * 0.1688);
		c.lineTo(w * 0.625, h * 0.1795);
		c.lineTo(w * 0.4779, h * 0.2835);
		c.lineTo(w * 0.395, h * 0.2299);
		c.lineTo(w * 0.4657, h * 0.1826);
		c.lineTo(w * 0.4707, h * 0.1223);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w, h * 0.1362);
		c.lineTo(w * 0.7643, h * 0.1237);
		c.lineTo(w * 0.7543, h * 0.1562);
		c.lineTo(w * 0.7643, h * 0.1585);
		c.lineTo(w * 0.9186, h * 0.2366);
		c.lineTo(w, h * 0.1732);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.2079, h * 0.1545);
		c.lineTo(w * 0.3886, h * 0.2536);
		c.lineTo(w * 0.3414, h * 0.2933);
		c.lineTo(w * 0.1743, h * 0.1969);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.1579, h * 0.2134);
		c.lineTo(w * 0.3221, h * 0.3067);
		c.lineTo(w * 0.2957, h * 0.3237);
		c.lineTo(w * 0.1157, h * 0.2424);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.405, h * 0.2656);
		c.lineTo(w * 0.31, h * 0.3353);
		c.lineTo(w * 0.3693, h * 0.3661);
		c.lineTo(w * 0.4571, h * 0.2982);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.7121, h * 0.1848);
		c.lineTo(w * 0.6879, h * 0.1754);
		c.lineTo(w * 0.6329, h * 0.1844);
		c.lineTo(w * 0.61, h * 0.2018);
		c.lineTo(w * 0.6207, h * 0.2085);
		c.lineTo(w * 0.4986, h * 0.2982);
		c.lineTo(w * 0.535, h * 0.3237);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.5557, h * 0.3379);
		c.lineTo(w * 0.7464, h * 0.1826);
		c.lineTo(w * 0.8036, h * 0.2076);
		c.lineTo(w * 0.595, h * 0.3616);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.8293, h * 0.2188);
		c.lineTo(w * 0.8979, h * 0.2509);
		c.lineTo(w * 0.6936, h * 0.4125);
		c.lineTo(w * 0.6171, h * 0.3737);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w, h * 0.2138);
		c.lineTo(w * 0.6821, h * 0.4603);
		c.lineTo(w * 0.815, h * 0.5277);
		c.lineTo(w, h * 0.4);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(0, h * 0.317);
		c.lineTo(w * 0.0971, h * 0.2554);
		c.lineTo(w * 0.4121, h * 0.4143);
		c.lineTo(w * 0.3736, h * 0.4415);
		c.lineTo(w * 0.315, h * 0.4076);
		c.lineTo(w * 0.3093, h * 0.4116);
		c.lineTo(w * 0.3686, h * 0.4455);
		c.lineTo(w * 0.285, h * 0.5045);
		c.lineTo(w * 0.1114, h * 0.4134);
		c.lineTo(w * 0.025, h * 0.4603);
		c.lineTo(w * 0.0371, h * 0.4723);
		c.lineTo(w * 0.1114, h * 0.4371);
		c.lineTo(w * 0.2871, h * 0.5312);
		c.lineTo(w * 0.1929, h * 0.6058);
		c.lineTo(w * 0.2271, h * 0.6705);
		c.lineTo(w * 0.17, h * 0.7147);
		c.lineTo(w * 0.0314, h * 0.6321);
		c.lineTo(0, h * 0.6246);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.48, h * 0.3121);
		c.lineTo(w * 0.5157, h * 0.3375);
		c.lineTo(w * 0.4314, h * 0.3982);
		c.lineTo(w * 0.3929, h * 0.3786);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.3086, h * 0.5179);
		c.lineTo(w * 0.53, h * 0.3518);
		c.lineTo(w * 0.5757, h * 0.3745);
		c.lineTo(w * 0.3479, h * 0.5411);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.5964, h * 0.3884);
		c.lineTo(w * 0.6736, h * 0.4277);
		c.lineTo(w * 0.445, h * 0.5991);
		c.lineTo(w * 0.3664, h * 0.5531);
		c.lineTo(w * 0.5057, h * 0.4545);
		c.lineTo(w * 0.5507, h * 0.4754);
		c.lineTo(w * 0.5571, h * 0.4723);
		c.lineTo(w * 0.5114, h * 0.4504);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.4793, h * 0.6161);
		c.lineTo(w * 0.6771, h * 0.4643);
		c.lineTo(w * 0.8086, h * 0.5326);
		c.lineTo(w * 0.7471, h * 0.5817);
		c.lineTo(w * 0.7214, h * 0.567);
		c.lineTo(w * 0.715, h * 0.571);
		c.lineTo(w * 0.7421, h * 0.5871);
		c.lineTo(w * 0.6014, h * 0.6933);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w, h * 0.4371);
		c.lineTo(w * 0.8443, h * 0.546);
		c.lineTo(w * 0.9071, h * 0.5701);
		c.lineTo(w, h * 0.5022);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.8407, h * 0.5504);
		c.lineTo(w * 0.8993, h * 0.5759);
		c.lineTo(w * 0.6757, h * 0.7416);
		c.lineTo(w * 0.6286, h * 0.7139);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w, h * 0.5321);
		c.lineTo(w * 0.6979, h * 0.7549);
		c.lineTo(w * 0.7457, h * 0.7781);
		c.lineTo(w * 0.9814, h * 0.6094);
		c.lineTo(w, h * 0.6067);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w, h * 0.6254);
		c.lineTo(w * 0.7664, h * 0.792);
		c.lineTo(w * 0.9586, h * 0.9062);
		c.lineTo(w, h * 0.8786);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.3093, h * 0.5464);
		c.lineTo(w * 0.4271, h * 0.6152);
		c.lineTo(w * 0.245, h * 0.7643);
		c.lineTo(w * 0.185, h * 0.7228);
		c.lineTo(w * 0.2493, h * 0.6728);
		c.lineTo(w * 0.2214, h * 0.6143);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(0, h * 0.65);
		c.lineTo(w * 0.2179, h * 0.7826);
		c.lineTo(w * 0.1136, h * 0.8424);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(0, h * 0.7272);
		c.lineTo(w * 0.0821, h * 0.859);
		c.lineTo(0, h * 0.9085);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.4529, h * 0.6366);
		c.lineTo(w * 0.575, h * 0.7143);
		c.lineTo(w * 0.39, h * 0.8621);
		c.lineTo(w * 0.2657, h * 0.7902);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(0, h * 0.9415);
		c.lineTo(w * 0.1036, h * 0.8821);
		c.lineTo(w * 0.2343, h * 0.959);
		c.lineTo(w * 0.1721, h);
		c.lineTo(0, h);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.2586, h * 0.7951);
		c.lineTo(w * 0.3829, h * 0.8674);
		c.lineTo(w * 0.2543, h * 0.9451);
		c.lineTo(w * 0.1279, h * 0.8692);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.2836, h * 0.9639);
		c.lineTo(w * 0.4207, h * 0.8772);
		c.lineTo(w * 0.605, h * 0.7321);
		c.lineTo(w * 0.6521, h * 0.7634);
		c.lineTo(w * 0.3486, h);
		c.lineTo(w * 0.3393, h);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.3879, h);
		c.lineTo(w * 0.6721, h * 0.7759);
		c.lineTo(w * 0.7171, h * 0.7982);
		c.lineTo(w * 0.4564, h);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.4986, h);
		c.lineTo(w * 0.7386, h * 0.8125);
		c.lineTo(w * 0.9307, h * 0.925);
		c.lineTo(w * 0.8264, h);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.8671, h);
		c.lineTo(w * 0.9464, h * 0.9491);
		c.lineTo(w, h * 0.975);
		c.lineTo(w, h);
		c.close();
		c.fillAndStroke();

		c.begin();
		c.moveTo(w * 0.2295, h);
		c.lineTo(w * 0.2648, h * 0.9792);
		c.lineTo(w * 0.2981, h);
		c.close();
		c.fillAndStroke();

		w = wOld;
		h = hOld;
		c.translate( - w * 0.0928, - h * 0.08);
	}

	c.setStrokeWidth(1);
	c.setStrokeColor('#18211b');
	c.rect(w * 0.0928, h * 0.08, w * 0.8144, h * 0.816);
	c.stroke();

	c.setStrokeWidth(1.5);
	c.setAlpha(0.8);
	c.setStrokeColor('#dddddd');
	c.begin();
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();	
	c.stroke();

	rSize = 22.5;
	c.begin();
	c.setStrokeColor('#666666');
	c.begin();
	c.moveTo(2.5, 2.5 + rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, 2.5 + rSize, 2.5);
	c.lineTo(w - rSize - 5, 2.5);
	c.arcTo(rSize, rSize, 0, 0, 1, w - 2.5, rSize + 2.5);
	c.lineTo(w - 2.5, h - rSize - 2.5);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize - 2.5, h - 2.5);
	c.lineTo(rSize + 2.5, h - 2.5);
	c.arcTo(rSize, rSize, 0, 0, 1, 2.5, h - rSize - 2.5);
	c.close();	
	c.stroke();

	c.setAlpha(1);
	c.ellipse(w * 0.4948, h * 0.0444, w * 0.0103, h * 0.008);
	c.setStrokeWidth(2.5);
	c.setStrokeColor('#000000');
	c.setFillColor('#000099');
	c.fillAndStroke();

	c.setGradient('#bbbbbb', '#000000', w * 0.4588, h * 0.912, w * 0.0825, h * 0.064, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.ellipse(w * 0.4588, h * 0.912, w * 0.0825, h * 0.064);
	c.fill();

	c.setAlpha(0.5);
	c.ellipse(w * 0.4588, h * 0.912, w * 0.0825, h * 0.064);
	c.stroke();

	c.begin();
	c.setAlpha(0.85);
	c.setFillColor('#000000');
	c.moveTo(w * 0.4598, h * 0.944);
	c.arcTo(w * 0.0402, h * 0.0296, 0, 0, 1, w * 0.5402, h * 0.944);
	c.arcTo(w * 0.0825, h * 0.064, 0, 0, 1, w * 0.4598, h * 0.944);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.setAlpha(0.7);
	c.setStrokeWidth(1.5);
	c.setStrokeColor('#dddddd');
	rSize = 4;
	c.roundrect(w * 0.4814, h * 0.9296, w * 0.0371, h * 0.0288, h * 0.00515, h * 0.004);
	c.stroke();
};

mxCellRenderer.registerShape(mxMockupC.SHAPE_IPAD, mxShapeMockupiPad);

//**********************************************************************************************************************************************************
//Rounded rectangle (adjustable rounding)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupRRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupRRect, mxShape);

mxShapeMockupRRect.prototype.cst = {
		RRECT : 'mxgraph.ios.rrect',
		R_SIZE : 'rSize'
};

mxShapeMockupRRect.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:5},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupRRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupRRect.prototype.cst.R_SIZE, '10'));
	c.roundrect(0, 0, w, h, rSize);
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeMockupRRect.prototype.cst.RRECT, mxShapeMockupRRect);

//**********************************************************************************************************************************************************
//Top Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIosTopButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIosTopButton, mxShape);

mxShapeIosTopButton.prototype.cst = {
		TOP_BUTTON : 'mxgraph.ios.topButton',
		R_SIZE : 'rSize'
};

mxShapeIosTopButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:5},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIosTopButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeIosTopButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.lineTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeIosTopButton.prototype.cst.TOP_BUTTON, mxShapeIosTopButton);

//**********************************************************************************************************************************************************
//Bottom Button
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIosBottomButton(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIosBottomButton, mxShape);

mxShapeIosBottomButton.prototype.cst = {
		BOTTOM_BUTTON : 'mxgraph.ios.bottomButton',
		R_SIZE : 'rSize'
};

mxShapeIosBottomButton.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:5},
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIosBottomButton.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeIosBottomButton.prototype.cst.R_SIZE, '10'));

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h - rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
	c.lineTo(rSize, h);
	c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
	c.close();
	c.fillAndStroke();
};

mxCellRenderer.registerShape(mxShapeIosBottomButton.prototype.cst.BOTTOM_BUTTON, mxShapeIosBottomButton);

//**********************************************************************************************************************************************************
//Anchor (a dummy shape without visuals used for anchoring)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIosAnchor(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIosAnchor, mxShape);

mxShapeIosAnchor.prototype.cst = {
		ANCHOR : 'mxgraph.ios.anchor'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIosAnchor.prototype.paintVertexShape = function(c, x, y, w, h)
{
};

mxCellRenderer.registerShape(mxShapeIosAnchor.prototype.cst.ANCHOR, mxShapeIosAnchor);

//**********************************************************************************************************************************************************
//Checkbox
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeIosCheckbox(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeIosCheckbox, mxShape);

mxShapeIosCheckbox.prototype.cst = {
		CHECKBOX : 'mxgraph.ios.checkbox'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeIosCheckbox.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.rect(0, 0, w, h);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w * 0.8, h * 0.2);
	c.lineTo(w * 0.4, h * 0.8);
	c.lineTo(w * 0.25, h * 0.6);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeIosCheckbox.prototype.cst.CHECKBOX, mxShapeIosCheckbox);

//**********************************************************************************************************************************************************
//Fancy Rounded rectangle (adjustable rounding)
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapeMockupFancyRRect(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapeMockupFancyRRect, mxShape);

mxShapeMockupFancyRRect.prototype.cst = {
		FANCY_RRECT : 'mxgraph.ios.fancyRRect',
		R_SIZE : 'rSize'
};

mxShapeMockupFancyRRect.prototype.customProperties = [
	{name: 'rSize', dispName: 'Arc Size', type: 'float', min:0, defVal:8}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapeMockupFancyRRect.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);

	var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupFancyRRect.prototype.cst.R_SIZE, '10'));
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');

//	c.setAlpha(0.8);
	c.roundrect(0, 0, w, h, rSize);
	c.fillAndStroke();
	
	c.setShadow(false);
	
	c.setStrokeColor(fillColor);
	c.setGradient(fillColor, '#ffffff', 0, 0, w, 22.5, mxConstants.DIRECTION_SOUTH, 1, 1);
	c.setAlpha(0.3);
	c.begin();
	c.moveTo(w - rSize, 0);
	c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
	c.lineTo(w, 17.5);
	c.arcTo(w * 1.67, h * 2.5, 0, 0, 1, 0, 17.5);
	c.lineTo(0, rSize);
	c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
	c.close();
	c.fillAndStroke();

	c.setAlpha(0.8);
	c.setStrokeColor(strokeColor);
	c.setStrokeWidth(1);
	c.roundrect(0, 0, w, h, rSize, rSize);
	c.stroke();
};

mxCellRenderer.registerShape(mxShapeMockupFancyRRect.prototype.cst.FANCY_RRECT, mxShapeMockupFancyRRect);

/**
 * $Id: mxPidInstruments.js,v 1.4 2014/01/21 13:10:17 gaudenz Exp $
 * Copyright (c) 2006-2013, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Discrete Instrument
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapePidDiscInst(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapePidDiscInst, mxShape);

mxShapePidDiscInst.prototype.cst = {
		SHAPE_DISC_INST : 'mxgraph.pid2inst.discInst',
		MOUNTING : 'mounting',
		FIELD : 'field',
		ROOM : 'room',
		INACCESSIBLE : 'inaccessible',
		LOCAL : 'local'
};

mxShapePidDiscInst.prototype.customProperties = [
	{name: 'mounting', dispName: 'Mounting', type: 'enum', defVal:'field',
		enumList: [
			{val:'field', dispName:'Field'},
			{val:'room', dispName:'Room'},
			{val:'inaccessible', dispName:'Inaccessible'},
			{val:'local', dispName:'Local'}
		]}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapePidDiscInst.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapePidDiscInst.prototype.background = function(c, x, y, w, h)
{
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();
};

mxShapePidDiscInst.prototype.foreground = function(c, x, y, w, h)
{
	var mounting = mxUtils.getValue(this.style, mxShapePidDiscInst.prototype.cst.MOUNTING, 'field');

	if (mounting === mxShapePidDiscInst.prototype.cst.ROOM)
	{
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
	else if (mounting === mxShapePidDiscInst.prototype.cst.INACCESSIBLE)
	{
		c.setDashed(true);
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
	else if (mounting === mxShapePidDiscInst.prototype.cst.LOCAL)
	{
		c.begin();
		c.moveTo(w * 0.005, h * 0.48);
		c.lineTo(w * 0.995, h * 0.48);
		c.moveTo(w * 0.005, h * 0.52);
		c.lineTo(w * 0.995, h * 0.52);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapePidDiscInst.prototype.cst.SHAPE_DISC_INST, mxShapePidDiscInst);

mxShapePidDiscInst.prototype.constraints = [
                    new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                    new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                    new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                    new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                    new mxConnectionConstraint(new mxPoint(0.145, 0.145), false),
                    new mxConnectionConstraint(new mxPoint(0.145, 0.855), false),
                    new mxConnectionConstraint(new mxPoint(0.855, 0.145), false),
                    new mxConnectionConstraint(new mxPoint(0.855, 0.855), false)
                    ];

//**********************************************************************************************************************************************************
//Shared Control/Display
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapePidSharedCont(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapePidSharedCont, mxShape);

mxShapePidSharedCont.prototype.cst = {
		SHAPE_SHARED_CONT : 'mxgraph.pid2inst.sharedCont',
		MOUNTING : 'mounting',
		FIELD : 'field',
		ROOM : 'room',
		INACCESSIBLE : 'inaccessible',
		LOCAL : 'local'
};

mxShapePidSharedCont.prototype.customProperties = [
	{name: 'mounting', dispName: 'Mounting', type: 'enum', defVal:'field',
		enumList: [
			{val:'field', dispName:'Field'},
			{val:'room', dispName:'Room'},
			{val:'inaccessible', dispName:'Inaccessible'},
			{val:'local', dispName:'Local'}
		]}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapePidSharedCont.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapePidSharedCont.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapePidSharedCont.prototype.foreground = function(c, x, y, w, h)
{
	var mounting = mxUtils.getValue(this.style, mxShapePidSharedCont.prototype.cst.MOUNTING, 'field');

	c.ellipse(0, 0, w, h);
	c.fillAndStroke();

	if (mounting === mxShapePidSharedCont.prototype.cst.ROOM)
	{
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
	else if (mounting === mxShapePidSharedCont.prototype.cst.INACCESSIBLE)
	{
		c.setDashed(true);
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
	else if (mounting === mxShapePidDiscInst.prototype.cst.LOCAL)
	{
		c.begin();
		c.moveTo(w * 0.005, h * 0.48);
		c.lineTo(w * 0.995, h * 0.48);
		c.moveTo(w * 0.005, h * 0.52);
		c.lineTo(w * 0.995, h * 0.52);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapePidSharedCont.prototype.cst.SHAPE_SHARED_CONT, mxShapePidSharedCont);

mxShapePidSharedCont.prototype.constraints = [
                                            new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                            new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                            new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                            new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                            new mxConnectionConstraint(new mxPoint(0, 0), false),
                                            new mxConnectionConstraint(new mxPoint(0, 1), false),
                                            new mxConnectionConstraint(new mxPoint(1, 0), false),
                                            new mxConnectionConstraint(new mxPoint(1, 1), false)
                                            ];

//**********************************************************************************************************************************************************
//Computer Function
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapePidCompFunc(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapePidCompFunc, mxShape);

mxShapePidCompFunc.prototype.cst = {
		SHAPE_COMP_FUNC : 'mxgraph.pid2inst.compFunc',
		MOUNTING : 'mounting',
		FIELD : 'field',
		ROOM : 'room',
		INACCESSIBLE : 'inaccessible',
		LOCAL : 'local'
};

mxShapePidCompFunc.prototype.customProperties = [
	{name: 'mounting', dispName: 'Mounting', type: 'enum', defVal:'field',
		enumList: [
			{val:'field', dispName:'Field'},
			{val:'room', dispName:'Room'},
			{val:'inaccessible', dispName:'Inaccessible'},
			{val:'local', dispName:'Local'}
		]}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapePidCompFunc.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapePidCompFunc.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w * 0.25, 0);
	c.lineTo(w * 0.75, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w * 0.75, h);
	c.lineTo(w * 0.25, h);
	c.close();
	c.fillAndStroke();
};

mxShapePidCompFunc.prototype.foreground = function(c, x, y, w, h)
{
	var mounting = mxUtils.getValue(this.style, mxShapePidCompFunc.prototype.cst.MOUNTING, 'field');

	if (mounting === mxShapePidCompFunc.prototype.cst.ROOM)
	{
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
	else if (mounting === mxShapePidCompFunc.prototype.cst.INACCESSIBLE)
	{
		c.setDashed(true);
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
	else if (mounting === mxShapePidDiscInst.prototype.cst.LOCAL)
	{
		c.begin();
		c.moveTo(w * 0.01, h * 0.48);
		c.lineTo(w * 0.99, h * 0.48);
		c.moveTo(w * 0.01, h * 0.52);
		c.lineTo(w * 0.99, h * 0.52);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapePidCompFunc.prototype.cst.SHAPE_COMP_FUNC, mxShapePidCompFunc);

mxShapePidCompFunc.prototype.constraints = [
                                              new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                              new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                              new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                              new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                              new mxConnectionConstraint(new mxPoint(0.25, 0), false),
                                              new mxConnectionConstraint(new mxPoint(0.75, 0), false),
                                              new mxConnectionConstraint(new mxPoint(0.25, 1), false),
                                              new mxConnectionConstraint(new mxPoint(0.75, 1), false)
                                              ];

//**********************************************************************************************************************************************************
//Computer Function
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapePidProgLogCont(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapePidProgLogCont, mxShape);

mxShapePidProgLogCont.prototype.cst = {
		SHAPE_PROG_LOG_CONT : 'mxgraph.pid2inst.progLogCont',
		MOUNTING : 'mounting',
		FIELD : 'field',
		ROOM : 'room',
		INACCESSIBLE : 'inaccessible',
		LOCAL : 'local'
};

mxShapePidProgLogCont.prototype.customProperties = [
	{name: 'mounting', dispName: 'Mounting', type: 'enum', defVal:'field',
		enumList: [
			{val:'field', dispName:'Field'},
			{val:'room', dispName:'Room'},
			{val:'inaccessible', dispName:'Inaccessible'},
			{val:'local', dispName:'Local'}
		]}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapePidProgLogCont.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapePidProgLogCont.prototype.background = function(c, x, y, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxShapePidProgLogCont.prototype.foreground = function(c, x, y, w, h)
{
	var mounting = mxUtils.getValue(this.style, mxShapePidProgLogCont.prototype.cst.MOUNTING, 'field');

	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w * 0.5, h);
	c.close();
	c.stroke();
	
	if (mounting === mxShapePidProgLogCont.prototype.cst.ROOM)
	{
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
	else if (mounting === mxShapePidProgLogCont.prototype.cst.INACCESSIBLE)
	{
		c.setDashed(true);
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
	else if (mounting === mxShapePidDiscInst.prototype.cst.LOCAL)
	{
		c.begin();
		c.moveTo(w * 0.02, h * 0.48);
		c.lineTo(w * 0.98, h * 0.48);
		c.moveTo(w * 0.02, h * 0.52);
		c.lineTo(w * 0.98, h * 0.52);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapePidProgLogCont.prototype.cst.SHAPE_PROG_LOG_CONT, mxShapePidProgLogCont);

mxShapePidProgLogCont.prototype.constraints = [
                                            new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                            new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                            new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                            new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                            new mxConnectionConstraint(new mxPoint(0, 0), false),
                                            new mxConnectionConstraint(new mxPoint(0, 1), false),
                                            new mxConnectionConstraint(new mxPoint(1, 0), false),
                                            new mxConnectionConstraint(new mxPoint(1, 1), false)
                                            ];

//**********************************************************************************************************************************************************
//Indicator
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapePidIndicator(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapePidIndicator, mxShape);

mxShapePidIndicator.prototype.cst = {
		SHAPE_INDICATOR : 'mxgraph.pid2inst.indicator',
		MOUNTING : 'mounting',
		FIELD : 'field',
		ROOM : 'room',
		INACCESSIBLE : 'inaccessible',
		LOCAL : 'local',
		IND_TYPE : 'indType',
		INSTRUMENT : 'inst',
		CONTROL : 'ctrl',
		FUNCTION : 'func',
		PLC : 'plc'
};

mxShapePidIndicator.prototype.customProperties = [
	{name: 'mounting', dispName: 'Mounting', type: 'enum', defVal:'field',
		enumList: [
			{val:'field', dispName:'Field'},
			{val:'room', dispName:'Room'},
			{val:'inaccessible', dispName:'Inaccessible'},
			{val:'local', dispName:'Local'}
	]},
	{name: 'indType', dispName: 'Type', type: 'enum', defVal:'inst',
		enumList: [
			{val:'inst', dispName:'Instrument'},
			{val:'ctrl', dispName:'Control'},
			{val:'func', dispName:'Function'},
			{val:'plc', dispName:'PLC'}
	]}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapePidIndicator.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapePidIndicator.prototype.background = function(c, x, y, w, h)
{
	var type = mxUtils.getValue(this.style, mxShapePidIndicator.prototype.cst.IND_TYPE, 'inst');
	
	c.begin();
	c.moveTo(w * 0.5, w);
	c.lineTo(w * 0.5, h);
	c.stroke();

	if (type === mxShapePidIndicator.prototype.cst.INSTRUMENT)
	{
		c.ellipse(0, 0, w, w);
		c.fillAndStroke();
	}
	else if (type === mxShapePidIndicator.prototype.cst.CONTROL)
	{
		c.rect(0, 0, w, w);
		c.fillAndStroke();
	}
	else if (type === mxShapePidIndicator.prototype.cst.FUNCTION)
	{
		c.begin();
		c.moveTo(0, w * 0.5);
		c.lineTo(w * 0.25, 0);
		c.lineTo(w * 0.75, 0);
		c.lineTo(w, w * 0.5);
		c.lineTo(w * 0.75, w);
		c.lineTo(w * 0.25, w);
		c.close();
		c.fillAndStroke();
	}
	else if (type === mxShapePidIndicator.prototype.cst.PLC)
	{
		c.rect(0, 0, w, w);
		c.fillAndStroke();
	}
};

mxShapePidIndicator.prototype.foreground = function(c, x, y, w, h)
{
	var mounting = mxUtils.getValue(this.style, mxShapePidIndicator.prototype.cst.MOUNTING, 'field');
	var type = mxUtils.getValue(this.style, mxShapePidIndicator.prototype.cst.IND_TYPE, 'inst');

	if (type === mxShapePidIndicator.prototype.cst.CONTROL)
	{
		c.ellipse(0, 0, w, w);
		c.stroke();
	}
	else if (type === mxShapePidIndicator.prototype.cst.PLC)
	{
		c.begin();
		c.moveTo(0, w * 0.5);
		c.lineTo(w * 0.5, 0);
		c.lineTo(w, w * 0.5);
		c.lineTo(w * 0.5, w);
		c.close();
		c.stroke();
	}

	if (mounting === mxShapePidIndicator.prototype.cst.ROOM)
	{
		c.begin();
		c.moveTo(0, w * 0.5);
		c.lineTo(w, w * 0.5);
		c.stroke();
	}
	else if (mounting === mxShapePidIndicator.prototype.cst.INACCESSIBLE)
	{
		c.setDashed(true);
		c.begin();
		c.moveTo(0, w * 0.5);
		c.lineTo(w, w * 0.5);
		c.stroke();
	}
	else if (mounting === mxShapePidIndicator.prototype.cst.LOCAL)
	{
		c.begin();
		c.moveTo(w * 0.005, w * 0.48);
		c.lineTo(w * 0.995, w * 0.48);
		c.moveTo(w * 0.005, w * 0.52);
		c.lineTo(w * 0.995, w * 0.52);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapePidIndicator.prototype.cst.SHAPE_INDICATOR, mxShapePidIndicator);

mxShapePidIndicator.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0.5, 1), true)];

//**********************************************************************************************************************************************************
//Logic
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapePidLogic(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxShapePidLogic, mxShape);

mxShapePidLogic.prototype.cst = {
		SHAPE_LOGIC : 'mxgraph.pid2inst.logic',
		MOUNTING : 'mounting',
		FIELD : 'field',
		ROOM : 'room',
		INACCESSIBLE : 'inaccessible',
		LOCAL : 'local'
};

mxShapePidLogic.prototype.customProperties = [
	{name: 'mounting', dispName: 'Mounting', type: 'enum', defVal:'field',
		enumList: [
			{val:'field', dispName:'Field'},
			{val:'room', dispName:'Room'},
			{val:'inaccessible', dispName:'Inaccessible'},
			{val:'local', dispName:'Local'}
	]}
];

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapePidLogic.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapePidLogic.prototype.background = function(c, x, y, w, h)
{
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
};

mxShapePidLogic.prototype.foreground = function(c, x, y, w, h)
{
	var mounting = mxUtils.getValue(this.style, mxShapePidLogic.prototype.cst.MOUNTING, 'field');

	if (mounting === mxShapePidLogic.prototype.cst.ROOM)
	{
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
	else if (mounting === mxShapePidLogic.prototype.cst.INACCESSIBLE)
	{
		c.setDashed(true);
		c.begin();
		c.moveTo(0, h * 0.5);
		c.lineTo(w, h * 0.5);
		c.stroke();
	}
	else if (mounting === mxShapePidLogic.prototype.cst.LOCAL)
	{
		c.begin();
		c.moveTo(w * 0.02, h * 0.48);
		c.lineTo(w * 0.98, h * 0.48);
		c.moveTo(w * 0.02, h * 0.52);
		c.lineTo(w * 0.98, h * 0.52);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapePidLogic.prototype.cst.SHAPE_LOGIC, mxShapePidLogic);

mxShapePidLogic.prototype.constraints = [
                                            new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                            new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                            new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                            new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                            new mxConnectionConstraint(new mxPoint(0.25, 0.25), false),
                                            new mxConnectionConstraint(new mxPoint(0.25, 0.75), false),
                                            new mxConnectionConstraint(new mxPoint(0.75, 0.25), false),
                                            new mxConnectionConstraint(new mxPoint(0.75, 0.75), false)
                                            ];

/**
 * $Id: mxPidMisc.js,v 1.4 2013/11/22 10:46:56 mate Exp $
 * Copyright (c) 2006-2013, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Fan
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapePidFan(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapePidFan, mxShape);

mxShapePidFan.prototype.cst = {
		SHAPE_FAN : 'mxgraph.pid2misc.fan',
		FAN_TYPE : 'fanType',
		COMMON : 'common',
		AXIAL : 'axial',
		RADIAL : 'radial'
};

mxShapePidFan.prototype.customProperties = [
	{name: 'fanType', dispName: 'Type', type: 'enum', defVal:'field',
		enumList: [
			{val:'common', dispName:'Common'},
			{val:'axial', dispName:'Axial'},
			{val:'radial', dispName:'Radial'}
	]}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapePidFan.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapePidFan.prototype.background = function(c, x, y, w, h)
{
	c.ellipse(0, 0, w, h);
	c.fillAndStroke();
};

mxShapePidFan.prototype.foreground = function(c, x, y, w, h)
{

	c.begin();
	c.moveTo(w * 0.3, h * 0.045);
	c.lineTo(w * 0.97, h * 0.33);
	c.moveTo(w * 0.3, h * 0.955);
	c.lineTo(w * 0.97, h * 0.67);

	c.moveTo(w * 0.4228, h * 0.3655);
	c.arcTo(w * 0.15, h * 0.03, 50, 0, 1, w * 0.5, h * 0.5);
	c.arcTo(w * 0,15, h * 0.03, 50, 0, 1, w * 0.3772, h * 0.4045);
	c.arcTo(w * 0.15, h * 0.03, 50, 0, 1, w * 0.3025, h * 0.271);
	c.arcTo(w * 0.15, h * 0.03, 50, 0, 1, w * 0.4228, h * 0.3655);
	c.close();

	c.moveTo(w * 0.377, h * 0.5973);
	c.arcTo(w * 0.15, h * 0.03, -50, 0, 1, w * 0.4966, h * 0.5019);
	c.arcTo(w * 0,15, h * 0.03, -50, 0, 1, w * 0.423, h * 0.636);
	c.arcTo(w * 0.15, h * 0.03, -50, 0, 1, w * 0.3034, h * 0.7314);
	c.arcTo(w * 0.15, h * 0.03, -50, 0, 1, w * 0.377, h * 0.5973);
	c.close();
	c.stroke();

	c.ellipse(w * 0.5, h * 0.47, w * 0.3, h * 0.06);
	c.stroke();

	var type = mxUtils.getValue(this.style, mxShapePidFan.prototype.cst.FAN_TYPE, 'common');

	if (type === mxShapePidFan.prototype.cst.AXIAL)
	{
		c.begin();
		c.moveTo(w * 0.1, h * 0.5);
		c.lineTo(w * 0.3, h * 0.5);
		c.stroke();
	}
	else if (type === mxShapePidFan.prototype.cst.RADIAL)
	{
		c.begin();
		c.moveTo(w * 0.2, h * 0.4);
		c.lineTo(w * 0.2, h * 0.6);
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapePidFan.prototype.cst.SHAPE_FAN, mxShapePidFan);

//**********************************************************************************************************************************************************
//Column
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapePidColumn(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapePidColumn, mxShape);

mxShapePidColumn.prototype.cst = {
		SHAPE_COLUMN : 'mxgraph.pid2misc.column',
		COLUMN_TYPE : 'columnType',
		COMMON : 'common',
		FIXED : 'fixed',
		FLUIDIZED : 'fluid',
		BAFFLE : 'baffle',
		VALVE : 'valve',
		BUBBLE : 'bubble',
		NOZZLE : 'nozzle',
		TRAY : 'tray'
};

mxShapePidColumn.prototype.customProperties = [
	{name: 'columnType', dispName: 'Type', type: 'enum', defVal:'field',
		enumList: [
			{val:'common', dispName:'Common'},
			{val:'fixed', dispName:'Fixed'},
			{val:'fluid', dispName:'Fluid'},
			{val:'baffle', dispName:'Baffle'},
			{val:'valve', dispName:'Valve'},
			{val:'bubble', dispName:'Bubble'},
			{val:'nozzle', dispName:'Nozzle'},
			{val:'tray', dispName:'Tray'}
	]}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapePidColumn.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
	this.foreground(c, x, y, w, h);
};

mxShapePidColumn.prototype.background = function(c, x, y, w, h)
{
	h = Math.max(h, 30);

	c.begin();
	c.moveTo(0, 15);
	c.arcTo(w * 0.5, 15, 0, 0, 1, w, 15);
	c.lineTo(w, h - 15);
	c.arcTo(w * 0.5, 15, 0, 0, 1, 0, h - 15);
	c.close();
	c.fillAndStroke();
};

mxShapePidColumn.prototype.foreground = function(c, x, y, w, h)
{
	var type = mxUtils.getValue(this.style, mxShapePidColumn.prototype.cst.COLUMN_TYPE, 'common');

	if (type === mxShapePidColumn.prototype.cst.FIXED)
	{
		var step = w * 1.2;
		var range = h - 50;
		var rem = range % step;
		var off = rem * 0.5 + 25;

		c.begin();

		for (var i = 0; i <= range - step; i += step)
		{
			c.moveTo(0, i + off + step * 0.1);
			c.lineTo(w, i + off + step * 0.1);
			c.moveTo(0, i + off + step * 0.9);
			c.lineTo(w, i + off + step * 0.9);
			c.moveTo(0, i + off + step * 0.1);
			c.lineTo(w, i + off + step * 0.9);
			c.moveTo(0, i + off + step * 0.9);
			c.lineTo(w, i + off + step * 0.1);
		}

		c.stroke();
	}
	else if (type === mxShapePidColumn.prototype.cst.TRAY)
	{
		var step = w * 0.2;
		var range = h - 50;
		var rem = range % step;
		var off = rem * 0.5 + 25;

		c.setDashed(true);
		c.begin();

		for (var i = 0; i <= range; i += step)
		{
			c.moveTo(0, i + off);
			c.lineTo(w, i + off);
		}

		c.stroke();
	}
	else if (type === mxShapePidColumn.prototype.cst.FLUIDIZED)
	{
		var stepY = w * 0.1;
		var stepX = w * 0.1;
		var range = h - 50;
		var rem = range % stepY;
		var off = 25;
		var dot = Math.min(w, h) * 0.02;
		var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
		var dashed = mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, '0');
		var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
		var odd = 0;

		c.setFillColor(strokeColor);
		c.setDashed(true);
		c.begin();
		c.moveTo(0, 25);
		c.lineTo(w, 25);
		c.moveTo(0, h - 25);
		c.lineTo(w, h - 25);
		c.stroke();

		if (dashed === '0')
		{
			c.setDashed(false);
		}
		else
		{
			c.setDashed(true);
		}

		var counter = 0;

		for (var i = off + stepY * 0.5; i < range + off - dot; i += stepY)
		{
			var startJ = stepX;
			odd = counter % 2;

			if (odd === 0)
			{
				startJ = stepX * 0.5;
			}

			for (var j = startJ; j < w; j += stepX )
			{
				c.ellipse(j, i, dot, dot);
				c.fillAndStroke();
			}

			counter++;
		}
	}
	else if (type === mxShapePidColumn.prototype.cst.BAFFLE)
	{
		var stepY = w * 0.2;
		var range = h - 50 - stepY;
		var rem = range % stepY;
		var off = 25 + stepY * 0.5;
		var odd = 0;

		c.setDashed(true);
		c.begin();
		c.moveTo(0, 25);
		c.lineTo(w, 25);
		c.moveTo(0, h - 25);
		c.lineTo(w, h - 25);
		c.stroke();

		var counter = 0;

		c.begin();

		for (var i = off + stepY * 0.5; i < range + off; i += stepY)
		{
			odd = counter % 2;

			if (odd === 0)
			{
				c.moveTo(0, i);
				c.lineTo(w * 0.9, i);
				c.lineTo(w * 0.9, i - stepY * 0.3);
			}
			else
			{
				c.moveTo(w * 0.1, i - stepY * 0.5);
				c.lineTo(w * 0.1, i);
				c.lineTo(w, i);
			}


			counter++;
		}

		c.stroke();
	}
	else if (type === mxShapePidColumn.prototype.cst.VALVE || type === mxShapePidColumn.prototype.cst.BUBBLE)
	{
		var stepY = w * 0.2;
		var range = h - 50 - stepY;
		var rem = range % stepY;
		var off = 25 + stepY * 0.5;
		var dashed = mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, '0');
		var odd = 0;

		c.setFillColor(strokeColor);
		c.setDashed(true);
		c.begin();
		c.moveTo(0, 25);
		c.lineTo(w, 25);
		c.moveTo(0, h - 25);
		c.lineTo(w, h - 25);
		c.stroke();

		if (dashed === '0')
		{
			c.setDashed(false);
		}
		else
		{
			c.setDashed(true);
		}
		
		c.begin();

		for (var i = off + stepY * 0.5; i < range + off; i += stepY)
		{
				c.moveTo(0, i);
				c.lineTo(w * 0.4, i);
				
				if (type === mxShapePidColumn.prototype.cst.VALVE)
				{
					c.moveTo(w * 0.4, i - stepY * 0.2);
					c.lineTo(w * 0.6, i - stepY * 0.2);
				}
				else if (type === mxShapePidColumn.prototype.cst.BUBBLE)
				{
					c.moveTo(w * 0.25, i - stepY * 0.2);
					c.arcTo(stepY * 3, stepY * 3, 0, 0, 1, w * 0.75, i - stepY * 0.2);
				}

				c.moveTo(w * 0.6, i);
				c.lineTo(w, i);
		}

		c.stroke();
	}
	else if (type === mxShapePidColumn.prototype.cst.NOZZLE)
	{
		var step = w * 1.2;
		var range = h - 50;
		var rem = range % step;
		var off = rem * 0.5 + 25;
		var dashed = mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, 0);


		for (var i = 0; i <= range - step; i += step)
		{
			c.setDashed(true);
			
			c.begin();
			c.moveTo(0, i + off + step * 0.2);
			c.lineTo(w, i + off + step * 0.2);
			c.moveTo(0, i + off + step * 0.8);
			c.lineTo(w, i + off + step * 0.8);
			c.stroke();
			
			if (dashed === 0)
			{
				c.setDashed(false);
			}
			else
			{
				c.setDashed(true);
			}

			c.begin();
			c.moveTo(0, i + off + step * 0.2);
			c.lineTo(w, i + off + step * 0.8);
			c.moveTo(0, i + off + step * 0.8);
			c.lineTo(w, i + off + step * 0.2);

			if (i !== 0)
			{
				c.moveTo(0, i + off);
				c.lineTo(w * 0.5, i + off);
				c.moveTo(w * 0.5 - step * 0.08, i + off + step * 0.08);
				c.lineTo(w * 0.5, i + off);
				c.lineTo(w * 0.5 + step * 0.08, i + off + step * 0.08);
				c.moveTo(w * 0.5, i + off);
				c.lineTo(w * 0.5, i + off + step * 0.08);
			}
			
			c.stroke();
		}
		
		c.stroke();
	}
};

mxCellRenderer.registerShape(mxShapePidColumn.prototype.cst.SHAPE_COLUMN, mxShapePidColumn);

//**********************************************************************************************************************************************************
//Conveyor
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapePidConveyor(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapePidConveyor, mxShape);

mxShapePidConveyor.prototype.cst = {
		SHAPE_CONVEYOR : 'mxgraph.pid2misc.conveyor'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapePidConveyor.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, x, y, w, h);
	c.setShadow(false);
};

mxShapePidConveyor.prototype.background = function(c, x, y, w, h)
{
	var wheelSize = Math.min(h, w * 0.5);

	c.begin();
	c.moveTo(wheelSize * 0.5, 0);
	c.lineTo(w - wheelSize * 0.5, 0);
	c.stroke();

	c.ellipse(0, 0, wheelSize, wheelSize);
	c.fillAndStroke();
	c.ellipse(w - wheelSize, 0, wheelSize, wheelSize);
	c.fillAndStroke();

	c.begin();
	c.moveTo(wheelSize * 0.5, wheelSize);
	c.lineTo(w - wheelSize * 0.5, wheelSize);
	c.stroke();

	//holders

	var dist = w - wheelSize * 1.8;
	var startX = wheelSize * 0.9;
	var step = wheelSize * 0.7;

	for (var i = 0; i < dist; i = i + step)
	{
		c.rect(startX + i, 0, wheelSize * 0.2, wheelSize * 0.1);
		c.fillAndStroke();
		c.rect(startX + i, wheelSize * 0.9, wheelSize * 0.2, wheelSize * 0.1);
		c.fillAndStroke();
	}

};

mxCellRenderer.registerShape(mxShapePidConveyor.prototype.cst.SHAPE_CONVEYOR, mxShapePidConveyor);


/**
 * $Id: mxPidValves.js,v 1.5 2013/10/22 12:55:55 mate Exp $
 * Copyright (c) 2006-2013, JGraph Ltd
 */

//**********************************************************************************************************************************************************
//Valve
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapePidValve(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapePidValve, mxShape);

mxShapePidValve.prototype.cst = {
		SHAPE_VALVE : 'mxgraph.pid2valves.valve',
		//states
		DEFAULT_STATE : 'defState',
		CLOSED : 'closed',
		OPEN : 'open',
		//actuators
		ACTUATOR : 'actuator',
		MANUAL : 'man',
		DIAPHRAGM : 'diaph',
		BALANCED_DIAPHRAGM : 'balDiaph',
		MOTOR : 'motor',
		NONE : 'none',
		SPRING : 'spring',
		PILOT : 'pilot',
		POWERED: 'powered',
		SOLENOID : 'solenoid',
		SOLENOID_MANUAL_RESET : 'solenoidManRes',
		SINGLE_ACTING : 'singActing',
		DOUBLE_ACTING : 'dblActing',
		PILOT_CYLINDER : 'pilotCyl',
		DIGITAL : 'digital',
		WEIGHT : 'weight',
		KEY : 'key',
		ELECTRO_HYDRAULIC : 'elHyd',
		//types
		VALVE_TYPE : 'valveType',
		BUTTERFLY : 'butterfly',
		CHECK : 'check',
		GATE : 'gate',
		GLOBE : 'globe',
		NEEDLE : 'needle',
		PLUG : 'plug',
		SELF_DRAINING : 'selfDrain',
		ANGLE : 'angle',
		ANGLE_GLOBE : 'angleGlobe',
		THREE_WAY : 'threeWay',
		ANGLE_BLOWDOWN : 'angBlow',
		BALL : 'ball'
};

mxShapePidValve.prototype.customProperties = [
	{name: 'defState', dispName: 'Default State', type: 'enum', defVal:'open',
		enumList: [
			{val:'closed', dispName:'Closed'},
			{val:'open', dispName:'Open'}
	]},
	{name: 'actuator', dispName: 'Actuator', type: 'enum', defVal:'man',
		enumList: [
			{val:'man', dispName:'Manual'},
			{val:'diaph', dispName:'Diphragm'},
			{val:'balDiaph', dispName:'Balanced Diaphragm'},
			{val:'motor', dispName:'Motor'},
			{val:'none', dispName:'None'},
			{val:'spring', dispName:'Spring'},
			{val:'pilot', dispName:'Pilot'},
			{val:'powered', dispName:'Powered'},
			{val:'solenoid', dispName:'Solenoid'},
			{val:'solenoidManRes', dispName:'Solenoid w/ Manual Reset'},
			{val:'singActing', dispName:'Single Acting'},
			{val:'dblActing', dispName:'Double Acting'},
			{val:'pilotCyl', dispName:'Pilot Cylinder'},
			{val:'digital', dispName:'Digital'},
			{val:'weight', dispName:'Weight'},
			{val:'key', dispName:'Key'},
			{val:'elHyd', dispName:'Electro-Hidraulic'}
	]},
	{name: 'valveType', dispName: 'Type', type: 'enum', defVal:'gate',
		enumList: [
			{val:'butterfly', dispName:'Butterfly'},
			{val:'check', dispName:'check'},
			{val:'gate', dispName:'Gate'},
			{val:'globe', dispName:'Globe'},
			{val:'needle', dispName:'Needle'},
			{val:'plug', dispName:'Plug'},
			{val:'selfDrain', dispName:'Self Draining'},
			{val:'angle', dispName:'Angle'},
			{val:'angleGlobe', dispName:'Angle Globe'},
			{val:'threeWay', dispName:'Three Way'},
//			{val:'angBlow', dispName:'Angle Blowdown'},
			{val:'ball', dispName:'Ball'}
	]},
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapePidValve.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var valveType = mxUtils.getValue(this.style, mxShapePidValve.prototype.cst.VALVE_TYPE, 'gate');
	var actuator = mxUtils.getValue(this.style, mxShapePidValve.prototype.cst.ACTUATOR, mxShapePidValve.prototype.cst.NONE);
	var actH = 0;

	if (actuator !== 'none')
	{
		if (this.isAngleVariant(valveType))
		{
			actH = h * 0.3333;
		}
		else
		{
			actH = h * 0.4;
		}
	}

	c.translate(x, y);
	c.setLineJoin('round');
	
	this.background(c, x, y, w, h, valveType, actuator, actH);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, valveType, actuator, actH);
};

mxShapePidValve.prototype.background = function(c, x, y, w, h, valveType, actuator, actH)
{
	//draw the actuator
	if (actuator !== mxShapePidValve.prototype.cst.NONE)
	{
		if (this.isAngleVariant(valveType))
		{
			this.drawActuatorBg(c, x, y, w, h / 1.2, actuator, actH);
		}
		else
		{
			this.drawActuatorBg(c, x, y, w, h, actuator, actH);
		}
	}

	//draw the valve body
	if (this.isGateVariant(valveType))
	{
		this.drawGateVariantBg(c, 0, 0, w, h, valveType, actuator, actH);
	}
	else if (this.isAngleVariant(valveType))
	{
		this.drawAngleVariantBg(c, 0, 0, w, h, valveType, actuator, actH);
	}
	else if (valveType === mxShapePidValve.prototype.cst.BUTTERFLY)
	{
		this.drawButterflyValve(c, 0, 0, w, h, actuator, actH);
	}
	else if (valveType === mxShapePidValve.prototype.cst.CHECK)
	{
		this.drawCheckValve(c, 0, 0, w, h, actuator, actH);
	}
};

mxShapePidValve.prototype.foreground = function(c, x, y, w, h, valveType, actuator, actH)
{
	var valveType = mxUtils.getValue(this.style, mxShapePidValve.prototype.cst.VALVE_TYPE, 'gate');

	//draw the actuator
	if (actuator !== mxShapePidValve.prototype.cst.NONE)
	{
		if (this.isAngleVariant(valveType))
		{
			this.drawActuatorFg(c, x, y, w, h / 1.2, actuator, actH);
		}
		else
		{
			this.drawActuatorFg(c, x, y, w, h, actuator, actH);
		}
	}

	if (this.isGateVariant(valveType))
	{
		this.drawGateVariantFg(c, 0, 0, w, h, valveType, actuator, actH);
	}
	if (this.isAngleVariant(valveType))
	{
		this.drawAngleVariantFg(c, 0, 0, w, h, valveType, actuator, actH);
	}
};

mxShapePidValve.prototype.drawActuatorBg = function(c, x, y, w, h, actuator)
{
	if (this.isSquareVariant(actuator))
	{
		c.translate(w * 0.325, 0);
		this.drawSquareAct(c, w * 0.35, h * 0.7, actuator);
		c.translate(- w * 0.325, 0);
	}
	else if (actuator === mxShapePidValve.prototype.cst.MANUAL)
	{
		c.translate(w * 0.25, h * 0.15);
		this.drawManAct(c, w * 0.5, h * 0.55);
		c.translate(- w * 0.25, - h * 0.15);
	}
	else if (actuator === mxShapePidValve.prototype.cst.DIAPHRAGM)
	{
		c.translate(w * 0.25, h * 0.1);
		this.drawDiaphAct(c, w * 0.5, h * 0.6);
		c.translate(- w * 0.25, - h * 0.1);
	}
	else if (actuator === mxShapePidValve.prototype.cst.BALANCED_DIAPHRAGM)
	{
		c.translate(w * 0.25, h * 0.1);
		this.drawBalDiaphActBg(c, w * 0.5, h * 0.6);
		c.translate(- w * 0.25, - h * 0.1);
	}
	else if (actuator === mxShapePidValve.prototype.cst.MOTOR || actuator === mxShapePidValve.prototype.cst.ELECTRO_HYDRAULIC)
	{
		c.translate(w * 0.325, 0);
		this.drawCircleAct(c, w * 0.35, h * 0.7, actuator);
		c.translate(- w * 0.325, 0);
	}
	else if (actuator === mxShapePidValve.prototype.cst.SPRING)
	{
		c.translate(w * 0.36, 0);
		this.drawSpringAct(c, w * 0.28, h * 0.7);
		c.translate(- w * 0.36, 0);
	}
	else if (actuator === mxShapePidValve.prototype.cst.SOLENOID_MANUAL_RESET)
	{
		c.translate(w * 0.325, 0);
		this.drawSolenoidManResetAct(c, w * 0.575, h * 0.7);
		c.translate(- w * 0.325, 0);
	}
	else if (actuator === mxShapePidValve.prototype.cst.SINGLE_ACTING)
	{
		c.translate(w * 0.35, 0);
		this.drawSingActingActBg(c, w * 0.65, h * 0.7);
		c.translate(- w * 0.35, 0);
	}
	else if (actuator === mxShapePidValve.prototype.cst.DOUBLE_ACTING)
	{
		c.translate(w * 0.35, 0);
		this.drawDblActingActBg(c, w * 0.65, h * 0.7);
		c.translate(- w * 0.35, 0);
	}
	else if (actuator === mxShapePidValve.prototype.cst.PILOT_CYLINDER)
	{
		c.translate(w * 0.35, 0);
		this.drawPilotCylinderActBg(c, w * 0.65, h * 0.7);
		c.translate(- w * 0.35, 0);
	}
	else if (actuator === mxShapePidValve.prototype.cst.ANGLE_BLOWDOWN)
	{
		c.translate(w * 0.5, h * 0.2);
		this.drawAngleBlowdownAct(c, w * 0.4, h * 0.5);
		c.translate(- w * 0.5, - h * 0.2);
	}
};

mxShapePidValve.prototype.drawActuatorFg = function(c, x, y, w, h, actuator)
{
	if (actuator === mxShapePidValve.prototype.cst.BALANCED_DIAPHRAGM)
	{
		c.translate(w * 0.25, h * 0.1);
		this.drawBalDiaphActFg(c, w * 0.5, h * 0.6);
		c.translate(- w * 0.25, - h * 0.1);
	}
	else if (actuator === mxShapePidValve.prototype.cst.SINGLE_ACTING || 
			actuator === mxShapePidValve.prototype.cst.DOUBLE_ACTING || 
			actuator === mxShapePidValve.prototype.cst.PILOT_CYLINDER)
	{
		c.translate(w * 0.35, 0);
		this.drawActingActFg(c, w * 0.65, h * 0.7);
		c.translate(- w * 0.35, 0);
	}
};

mxShapePidValve.prototype.drawManAct = function(c, w, h)
{
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.moveTo(w * 0.5, 0);
	c.lineTo(w * 0.5, h);
	c.stroke();
};

mxShapePidValve.prototype.drawDiaphAct = function(c, w, h)
{
	c.begin();
	c.moveTo(w * 0.5, h * 0.2);
	c.lineTo(w * 0.5, h);
	c.stroke();
	
	c.begin();
	c.moveTo(0, h * 0.2);
	c.arcTo(w * 0.6, h * 0.4, 0, 0, 1, w, h * 0.2);
	c.close();
	c.fillAndStroke();
};

mxShapePidValve.prototype.drawBalDiaphActBg = function(c, w, h)
{
	c.ellipse(0, 0, w, h * 0.3);
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.5, h * 0.3);
	c.lineTo(w * 0.5, h);
	c.stroke();
};

mxShapePidValve.prototype.drawBalDiaphActFg = function(c, w, h)
{
	c.begin();
	c.moveTo(0, h * 0.15);
	c.lineTo(w, h * 0.15);
	c.stroke();
};

mxShapePidValve.prototype.drawCircleAct = function(c, w, h, actuator)
{
	c.ellipse(0, 0, w, h * 0.5);
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.5, h * 0.5);
	c.lineTo(w * 0.5, h);
	c.stroke();

	var m = '';
	
	if (actuator === mxShapePidValve.prototype.cst.MOTOR)
	{
		m = 'M';
	}
	else if (actuator === mxShapePidValve.prototype.cst.ELECTRO_HYDRAULIC)
	{
		m = 'E/H';
	}

	c.setFontStyle(1);
	c.setFontFamily('Helvetica');
	c.setFontSize(Math.min(w, h) * 0.4);
	c.text(w * 0.5, h * 0.25, 0, 0, m, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxShapePidValve.prototype.drawSpringAct = function(c, w, h)
{
	c.begin();
	c.moveTo(w * 0.5, 0);
	c.lineTo(w * 0.5, h);
	c.moveTo(w * 0.32, h * 0.16);
	c.lineTo(w * 0.68, h * 0.08);
	c.moveTo(w * 0.21, h * 0.32);
	c.lineTo(w * 0.79, h * 0.20);
	c.moveTo(w * 0.1, h * 0.52);
	c.lineTo(w * 0.9, h * 0.36);
	c.moveTo(0, h * 0.72);
	c.lineTo(w, h * 0.5);
	c.stroke();
};

mxShapePidValve.prototype.drawSolenoidManResetAct = function(c, w, h)
{
	c.rect(0, 0, w * 0.61, h * 0.46);
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w * 0.56, h * 0.6);
	c.lineTo(w * 0.78, h * 0.5);
	c.lineTo(w, h * 0.6);
	c.lineTo(w * 0.78, h * 0.7);
	c.close();
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w * 0.305, h * 0.46);
	c.lineTo(w * 0.305, h);
	c.moveTo(w * 0.305, h * 0.6);
	c.lineTo(w * 0.56, h * 0.6);
	c.stroke();

	c.setFontStyle(1);
	c.setFontFamily('Helvetica');
	c.setFontSize(Math.min(w, h) * 0.4);
	c.text(w * 0.305, h * 0.23, 0, 0, 'S', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);

	c.setFontStyle(0);
	c.setFontSize(Math.min(w, h) * 0.15);
	c.text(w * 0.78, h * 0.6, 0, 0, 'R', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxShapePidValve.prototype.drawSingActingActBg = function(c, w, h)
{
	c.rect(0, 0, w * 0.46, h * 0.46);
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.23, h * 0.46);
	c.lineTo(w * 0.23, h);
	c.moveTo(w * 0.46, h * 0.23);
	c.lineTo(w, h * 0.23);
	c.moveTo(w * 0.77, h * 0.15);
	c.lineTo(w * 0.69, h * 0.31);
	c.moveTo(w * 0.82, h * 0.15);
	c.lineTo(w * 0.74, h * 0.31);
	c.stroke();
};

mxShapePidValve.prototype.drawActingActFg = function(c, w, h)
{
	c.begin();
	c.moveTo(w * 0.23, h * 0.23);
	c.lineTo(w * 0.23, h * 0.46);
	c.moveTo(0, h * 0.23);
	c.lineTo(w * 0.46, h * 0.23);
	c.stroke();
};

mxShapePidValve.prototype.drawDblActingActBg = function(c, w, h)
{
	c.rect(0, 0, w * 0.46, h * 0.46);
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.23, h * 0.46);
	c.lineTo(w * 0.23, h);
	c.moveTo(w * 0.46, h * 0.115);
	c.lineTo(w, h * 0.115);
	c.moveTo(w * 0.77, h * 0.035);
	c.lineTo(w * 0.69, h * 0.195);
	c.moveTo(w * 0.82, h * 0.035);
	c.lineTo(w * 0.74, h * 0.195);
	c.moveTo(w * 0.46, h * 0.345);
	c.lineTo(w, h * 0.345);
	c.moveTo(w * 0.77, h * 0.265);
	c.lineTo(w * 0.69, h * 0.425);
	c.moveTo(w * 0.82, h * 0.265);
	c.lineTo(w * 0.74, h * 0.425);
	c.stroke();
};

mxShapePidValve.prototype.drawPilotCylinderActBg = function(c, w, h)
{
	c.rect(0, 0, w * 0.46, h * 0.46);
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.23, h * 0.46);
	c.lineTo(w * 0.23, h);
	c.moveTo(w * 0.46, h * 0.23);
	c.lineTo(w * 0.77, h * 0.23);
	c.stroke();
	
	c.rect(w * 0.77, h * 0.115, w * 0.23, h * 0.23);
	c.fillAndStroke();

	c.setFontStyle(0);
	c.setFontFamily('Helvetica');
	c.setFontSize(Math.min(w, h) * 0.15);
	c.text(w * 0.885, h * 0.23, 0, 0, 'P', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxShapePidValve.prototype.drawAngleBlowdownAct = function(c, w, h)
{
	c.begin();
	c.moveTo(w * 0.34, 0);
	c.lineTo(w, h * 0.405);
	c.moveTo(0, h);
	c.lineTo(w * 0.665, h * 0.205);
	c.stroke();
};

mxShapePidValve.prototype.drawSquareAct = function(c, w, h, actuator)
{
	c.rect(0, 0, w, h * 0.5);
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.5, h * 0.5);
	c.lineTo(w * 0.5, h);
	c.stroke();

	var m = '';
	
	if (actuator === mxShapePidValve.prototype.cst.PILOT)
	{
		m = 'P';
	}
	else if (actuator === mxShapePidValve.prototype.cst.SOLENOID)
	{
		m = 'S';
	}
	else if (actuator === mxShapePidValve.prototype.cst.DIGITAL)
	{
		m = 'D';
	}
	else if (actuator === mxShapePidValve.prototype.cst.WEIGHT)
	{
		m = 'W';
	}
	else if (actuator === mxShapePidValve.prototype.cst.KEY)
	{
		m = 'K';
	}
	
	c.setFontStyle(1);
	c.setFontFamily('Helvetica');
	c.setFontSize(Math.min(w, h) * 0.4);
	c.text(w * 0.5, h * 0.25, 0, 0, m, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

mxShapePidValve.prototype.drawGateVariantFg = function(c, x, y, w, h, valveType, actuator, actH)
{
	var defState = mxUtils.getValue(this.style, mxShapePidValve.prototype.cst.DEFAULT_STATE, 'open');
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	
	if (valveType === mxShapePidValve.prototype.cst.BALL)
	{
		c.ellipse(x + w * 0.3, y + actH + (h - actH) * 0.18, w * 0.4, (h - actH) * 0.64);
		c.fillAndStroke();
	}
	else if (valveType === mxShapePidValve.prototype.cst.GLOBE)
	{
		c.ellipse(x + w * 0.3, y + actH + (h - actH) * 0.18, w * 0.4, (h - actH) * 0.64);
		c.setFillColor(strokeColor);
		c.fillAndStroke();
		c.setFillColor(fillColor);
	}
	else if (valveType === mxShapePidValve.prototype.cst.PLUG)
	{
		this.drawPlug(c, x + w * 0.4, y + actH + (h - actH) * 0.25, w * 0.2, (h - actH) * 0.5);
	}
	else if (valveType === mxShapePidValve.prototype.cst.NEEDLE)
	{
		this.drawNeedle(c, x + w * 0.45, y + actH + (h - actH) * 0.1, w * 0.1, (h - actH) * 0.9);
	}
	else if (valveType === mxShapePidValve.prototype.cst.SELF_DRAINING)
	{
		this.drawDrain(c, x + w * 0.48, y + actH + (h - actH) * 0.5, w * 0.04, (h - actH) * 0.49);
	}
};

mxShapePidValve.prototype.drawAngleVariantFg = function(c, x, y, w, h, valveType, actuator, actH)
{
	var defState = mxUtils.getValue(this.style, mxShapePidValve.prototype.cst.DEFAULT_STATE, 'open');
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	
	if (valveType === mxShapePidValve.prototype.cst.ANGLE_GLOBE)
	{
		if (actuator === 'none')
		{
			c.ellipse(w * 0.34, h * 0.175, w * 0.32, h * 0.4);
		}
		else
		{
			c.ellipse(w * 0.34, h * 0.45, w * 0.32, h * 0.2667);
		}
		c.setFillColor(strokeColor);
		c.fillAndStroke();
		c.setFillColor(fillColor);
	}
};

mxShapePidValve.prototype.drawGateVariantBg = function(c, x, y, w, h, valveType, actuator, actH)
{
	if (valveType === mxShapePidValve.prototype.cst.GATE)
	{
		this.drawGateValve(c, x, y + actH, w, h - actH);
	}
	else if (valveType === mxShapePidValve.prototype.cst.BALL || valveType === mxShapePidValve.prototype.cst.GLOBE)
	{
		c.ellipse(x + w * 0.3, y + actH + (h - actH) * 0.18, w * 0.4, (h - actH) * 0.64);
		c.fillAndStroke();
		this.drawGateValve(c, x, y + actH, w, h - actH);
	}
	else if (valveType === mxShapePidValve.prototype.cst.PLUG)
	{
		this.drawPlug(c, x + w * 0.4, y + actH + (h - actH) * 0.25, w * 0.2, (h - actH) * 0.5);
		this.drawGateValve(c, x, y + actH, w, h - actH);
	}
	else if (valveType === mxShapePidValve.prototype.cst.NEEDLE)
	{
		this.drawNeedle(c, x + w * 0.45, y + actH + (h - actH) * 0.1, w * 0.1, (h - actH) * 0.9);
		this.drawGateValve(c, x, y + actH, w, h - actH);
	}
	else if (valveType === mxShapePidValve.prototype.cst.SELF_DRAINING)
	{
		this.drawDrain(c, x + w * 0.48, y + actH + (h - actH) * 0.5, w * 0.04, (h - actH) * 0.49);
		this.drawGateValve(c, x, y + actH, w, h - actH);
	}
};

mxShapePidValve.prototype.drawAngleVariantBg = function(c, x, y, w, h, valveType, actuator, actH)
{
	if (valveType === mxShapePidValve.prototype.cst.ANGLE)
	{
		this.drawAngleValve(c, w * 0.2, y + actH, w * 0.8, h - actH);
	}
	else if (valveType === mxShapePidValve.prototype.cst.ANGLE_GLOBE)
	{
		this.drawAngleGlobeValveBg(c, w * 0.2, y + actH, w * 0.8, h - actH);
	}
	else if (valveType === mxShapePidValve.prototype.cst.THREE_WAY)
	{
		this.drawThreeWayValve(c, 0, y + actH, w, h - actH);
	}
	else if (valveType === mxShapePidValve.prototype.cst.ANGLE_BLOWDOWN)
	{
		this.drawAngleBlowdownValve(c, x, y + actH, w, h - actH);
	}
};

mxShapePidValve.prototype.drawPlug = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.begin();
	c.moveTo(0, h * 0.5);
	c.lineTo(w * 0.5, 0);
	c.lineTo(w, h * 0.5);
	c.lineTo(w * 0.5, h);
	c.close();
	c.fillAndStroke();
	c.translate(-x, -y);
};

mxShapePidValve.prototype.drawNeedle = function(c, x, y, w, h)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');

	c.translate(x, y);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w, 0);
	c.lineTo(w * 0.5, h);
	c.close();
	c.setFillColor(strokeColor);
	c.fillAndStroke();
	c.setFillColor(fillColor);
	c.translate(-x, -y);
};

mxShapePidValve.prototype.drawDrain = function(c, x, y, w, h)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');

	c.translate(x, y);
	c.begin();
	c.moveTo(w * 0.5, 0);
	c.lineTo(w * 0.5, h * 0.96);
	c.stroke();

	c.begin();
	c.moveTo(0, h * 0.9);
	c.lineTo(w, h * 0.9);
	c.lineTo(w * 0.5, h);
	c.close();
	c.setFillColor(strokeColor);
	c.fillAndStroke();
	c.setFillColor(fillColor);
	c.translate(-x, -y);
};

mxShapePidValve.prototype.drawGateValve = function(c, x, y, w, h)
{
	var defState = mxUtils.getValue(this.style, mxShapePidValve.prototype.cst.DEFAULT_STATE, 'open');
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');

	c.translate(x, y);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w * 0.5, h * 0.5);
	c.lineTo(0, h);
	c.close();
	c.moveTo(w, 0);
	c.lineTo(w * 0.5, h * 0.5);
	c.lineTo(w, h);
	c.close();

	if (defState === mxShapePidValve.prototype.cst.CLOSED)
	{
		c.setFillColor(strokeColor);
		c.fillAndStroke();
		c.setFillColor(fillColor);
	}
	else
	{
		c.fillAndStroke();
	}

	c.translate(-x, -y);
};

mxShapePidValve.prototype.drawAngleValve = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(w * 0.375, h * 0.375);
	c.lineTo(w, 0);
	c.lineTo(w, h * 0.75);
	c.close();
	c.moveTo(w * 0.375, h * 0.375);
	c.lineTo(w * 0.75, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();

	c.translate(-x, -y);
};

mxShapePidValve.prototype.drawAngleGlobeValveBg = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.ellipse(w * 0.175, h * 0.175, w * 0.4, h * 0.4);
	c.fillAndStroke();
	c.begin();
	c.moveTo(w * 0.375, h * 0.375);
	c.lineTo(w, 0);
	c.lineTo(w, h * 0.75);
	c.close();
	c.moveTo(w * 0.375, h * 0.375);
	c.lineTo(w * 0.75, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
	c.translate(-x, -y);
};

mxShapePidValve.prototype.drawAngleGlobeValveFg = function(c, x, y, w, h)
{
	c.translate(x, y);
	c.ellipse(w * 0.275, h * 0.275, w * 0.2, h * 0.2);
	c.fillAndStroke();
	c.translate(-x, -y);
};

mxShapePidValve.prototype.drawThreeWayValve = function(c, x, y, w, h)
{
	c.translate(x, y);

	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w * 0.5, h * 0.375);
	c.lineTo(0, h * 0.75);
	c.close();
	
	c.moveTo(w, 0);
	c.lineTo(w * 0.5, h * 0.375);
	c.lineTo(w, h * 0.75);
	c.close();
	
	c.moveTo(w * 0.5, h * 0.375);
	c.lineTo(w * 0.8, h);
	c.lineTo(w * 0.2, h);
	c.close();
	c.fillAndStroke();

	c.translate(-x, -y);
};

mxShapePidValve.prototype.drawAngleBlowdownValve = function(c, x, y, w, h)
{
	
};

	
mxShapePidValve.prototype.drawButterflyValve = function(c, x, y, w, h, actuator, actH)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');

	var yv = y + actH;
	var hv = h - actH;

	c.translate(x, yv);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(0, hv);
	c.moveTo(w, 0);
	c.lineTo(w, hv);

	c.moveTo(w * 0.05, hv * 0.05);
	c.lineTo(w * 0.95, hv * 0.95);
	
	c.fillAndStroke();

	c.ellipse(w * 0.4, hv * 0.33, w * 0.2, hv * 0.33);
	c.fillAndStroke();
	
	c.translate(-x, -y);
};

mxShapePidValve.prototype.drawCheckValve = function(c, x, y, w, h, actuator, actH)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');

	var yv = y + actH;
	var hv = h - actH;

	c.translate(x, yv);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(0, hv);
	c.moveTo(w, 0);
	c.lineTo(w, hv);
	c.moveTo(w * 0.05, hv * 0.05);
	c.lineTo(w * 0.95, hv * 0.95);
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.8925, hv * 0.815);
	c.lineTo(w * 0.957, hv * 0.955);
	c.lineTo(w * 0.85, hv * 0.928);
	c.close();
	c.setFillColor(strokeColor);
	c.fillAndStroke();
	c.setFillColor(fillColor);
	
	c.translate(-x, -y);
};

mxShapePidValve.prototype.isGateVariant = function(valveType)
{
	if (valveType === mxShapePidValve.prototype.cst.GATE || 
			valveType === mxShapePidValve.prototype.cst.BALL ||
			valveType === mxShapePidValve.prototype.cst.PLUG ||
			valveType === mxShapePidValve.prototype.cst.NEEDLE ||
			valveType === mxShapePidValve.prototype.cst.SELF_DRAINING ||
			valveType === mxShapePidValve.prototype.cst.GLOBE)
	{
		return true;
	}
	else
	{
		return false;
	}
};

mxShapePidValve.prototype.isAngleVariant = function(valveType)
{
	if (valveType === mxShapePidValve.prototype.cst.ANGLE || 
			valveType === mxShapePidValve.prototype.cst.ANGLE_GLOBE ||
			valveType === mxShapePidValve.prototype.cst.THREE_WAY ||
			valveType === mxShapePidValve.prototype.cst.ANGLE_BLOWDOWN)
	{
		return true;
	}
	else
	{
		return false;
	}
};

mxShapePidValve.prototype.isSquareVariant = function(actType)
{
	if (actType === mxShapePidValve.prototype.cst.PILOT || 
			actType === mxShapePidValve.prototype.cst.SOLENOID ||
			actType === mxShapePidValve.prototype.cst.POWERED ||
			actType === mxShapePidValve.prototype.cst.DIGITAL ||
			actType === mxShapePidValve.prototype.cst.WEIGHT ||
			actType === mxShapePidValve.prototype.cst.KEY)
	{
		return true;
	}
	else
	{
		return false;
	}
};

mxCellRenderer.registerShape(mxShapePidValve.prototype.cst.SHAPE_VALVE, mxShapePidValve);

//**********************************************************************************************************************************************************
//Integrated Block And Bleed Valve
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxShapePidIntBlockBleedValve(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShapePidValve.
*/
mxUtils.extend(mxShapePidIntBlockBleedValve, mxShapePidValve);

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxShapePidIntBlockBleedValve.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var actuator = mxUtils.getValue(this.style, mxShapePidIntBlockBleedValve.prototype.cst.ACTUATOR, mxShapePidIntBlockBleedValve.prototype.cst.NONE);
	var actH = 0;

	if (actuator !== 'none')
	{
		actH = h * 0.2353;
	}

	c.translate(x, y);
	c.setLineJoin('round');
	
	this.background(c, x, y, w, h, actuator, actH);
	c.setShadow(false);
	this.foreground(c, x, y, w, h, actuator, actH);
};

mxShapePidIntBlockBleedValve.prototype.background = function(c, x, y, w, h, actuator, actH)
{
	//draw the actuator
	if (actuator !== mxShapePidIntBlockBleedValve.prototype.cst.NONE)
	{
		this.drawActuatorBg(c, x, y, w, h, actuator);
	}

	//draw the valve body
	this.drawValveBg(c, 0, actH, w, h - actH);
};

mxShapePidIntBlockBleedValve.prototype.foreground = function(c, x, y, w, h, actuator, actH)
{
	//draw the actuator
	if (actuator !== mxShapePidIntBlockBleedValve.prototype.cst.NONE)
	{
		this.drawActuatorFg(c, x, y, w, h, actuator);
	}
};

mxShapePidIntBlockBleedValve.prototype.drawValveBg = function(c, x, y, w, h)
{
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');

	c.translate(x, y);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(w * 0.5, h * 0.23);
	c.lineTo(0, h * 0.46);
	c.close();
	c.moveTo(w * 0.5, h * 0.23);
	c.lineTo(w, 0);
	c.lineTo(w, h * 0.46);
	c.close();
	c.fillAndStroke();

	c.begin();
	c.moveTo(w * 0.5, h * 0.23);
	c.lineTo(w * 0.5, h * 0.5);
	c.stroke();
	
	c.setFillColor(strokeColor);
	c.begin();
	c.moveTo(w * 0.3, h * 0.5);
	c.lineTo(w * 0.7, h * 0.5);
	c.lineTo(w * 0.5, h * 0.75);
	c.close();
	c.fillAndStroke();
	
	c.begin();
	c.moveTo(w * 0.3, h);
	c.lineTo(w * 0.5, h * 0.75);
	c.lineTo(w * 0.7, h);
	c.fillAndStroke();
	c.setFillColor(fillColor);

	c.translate(-x, -y);
};

mxShapePidIntBlockBleedValve.prototype.drawActuatorBg = function(c, x, y, w, h, actuator)
{
	if (this.isSquareVariant(actuator))
	{
		c.translate(w * 0.325, 0);
		this.drawSquareAct(c, w * 0.35, h * 0.4112, actuator);
		c.translate(- w * 0.325, 0);
	}
	else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.MANUAL)
	{
		c.translate(w * 0.25, h * 0.0882);
		this.drawManAct(c, w * 0.5, h * 0.323);
		c.translate(- w * 0.25, - h * 0.0882);
	}
	else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.DIAPHRAGM)
	{
		c.translate(w * 0.25, h * 0.0588);
		this.drawDiaphAct(c, w * 0.5, h * 0.3524);
		c.translate(- w * 0.25, - h * 0.0588);
	}
	else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.BALANCED_DIAPHRAGM)
	{
		c.translate(w * 0.25, h * 0.0588);
		this.drawBalDiaphActBg(c, w * 0.5, h * 0.3524);
		c.translate(- w * 0.25, - h * 0.0588);
	}
	else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.MOTOR || actuator === mxShapePidIntBlockBleedValve.prototype.cst.ELECTRO_HYDRAULIC)
	{
		c.translate(w * 0.325, 0);
		this.drawCircleAct(c, w * 0.35, h * 0.4112, actuator);
		c.translate(- w * 0.325, 0);
	}
	else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.SPRING)
	{
		c.translate(w * 0.36, 0);
		this.drawSpringAct(c, w * 0.28, h * 0.4112);
		c.translate(- w * 0.36, 0);
	}
	else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.SOLENOID_MANUAL_RESET)
	{
		c.translate(w * 0.325, 0);
		this.drawSolenoidManResetAct(c, w * 0.575, h * 0.4112);
		c.translate(- w * 0.325, 0);
	}
	else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.SINGLE_ACTING)
	{
		c.translate(w * 0.35, 0);
		this.drawSingActingActBg(c, w * 0.65, h * 0.4112);
		c.translate(- w * 0.35, 0);
	}
	else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.DOUBLE_ACTING)
	{
		c.translate(w * 0.35, 0);
		this.drawDblActingActBg(c, w * 0.65, h * 0.4112);
		c.translate(- w * 0.35, 0);
	}
	else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.PILOT_CYLINDER)
	{
		c.translate(w * 0.35, 0);
		this.drawPilotCylinderActBg(c, w * 0.65, h * 0.4112);
		c.translate(- w * 0.35, 0);
	}
};

mxShapePidIntBlockBleedValve.prototype.drawActuatorFg = function(c, x, y, w, h, actuator)
{
	if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.BALANCED_DIAPHRAGM)
	{
		c.translate(w * 0.25, h * 0.0588);
		this.drawBalDiaphActFg(c, w * 0.5, h * 0.3524);
		c.translate(- w * 0.25, - h * 0.0588);
	}
	else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.SINGLE_ACTING || 
			actuator === mxShapePidIntBlockBleedValve.prototype.cst.DOUBLE_ACTING || 
			actuator === mxShapePidIntBlockBleedValve.prototype.cst.PILOT_CYLINDER)
	{
		c.translate(w * 0.35, 0);
		this.drawActingActFg(c, w * 0.65, h * 0.4112);
		c.translate(- w * 0.35, 0);
	}
};

mxCellRenderer.registerShape('mxgraph.pid2valves.blockBleedValve', mxShapePidIntBlockBleedValve);

//**********************************************************************************************************************************************************
//Auto Recirculation Valve
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxShapePidAutoRecircValve(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxShapePidAutoRecircValve, mxShape);


/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxShapePidAutoRecircValve.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.setLineJoin('round');
	c.translate(x, y);

	//background
	c.rect(0, 0, w, h);
	c.fillAndStroke();
	c.setShadow(false);

	//foreground
	c.begin();
	c.moveTo(w * 0.08, h * 0.08);
	c.lineTo(w * 0.08, h * 0.92);
	c.moveTo(w * 0.92, h * 0.08);
	c.lineTo(w * 0.92, h * 0.92);
	c.moveTo(w * 0.12, h * 0.122);
	c.lineTo(w * 0.8738, h * 0.8837);
	
	c.moveTo(w * 0.5, 0);
	c.lineTo(w * 0.55, h * 0.05);
	c.lineTo(w * 0.45, h * 0.15);
	c.lineTo(w * 0.55, h * 0.25);
	c.lineTo(w * 0.45, h * 0.35);
	c.lineTo(w * 0.55, h * 0.45);
	c.lineTo(w * 0.49, h * 0.5);
	c.stroke();
	
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, '#000000');
	
	c.begin();
	c.moveTo(w * 0.8257, h * 0.7695);
	c.lineTo(w * 0.8797, h * 0.888);
	c.lineTo(w * 0.79, h * 0.8651);
	c.close();
	c.setFillColor(strokeColor);
	c.fillAndStroke();
	c.setFillColor(fillColor);
};

mxCellRenderer.registerShape('mxgraph.pid2valves.autoRecircValve', mxShapePidAutoRecircValve);

/**
 * $Id: mxRack.js,v 1.5 2014/01/21 13:10:37 gaudenz Exp $
 * Copyright (c) 2006-2013, JGraph Ltd
 */
//**********************************************************************************************************************************************************
//Rack Numbering
//**********************************************************************************************************************************************************

//**********************************************************************************************************************************************************
// v2 Rack cabinet, old versions below this
//**********************************************************************************************************************************************************

//**********************************************************************************************************************************************************
//START LEGACY RACKS
//**********************************************************************************************************************************************************
function mxRackContainer(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxRackContainer, mxShape);

mxRackContainer.unitSize = 20;

mxRackContainer.prototype.cst = 
{
		SHAPE_RACK_CONTAINER : 'mxgraph.rackGeneral.container',
		TEXT_COLOR : 'textColor',
		NUMBER_DISPLAY : 'numDisp',
		OFF : 'off',
		DIR_ASC : 'ascend',
		DIR_DESC : 'descend'
};

mxRackContainer.prototype.customProperties = [
	{name: 'fillColor2', dispName: 'Cabinet Color', type: 'color'},
	{name: 'textColor', dispName: 'Numbers Color', type: 'color'},
	{name: 'numDisp', dispName: 'Display Numbers', type: 'enum',
		enumList: [{val: 'off', dispName: 'Off'}, {val: 'ascend', dispName: 'Ascending'}, {val: 'descend', dispName: 'Descending'}],
		onChange: function(graph, newValue)
		{
			graph.setCellStyles('marginLeft', (newValue == 'off') ? 9 : 33, graph.getSelectionCells());
		}
	}
];

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxRackContainer.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var fontSize = 12;
	var displayNumbers = mxUtils.getValue(this.style, mxRackContainer.prototype.cst.NUMBER_DISPLAY, mxRackContainer.prototype.cst.DIR_ASC);
	var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, '#ffffff');
	var fillColor2 = mxUtils.getValue(this.style, 'fillColor2', '#f4f4f4');

	if (displayNumbers !== mxRackContainer.prototype.cst.OFF)
	{
		c.translate(x + fontSize * 2, y);
		w = Math.max(w - fontSize * 2, 0);
	}
	else
	{
		c.translate(x, y);
	};

	c.setFillColor(fillColor);
	this.background(c, w, h, fontSize);
	c.setShadow(false);
	c.setFillColor(fillColor2);
	this.foreground(c, w, h, fontSize);

	if (displayNumbers !== mxRackContainer.prototype.cst.OFF && w > 18 + fontSize * 2)
	{
		this.sideText(c, w, h, fontSize);
	};
};

mxRackContainer.prototype.background = function(c, w, h, fontSize)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxRackContainer.prototype.foreground = function(c, w, h, fontSize)
{
	if (w > 18 + fontSize * 2 && h > 42)
	{
		c.rect(0, 0, w, 21);
		c.fillAndStroke();
		c.rect(0, h - 21, w, 21);
		c.fillAndStroke();
		c.rect(0, 21, 9, h - 42);
		c.fillAndStroke();
		c.rect(w - 9, 21, 9, h - 42);
		c.fillAndStroke();
		c.ellipse(2.5, 7.5, 6, 6);
		c.stroke();
		c.ellipse(w - 8.5, 7.5, 6, 6);
		c.stroke();
		c.ellipse(2.5, h - 13.5, 6, 6);
		c.stroke();
		c.ellipse(w - 8.5, h - 13.5, 6, 6);
		c.stroke();
	}
};

mxRackContainer.prototype.sideText = function(c, w, h, fontSize)
{
	var fontColor = mxUtils.getValue(this.style, mxRackContainer.prototype.cst.TEXT_COLOR, '#666666');
	var displayNumbers = mxUtils.getValue(this.style, mxRackContainer.prototype.cst.NUMBER_DISPLAY, mxRackContainer.prototype.cst.DIR_ASC);
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);

	// Calculate number of units
	var units = Math.floor((Math.abs(h) - 42) / mxRackContainer.unitSize);

	for (var i = 0; i < units; i++)
	{
		var displayNumber = (displayNumbers === mxRackContainer.prototype.cst.DIR_DESC) ? (i + 1).toString() : (units - i).toString();
		c.text(-fontSize, 21 + mxRackContainer.unitSize * 0.5 + i * mxRackContainer.unitSize, 0, 0, displayNumber, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
	}

	c.begin();

	for (var i = 0; i < units + 1; i++)
	{
		c.moveTo(-2 * fontSize, 21 + i * mxRackContainer.unitSize);
		c.lineTo(0, 21 + i * mxRackContainer.unitSize);
	};

	c.stroke();
};

/**
* Extends mxShape.
*/
function mxRackPlate(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxRackPlate, mxShape);

mxRackPlate.prototype.cst = 
{
		SHAPE_RACK_PLATE : 'mxgraph.rackGeneral.plate'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxRackPlate.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxRackPlate.prototype.background = function(c, w, h)
{
	c.begin();
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxRackPlate.prototype.foreground = function(c, w, h)
{
	var bufferSize = 9;

	if (w > bufferSize * 2)
	{
		c.save();
		c.setFillColor('#000000');
		c.setAlpha(0.23);
		c.rect(0,0, bufferSize, h);
		c.fill();
		c.rect(w - bufferSize,0, bufferSize, h);
		c.fill();
		c.restore();
		c.rect(0, 0, w, h);
		c.stroke();
		c.rect(bufferSize, 0, w - bufferSize * 2, h);
		c.stroke();
	}
};

//**********************************************************************************************************************************************************
//Horizontal Cable Duct
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxRackHorCableDuct(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxRackHorCableDuct, mxShape);

mxRackHorCableDuct.prototype.cst = 
{
		SHAPE_RACK_HOR_CABLE_DUCT : 'mxgraph.rackGeneral.horCableDuct'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxRackHorCableDuct.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxRackHorCableDuct.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxRackHorCableDuct.prototype.foreground = function(c, w, h)
{
	// Divide the space equally with 33 between each duct
	var spaceBuffer = 20;
	var unitSpacing = 33;
	var unitsAcross = Math.floor((w - spaceBuffer) / unitSpacing);
	var buffer = spaceBuffer / 2 + Math.floor(((w - spaceBuffer) - unitsAcross * unitSpacing) / 2);

	if (unitsAcross > 0)
	{
		for (var i = 0; i <= unitsAcross; i++)
		{
			c.rect(buffer, 0, 3, 7);
			c.stroke();
			c.rect(buffer, 7, 3, 7.8);
			c.stroke();
			
			buffer += unitSpacing;
		}
	}
};

function mxRackHorRoutingBank(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxRackHorRoutingBank, mxShape);

mxRackHorRoutingBank.prototype.cst = 
{
		SHAPE_RACK_HOR_ROUTING_BANK : 'mxgraph.rackGeneral.horRoutingBank'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxRackHorRoutingBank.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxRackHorRoutingBank.prototype.background = function(c, w, h)
{
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxRackHorRoutingBank.prototype.foreground = function(c, w, h)
{
	// Divide the space equally with 33 between each duct
	var spaceBuffer = 20;
	var unitSpacing = 22;
	var rectWidth = 16;
	var unitsAcross = Math.floor((w - spaceBuffer - rectWidth) / unitSpacing);
	var unitsDown = Math.floor(h / mxRackContainer.unitSize);

	if (unitsAcross > 0 && unitsDown > 0)
	{
		for (var i = 0; i < unitsDown; i++)
		{
			var buffer = (spaceBuffer + rectWidth) / 2 + Math.floor(((w - spaceBuffer - rectWidth) - unitsAcross * unitSpacing) / 2) - rectWidth / 2;

			for (var j = 0; j <= unitsAcross; j++)
			{
				c.rect(buffer, 4 + (i * mxRackContainer.unitSize), rectWidth, 6.8);
				c.stroke();
				
				buffer += unitSpacing;
			}
		}
	}
};

function mxRackNeatPatch(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxRackNeatPatch, mxShape);

mxRackNeatPatch.prototype.cst = 
{
		SHAPE_RACK_NEAT_PATCH : 'mxgraph.rackGeneral.neatPatch'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxRackNeatPatch.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.mainText(c, w, h);
};

mxRackNeatPatch.prototype.background = function(c, w, h)
{
	c.setFillColor('#666666');
	c.rect(0, 0, w, h);
	c.fillAndStroke();
};

mxRackNeatPatch.prototype.mainText = function(c, w, h)
{
	c.setFontSize('12');
	c.setFontColor('#ffffff');
	c.setFontStyle(mxConstants.FONT_BOLD);
	c.text(w / 2, h - 6, 0, 0, 'NEAT-PATCH', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

function mxRackShelf(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxRackShelf, mxShape);

mxRackShelf.prototype.cst = 
{
		SHAPE_RACK_SHELF : 'mxgraph.rackGeneral.shelf'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxRackShelf.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
};

mxRackShelf.prototype.background = function(c, w, h)
{
	c.setStrokeWidth(2);
	c.begin();
	c.moveTo(1, 0);
	c.lineTo(1, h - 1);
	c.lineTo(w - 1, h - 1);
	c.lineTo(w - 1, 1);
	c.fillAndStroke();
};

function mxRackRackNumbering(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxRackRackNumbering, mxShape);

mxRackRackNumbering.prototype.cst = 
{
		SHAPE_RACK_RACK_NUMBERING : 'mxgraph.rackGeneral.rackNumbering',
		UNIT_NUM : 'unitNum',
		UNIT_HEIGHT : 'unitHeight',
		TEXT_COLOR : 'textColor',
		NUM_DIR : 'numDir',
		DIR_ASC : 'ascend',
		DIR_DESC : 'descend',
		TEXT_SIZE : 'textSize'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxRackRackNumbering.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var unitNum = parseFloat(mxUtils.getValue(this.style, mxRackRackNumbering.prototype.cst.UNIT_NUM, '42'));
	var unitH = parseFloat(mxUtils.getValue(this.style, mxRackRackNumbering.prototype.cst.UNIT_HEIGHT, '14.8'));
	var fontSize = parseFloat(mxUtils.getValue(this.style, mxRackRackNumbering.prototype.cst.TEXT_SIZE, '12'));
	c.translate(x, y);

	var h = unitNum * unitH;
	this.background(c, w, h, fontSize);
	c.setShadow(false);
	this.sideText(c, w, h, unitNum, unitH, fontSize);
};

mxRackRackNumbering.prototype.background = function(c, w, h, fontSize)
{
	c.rect(fontSize * 3, 0, 160.9, h);
	c.fillAndStroke();
};

mxRackRackNumbering.prototype.sideText = function(c, w, h, unitNum, unitH, fontSize)
{
	var fontColor = mxUtils.getValue(this.style, mxRackRackNumbering.prototype.cst.TEXT_COLOR, '#666666');
	var numDir = mxUtils.getValue(this.style, mxRackRackNumbering.prototype.cst.NUM_DIR, mxRackRackNumbering.prototype.cst.DIR_DESC);
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);

	if (numDir === mxRackRackNumbering.prototype.cst.DIR_ASC)
	{
		for (var i = 0; i < unitNum; i++)
		{
			c.text(fontSize, unitH * 0.5 + i * unitH, 0, 0, (i + 1).toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		};
	}
	else
	{
		for (var i = 0; i < unitNum; i++)
		{
			c.text(fontSize, h - unitH * 0.5 - i * unitH, 0, 0, (i + 1).toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		};
	};

	c.setStrokeColor('#dddddd');

	c.begin();

	for (var i = 0; i < unitNum + 1; i++)
	{
		c.moveTo(0, i * unitH);
		c.lineTo(fontSize * 3, i * unitH);
	};

	c.stroke();
};

//**********************************************************************************************************************************************************
//Rack Cabinet
//**********************************************************************************************************************************************************
/**
 * Extends mxShape.
 */
function mxRackRackCabinet(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxRackRackCabinet, mxShape);

mxRackRackCabinet.prototype.cst = 
{
		SHAPE_RACK_RACK_CABINET : 'mxgraph.rackGeneral.rackCabinet',
		UNIT_NUM : 'unitNum',
		UNIT_HEIGHT : 'unitHeight',
		TEXT_COLOR : 'textColor',
		NUM_DIR : 'numDir',
		NUMBER_DISPLAY : 'numDisp',
		ON : 'on',
		OFF : 'off',
		DIR_ASC : 'ascend',
		DIR_DESC : 'descend',
		TEXT_SIZE : 'textSize'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxRackRackCabinet.prototype.paintVertexShape = function(c, x, y, w, h)
{
	var unitNum = parseFloat(mxUtils.getValue(this.style, mxRackRackCabinet.prototype.cst.UNIT_NUM, '12'));
	var unitH = parseFloat(mxUtils.getValue(this.style, mxRackRackCabinet.prototype.cst.UNIT_HEIGHT, '14.8'));
	var fontSize = parseFloat(mxUtils.getValue(this.style, mxRackRackCabinet.prototype.cst.TEXT_SIZE, '12'));
	var numDis = mxUtils.getValue(this.style, mxRackRackCabinet.prototype.cst.NUMBER_DISPLAY, mxRackRackCabinet.prototype.cst.ON);

	if (numDis === mxRackRackCabinet.prototype.cst.ON)
	{
		c.translate(x + fontSize * 2, y);
	}
	else
	{
		c.translate(x, y);
	};

	var h = unitNum * unitH + 42;
	this.background(c, w, h, fontSize);
	c.setShadow(false);
	this.foreground(c, w, h, fontSize);

	if (numDis === mxRackRackCabinet.prototype.cst.ON)
	{
		this.sideText(c, w, h, unitNum, unitH, fontSize);
	};
};

mxRackRackCabinet.prototype.background = function(c, w, h, fontSize)
{
	c.setFillColor('#ffffff');
	c.rect(0, 0, 180, h);
	c.fillAndStroke();
};

mxRackRackCabinet.prototype.foreground = function(c, w, h, fontSize)
{
	c.setFillColor('#f4f4f4');
	c.rect(0, 0, 180, 21);
	c.fillAndStroke();
	c.rect(0, h - 21, 180, 21);
	c.fillAndStroke();
	c.rect(0, 21, 9, h - 42);
	c.fillAndStroke();
	c.rect(171, 21, 9, h - 42);
	c.fillAndStroke();
	c.ellipse(2.5, 7.5, 6, 6);
	c.stroke();
	c.ellipse(171.5, 7.5, 6, 6);
	c.stroke();
	c.ellipse(2.5, h - 13.5, 6, 6);
	c.stroke();
	c.ellipse(171.5, h - 13.5, 6, 6);
	c.stroke();
};

mxRackRackCabinet.prototype.sideText = function(c, w, h, unitNum, unitH, fontSize)
{
	var fontColor = mxUtils.getValue(this.style, mxRackRackCabinet.prototype.cst.TEXT_COLOR, '#666666');
	var numDir = mxUtils.getValue(this.style, mxRackRackCabinet.prototype.cst.NUM_DIR, mxRackRackCabinet.prototype.cst.DIR_DESC);
	c.setFontSize(fontSize);
	c.setFontColor(fontColor);

	if (numDir === mxRackRackCabinet.prototype.cst.DIR_ASC)
	{
		for (var i = 0; i < unitNum; i++)
		{
			c.text(-fontSize, 21 + unitH * 0.5 + i * unitH, 0, 0, (i + 1).toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		};
	}
	else
	{
		for (var i = 0; i < unitNum; i++)
		{
			c.text(-fontSize, h - 21 - unitH * 0.5 - i * unitH, 0, 0, (i + 1).toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
		};
	};

	c.setStrokeColor('#dddddd');

	c.begin();

	for (var i = 0; i < unitNum + 1; i++)
	{
		c.moveTo(-2 * fontSize, 21 + i * unitH);
		c.lineTo(0, 21 + i * unitH);
	};

	c.stroke();
};

//**********************************************************************************************************************************************************
//1U Horizontal Cable Duct
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxRackHorCableDuct1U(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxRackHorCableDuct1U, mxShape);

mxRackHorCableDuct1U.prototype.cst = 
{
		SHAPE_RACK_HOR_CABLE_DUCT_1U : 'mxgraph.rackGeneral.horCableDuct1U'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxRackHorCableDuct1U.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxRackHorCableDuct1U.prototype.background = function(c, w, h)
{
	c.rect(0, 0, 160.9, 14.8);
	c.fillAndStroke();
};

mxRackHorCableDuct1U.prototype.foreground = function(c, w, h)
{
	c.rect(12, 0, 3, 7);
	c.stroke();
	c.rect(12, 7, 3, 7.8);
	c.stroke();

	c.rect(45.5, 0, 3, 7);
	c.stroke();
	c.rect(45.5, 7, 3, 7.8);
	c.stroke();
	
	c.rect(79, 0, 3, 7);
	c.stroke();
	c.rect(79, 7, 3, 7.8);
	c.stroke();
	
	c.rect(112.5, 0, 3, 7);
	c.stroke();
	c.rect(112.5, 7, 3, 7.8);
	c.stroke();
	
	c.rect(146, 0, 3, 7);
	c.stroke();
	c.rect(146, 7, 3, 7.8);
	c.stroke();
};

//**********************************************************************************************************************************************************
//2U Horizontal Cable Duct
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxRackHorCableDuct2U(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxRackHorCableDuct2U, mxShape);

mxRackHorCableDuct2U.prototype.cst = 
{
		SHAPE_RACK_HOR_CABLE_DUCT_2U : 'mxgraph.rackGeneral.horCableDuct2U'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxRackHorCableDuct2U.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxRackHorCableDuct2U.prototype.background = function(c, w, h)
{
	c.rect(0, 0, 160.9, 29.6);
	c.fillAndStroke();
};

mxRackHorCableDuct2U.prototype.foreground = function(c, w, h)
{
	c.rect(12, 0, 3, 7);
	c.stroke();
	c.rect(12, 7, 3, 22.6);
	c.stroke();

	c.rect(45.5, 0, 3, 7);
	c.stroke();
	c.rect(45.5, 7, 3, 22.6);
	c.stroke();
	
	c.rect(79, 0, 3, 7);
	c.stroke();
	c.rect(79, 7, 3, 22.6);
	c.stroke();
	
	c.rect(112.5, 0, 3, 7);
	c.stroke();
	c.rect(112.5, 7, 3, 22.6);
	c.stroke();
	
	c.rect(146, 0, 3, 7);
	c.stroke();
	c.rect(146, 7, 3, 22.6);
	c.stroke();
};

//**********************************************************************************************************************************************************
//1U Cable Routing Bank
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxRackHorRoutingBank1U(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxRackHorRoutingBank1U, mxShape);

mxRackHorRoutingBank1U.prototype.cst = 
{
		SHAPE_RACK_HOR_ROUTING_BANK_1U : 'mxgraph.rackGeneral.horRoutingBank1U'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxRackHorRoutingBank1U.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxRackHorRoutingBank1U.prototype.background = function(c, w, h)
{
	c.rect(0, 0, 160.9, 14.8);
	c.fillAndStroke();
};

mxRackHorRoutingBank1U.prototype.foreground = function(c, w, h)
{
	c.rect(10, 4, 17, 6.8);
	c.stroke();
	c.rect(31, 4, 17, 6.8);
	c.stroke();
	c.rect(52, 4, 17, 6.8);
	c.stroke();
	c.rect(73, 4, 17, 6.8);
	c.stroke();
	c.rect(94, 4, 17, 6.8);
	c.stroke();
	c.rect(115, 4, 17, 6.8);
	c.stroke();
	c.rect(136, 4, 17, 6.8);
	c.stroke();
};

//**********************************************************************************************************************************************************
//2U Cable Routing Bank
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxRackHorRoutingBank2U(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxRackHorRoutingBank2U, mxShape);

mxRackHorRoutingBank2U.prototype.cst = 
{
		SHAPE_RACK_HOR_ROUTING_BANK_2U : 'mxgraph.rackGeneral.horRoutingBank2U'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxRackHorRoutingBank2U.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxRackHorRoutingBank2U.prototype.background = function(c, w, h)
{
	c.rect(0, 0, 160.9, 29.6);
	c.fillAndStroke();
};

mxRackHorRoutingBank2U.prototype.foreground = function(c, w, h)
{
	c.rect(10, 4, 17, 6.8);
	c.stroke();
	c.rect(31, 4, 17, 6.8);
	c.stroke();
	c.rect(52, 4, 17, 6.8);
	c.stroke();
	c.rect(73, 4, 17, 6.8);
	c.stroke();
	c.rect(94, 4, 17, 6.8);
	c.stroke();
	c.rect(115, 4, 17, 6.8);
	c.stroke();
	c.rect(136, 4, 17, 6.8);
	c.stroke();

	c.rect(10, 18.8, 17, 6.8);
	c.stroke();
	c.rect(31, 18.8, 17, 6.8);
	c.stroke();
	c.rect(52, 18.8, 17, 6.8);
	c.stroke();
	c.rect(73, 18.8, 17, 6.8);
	c.stroke();
	c.rect(94, 18.8, 17, 6.8);
	c.stroke();
	c.rect(115, 18.8, 17, 6.8);
	c.stroke();
	c.rect(136, 18.8, 17, 6.8);
	c.stroke();
};

//**********************************************************************************************************************************************************
//2U Neat-Patch
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxRackNeatPatch2U(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxRackNeatPatch2U, mxShape);

mxRackNeatPatch2U.prototype.cst = 
{
		SHAPE_RACK_NEAT_PATCH_2U : 'mxgraph.rackGeneral.neatPatch2U'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxRackNeatPatch2U.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
	c.setShadow(false);
	this.mainText(c, w, h);
};

mxRackNeatPatch2U.prototype.background = function(c, w, h)
{
	c.setFillColor('#666666');
	c.rect(0, 0, 160.9, 29.6);
	c.fillAndStroke();
};

mxRackNeatPatch2U.prototype.mainText = function(c, w, h)
{
	c.setFontSize('12');
	c.setFontColor('#ffffff');
	c.setFontStyle(mxConstants.FONT_BOLD);
	c.text(80.45, 24, 0, 0, 'NEAT-PATCH', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
};

//**********************************************************************************************************************************************************
//1U shelf
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxRackShelf1U(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxRackShelf1U, mxShape);

mxRackShelf1U.prototype.cst = 
{
		SHAPE_RACK_SHELF_1U : 'mxgraph.rackGeneral.shelf1U'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxRackShelf1U.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
};

mxRackShelf1U.prototype.background = function(c, w, h)
{
	c.setStrokeWidth(2);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(0, 14.8);
	c.lineTo(160.9, 14.8);
	c.lineTo(160.9, 0);
	c.fillAndStroke();
};

//**********************************************************************************************************************************************************
//2U shelf
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxRackShelf2U(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxRackShelf2U, mxShape);

mxRackShelf2U.prototype.cst = 
{
		SHAPE_RACK_SHELF_2U : 'mxgraph.rackGeneral.shelf2U'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxRackShelf2U.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
};

mxRackShelf2U.prototype.background = function(c, w, h)
{
	c.setStrokeWidth(2);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(0, 29.6);
	c.lineTo(160.9, 29.6);
	c.lineTo(160.9, 0);
	c.fillAndStroke();
};

//**********************************************************************************************************************************************************
//4U shelf
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxRackShelf4U(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxRackShelf4U, mxShape);

mxRackShelf4U.prototype.cst = 
{
		SHAPE_RACK_SHELF_4U : 'mxgraph.rackGeneral.shelf4U'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxRackShelf4U.prototype.paintVertexShape = function(c, x, y, w, h)
{
	c.translate(x, y);
	this.background(c, w, h);
};

mxRackShelf4U.prototype.background = function(c, w, h)
{
	c.setStrokeWidth(2);
	c.begin();
	c.moveTo(0, 0);
	c.lineTo(0, 59.2);
	c.lineTo(160.9, 59.2);
	c.lineTo(160.9, 0);
	c.fillAndStroke();
};

//**********************************************************************************************************************************************************
//END LEGACY RACKS
//**********************************************************************************************************************************************************


//**********************************************************************************************************************************************************
//Channel Base
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxRackChannelBase(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
 * Extends mxShape.
 */
mxUtils.extend(mxRackChannelBase, mxShape);

mxRackChannelBase.prototype.cst = 
{
		SHAPE_RACK_CHANNEL_BASE : 'mxgraph.rackGeneral.channelBase'
};

/**
 * Function: paintVertexShape
 * 
 * Paints the vertex shape.
 */
mxRackChannelBase.prototype.paintVertexShape = function(c, x, y, w, h)
{
	w = Math.max(w, 20);
	h = Math.max(h, 20);
	c.translate(x, y);

	this.background(c, w, h);
	c.setShadow(false);
	this.foreground(c, w, h);
};

mxRackChannelBase.prototype.background = function(c, w, h)
{
	c.rect(10, h - 15, 5, 15);
	c.fillAndStroke();
	c.rect(w - 15, h - 15, 5, 15);
	c.fillAndStroke();
	c.rect(0, 0, w, h - 5);
	c.fillAndStroke();
};

mxRackChannelBase.prototype.foreground = function(c, w, h)
{
	c.setFillColor('#000000');
	c.rect(10, h - 15, 5, 15);
	c.fillAndStroke();
	c.rect(w - 15, h - 15, 5, 15);
	c.fillAndStroke();
};

//**********************************************************************************************************************************************************
//Cabinet Leg
//**********************************************************************************************************************************************************
/**
* Extends mxShape.
*/
function mxRackCabinetLeg(bounds, fill, stroke, strokewidth)
{
	mxShape.call(this);
	this.bounds = bounds;
	this.fill = fill;
	this.stroke = stroke;
	this.strokewidth = (strokewidth != null) ? strokewidth : 1;
};

/**
* Extends mxShape.
*/
mxUtils.extend(mxRackCabinetLeg, mxShape);

mxRackCabinetLeg.prototype.cst = 
{
		SHAPE_RACK_CABINET_LEG : 'mxgraph.rackGeneral.cabinetLeg'
};

/**
* Function: paintVertexShape
* 
* Paints the vertex shape.
*/
mxRackCabinetLeg.prototype.paintVertexShape = function(c, x, y, w, h)
{
	w = Math.max(w, 20);
	h = Math.max(h, 20);
	c.translate(x, y);

	this.background(c, w, h);
};

mxRackCabinetLeg.prototype.background = function(c, w, h)
{
	c.begin();
	c.moveTo(0, h - 10);
	c.lineTo(5, h - 10);
	c.lineTo(5, h - 12);
	c.lineTo(9, h - 12);
	c.lineTo(9, h - 10);
	c.lineTo(w - 10, h - 10);
	c.lineTo(w - 10, 9);
	c.lineTo(w - 12, 9);
	c.lineTo(w - 12, 5);
	c.lineTo(w - 10, 5);
	c.lineTo(w - 10, 0);
	c.lineTo(w, 0);
	c.lineTo(w, h);
	c.lineTo(0, h);
	c.close();
	c.fillAndStroke();
};

// New generic unit size implementations
mxCellRenderer.registerShape(mxRackContainer.prototype.cst.SHAPE_RACK_CONTAINER, mxRackContainer);
mxCellRenderer.registerShape(mxRackHorCableDuct.prototype.cst.SHAPE_RACK_HOR_CABLE_DUCT, mxRackHorCableDuct);
mxCellRenderer.registerShape(mxRackHorRoutingBank.prototype.cst.SHAPE_RACK_HOR_ROUTING_BANK, mxRackHorRoutingBank);
mxCellRenderer.registerShape(mxRackNeatPatch.prototype.cst.SHAPE_RACK_NEAT_PATCH, mxRackNeatPatch);
mxCellRenderer.registerShape(mxRackShelf.prototype.cst.SHAPE_RACK_SHELF, mxRackShelf);
mxCellRenderer.registerShape(mxRackPlate.prototype.cst.SHAPE_RACK_PLATE, mxRackPlate);

// Legacy resizable / fixed unit size implementations
mxCellRenderer.registerShape(mxRackRackNumbering.prototype.cst.SHAPE_RACK_RACK_NUMBERING, mxRackRackNumbering);
mxCellRenderer.registerShape(mxRackRackCabinet.prototype.cst.SHAPE_RACK_RACK_CABINET, mxRackRackCabinet);
mxCellRenderer.registerShape(mxRackHorCableDuct1U.prototype.cst.SHAPE_RACK_HOR_CABLE_DUCT_1U, mxRackHorCableDuct1U);
mxCellRenderer.registerShape(mxRackHorCableDuct2U.prototype.cst.SHAPE_RACK_HOR_CABLE_DUCT_2U, mxRackHorCableDuct2U);
mxCellRenderer.registerShape(mxRackHorRoutingBank1U.prototype.cst.SHAPE_RACK_HOR_ROUTING_BANK_1U, mxRackHorRoutingBank1U);
mxCellRenderer.registerShape(mxRackHorRoutingBank2U.prototype.cst.SHAPE_RACK_HOR_ROUTING_BANK_2U, mxRackHorRoutingBank2U);
mxCellRenderer.registerShape(mxRackNeatPatch2U.prototype.cst.SHAPE_RACK_NEAT_PATCH_2U, mxRackNeatPatch2U);
mxCellRenderer.registerShape(mxRackShelf1U.prototype.cst.SHAPE_RACK_SHELF_1U, mxRackShelf1U);
mxCellRenderer.registerShape(mxRackShelf2U.prototype.cst.SHAPE_RACK_SHELF_2U, mxRackShelf2U);
mxCellRenderer.registerShape(mxRackShelf4U.prototype.cst.SHAPE_RACK_SHELF_4U, mxRackShelf4U);

mxCellRenderer.registerShape(mxRackChannelBase.prototype.cst.SHAPE_RACK_CHANNEL_BASE, mxRackChannelBase);
mxCellRenderer.registerShape(mxRackCabinetLeg.prototype.cst.SHAPE_RACK_CABINET_LEG, mxRackCabinetLeg);